// Code generated by 'ccgo -o pcre2_linux_amd64.go -pkgname lib -trace-translation-units -export-externs X -export-defines D -export-fields F -export-structs S -export-typedefs T pcre.json .libs/libpcre2-8.a', DO NOT EDIT.

package lib

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

const (
	DAIO_PRIO_DELTA_MAX                              = 20                   // local_lim.h:78:1:
	DBC_BASE_MAX                                     = 99                   // posix2_lim.h:63:1:
	DBC_DIM_MAX                                      = 2048                 // posix2_lim.h:66:1:
	DBC_SCALE_MAX                                    = 99                   // posix2_lim.h:69:1:
	DBC_STRING_MAX                                   = 1000                 // posix2_lim.h:72:1:
	DBIG_ENDIAN                                      = 4321                 // endian.h:28:1:
	DBOOL_MAX                                        = 1                    // limits.h:186:1:
	DBOOL_WIDTH                                      = 1                    // limits.h:189:1:
	DBSR_DEFAULT                                     = 1                    // pcre2_internal.h:242:1:
	DBUFSIZ                                          = 8192                 // stdio.h:99:1:
	DBYTE_ORDER                                      = 1234                 // endian.h:30:1:
	DCHARCLASS_NAME_MAX                              = 2048                 // posix2_lim.h:84:1:
	DCHAR_0                                          = 48                   // pcre2_internal.h:998:1:
	DCHAR_1                                          = 49                   // pcre2_internal.h:999:1:
	DCHAR_2                                          = 50                   // pcre2_internal.h:1000:1:
	DCHAR_3                                          = 51                   // pcre2_internal.h:1001:1:
	DCHAR_4                                          = 52                   // pcre2_internal.h:1002:1:
	DCHAR_5                                          = 53                   // pcre2_internal.h:1003:1:
	DCHAR_6                                          = 54                   // pcre2_internal.h:1004:1:
	DCHAR_7                                          = 55                   // pcre2_internal.h:1005:1:
	DCHAR_8                                          = 56                   // pcre2_internal.h:1006:1:
	DCHAR_9                                          = 57                   // pcre2_internal.h:1007:1:
	DCHAR_A                                          = 65                   // pcre2_internal.h:1015:1:
	DCHAR_AMPERSAND                                  = 38                   // pcre2_internal.h:988:1:
	DCHAR_APOSTROPHE                                 = 39                   // pcre2_internal.h:989:1:
	DCHAR_ASTERISK                                   = 42                   // pcre2_internal.h:992:1:
	DCHAR_B                                          = 66                   // pcre2_internal.h:1016:1:
	DCHAR_BACKSLASH                                  = 92                   // pcre2_internal.h:1042:1:
	DCHAR_BEL                                        = 7                    // pcre2_internal.h:977:1:
	DCHAR_BIT                                        = 8                    // limits.h:64:1:
	DCHAR_BS                                         = 8                    // pcre2_internal.h:976:1:
	DCHAR_C                                          = 67                   // pcre2_internal.h:1017:1:
	DCHAR_CIRCUMFLEX_ACCENT                          = 94                   // pcre2_internal.h:1044:1:
	DCHAR_COLON                                      = 58                   // pcre2_internal.h:1008:1:
	DCHAR_COMMA                                      = 44                   // pcre2_internal.h:994:1:
	DCHAR_COMMERCIAL_AT                              = 64                   // pcre2_internal.h:1014:1:
	DCHAR_CR                                         = 13                   // pcre2_internal.h:972:1:
	DCHAR_D                                          = 68                   // pcre2_internal.h:1018:1:
	DCHAR_DEL                                        = 127                  // pcre2_internal.h:979:1:
	DCHAR_DOLLAR_SIGN                                = 36                   // pcre2_internal.h:986:1:
	DCHAR_DOT                                        = 46                   // pcre2_internal.h:996:1:
	DCHAR_E                                          = 69                   // pcre2_internal.h:1019:1:
	DCHAR_EQUALS_SIGN                                = 61                   // pcre2_internal.h:1011:1:
	DCHAR_ESC                                        = 27                   // pcre2_internal.h:978:1:
	DCHAR_EXCLAMATION_MARK                           = 33                   // pcre2_internal.h:983:1:
	DCHAR_F                                          = 70                   // pcre2_internal.h:1020:1:
	DCHAR_FF                                         = 12                   // pcre2_internal.h:971:1:
	DCHAR_G                                          = 71                   // pcre2_internal.h:1021:1:
	DCHAR_GRAVE_ACCENT                               = 96                   // pcre2_internal.h:1046:1:
	DCHAR_GREATER_THAN_SIGN                          = 62                   // pcre2_internal.h:1012:1:
	DCHAR_H                                          = 72                   // pcre2_internal.h:1022:1:
	DCHAR_HT                                         = 9                    // pcre2_internal.h:969:1:
	DCHAR_I                                          = 73                   // pcre2_internal.h:1023:1:
	DCHAR_J                                          = 74                   // pcre2_internal.h:1024:1:
	DCHAR_K                                          = 75                   // pcre2_internal.h:1025:1:
	DCHAR_L                                          = 76                   // pcre2_internal.h:1026:1:
	DCHAR_LEFT_CURLY_BRACKET                         = 123                  // pcre2_internal.h:1073:1:
	DCHAR_LEFT_PARENTHESIS                           = 40                   // pcre2_internal.h:990:1:
	DCHAR_LEFT_SQUARE_BRACKET                        = 91                   // pcre2_internal.h:1041:1:
	DCHAR_LESS_THAN_SIGN                             = 60                   // pcre2_internal.h:1010:1:
	DCHAR_LF                                         = 10                   // pcre2_internal.h:973:1:
	DCHAR_M                                          = 77                   // pcre2_internal.h:1027:1:
	DCHAR_MAX                                        = 127                  // limits.h:99:1:
	DCHAR_MIN                                        = -128                 // limits.h:97:1:
	DCHAR_MINUS                                      = 45                   // pcre2_internal.h:995:1:
	DCHAR_N                                          = 78                   // pcre2_internal.h:1028:1:
	DCHAR_NL                                         = 10                   // pcre2_internal.h:974:1:
	DCHAR_NUL                                        = 0                    // pcre2_internal.h:981:1:
	DCHAR_NUMBER_SIGN                                = 35                   // pcre2_internal.h:985:1:
	DCHAR_O                                          = 79                   // pcre2_internal.h:1029:1:
	DCHAR_P                                          = 80                   // pcre2_internal.h:1030:1:
	DCHAR_PERCENT_SIGN                               = 37                   // pcre2_internal.h:987:1:
	DCHAR_PLUS                                       = 43                   // pcre2_internal.h:993:1:
	DCHAR_Q                                          = 81                   // pcre2_internal.h:1031:1:
	DCHAR_QUESTION_MARK                              = 63                   // pcre2_internal.h:1013:1:
	DCHAR_QUOTATION_MARK                             = 34                   // pcre2_internal.h:984:1:
	DCHAR_R                                          = 82                   // pcre2_internal.h:1032:1:
	DCHAR_RIGHT_CURLY_BRACKET                        = 125                  // pcre2_internal.h:1075:1:
	DCHAR_RIGHT_PARENTHESIS                          = 41                   // pcre2_internal.h:991:1:
	DCHAR_RIGHT_SQUARE_BRACKET                       = 93                   // pcre2_internal.h:1043:1:
	DCHAR_S                                          = 83                   // pcre2_internal.h:1033:1:
	DCHAR_SEMICOLON                                  = 59                   // pcre2_internal.h:1009:1:
	DCHAR_SLASH                                      = 47                   // pcre2_internal.h:997:1:
	DCHAR_SPACE                                      = 32                   // pcre2_internal.h:982:1:
	DCHAR_T                                          = 84                   // pcre2_internal.h:1034:1:
	DCHAR_TILDE                                      = 126                  // pcre2_internal.h:1076:1:
	DCHAR_U                                          = 85                   // pcre2_internal.h:1035:1:
	DCHAR_UNDERSCORE                                 = 95                   // pcre2_internal.h:1045:1:
	DCHAR_V                                          = 86                   // pcre2_internal.h:1036:1:
	DCHAR_VERTICAL_LINE                              = 124                  // pcre2_internal.h:1074:1:
	DCHAR_VT                                         = 11                   // pcre2_internal.h:970:1:
	DCHAR_W                                          = 87                   // pcre2_internal.h:1037:1:
	DCHAR_WIDTH                                      = 8                    // limits.h:165:1:
	DCHAR_X                                          = 88                   // pcre2_internal.h:1038:1:
	DCHAR_Y                                          = 89                   // pcre2_internal.h:1039:1:
	DCHAR_Z                                          = 90                   // pcre2_internal.h:1040:1:
	DCHAR_a                                          = 97                   // pcre2_internal.h:1047:1:
	DCHAR_b                                          = 98                   // pcre2_internal.h:1048:1:
	DCHAR_c                                          = 99                   // pcre2_internal.h:1049:1:
	DCHAR_d                                          = 100                  // pcre2_internal.h:1050:1:
	DCHAR_e                                          = 101                  // pcre2_internal.h:1051:1:
	DCHAR_f                                          = 102                  // pcre2_internal.h:1052:1:
	DCHAR_g                                          = 103                  // pcre2_internal.h:1053:1:
	DCHAR_h                                          = 104                  // pcre2_internal.h:1054:1:
	DCHAR_i                                          = 105                  // pcre2_internal.h:1055:1:
	DCHAR_j                                          = 106                  // pcre2_internal.h:1056:1:
	DCHAR_k                                          = 107                  // pcre2_internal.h:1057:1:
	DCHAR_l                                          = 108                  // pcre2_internal.h:1058:1:
	DCHAR_m                                          = 109                  // pcre2_internal.h:1059:1:
	DCHAR_n                                          = 110                  // pcre2_internal.h:1060:1:
	DCHAR_o                                          = 111                  // pcre2_internal.h:1061:1:
	DCHAR_p                                          = 112                  // pcre2_internal.h:1062:1:
	DCHAR_q                                          = 113                  // pcre2_internal.h:1063:1:
	DCHAR_r                                          = 114                  // pcre2_internal.h:1064:1:
	DCHAR_s                                          = 115                  // pcre2_internal.h:1065:1:
	DCHAR_t                                          = 116                  // pcre2_internal.h:1066:1:
	DCHAR_u                                          = 117                  // pcre2_internal.h:1067:1:
	DCHAR_v                                          = 118                  // pcre2_internal.h:1068:1:
	DCHAR_w                                          = 119                  // pcre2_internal.h:1069:1:
	DCHAR_x                                          = 120                  // pcre2_internal.h:1070:1:
	DCHAR_y                                          = 121                  // pcre2_internal.h:1071:1:
	DCHAR_z                                          = 122                  // pcre2_internal.h:1072:1:
	DCOLL_WEIGHTS_MAX                                = 255                  // posix2_lim.h:75:1:
	DCOMPILE_ERROR_BASE                              = 100                  // pcre2_internal.h:221:1:
	DDELAYTIMER_MAX                                  = 2147483647           // local_lim.h:84:1:
	DDFA_START_RWS_SIZE                              = 30720                // pcre2_internal.h:235:1:
	DEOF                                             = -1                   // stdio.h:104:1:
	DEXIT_FAILURE                                    = 1                    // stdlib.h:92:1:
	DEXIT_SUCCESS                                    = 0                    // stdlib.h:93:1:
	DEXPR_NEST_MAX                                   = 32                   // posix2_lim.h:78:1:
	DFALSE                                           = 0                    // pcre2_internal.h:69:1:
	DFD_SETSIZE                                      = 1024                 // select.h:73:1:
	DFILENAME_MAX                                    = 4096                 // stdio_lim.h:27:1:
	DFOPEN_MAX                                       = 16                   // stdio_lim.h:37:1:
	DHAVE_ATTRIBUTE_UNINITIALIZED                    = 1                    // config.h:57:1:
	DHAVE_BCOPY                                      = 1                    // config.h:60:1:
	DHAVE_BZLIB_H                                    = 1                    // config.h:63:1:
	DHAVE_CONFIG_H                                   = 1                    // <defines>:1:1:
	DHAVE_DIRENT_H                                   = 1                    // config.h:66:1:
	DHAVE_DLFCN_H                                    = 1                    // config.h:69:1:
	DHAVE_INTTYPES_H                                 = 1                    // config.h:78:1:
	DHAVE_LIMITS_H                                   = 1                    // config.h:81:1:
	DHAVE_MEMFD_CREATE                               = 1                    // config.h:84:1:
	DHAVE_MEMMOVE                                    = 1                    // config.h:87:1:
	DHAVE_MKOSTEMP                                   = 1                    // config.h:93:1:
	DHAVE_REALPATH                                   = 1                    // config.h:111:1:
	DHAVE_SECURE_GETENV                              = 1                    // config.h:114:1:
	DHAVE_STDINT_H                                   = 1                    // config.h:117:1:
	DHAVE_STDIO_H                                    = 1                    // config.h:120:1:
	DHAVE_STDLIB_H                                   = 1                    // config.h:123:1:
	DHAVE_STRERROR                                   = 1                    // config.h:126:1:
	DHAVE_STRINGS_H                                  = 1                    // config.h:129:1:
	DHAVE_STRING_H                                   = 1                    // config.h:132:1:
	DHAVE_SYS_STAT_H                                 = 1                    // config.h:135:1:
	DHAVE_SYS_TYPES_H                                = 1                    // config.h:138:1:
	DHAVE_SYS_WAIT_H                                 = 1                    // config.h:141:1:
	DHAVE_UNISTD_H                                   = 1                    // config.h:144:1:
	DHAVE_VISIBILITY                                 = 1                    // config.h:147:1:
	DHAVE_WCHAR_H                                    = 1                    // config.h:150:1:
	DHAVE_ZLIB_H                                     = 1                    // config.h:156:1:
	DHEAP_LIMIT                                      = 20000000             // config.h:161:1:
	DHOST_NAME_MAX                                   = 64                   // local_lim.h:93:1:
	DIMM2_SIZE                                       = 2                    // pcre2_intmodedep.h:193:1:
	DINT16_MAX                                       = 32767                // stdint.h:122:1:
	DINT16_MIN                                       = -32768               // stdint.h:117:1:
	DINT16_WIDTH                                     = 16                   // stdint.h:280:1:
	DINT32_MAX                                       = 2147483647           // stdint.h:123:1:
	DINT32_MIN                                       = -2147483648          // stdint.h:118:1:
	DINT32_WIDTH                                     = 32                   // stdint.h:282:1:
	DINT64_MAX                                       = 9223372036854775807  // stdint.h:124:1:
	DINT64_MIN                                       = -9223372036854775808 // stdint.h:119:1:
	DINT64_WIDTH                                     = 64                   // stdint.h:284:1:
	DINT8_MAX                                        = 127                  // stdint.h:121:1:
	DINT8_MIN                                        = -128                 // stdint.h:116:1:
	DINT8_WIDTH                                      = 8                    // stdint.h:278:1:
	DINTMAX_MAX                                      = 9223372036854775807  // stdint.h:199:1:
	DINTMAX_MIN                                      = -9223372036854775808 // stdint.h:197:1:
	DINTMAX_WIDTH                                    = 64                   // stdint.h:308:1:
	DINTPTR_MAX                                      = 9223372036854775807  // stdint.h:187:1:
	DINTPTR_MIN                                      = -9223372036854775808 // stdint.h:186:1:
	DINTPTR_WIDTH                                    = 64                   // stdint.h:305:1:
	DINT_FAST16_MAX                                  = 9223372036854775807  // stdint.h:164:1:
	DINT_FAST16_MIN                                  = -9223372036854775808 // stdint.h:154:1:
	DINT_FAST16_WIDTH                                = 64                   // stdint.h:298:1:
	DINT_FAST32_MAX                                  = 9223372036854775807  // stdint.h:165:1:
	DINT_FAST32_MIN                                  = -9223372036854775808 // stdint.h:155:1:
	DINT_FAST32_WIDTH                                = 64                   // stdint.h:300:1:
	DINT_FAST64_MAX                                  = 9223372036854775807  // stdint.h:170:1:
	DINT_FAST64_MIN                                  = -9223372036854775808 // stdint.h:160:1:
	DINT_FAST64_WIDTH                                = 64                   // stdint.h:302:1:
	DINT_FAST8_MAX                                   = 127                  // stdint.h:162:1:
	DINT_FAST8_MIN                                   = -128                 // stdint.h:152:1:
	DINT_FAST8_WIDTH                                 = 8                    // stdint.h:296:1:
	DINT_LEAST16_MAX                                 = 32767                // stdint.h:140:1:
	DINT_LEAST16_MIN                                 = -32768               // stdint.h:135:1:
	DINT_LEAST16_WIDTH                               = 16                   // stdint.h:289:1:
	DINT_LEAST32_MAX                                 = 2147483647           // stdint.h:141:1:
	DINT_LEAST32_MIN                                 = -2147483648          // stdint.h:136:1:
	DINT_LEAST32_WIDTH                               = 32                   // stdint.h:291:1:
	DINT_LEAST64_MAX                                 = 9223372036854775807  // stdint.h:142:1:
	DINT_LEAST64_MIN                                 = -9223372036854775808 // stdint.h:137:1:
	DINT_LEAST64_WIDTH                               = 64                   // stdint.h:293:1:
	DINT_LEAST8_MAX                                  = 127                  // stdint.h:139:1:
	DINT_LEAST8_MIN                                  = -128                 // stdint.h:134:1:
	DINT_LEAST8_WIDTH                                = 8                    // stdint.h:287:1:
	DINT_MAX                                         = 2147483647           // limits.h:120:1:
	DINT_MIN                                         = -2147483648          // limits.h:118:1:
	DINT_WIDTH                                       = 32                   // limits.h:175:1:
	DIOV_MAX                                         = 1024                 // xopen_lim.h:66:1:
	DLINE_MAX                                        = 2048                 // posix2_lim.h:81:1:
	DLINK_SIZE                                       = 2                    // config.h:168:1:
	DLITTLE_ENDIAN                                   = 1234                 // endian.h:27:1:
	DLLONG_MAX                                       = 9223372036854775807  // limits.h:142:1:
	DLLONG_MIN                                       = -9223372036854775808 // limits.h:140:1:
	DLLONG_WIDTH                                     = 64                   // limits.h:183:1:
	DLOGIN_NAME_MAX                                  = 256                  // local_lim.h:90:1:
	DLONG_BIT                                        = 64                   // xopen_lim.h:137:1:
	DLONG_LONG_MAX                                   = 9223372036854775807  // limits.h:154:1:
	DLONG_LONG_MIN                                   = -9223372036854775808 // limits.h:152:1:
	DLONG_MAX                                        = 9223372036854775807  // limits.h:131:1:
	DLONG_MIN                                        = -9223372036854775808 // limits.h:129:1:
	DLONG_WIDTH                                      = 64                   // limits.h:179:1:
	DLOOKBEHIND_MAX                                  = 65535                // pcre2_intmodedep.h:616:1:
	DLT_OBJDIR                                       = ".libs/"             // config.h:171:1:
	DL_ctermid                                       = 9                    // stdio_lim.h:30:1:
	DL_cuserid                                       = 9                    // stdio_lim.h:32:1:
	DL_tmpnam                                        = 20                   // stdio_lim.h:25:1:
	DMAGIC_NUMBER                                    = 0x50435245           // pcre2_internal.h:546:1:
	DMATCH_LIMIT                                     = 10000000             // config.h:180:1:
	DMATCH_LIMIT_DEPTH                               = 10000000             // config.h:192:1:
	DMAX_CANON                                       = 255                  // limits.h:10:1:
	DMAX_INPUT                                       = 255                  // limits.h:11:1:
	DMAX_MARK                                        = 255                  // pcre2_intmodedep.h:213:1:
	DMAX_NAME_COUNT                                  = 10000                // config.h:197:1:
	DMAX_NAME_SIZE                                   = 32                   // config.h:202:1:
	DMAX_NON_UTF_CHAR                                = 255                  // pcre2_internal.h:1893:1:
	DMAX_PATTERN_SIZE                                = 65536                // pcre2_intmodedep.h:110:1:
	DMAX_UTF_CODE_POINT                              = 0x10ffff             // pcre2_internal.h:209:1:
	DMAX_UTF_SINGLE_CU                               = 127                  // pcre2_intmodedep.h:282:1:
	DMAYBE_UTF_MULTI                                 = 0                    // pcre2_intmodedep.h:278:1:
	DMB_LEN_MAX                                      = 16                   // limits.h:32:1:
	DMQ_PRIO_MAX                                     = 32768                // local_lim.h:96:1:
	DNAME_MAX                                        = 255                  // limits.h:12:1:
	DNEWLINE_DEFAULT                                 = 2                    // config.h:211:1:
	DNGROUPS_MAX                                     = 65536                // limits.h:7:1:
	DNLTYPE_ANY                                      = 1                    // pcre2_internal.h:473:1:
	DNLTYPE_ANYCRLF                                  = 2                    // pcre2_internal.h:474:1:
	DNLTYPE_FIXED                                    = 0                    // pcre2_internal.h:472:1:
	DNL_ARGMAX                                       = 4096                 // xopen_lim.h:73:1:
	DNL_LANGMAX                                      = 2048                 // xopen_lim.h:76:1:
	DNL_MSGMAX                                       = 2147483647           // xopen_lim.h:79:1:
	DNL_NMAX                                         = 2147483647           // xopen_lim.h:84:1:
	DNL_SETMAX                                       = 2147483647           // xopen_lim.h:88:1:
	DNL_TEXTMAX                                      = 2147483647           // xopen_lim.h:91:1:
	DNOTACHAR                                        = 0xffffffff           // pcre2_internal.h:205:1:
	DNZERO                                           = 20                   // xopen_lim.h:94:1:
	DPACKAGE                                         = "pcre2"              // config.h:214:1:
	DPACKAGE_BUGREPORT                               = ""                   // config.h:217:1:
	DPACKAGE_NAME                                    = "PCRE2"              // config.h:220:1:
	DPACKAGE_STRING                                  = "PCRE2 10.42"        // config.h:223:1:
	DPACKAGE_TARNAME                                 = "pcre2"              // config.h:226:1:
	DPACKAGE_URL                                     = ""                   // config.h:229:1:
	DPACKAGE_VERSION                                 = "10.42"              // config.h:232:1:
	DPARENS_NEST_LIMIT                               = 250                  // config.h:237:1:
	DPATH_MAX                                        = 4096                 // limits.h:13:1:
	DPCRE2GREP_BUFSIZE                               = 20480                // config.h:245:1:
	DPCRE2GREP_MAX_BUFSIZE                           = 1048576              // config.h:251:1:
	DPCRE2_ALLOW_EMPTY_CLASS                         = 0x00000001           // pcre2.h:119:1:
	DPCRE2_ALT_BSUX                                  = 0x00000002           // pcre2.h:120:1:
	DPCRE2_ALT_CIRCUMFLEX                            = 0x00200000           // pcre2.h:140:1:
	DPCRE2_ALT_VERBNAMES                             = 0x00400000           // pcre2.h:141:1:
	DPCRE2_ANCHORED                                  = 0x80000000           // pcre2.h:105:1:
	DPCRE2_AUTO_CALLOUT                              = 0x00000004           // pcre2.h:121:1:
	DPCRE2_BSR_ANYCRLF                               = 2                    // pcre2.h:211:1:
	DPCRE2_BSR_SET                                   = 0x00004000           // pcre2_internal.h:521:1:
	DPCRE2_BSR_UNICODE                               = 1                    // pcre2.h:210:1:
	DPCRE2_CALLOUT_BACKTRACK                         = 0x00000002           // pcre2.h:513:1:
	DPCRE2_CALLOUT_STARTMATCH                        = 0x00000001           // pcre2.h:512:1:
	DPCRE2_CALL_CONVENTION                           = 0                    // pcre2.h:81:1:
	DPCRE2_CASELESS                                  = 0x00000008           // pcre2.h:122:1:
	DPCRE2_CODE_UNIT_WIDTH                           = 8                    // <defines>:2:1:
	DPCRE2_CONFIG_BSR                                = 0                    // pcre2.h:437:1:
	DPCRE2_CONFIG_COMPILED_WIDTHS                    = 14                   // pcre2.h:452:1:
	DPCRE2_CONFIG_DEPTHLIMIT                         = 7                    // pcre2.h:444:1:
	DPCRE2_CONFIG_HEAPLIMIT                          = 12                   // pcre2.h:450:1:
	DPCRE2_CONFIG_JIT                                = 1                    // pcre2.h:438:1:
	DPCRE2_CONFIG_JITTARGET                          = 2                    // pcre2.h:439:1:
	DPCRE2_CONFIG_LINKSIZE                           = 3                    // pcre2.h:440:1:
	DPCRE2_CONFIG_MATCHLIMIT                         = 4                    // pcre2.h:441:1:
	DPCRE2_CONFIG_NEVER_BACKSLASH_C                  = 13                   // pcre2.h:451:1:
	DPCRE2_CONFIG_NEWLINE                            = 5                    // pcre2.h:442:1:
	DPCRE2_CONFIG_PARENSLIMIT                        = 6                    // pcre2.h:443:1:
	DPCRE2_CONFIG_RECURSIONLIMIT                     = 7                    // pcre2.h:445:1:
	DPCRE2_CONFIG_STACKRECURSE                       = 8                    // pcre2.h:446:1:
	DPCRE2_CONFIG_TABLES_LENGTH                      = 15                   // pcre2.h:453:1:
	DPCRE2_CONFIG_UNICODE                            = 9                    // pcre2.h:447:1:
	DPCRE2_CONFIG_UNICODE_VERSION                    = 10                   // pcre2.h:448:1:
	DPCRE2_CONFIG_VERSION                            = 11                   // pcre2.h:449:1:
	DPCRE2_CONVERT_GLOB                              = 0x00000010           // pcre2.h:195:1:
	DPCRE2_CONVERT_GLOB_NO_STARSTAR                  = 0x00000050           // pcre2.h:197:1:
	DPCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR            = 0x00000030           // pcre2.h:196:1:
	DPCRE2_CONVERT_NO_UTF_CHECK                      = 0x00000002           // pcre2.h:192:1:
	DPCRE2_CONVERT_POSIX_BASIC                       = 0x00000004           // pcre2.h:193:1:
	DPCRE2_CONVERT_POSIX_EXTENDED                    = 0x00000008           // pcre2.h:194:1:
	DPCRE2_CONVERT_UTF                               = 0x00000001           // pcre2.h:191:1:
	DPCRE2_COPY_MATCHED_SUBJECT                      = 0x00004000           // pcre2.h:184:1:
	DPCRE2_DATE                                      = 1999                 // pcre2.h:47:1:
	DPCRE2_DEREF_TABLES                              = 0x00040000           // pcre2_internal.h:525:1:
	DPCRE2_DFA_RESTART                               = 0x00000040           // pcre2.h:176:1:
	DPCRE2_DFA_SHORTEST                              = 0x00000080           // pcre2.h:177:1:
	DPCRE2_DOLLAR_ENDONLY                            = 0x00000010           // pcre2.h:123:1:
	DPCRE2_DOTALL                                    = 0x00000020           // pcre2.h:124:1:
	DPCRE2_DUPCAPUSED                                = 0x00200000           // pcre2_internal.h:528:1:
	DPCRE2_DUPNAMES                                  = 0x00000040           // pcre2.h:125:1:
	DPCRE2_ENDANCHORED                               = 0x20000000           // pcre2.h:107:1:
	DPCRE2_ERROR_ALPHA_ASSERTION_UNKNOWN             = 195                  // pcre2.h:311:1:
	DPCRE2_ERROR_BACKSLASH_C_CALLER_DISABLED         = 183                  // pcre2.h:299:1:
	DPCRE2_ERROR_BACKSLASH_C_LIBRARY_DISABLED        = 185                  // pcre2.h:301:1:
	DPCRE2_ERROR_BACKSLASH_C_SYNTAX                  = 168                  // pcre2.h:284:1:
	DPCRE2_ERROR_BACKSLASH_G_SYNTAX                  = 157                  // pcre2.h:272:1:
	DPCRE2_ERROR_BACKSLASH_K_IN_LOOKAROUND           = 199                  // pcre2.h:315:1:
	DPCRE2_ERROR_BACKSLASH_K_SYNTAX                  = 169                  // pcre2.h:285:1:
	DPCRE2_ERROR_BACKSLASH_N_IN_CLASS                = 171                  // pcre2.h:287:1:
	DPCRE2_ERROR_BACKSLASH_O_MISSING_BRACE           = 155                  // pcre2.h:270:1:
	DPCRE2_ERROR_BACKSLASH_U_CODE_POINT_TOO_BIG      = 177                  // pcre2.h:293:1:
	DPCRE2_ERROR_BADDATA                             = -29                  // pcre2.h:363:1:
	DPCRE2_ERROR_BADMAGIC                            = -31                  // pcre2.h:365:1:
	DPCRE2_ERROR_BADMODE                             = -32                  // pcre2.h:366:1:
	DPCRE2_ERROR_BADOFFSET                           = -33                  // pcre2.h:367:1:
	DPCRE2_ERROR_BADOFFSETLIMIT                      = -56                  // pcre2.h:391:1:
	DPCRE2_ERROR_BADOPTION                           = -34                  // pcre2.h:368:1:
	DPCRE2_ERROR_BADREPESCAPE                        = -57                  // pcre2.h:392:1:
	DPCRE2_ERROR_BADREPLACEMENT                      = -35                  // pcre2.h:369:1:
	DPCRE2_ERROR_BADSERIALIZEDDATA                   = -62                  // pcre2.h:397:1:
	DPCRE2_ERROR_BADSUBSPATTERN                      = -60                  // pcre2.h:395:1:
	DPCRE2_ERROR_BADSUBSTITUTION                     = -59                  // pcre2.h:394:1:
	DPCRE2_ERROR_BADUTFOFFSET                        = -36                  // pcre2.h:370:1:
	DPCRE2_ERROR_BAD_LITERAL_OPTIONS                 = 192                  // pcre2.h:308:1:
	DPCRE2_ERROR_BAD_OPTIONS                         = 117                  // pcre2.h:232:1:
	DPCRE2_ERROR_BAD_RELATIVE_REFERENCE              = 129                  // pcre2.h:244:1:
	DPCRE2_ERROR_BAD_SUBPATTERN_REFERENCE            = 115                  // pcre2.h:230:1:
	DPCRE2_ERROR_CALLOUT                             = -37                  // pcre2.h:371:1:
	DPCRE2_ERROR_CALLOUT_BAD_STRING_DELIMITER        = 182                  // pcre2.h:298:1:
	DPCRE2_ERROR_CALLOUT_NO_STRING_DELIMITER         = 181                  // pcre2.h:297:1:
	DPCRE2_ERROR_CALLOUT_NUMBER_TOO_BIG              = 138                  // pcre2.h:253:1:
	DPCRE2_ERROR_CALLOUT_STRING_TOO_LONG             = 172                  // pcre2.h:288:1:
	DPCRE2_ERROR_CLASS_INVALID_RANGE                 = 150                  // pcre2.h:265:1:
	DPCRE2_ERROR_CLASS_RANGE_ORDER                   = 108                  // pcre2.h:223:1:
	DPCRE2_ERROR_CODE_POINT_TOO_BIG                  = 134                  // pcre2.h:249:1:
	DPCRE2_ERROR_CONDITION_ASSERTION_EXPECTED        = 128                  // pcre2.h:243:1:
	DPCRE2_ERROR_CONDITION_ATOMIC_ASSERTION_EXPECTED = 198                  // pcre2.h:314:1:
	DPCRE2_ERROR_CONVERT_SYNTAX                      = -64                  // pcre2.h:399:1:
	DPCRE2_ERROR_DEFINE_TOO_MANY_BRANCHES            = 154                  // pcre2.h:269:1:
	DPCRE2_ERROR_DEPTHLIMIT                          = -53                  // pcre2.h:387:1:
	DPCRE2_ERROR_DFA_BADRESTART                      = -38                  // pcre2.h:372:1:
	DPCRE2_ERROR_DFA_RECURSE                         = -39                  // pcre2.h:373:1:
	DPCRE2_ERROR_DFA_UCOND                           = -40                  // pcre2.h:374:1:
	DPCRE2_ERROR_DFA_UFUNC                           = -41                  // pcre2.h:375:1:
	DPCRE2_ERROR_DFA_UINVALID_UTF                    = -66                  // pcre2.h:401:1:
	DPCRE2_ERROR_DFA_UITEM                           = -42                  // pcre2.h:376:1:
	DPCRE2_ERROR_DFA_WSSIZE                          = -43                  // pcre2.h:377:1:
	DPCRE2_ERROR_DUPLICATE_SUBPATTERN_NAME           = 143                  // pcre2.h:258:1:
	DPCRE2_ERROR_END_BACKSLASH                       = 101                  // pcre2.h:216:1:
	DPCRE2_ERROR_END_BACKSLASH_C                     = 102                  // pcre2.h:217:1:
	DPCRE2_ERROR_ESCAPE_INVALID_IN_CLASS             = 107                  // pcre2.h:222:1:
	DPCRE2_ERROR_ESCAPE_INVALID_IN_VERB              = 140                  // pcre2.h:255:1:
	DPCRE2_ERROR_HEAPLIMIT                           = -63                  // pcre2.h:398:1:
	DPCRE2_ERROR_HEAP_FAILED                         = 121                  // pcre2.h:236:1:
	DPCRE2_ERROR_INTERNAL                            = -44                  // pcre2.h:378:1:
	DPCRE2_ERROR_INTERNAL_BAD_CODE                   = 189                  // pcre2.h:305:1:
	DPCRE2_ERROR_INTERNAL_BAD_CODE_AUTO_POSSESS      = 180                  // pcre2.h:296:1:
	DPCRE2_ERROR_INTERNAL_BAD_CODE_IN_SKIP           = 190                  // pcre2.h:306:1:
	DPCRE2_ERROR_INTERNAL_BAD_CODE_LOOKBEHINDS       = 170                  // pcre2.h:286:1:
	DPCRE2_ERROR_INTERNAL_CODE_OVERFLOW              = 123                  // pcre2.h:238:1:
	DPCRE2_ERROR_INTERNAL_DUPMATCH                   = -65                  // pcre2.h:400:1:
	DPCRE2_ERROR_INTERNAL_MISSING_SUBPATTERN         = 153                  // pcre2.h:268:1:
	DPCRE2_ERROR_INTERNAL_OVERRAN_WORKSPACE          = 152                  // pcre2.h:267:1:
	DPCRE2_ERROR_INTERNAL_PARSED_OVERFLOW            = 163                  // pcre2.h:279:1:
	DPCRE2_ERROR_INTERNAL_STUDY_ERROR                = 131                  // pcre2.h:246:1:
	DPCRE2_ERROR_INTERNAL_UNEXPECTED_REPEAT          = 110                  // pcre2.h:225:1:
	DPCRE2_ERROR_INTERNAL_UNKNOWN_NEWLINE            = 156                  // pcre2.h:271:1:
	DPCRE2_ERROR_INVALID_AFTER_PARENS_QUERY          = 111                  // pcre2.h:226:1:
	DPCRE2_ERROR_INVALID_HEXADECIMAL                 = 167                  // pcre2.h:283:1:
	DPCRE2_ERROR_INVALID_HYPHEN_IN_OPTIONS           = 194                  // pcre2.h:310:1:
	DPCRE2_ERROR_INVALID_OCTAL                       = 164                  // pcre2.h:280:1:
	DPCRE2_ERROR_INVALID_SUBPATTERN_NAME             = 144                  // pcre2.h:259:1:
	DPCRE2_ERROR_JIT_BADOPTION                       = -45                  // pcre2.h:379:1:
	DPCRE2_ERROR_JIT_STACKLIMIT                      = -46                  // pcre2.h:380:1:
	DPCRE2_ERROR_LOOKBEHIND_INVALID_BACKSLASH_C      = 136                  // pcre2.h:251:1:
	DPCRE2_ERROR_LOOKBEHIND_NOT_FIXED_LENGTH         = 125                  // pcre2.h:240:1:
	DPCRE2_ERROR_LOOKBEHIND_TOO_COMPLICATED          = 135                  // pcre2.h:250:1:
	DPCRE2_ERROR_LOOKBEHIND_TOO_LONG                 = 187                  // pcre2.h:303:1:
	DPCRE2_ERROR_MALFORMED_UNICODE_PROPERTY          = 146                  // pcre2.h:261:1:
	DPCRE2_ERROR_MARK_MISSING_ARGUMENT               = 166                  // pcre2.h:282:1:
	DPCRE2_ERROR_MATCHLIMIT                          = -47                  // pcre2.h:381:1:
	DPCRE2_ERROR_MISSING_CALLOUT_CLOSING             = 139                  // pcre2.h:254:1:
	DPCRE2_ERROR_MISSING_CLOSING_PARENTHESIS         = 114                  // pcre2.h:229:1:
	DPCRE2_ERROR_MISSING_COMMENT_CLOSING             = 118                  // pcre2.h:233:1:
	DPCRE2_ERROR_MISSING_CONDITION_CLOSING           = 124                  // pcre2.h:239:1:
	DPCRE2_ERROR_MISSING_NAME_TERMINATOR             = 142                  // pcre2.h:257:1:
	DPCRE2_ERROR_MISSING_OCTAL_OR_HEX_DIGITS         = 178                  // pcre2.h:294:1:
	DPCRE2_ERROR_MISSING_SQUARE_BRACKET              = 106                  // pcre2.h:221:1:
	DPCRE2_ERROR_MIXEDTABLES                         = -30                  // pcre2.h:364:1:
	DPCRE2_ERROR_NOMATCH                             = -1                   // pcre2.h:320:1:
	DPCRE2_ERROR_NOMEMORY                            = -48                  // pcre2.h:382:1:
	DPCRE2_ERROR_NOSUBSTRING                         = -49                  // pcre2.h:383:1:
	DPCRE2_ERROR_NOUNIQUESUBSTRING                   = -50                  // pcre2.h:384:1:
	DPCRE2_ERROR_NO_SURROGATES_IN_UTF16              = 191                  // pcre2.h:307:1:
	DPCRE2_ERROR_NULL                                = -51                  // pcre2.h:385:1:
	DPCRE2_ERROR_NULL_PATTERN                        = 116                  // pcre2.h:231:1:
	DPCRE2_ERROR_OCTAL_BYTE_TOO_BIG                  = 151                  // pcre2.h:266:1:
	DPCRE2_ERROR_PARENS_QUERY_R_MISSING_CLOSING      = 158                  // pcre2.h:273:1:
	DPCRE2_ERROR_PARENTHESES_NEST_TOO_DEEP           = 119                  // pcre2.h:234:1:
	DPCRE2_ERROR_PARENTHESES_STACK_CHECK             = 133                  // pcre2.h:248:1:
	DPCRE2_ERROR_PARTIAL                             = -2                   // pcre2.h:321:1:
	DPCRE2_ERROR_PATTERN_STRING_TOO_LONG             = 188                  // pcre2.h:304:1:
	DPCRE2_ERROR_PATTERN_TOO_COMPLICATED             = 186                  // pcre2.h:302:1:
	DPCRE2_ERROR_PATTERN_TOO_LARGE                   = 120                  // pcre2.h:235:1:
	DPCRE2_ERROR_POSIX_CLASS_NOT_IN_CLASS            = 112                  // pcre2.h:227:1:
	DPCRE2_ERROR_POSIX_NO_SUPPORT_COLLATING          = 113                  // pcre2.h:228:1:
	DPCRE2_ERROR_QUANTIFIER_INVALID                  = 109                  // pcre2.h:224:1:
	DPCRE2_ERROR_QUANTIFIER_OUT_OF_ORDER             = 104                  // pcre2.h:219:1:
	DPCRE2_ERROR_QUANTIFIER_TOO_BIG                  = 105                  // pcre2.h:220:1:
	DPCRE2_ERROR_QUERY_BARJX_NEST_TOO_DEEP           = 184                  // pcre2.h:300:1:
	DPCRE2_ERROR_RECURSELOOP                         = -52                  // pcre2.h:386:1:
	DPCRE2_ERROR_RECURSIONLIMIT                      = -53                  // pcre2.h:388:1:
	DPCRE2_ERROR_REPMISSINGBRACE                     = -58                  // pcre2.h:393:1:
	DPCRE2_ERROR_SCRIPT_RUN_NOT_AVAILABLE            = 196                  // pcre2.h:312:1:
	DPCRE2_ERROR_SUBPATTERN_NAMES_MISMATCH           = 165                  // pcre2.h:281:1:
	DPCRE2_ERROR_SUBPATTERN_NAME_EXPECTED            = 162                  // pcre2.h:278:1:
	DPCRE2_ERROR_SUBPATTERN_NAME_TOO_LONG            = 148                  // pcre2.h:263:1:
	DPCRE2_ERROR_SUBPATTERN_NUMBER_TOO_BIG           = 161                  // pcre2.h:277:1:
	DPCRE2_ERROR_SUPPORTED_ONLY_IN_UNICODE           = 193                  // pcre2.h:309:1:
	DPCRE2_ERROR_TOOMANYREPLACE                      = -61                  // pcre2.h:396:1:
	DPCRE2_ERROR_TOO_MANY_CAPTURES                   = 197                  // pcre2.h:313:1:
	DPCRE2_ERROR_TOO_MANY_CONDITION_BRANCHES         = 127                  // pcre2.h:242:1:
	DPCRE2_ERROR_TOO_MANY_NAMED_SUBPATTERNS          = 149                  // pcre2.h:264:1:
	DPCRE2_ERROR_UCP_IS_DISABLED                     = 175                  // pcre2.h:291:1:
	DPCRE2_ERROR_UNAVAILABLE                         = -54                  // pcre2.h:389:1:
	DPCRE2_ERROR_UNICODE_DISALLOWED_CODE_POINT       = 173                  // pcre2.h:289:1:
	DPCRE2_ERROR_UNICODE_NOT_SUPPORTED               = 132                  // pcre2.h:247:1:
	DPCRE2_ERROR_UNICODE_PROPERTIES_UNAVAILABLE      = 145                  // pcre2.h:260:1:
	DPCRE2_ERROR_UNKNOWN_ESCAPE                      = 103                  // pcre2.h:218:1:
	DPCRE2_ERROR_UNKNOWN_POSIX_CLASS                 = 130                  // pcre2.h:245:1:
	DPCRE2_ERROR_UNKNOWN_UNICODE_PROPERTY            = 147                  // pcre2.h:262:1:
	DPCRE2_ERROR_UNMATCHED_CLOSING_PARENTHESIS       = 122                  // pcre2.h:237:1:
	DPCRE2_ERROR_UNRECOGNIZED_AFTER_QUERY_P          = 141                  // pcre2.h:256:1:
	DPCRE2_ERROR_UNSET                               = -55                  // pcre2.h:390:1:
	DPCRE2_ERROR_UNSUPPORTED_ESCAPE_SEQUENCE         = 137                  // pcre2.h:252:1:
	DPCRE2_ERROR_UTF16_ERR1                          = -24                  // pcre2.h:349:1:
	DPCRE2_ERROR_UTF16_ERR2                          = -25                  // pcre2.h:350:1:
	DPCRE2_ERROR_UTF16_ERR3                          = -26                  // pcre2.h:351:1:
	DPCRE2_ERROR_UTF32_ERR1                          = -27                  // pcre2.h:355:1:
	DPCRE2_ERROR_UTF32_ERR2                          = -28                  // pcre2.h:356:1:
	DPCRE2_ERROR_UTF8_ERR1                           = -3                   // pcre2.h:325:1:
	DPCRE2_ERROR_UTF8_ERR10                          = -12                  // pcre2.h:334:1:
	DPCRE2_ERROR_UTF8_ERR11                          = -13                  // pcre2.h:335:1:
	DPCRE2_ERROR_UTF8_ERR12                          = -14                  // pcre2.h:336:1:
	DPCRE2_ERROR_UTF8_ERR13                          = -15                  // pcre2.h:337:1:
	DPCRE2_ERROR_UTF8_ERR14                          = -16                  // pcre2.h:338:1:
	DPCRE2_ERROR_UTF8_ERR15                          = -17                  // pcre2.h:339:1:
	DPCRE2_ERROR_UTF8_ERR16                          = -18                  // pcre2.h:340:1:
	DPCRE2_ERROR_UTF8_ERR17                          = -19                  // pcre2.h:341:1:
	DPCRE2_ERROR_UTF8_ERR18                          = -20                  // pcre2.h:342:1:
	DPCRE2_ERROR_UTF8_ERR19                          = -21                  // pcre2.h:343:1:
	DPCRE2_ERROR_UTF8_ERR2                           = -4                   // pcre2.h:326:1:
	DPCRE2_ERROR_UTF8_ERR20                          = -22                  // pcre2.h:344:1:
	DPCRE2_ERROR_UTF8_ERR21                          = -23                  // pcre2.h:345:1:
	DPCRE2_ERROR_UTF8_ERR3                           = -5                   // pcre2.h:327:1:
	DPCRE2_ERROR_UTF8_ERR4                           = -6                   // pcre2.h:328:1:
	DPCRE2_ERROR_UTF8_ERR5                           = -7                   // pcre2.h:329:1:
	DPCRE2_ERROR_UTF8_ERR6                           = -8                   // pcre2.h:330:1:
	DPCRE2_ERROR_UTF8_ERR7                           = -9                   // pcre2.h:331:1:
	DPCRE2_ERROR_UTF8_ERR8                           = -10                  // pcre2.h:332:1:
	DPCRE2_ERROR_UTF8_ERR9                           = -11                  // pcre2.h:333:1:
	DPCRE2_ERROR_UTF_IS_DISABLED                     = 174                  // pcre2.h:290:1:
	DPCRE2_ERROR_VERB_ARGUMENT_NOT_ALLOWED           = 159                  // pcre2.h:275:1:
	DPCRE2_ERROR_VERB_NAME_TOO_LONG                  = 176                  // pcre2.h:292:1:
	DPCRE2_ERROR_VERB_UNKNOWN                        = 160                  // pcre2.h:276:1:
	DPCRE2_ERROR_VERSION_CONDITION_SYNTAX            = 179                  // pcre2.h:295:1:
	DPCRE2_ERROR_ZERO_RELATIVE_REFERENCE             = 126                  // pcre2.h:241:1:
	DPCRE2_EXTENDED                                  = 0x00000080           // pcre2.h:126:1:
	DPCRE2_EXTENDED_MORE                             = 0x01000000           // pcre2.h:143:1:
	DPCRE2_EXTRA_ALLOW_LOOKAROUND_BSK                = 0x00000040           // pcre2.h:155:1:
	DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES             = 0x00000001           // pcre2.h:149:1:
	DPCRE2_EXTRA_ALT_BSUX                            = 0x00000020           // pcre2.h:154:1:
	DPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL               = 0x00000002           // pcre2.h:150:1:
	DPCRE2_EXTRA_ESCAPED_CR_IS_LF                    = 0x00000010           // pcre2.h:153:1:
	DPCRE2_EXTRA_MATCH_LINE                          = 0x00000008           // pcre2.h:152:1:
	DPCRE2_EXTRA_MATCH_WORD                          = 0x00000004           // pcre2.h:151:1:
	DPCRE2_FIRSTCASELESS                             = 0x00000020           // pcre2_internal.h:512:1:
	DPCRE2_FIRSTLINE                                 = 0x00000100           // pcre2.h:127:1:
	DPCRE2_FIRSTMAPSET                               = 0x00000040           // pcre2_internal.h:513:1:
	DPCRE2_FIRSTSET                                  = 0x00000010           // pcre2_internal.h:511:1:
	DPCRE2_HASACCEPT                                 = 0x00800000           // pcre2_internal.h:530:1:
	DPCRE2_HASBKC                                    = 0x00400000           // pcre2_internal.h:529:1:
	DPCRE2_HASBKPORX                                 = 0x00100000           // pcre2_internal.h:527:1:
	DPCRE2_HASCRORLF                                 = 0x00000800           // pcre2_internal.h:518:1:
	DPCRE2_HASTHEN                                   = 0x00001000           // pcre2_internal.h:519:1:
	DPCRE2_H_IDEMPOTENT_GUARD                        = 0                    // pcre2.h:40:1:
	DPCRE2_INFO_ALLOPTIONS                           = 0                    // pcre2.h:406:1:
	DPCRE2_INFO_ARGOPTIONS                           = 1                    // pcre2.h:407:1:
	DPCRE2_INFO_BACKREFMAX                           = 2                    // pcre2.h:408:1:
	DPCRE2_INFO_BSR                                  = 3                    // pcre2.h:409:1:
	DPCRE2_INFO_CAPTURECOUNT                         = 4                    // pcre2.h:410:1:
	DPCRE2_INFO_DEPTHLIMIT                           = 21                   // pcre2.h:427:1:
	DPCRE2_INFO_EXTRAOPTIONS                         = 26                   // pcre2.h:433:1:
	DPCRE2_INFO_FIRSTBITMAP                          = 7                    // pcre2.h:413:1:
	DPCRE2_INFO_FIRSTCODETYPE                        = 6                    // pcre2.h:412:1:
	DPCRE2_INFO_FIRSTCODEUNIT                        = 5                    // pcre2.h:411:1:
	DPCRE2_INFO_FRAMESIZE                            = 24                   // pcre2.h:431:1:
	DPCRE2_INFO_HASBACKSLASHC                        = 23                   // pcre2.h:430:1:
	DPCRE2_INFO_HASCRORLF                            = 8                    // pcre2.h:414:1:
	DPCRE2_INFO_HEAPLIMIT                            = 25                   // pcre2.h:432:1:
	DPCRE2_INFO_JCHANGED                             = 9                    // pcre2.h:415:1:
	DPCRE2_INFO_JITSIZE                              = 10                   // pcre2.h:416:1:
	DPCRE2_INFO_LASTCODETYPE                         = 12                   // pcre2.h:418:1:
	DPCRE2_INFO_LASTCODEUNIT                         = 11                   // pcre2.h:417:1:
	DPCRE2_INFO_MATCHEMPTY                           = 13                   // pcre2.h:419:1:
	DPCRE2_INFO_MATCHLIMIT                           = 14                   // pcre2.h:420:1:
	DPCRE2_INFO_MAXLOOKBEHIND                        = 15                   // pcre2.h:421:1:
	DPCRE2_INFO_MINLENGTH                            = 16                   // pcre2.h:422:1:
	DPCRE2_INFO_NAMECOUNT                            = 17                   // pcre2.h:423:1:
	DPCRE2_INFO_NAMEENTRYSIZE                        = 18                   // pcre2.h:424:1:
	DPCRE2_INFO_NAMETABLE                            = 19                   // pcre2.h:425:1:
	DPCRE2_INFO_NEWLINE                              = 20                   // pcre2.h:426:1:
	DPCRE2_INFO_RECURSIONLIMIT                       = 21                   // pcre2.h:428:1:
	DPCRE2_INFO_SIZE                                 = 22                   // pcre2.h:429:1:
	DPCRE2_INTERNAL_H_IDEMPOTENT_GUARD               = 0                    // pcre2_internal.h:42:1:
	DPCRE2_JCHANGED                                  = 0x00000400           // pcre2_internal.h:517:1:
	DPCRE2_JIT_COMPLETE                              = 0x00000001           // pcre2.h:159:1:
	DPCRE2_JIT_INVALID_UTF                           = 0x00000100           // pcre2.h:162:1:
	DPCRE2_JIT_PARTIAL_HARD                          = 0x00000004           // pcre2.h:161:1:
	DPCRE2_JIT_PARTIAL_SOFT                          = 0x00000002           // pcre2.h:160:1:
	DPCRE2_LASTCASELESS                              = 0x00000100           // pcre2_internal.h:515:1:
	DPCRE2_LASTSET                                   = 0x00000080           // pcre2_internal.h:514:1:
	DPCRE2_LITERAL                                   = 0x02000000           // pcre2.h:144:1:
	DPCRE2_MAJOR                                     = 10                   // pcre2.h:44:1:
	DPCRE2_MATCH_EMPTY                               = 0x00002000           // pcre2_internal.h:520:1:
	DPCRE2_MATCH_INVALID_UTF                         = 0x04000000           // pcre2.h:145:1:
	DPCRE2_MATCH_UNSET_BACKREF                       = 0x00000200           // pcre2.h:128:1:
	DPCRE2_MD_COPIED_SUBJECT                         = 0x01                 // pcre2_internal.h:542:1:
	DPCRE2_MINOR                                     = 42                   // pcre2.h:45:1:
	DPCRE2_MODE16                                    = 0x00000002           // pcre2_internal.h:509:1:
	DPCRE2_MODE32                                    = 0x00000004           // pcre2_internal.h:510:1:
	DPCRE2_MODE8                                     = 0x00000001           // pcre2_internal.h:508:1:
	DPCRE2_MODE_MASK                                 = 7                    // pcre2_internal.h:532:1:
	DPCRE2_MULTILINE                                 = 0x00000400           // pcre2.h:129:1:
	DPCRE2_NEVER_BACKSLASH_C                         = 0x00100000           // pcre2.h:139:1:
	DPCRE2_NEVER_UCP                                 = 0x00000800           // pcre2.h:130:1:
	DPCRE2_NEVER_UTF                                 = 0x00001000           // pcre2.h:131:1:
	DPCRE2_NEWLINE_ANY                               = 4                    // pcre2.h:206:1:
	DPCRE2_NEWLINE_ANYCRLF                           = 5                    // pcre2.h:207:1:
	DPCRE2_NEWLINE_CR                                = 1                    // pcre2.h:203:1:
	DPCRE2_NEWLINE_CRLF                              = 3                    // pcre2.h:205:1:
	DPCRE2_NEWLINE_LF                                = 2                    // pcre2.h:204:1:
	DPCRE2_NEWLINE_NUL                               = 6                    // pcre2.h:208:1:
	DPCRE2_NE_ATST_SET                               = 0x00020000           // pcre2_internal.h:524:1:
	DPCRE2_NL_SET                                    = 0x00008000           // pcre2_internal.h:522:1:
	DPCRE2_NOJIT                                     = 0x00080000           // pcre2_internal.h:526:1:
	DPCRE2_NOTBOL                                    = 0x00000001           // pcre2.h:170:1:
	DPCRE2_NOTEMPTY                                  = 0x00000004           // pcre2.h:172:1:
	DPCRE2_NOTEMPTY_ATSTART                          = 0x00000008           // pcre2.h:173:1:
	DPCRE2_NOTEMPTY_SET                              = 0x00010000           // pcre2_internal.h:523:1:
	DPCRE2_NOTEOL                                    = 0x00000002           // pcre2.h:171:1:
	DPCRE2_NO_AUTO_CAPTURE                           = 0x00002000           // pcre2.h:132:1:
	DPCRE2_NO_AUTO_POSSESS                           = 0x00004000           // pcre2.h:133:1:
	DPCRE2_NO_DOTSTAR_ANCHOR                         = 0x00008000           // pcre2.h:134:1:
	DPCRE2_NO_JIT                                    = 0x00002000           // pcre2.h:183:1:
	DPCRE2_NO_START_OPTIMIZE                         = 0x00010000           // pcre2.h:135:1:
	DPCRE2_NO_UTF_CHECK                              = 0x40000000           // pcre2.h:106:1:
	DPCRE2_PARTIAL_HARD                              = 0x00000020           // pcre2.h:175:1:
	DPCRE2_PARTIAL_SOFT                              = 0x00000010           // pcre2.h:174:1:
	DPCRE2_PRERELEASE                                = 0                    // pcre2.h:46:1:
	DPCRE2_SIZE_MAX                                  = 18446744073709551615 // pcre2.h:472:1:
	DPCRE2_STARTLINE                                 = 0x00000200           // pcre2_internal.h:516:1:
	DPCRE2_STATIC                                    = 1                    // config.h:278:1:
	DPCRE2_SUBSTITUTE_EXTENDED                       = 0x00000200           // pcre2.h:179:1:
	DPCRE2_SUBSTITUTE_GLOBAL                         = 0x00000100           // pcre2.h:178:1:
	DPCRE2_SUBSTITUTE_LITERAL                        = 0x00008000           // pcre2.h:185:1:
	DPCRE2_SUBSTITUTE_MATCHED                        = 0x00010000           // pcre2.h:186:1:
	DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH                = 0x00001000           // pcre2.h:182:1:
	DPCRE2_SUBSTITUTE_REPLACEMENT_ONLY               = 0x00020000           // pcre2.h:187:1:
	DPCRE2_SUBSTITUTE_UNKNOWN_UNSET                  = 0x00000800           // pcre2.h:181:1:
	DPCRE2_SUBSTITUTE_UNSET_EMPTY                    = 0x00000400           // pcre2.h:180:1:
	DPCRE2_UCP                                       = 0x00020000           // pcre2.h:136:1:
	DPCRE2_UCP_H_IDEMPOTENT_GUARD                    = 0                    // pcre2_ucp.h:46:1:
	DPCRE2_UNGREEDY                                  = 0x00040000           // pcre2.h:137:1:
	DPCRE2_USE_OFFSET_LIMIT                          = 0x00800000           // pcre2.h:142:1:
	DPCRE2_UTF                                       = 0x00080000           // pcre2.h:138:1:
	DPDP_ENDIAN                                      = 3412                 // endian.h:29:1:
	DPIPE_BUF                                        = 4096                 // limits.h:14:1:
	DPRIX16                                          = "X"                  // inttypes.h:135:1:
	DPRIX32                                          = "X"                  // inttypes.h:136:1:
	DPRIX8                                           = "X"                  // inttypes.h:134:1:
	DPRIXFAST8                                       = "X"                  // inttypes.h:144:1:
	DPRIXLEAST16                                     = "X"                  // inttypes.h:140:1:
	DPRIXLEAST32                                     = "X"                  // inttypes.h:141:1:
	DPRIXLEAST8                                      = "X"                  // inttypes.h:139:1:
	DPRId16                                          = "d"                  // inttypes.h:55:1:
	DPRId32                                          = "d"                  // inttypes.h:56:1:
	DPRId8                                           = "d"                  // inttypes.h:54:1:
	DPRIdFAST8                                       = "d"                  // inttypes.h:64:1:
	DPRIdLEAST16                                     = "d"                  // inttypes.h:60:1:
	DPRIdLEAST32                                     = "d"                  // inttypes.h:61:1:
	DPRIdLEAST8                                      = "d"                  // inttypes.h:59:1:
	DPRIi16                                          = "i"                  // inttypes.h:71:1:
	DPRIi32                                          = "i"                  // inttypes.h:72:1:
	DPRIi8                                           = "i"                  // inttypes.h:70:1:
	DPRIiFAST8                                       = "i"                  // inttypes.h:80:1:
	DPRIiLEAST16                                     = "i"                  // inttypes.h:76:1:
	DPRIiLEAST32                                     = "i"                  // inttypes.h:77:1:
	DPRIiLEAST8                                      = "i"                  // inttypes.h:75:1:
	DPRIo16                                          = "o"                  // inttypes.h:87:1:
	DPRIo32                                          = "o"                  // inttypes.h:88:1:
	DPRIo8                                           = "o"                  // inttypes.h:86:1:
	DPRIoFAST8                                       = "o"                  // inttypes.h:96:1:
	DPRIoLEAST16                                     = "o"                  // inttypes.h:92:1:
	DPRIoLEAST32                                     = "o"                  // inttypes.h:93:1:
	DPRIoLEAST8                                      = "o"                  // inttypes.h:91:1:
	DPRIu16                                          = "u"                  // inttypes.h:103:1:
	DPRIu32                                          = "u"                  // inttypes.h:104:1:
	DPRIu8                                           = "u"                  // inttypes.h:102:1:
	DPRIuFAST8                                       = "u"                  // inttypes.h:112:1:
	DPRIuLEAST16                                     = "u"                  // inttypes.h:108:1:
	DPRIuLEAST32                                     = "u"                  // inttypes.h:109:1:
	DPRIuLEAST8                                      = "u"                  // inttypes.h:107:1:
	DPRIx16                                          = "x"                  // inttypes.h:119:1:
	DPRIx32                                          = "x"                  // inttypes.h:120:1:
	DPRIx8                                           = "x"                  // inttypes.h:118:1:
	DPRIxFAST8                                       = "x"                  // inttypes.h:128:1:
	DPRIxLEAST16                                     = "x"                  // inttypes.h:124:1:
	DPRIxLEAST32                                     = "x"                  // inttypes.h:125:1:
	DPRIxLEAST8                                      = "x"                  // inttypes.h:123:1:
	DPTHREAD_DESTRUCTOR_ITERATIONS                   = 4                    // local_lim.h:69:1:
	DPTHREAD_KEYS_MAX                                = 1024                 // local_lim.h:64:1:
	DPTRDIFF_MAX                                     = 9223372036854775807  // stdint.h:210:1:
	DPTRDIFF_MIN                                     = -9223372036854775808 // stdint.h:209:1:
	DPTRDIFF_WIDTH                                   = 64                   // stdint.h:311:1:
	DPT_ALNUM                                        = 6                    // pcre2_internal.h:1281:1:
	DPT_ANY                                          = 0                    // pcre2_internal.h:1275:1:
	DPT_BIDICL                                       = 12                   // pcre2_internal.h:1287:1:
	DPT_BOOL                                         = 13                   // pcre2_internal.h:1288:1:
	DPT_CLIST                                        = 10                   // pcre2_internal.h:1285:1:
	DPT_GC                                           = 2                    // pcre2_internal.h:1277:1:
	DPT_LAMP                                         = 1                    // pcre2_internal.h:1276:1:
	DPT_NOTSCRIPT                                    = 255                  // pcre2_internal.h:1304:1:
	DPT_PC                                           = 3                    // pcre2_internal.h:1278:1:
	DPT_PXGRAPH                                      = 14                   // pcre2_internal.h:1297:1:
	DPT_PXPRINT                                      = 15                   // pcre2_internal.h:1298:1:
	DPT_PXPUNCT                                      = 16                   // pcre2_internal.h:1299:1:
	DPT_PXSPACE                                      = 8                    // pcre2_internal.h:1283:1:
	DPT_SC                                           = 4                    // pcre2_internal.h:1279:1:
	DPT_SCX                                          = 5                    // pcre2_internal.h:1280:1:
	DPT_SPACE                                        = 7                    // pcre2_internal.h:1282:1:
	DPT_TABSIZE                                      = 14                   // pcre2_internal.h:1289:1:
	DPT_UCNC                                         = 11                   // pcre2_internal.h:1286:1:
	DPT_WORD                                         = 9                    // pcre2_internal.h:1284:1:
	DP_tmpdir                                        = "/tmp"               // stdio.h:120:1:
	DRAND_MAX                                        = 2147483647           // stdlib.h:87:1:
	DRENAME_EXCHANGE                                 = 2                    // stdio.h:165:1:
	DRENAME_NOREPLACE                                = 1                    // stdio.h:164:1:
	DRENAME_WHITEOUT                                 = 4                    // stdio.h:166:1:
	DREQ_CU_MAX                                      = 5000                 // pcre2_internal.h:554:1:
	DRE_DUP_MAX                                      = 32767                // posix2_lim.h:88:1:
	DRREF_ANY                                        = 0xffff               // pcre2_internal.h:1782:1:
	DRTSIG_MAX                                       = 32                   // limits.h:19:1:
	DSCHAR_MAX                                       = 127                  // limits.h:75:1:
	DSCHAR_MIN                                       = -128                 // limits.h:73:1:
	DSCHAR_WIDTH                                     = 8                    // limits.h:167:1:
	DSCNd16                                          = "hd"                 // inttypes.h:172:1:
	DSCNd32                                          = "d"                  // inttypes.h:173:1:
	DSCNd8                                           = "hhd"                // inttypes.h:171:1:
	DSCNdFAST8                                       = "hhd"                // inttypes.h:181:1:
	DSCNdLEAST16                                     = "hd"                 // inttypes.h:177:1:
	DSCNdLEAST32                                     = "d"                  // inttypes.h:178:1:
	DSCNdLEAST8                                      = "hhd"                // inttypes.h:176:1:
	DSCNi16                                          = "hi"                 // inttypes.h:188:1:
	DSCNi32                                          = "i"                  // inttypes.h:189:1:
	DSCNi8                                           = "hhi"                // inttypes.h:187:1:
	DSCNiFAST8                                       = "hhi"                // inttypes.h:197:1:
	DSCNiLEAST16                                     = "hi"                 // inttypes.h:193:1:
	DSCNiLEAST32                                     = "i"                  // inttypes.h:194:1:
	DSCNiLEAST8                                      = "hhi"                // inttypes.h:192:1:
	DSCNo16                                          = "ho"                 // inttypes.h:220:1:
	DSCNo32                                          = "o"                  // inttypes.h:221:1:
	DSCNo8                                           = "hho"                // inttypes.h:219:1:
	DSCNoFAST8                                       = "hho"                // inttypes.h:229:1:
	DSCNoLEAST16                                     = "ho"                 // inttypes.h:225:1:
	DSCNoLEAST32                                     = "o"                  // inttypes.h:226:1:
	DSCNoLEAST8                                      = "hho"                // inttypes.h:224:1:
	DSCNu16                                          = "hu"                 // inttypes.h:204:1:
	DSCNu32                                          = "u"                  // inttypes.h:205:1:
	DSCNu8                                           = "hhu"                // inttypes.h:203:1:
	DSCNuFAST8                                       = "hhu"                // inttypes.h:213:1:
	DSCNuLEAST16                                     = "hu"                 // inttypes.h:209:1:
	DSCNuLEAST32                                     = "u"                  // inttypes.h:210:1:
	DSCNuLEAST8                                      = "hhu"                // inttypes.h:208:1:
	DSCNx16                                          = "hx"                 // inttypes.h:236:1:
	DSCNx32                                          = "x"                  // inttypes.h:237:1:
	DSCNx8                                           = "hhx"                // inttypes.h:235:1:
	DSCNxFAST8                                       = "hhx"                // inttypes.h:245:1:
	DSCNxLEAST16                                     = "hx"                 // inttypes.h:241:1:
	DSCNxLEAST32                                     = "x"                  // inttypes.h:242:1:
	DSCNxLEAST8                                      = "hhx"                // inttypes.h:240:1:
	DSEEK_CUR                                        = 1                    // stdio.h:110:1:
	DSEEK_DATA                                       = 3                    // stdio.h:113:1:
	DSEEK_END                                        = 2                    // stdio.h:111:1:
	DSEEK_HOLE                                       = 4                    // stdio.h:114:1:
	DSEEK_SET                                        = 0                    // stdio.h:109:1:
	DSEM_VALUE_MAX                                   = 2147483647           // local_lim.h:99:1:
	DSHRT_MAX                                        = 32767                // limits.h:106:1:
	DSHRT_MIN                                        = -32768               // limits.h:104:1:
	DSHRT_WIDTH                                      = 16                   // limits.h:171:1:
	DSIG_ATOMIC_MAX                                  = 2147483647           // stdint.h:223:1:
	DSIG_ATOMIC_MIN                                  = -2147483648          // stdint.h:222:1:
	DSIG_ATOMIC_WIDTH                                = 32                   // stdint.h:312:1:
	DSIZE_MAX                                        = 18446744073709551615 // stdint.h:227:1:
	DSIZE_WIDTH                                      = 64                   // stdint.h:313:1:
	DSSIZE_MAX                                       = 9223372036854775807  // posix1_lim.h:169:1:
	DSTART_FRAMES_SIZE                               = 20480                // pcre2_internal.h:230:1:
	DSTDC_HEADERS                                    = 1                    // config.h:292:1:
	DSTR_0                                           = "\060"               // pcre2_internal.h:1105:1:
	DSTR_1                                           = "\061"               // pcre2_internal.h:1106:1:
	DSTR_2                                           = "\062"               // pcre2_internal.h:1107:1:
	DSTR_3                                           = "\063"               // pcre2_internal.h:1108:1:
	DSTR_4                                           = "\064"               // pcre2_internal.h:1109:1:
	DSTR_5                                           = "\065"               // pcre2_internal.h:1110:1:
	DSTR_6                                           = "\066"               // pcre2_internal.h:1111:1:
	DSTR_7                                           = "\067"               // pcre2_internal.h:1112:1:
	DSTR_8                                           = "\070"               // pcre2_internal.h:1113:1:
	DSTR_9                                           = "\071"               // pcre2_internal.h:1114:1:
	DSTR_A                                           = "\101"               // pcre2_internal.h:1122:1:
	DSTR_AMPERSAND                                   = "\046"               // pcre2_internal.h:1095:1:
	DSTR_APOSTROPHE                                  = "\047"               // pcre2_internal.h:1096:1:
	DSTR_ASTERISK                                    = "\052"               // pcre2_internal.h:1099:1:
	DSTR_B                                           = "\102"               // pcre2_internal.h:1123:1:
	DSTR_BACKSLASH                                   = "\134"               // pcre2_internal.h:1149:1:
	DSTR_BEL                                         = "\007"               // pcre2_internal.h:1085:1:
	DSTR_BS                                          = "\010"               // pcre2_internal.h:1084:1:
	DSTR_C                                           = "\103"               // pcre2_internal.h:1124:1:
	DSTR_CIRCUMFLEX_ACCENT                           = "\136"               // pcre2_internal.h:1151:1:
	DSTR_COLON                                       = "\072"               // pcre2_internal.h:1115:1:
	DSTR_COMMA                                       = "\054"               // pcre2_internal.h:1101:1:
	DSTR_COMMERCIAL_AT                               = "\100"               // pcre2_internal.h:1121:1:
	DSTR_CR                                          = "\015"               // pcre2_internal.h:1082:1:
	DSTR_D                                           = "\104"               // pcre2_internal.h:1125:1:
	DSTR_DEL                                         = "\177"               // pcre2_internal.h:1087:1:
	DSTR_DOLLAR_SIGN                                 = "\044"               // pcre2_internal.h:1093:1:
	DSTR_DOT                                         = "\056"               // pcre2_internal.h:1103:1:
	DSTR_E                                           = "\105"               // pcre2_internal.h:1126:1:
	DSTR_EQUALS_SIGN                                 = "\075"               // pcre2_internal.h:1118:1:
	DSTR_ESC                                         = "\033"               // pcre2_internal.h:1086:1:
	DSTR_EXCLAMATION_MARK                            = "\041"               // pcre2_internal.h:1090:1:
	DSTR_F                                           = "\106"               // pcre2_internal.h:1127:1:
	DSTR_FF                                          = "\014"               // pcre2_internal.h:1081:1:
	DSTR_G                                           = "\107"               // pcre2_internal.h:1128:1:
	DSTR_GRAVE_ACCENT                                = "\140"               // pcre2_internal.h:1153:1:
	DSTR_GREATER_THAN_SIGN                           = "\076"               // pcre2_internal.h:1119:1:
	DSTR_H                                           = "\110"               // pcre2_internal.h:1129:1:
	DSTR_HT                                          = "\011"               // pcre2_internal.h:1079:1:
	DSTR_I                                           = "\111"               // pcre2_internal.h:1130:1:
	DSTR_J                                           = "\112"               // pcre2_internal.h:1131:1:
	DSTR_K                                           = "\113"               // pcre2_internal.h:1132:1:
	DSTR_L                                           = "\114"               // pcre2_internal.h:1133:1:
	DSTR_LEFT_CURLY_BRACKET                          = "\173"               // pcre2_internal.h:1180:1:
	DSTR_LEFT_PARENTHESIS                            = "\050"               // pcre2_internal.h:1097:1:
	DSTR_LEFT_SQUARE_BRACKET                         = "\133"               // pcre2_internal.h:1148:1:
	DSTR_LESS_THAN_SIGN                              = "\074"               // pcre2_internal.h:1117:1:
	DSTR_M                                           = "\115"               // pcre2_internal.h:1134:1:
	DSTR_MINUS                                       = "\055"               // pcre2_internal.h:1102:1:
	DSTR_N                                           = "\116"               // pcre2_internal.h:1135:1:
	DSTR_NL                                          = "\012"               // pcre2_internal.h:1083:1:
	DSTR_NUMBER_SIGN                                 = "\043"               // pcre2_internal.h:1092:1:
	DSTR_O                                           = "\117"               // pcre2_internal.h:1136:1:
	DSTR_P                                           = "\120"               // pcre2_internal.h:1137:1:
	DSTR_PERCENT_SIGN                                = "\045"               // pcre2_internal.h:1094:1:
	DSTR_PLUS                                        = "\053"               // pcre2_internal.h:1100:1:
	DSTR_Q                                           = "\121"               // pcre2_internal.h:1138:1:
	DSTR_QUESTION_MARK                               = "\077"               // pcre2_internal.h:1120:1:
	DSTR_QUOTATION_MARK                              = "\042"               // pcre2_internal.h:1091:1:
	DSTR_R                                           = "\122"               // pcre2_internal.h:1139:1:
	DSTR_RIGHT_CURLY_BRACKET                         = "\175"               // pcre2_internal.h:1182:1:
	DSTR_RIGHT_PARENTHESIS                           = "\051"               // pcre2_internal.h:1098:1:
	DSTR_RIGHT_SQUARE_BRACKET                        = "\135"               // pcre2_internal.h:1150:1:
	DSTR_S                                           = "\123"               // pcre2_internal.h:1140:1:
	DSTR_SEMICOLON                                   = "\073"               // pcre2_internal.h:1116:1:
	DSTR_SLASH                                       = "\057"               // pcre2_internal.h:1104:1:
	DSTR_SPACE                                       = "\040"               // pcre2_internal.h:1089:1:
	DSTR_T                                           = "\124"               // pcre2_internal.h:1141:1:
	DSTR_TILDE                                       = "\176"               // pcre2_internal.h:1183:1:
	DSTR_U                                           = "\125"               // pcre2_internal.h:1142:1:
	DSTR_UNDERSCORE                                  = "\137"               // pcre2_internal.h:1152:1:
	DSTR_V                                           = "\126"               // pcre2_internal.h:1143:1:
	DSTR_VERTICAL_LINE                               = "\174"               // pcre2_internal.h:1181:1:
	DSTR_VT                                          = "\013"               // pcre2_internal.h:1080:1:
	DSTR_W                                           = "\127"               // pcre2_internal.h:1144:1:
	DSTR_X                                           = "\130"               // pcre2_internal.h:1145:1:
	DSTR_Y                                           = "\131"               // pcre2_internal.h:1146:1:
	DSTR_Z                                           = "\132"               // pcre2_internal.h:1147:1:
	DSTR_a                                           = "\141"               // pcre2_internal.h:1154:1:
	DSTR_b                                           = "\142"               // pcre2_internal.h:1155:1:
	DSTR_c                                           = "\143"               // pcre2_internal.h:1156:1:
	DSTR_d                                           = "\144"               // pcre2_internal.h:1157:1:
	DSTR_e                                           = "\145"               // pcre2_internal.h:1158:1:
	DSTR_f                                           = "\146"               // pcre2_internal.h:1159:1:
	DSTR_g                                           = "\147"               // pcre2_internal.h:1160:1:
	DSTR_h                                           = "\150"               // pcre2_internal.h:1161:1:
	DSTR_i                                           = "\151"               // pcre2_internal.h:1162:1:
	DSTR_j                                           = "\152"               // pcre2_internal.h:1163:1:
	DSTR_k                                           = "\153"               // pcre2_internal.h:1164:1:
	DSTR_l                                           = "\154"               // pcre2_internal.h:1165:1:
	DSTR_m                                           = "\155"               // pcre2_internal.h:1166:1:
	DSTR_n                                           = "\156"               // pcre2_internal.h:1167:1:
	DSTR_o                                           = "\157"               // pcre2_internal.h:1168:1:
	DSTR_p                                           = "\160"               // pcre2_internal.h:1169:1:
	DSTR_q                                           = "\161"               // pcre2_internal.h:1170:1:
	DSTR_r                                           = "\162"               // pcre2_internal.h:1171:1:
	DSTR_s                                           = "\163"               // pcre2_internal.h:1172:1:
	DSTR_t                                           = "\164"               // pcre2_internal.h:1173:1:
	DSTR_u                                           = "\165"               // pcre2_internal.h:1174:1:
	DSTR_v                                           = "\166"               // pcre2_internal.h:1175:1:
	DSTR_w                                           = "\167"               // pcre2_internal.h:1176:1:
	DSTR_x                                           = "\170"               // pcre2_internal.h:1177:1:
	DSTR_y                                           = "\171"               // pcre2_internal.h:1178:1:
	DSTR_z                                           = "\172"               // pcre2_internal.h:1179:1:
	DSUPPORT_PCRE2GREP_CALLOUT                       = 0                    // config.h:312:1:
	DSUPPORT_PCRE2GREP_CALLOUT_FORK                  = 0                    // config.h:317:1:
	DSUPPORT_PCRE2_8                                 = 0                    // config.h:330:1:
	DSUPPORT_UNICODE                                 = 0                    // config.h:336:1:
	DSUPPORT_WIDE_CHARS                              = 0                    // pcre2_intmodedep.h:216:1:
	DTABLES_LENGTH                                   = 1088                 // pcre2_internal.h:592:1:
	DTMP_MAX                                         = 238328               // stdio_lim.h:26:1:
	DTRUE                                            = 1                    // pcre2_internal.h:70:1:
	DTTY_NAME_MAX                                    = 32                   // local_lim.h:87:1:
	DUCD_BIDICLASS_SHIFT                             = 11                   // pcre2_internal.h:1843:1:
	DUCD_BLOCK_SIZE                                  = 128                  // pcre2_internal.h:1830:1:
	DUCD_BPROPS_MASK                                 = 0xfff                // pcre2_internal.h:1844:1:
	DUCD_SCRIPTX_MASK                                = 0x3ff                // pcre2_internal.h:1842:1:
	DUCHAR_MAX                                       = 255                  // limits.h:82:1:
	DUCHAR_WIDTH                                     = 8                    // limits.h:169:1:
	DUINT16_MAX                                      = 65535                // stdint.h:128:1:
	DUINT16_WIDTH                                    = 16                   // stdint.h:281:1:
	DUINT32_MAX                                      = 4294967295           // stdint.h:129:1:
	DUINT32_WIDTH                                    = 32                   // stdint.h:283:1:
	DUINT64_MAX                                      = 18446744073709551615 // stdint.h:130:1:
	DUINT64_WIDTH                                    = 64                   // stdint.h:285:1:
	DUINT8_MAX                                       = 255                  // stdint.h:127:1:
	DUINT8_WIDTH                                     = 8                    // stdint.h:279:1:
	DUINTMAX_MAX                                     = 18446744073709551615 // stdint.h:202:1:
	DUINTMAX_WIDTH                                   = 64                   // stdint.h:309:1:
	DUINTPTR_MAX                                     = 18446744073709551615 // stdint.h:188:1:
	DUINTPTR_WIDTH                                   = 64                   // stdint.h:306:1:
	DUINT_FAST16_MAX                                 = 18446744073709551615 // stdint.h:175:1:
	DUINT_FAST16_WIDTH                               = 64                   // stdint.h:299:1:
	DUINT_FAST32_MAX                                 = 18446744073709551615 // stdint.h:176:1:
	DUINT_FAST32_WIDTH                               = 64                   // stdint.h:301:1:
	DUINT_FAST64_MAX                                 = 18446744073709551615 // stdint.h:181:1:
	DUINT_FAST64_WIDTH                               = 64                   // stdint.h:303:1:
	DUINT_FAST8_MAX                                  = 255                  // stdint.h:173:1:
	DUINT_FAST8_WIDTH                                = 8                    // stdint.h:297:1:
	DUINT_LEAST16_MAX                                = 65535                // stdint.h:146:1:
	DUINT_LEAST16_WIDTH                              = 16                   // stdint.h:290:1:
	DUINT_LEAST32_MAX                                = 4294967295           // stdint.h:147:1:
	DUINT_LEAST32_WIDTH                              = 32                   // stdint.h:292:1:
	DUINT_LEAST64_MAX                                = 18446744073709551615 // stdint.h:148:1:
	DUINT_LEAST64_WIDTH                              = 64                   // stdint.h:294:1:
	DUINT_LEAST8_MAX                                 = 255                  // stdint.h:145:1:
	DUINT_LEAST8_WIDTH                               = 8                    // stdint.h:288:1:
	DUINT_MAX                                        = 4294967295           // limits.h:124:1:
	DUINT_WIDTH                                      = 32                   // limits.h:177:1:
	DULLONG_MAX                                      = 18446744073709551615 // limits.h:146:1:
	DULLONG_WIDTH                                    = 64                   // limits.h:185:1:
	DULONG_LONG_MAX                                  = 18446744073709551615 // limits.h:158:1:
	DULONG_MAX                                       = 18446744073709551615 // limits.h:135:1:
	DULONG_WIDTH                                     = 64                   // limits.h:181:1:
	DUSHRT_MAX                                       = 65535                // limits.h:113:1:
	DUSHRT_WIDTH                                     = 16                   // limits.h:173:1:
	DVERSION                                         = "10.42"              // config.h:430:1:
	DWCHAR_MAX                                       = 2147483647           // stdint.h:240:1:
	DWCHAR_MIN                                       = -2147483648          // stdint.h:239:1:
	DWCHAR_WIDTH                                     = 32                   // stdint.h:314:1:
	DWCONTINUED                                      = 8                    // waitflags.h:32:1:
	DWEXITED                                         = 4                    // waitflags.h:31:1:
	DWINT_MAX                                        = 4294967295           // stdint.h:245:1:
	DWINT_MIN                                        = 0                    // stdint.h:244:1:
	DWINT_WIDTH                                      = 32                   // stdint.h:315:1:
	DWNOHANG                                         = 1                    // waitflags.h:25:1:
	DWNOWAIT                                         = 0x01000000           // waitflags.h:33:1:
	DWORD_BIT                                        = 32                   // xopen_lim.h:114:1:
	DWSTOPPED                                        = 2                    // waitflags.h:30:1:
	DWUNTRACED                                       = 2                    // waitflags.h:26:1:
	DXATTR_LIST_MAX                                  = 65536                // limits.h:17:1:
	DXATTR_NAME_MAX                                  = 255                  // limits.h:15:1:
	DXATTR_SIZE_MAX                                  = 65536                // limits.h:16:1:
	DXCL_END                                         = 0                    // pcre2_internal.h:1313:1:
	DXCL_HASPROP                                     = 0x04                 // pcre2_internal.h:1311:1:
	DXCL_MAP                                         = 0x02                 // pcre2_internal.h:1310:1:
	DXCL_NOT                                         = 0x01                 // pcre2_internal.h:1309:1:
	DXCL_NOTPROP                                     = 4                    // pcre2_internal.h:1317:1:
	DXCL_PROP                                        = 3                    // pcre2_internal.h:1316:1:
	DXCL_RANGE                                       = 2                    // pcre2_internal.h:1315:1:
	DXCL_SINGLE                                      = 1                    // pcre2_internal.h:1314:1:
	D_ALLOCA_H                                       = 1                    // alloca.h:19:1:
	D_ALL_SOURCE                                     = 1                    // config.h:343:1:
	D_ANSI_STDDEF_H                                  = 0                    // stddef.h:42:1:
	D_ATFILE_SOURCE                                  = 1                    // features.h:352:1:
	D_BITS_ATOMIC_WIDE_COUNTER_H                     = 0                    // atomic_wide_counter.h:20:1:
	D_BITS_BYTESWAP_H                                = 1                    // byteswap.h:24:1:
	D_BITS_ENDIANNESS_H                              = 1                    // endianness.h:2:1:
	D_BITS_ENDIAN_H                                  = 1                    // endian.h:20:1:
	D_BITS_FLOATN_COMMON_H                           = 0                    // floatn-common.h:21:1:
	D_BITS_FLOATN_H                                  = 0                    // floatn.h:20:1:
	D_BITS_POSIX1_LIM_H                              = 1                    // posix1_lim.h:25:1:
	D_BITS_POSIX2_LIM_H                              = 1                    // posix2_lim.h:23:1:
	D_BITS_PTHREADTYPES_ARCH_H                       = 1                    // pthreadtypes-arch.h:19:1:
	D_BITS_PTHREADTYPES_COMMON_H                     = 1                    // pthreadtypes.h:20:1:
	D_BITS_STDINT_INTN_H                             = 1                    // stdint-intn.h:20:1:
	D_BITS_STDINT_UINTN_H                            = 1                    // stdint-uintn.h:20:1:
	D_BITS_STDIO_LIM_H                               = 1                    // stdio_lim.h:19:1:
	D_BITS_TIME64_H                                  = 1                    // time64.h:24:1:
	D_BITS_TYPESIZES_H                               = 1                    // typesizes.h:24:1:
	D_BITS_TYPES_H                                   = 1                    // types.h:24:1:
	D_BITS_TYPES_LOCALE_T_H                          = 1                    // locale_t.h:20:1:
	D_BITS_TYPES___LOCALE_T_H                        = 1                    // __locale_t.h:20:1:
	D_BITS_UINTN_IDENTITY_H                          = 1                    // uintn-identity.h:24:1:
	D_BITS_UIO_LIM_H                                 = 1                    // uio_lim.h:20:1:
	D_BITS_WCHAR_H                                   = 1                    // wchar.h:20:1:
	D_BSD_PTRDIFF_T_                                 = 0                    // stddef.h:137:1:
	D_BSD_SIZE_T_                                    = 0                    // stddef.h:193:1:
	D_BSD_SIZE_T_DEFINED_                            = 0                    // stddef.h:196:1:
	D_CTYPE_H                                        = 1                    // ctype.h:23:1:
	D_DARWIN_C_SOURCE                                = 1                    // config.h:347:1:
	D_DEFAULT_SOURCE                                 = 1                    // features.h:237:1:
	D_DYNAMIC_STACK_SIZE_SOURCE                      = 1                    // features.h:225:1:
	D_ENDIAN_H                                       = 1                    // endian.h:19:1:
	D_FEATURES_H                                     = 1                    // features.h:19:1:
	D_FILE_OFFSET_BITS                               = 64                   // <builtin>:25:1:
	D_GCC_LIMITS_H_                                  = 0                    // limits.h:30:1:
	D_GCC_MAX_ALIGN_T                                = 0                    // stddef.h:421:1:
	D_GCC_PTRDIFF_T                                  = 0                    // stddef.h:139:1:
	D_GCC_SIZE_T                                     = 0                    // stddef.h:200:1:
	D_GCC_WCHAR_T                                    = 0                    // stddef.h:280:1:
	D_GCC_WRAP_STDINT_H                              = 0                    // stdint.h:13:1:
	D_GNU_SOURCE                                     = 1                    // config.h:355:1:
	D_HPUX_ALT_XOPEN_SOCKET_API                      = 1                    // config.h:360:1:
	D_INTTYPES_H                                     = 1                    // inttypes.h:23:1:
	D_IOFBF                                          = 0                    // stdio.h:93:1:
	D_IOLBF                                          = 1                    // stdio.h:94:1:
	D_IONBF                                          = 2                    // stdio.h:95:1:
	D_IO_EOF_SEEN                                    = 0x0010               // struct_FILE.h:111:1:
	D_IO_ERR_SEEN                                    = 0x0020               // struct_FILE.h:114:1:
	D_IO_USER_LOCK                                   = 0x8000               // struct_FILE.h:117:1:
	D_ISOC11_SOURCE                                  = 1                    // features.h:207:1:
	D_ISOC2X_SOURCE                                  = 1                    // features.h:209:1:
	D_ISOC95_SOURCE                                  = 1                    // features.h:203:1:
	D_ISOC99_SOURCE                                  = 1                    // features.h:205:1:
	D_LARGEFILE64_SOURCE                             = 1                    // features.h:219:1:
	D_LARGEFILE_SOURCE                               = 1                    // features.h:361:1:
	D_LIBC_LIMITS_H_                                 = 1                    // limits.h:23:1:
	D_LIMITS_H___                                    = 0                    // limits.h:60:1:
	D_LINUX_LIMITS_H                                 = 0                    // limits.h:3:1:
	D_LP64                                           = 1                    // <predefined>:329:1:
	D_NETBSD_SOURCE                                  = 1                    // config.h:371:1:
	D_OPENBSD_SOURCE                                 = 1                    // config.h:376:1:
	D_POSIX2_BC_BASE_MAX                             = 99                   // posix2_lim.h:27:1:
	D_POSIX2_BC_DIM_MAX                              = 2048                 // posix2_lim.h:30:1:
	D_POSIX2_BC_SCALE_MAX                            = 99                   // posix2_lim.h:33:1:
	D_POSIX2_BC_STRING_MAX                           = 1000                 // posix2_lim.h:36:1:
	D_POSIX2_CHARCLASS_NAME_MAX                      = 14                   // posix2_lim.h:55:1:
	D_POSIX2_COLL_WEIGHTS_MAX                        = 2                    // posix2_lim.h:40:1:
	D_POSIX2_EXPR_NEST_MAX                           = 32                   // posix2_lim.h:44:1:
	D_POSIX2_LINE_MAX                                = 2048                 // posix2_lim.h:47:1:
	D_POSIX2_RE_DUP_MAX                              = 255                  // posix2_lim.h:51:1:
	D_POSIX_AIO_LISTIO_MAX                           = 2                    // posix1_lim.h:32:1:
	D_POSIX_AIO_MAX                                  = 1                    // posix1_lim.h:35:1:
	D_POSIX_ARG_MAX                                  = 4096                 // posix1_lim.h:38:1:
	D_POSIX_CHILD_MAX                                = 25                   // posix1_lim.h:42:1:
	D_POSIX_CLOCKRES_MIN                             = 20000000             // posix1_lim.h:157:1:
	D_POSIX_C_SOURCE                                 = 200809               // features.h:291:1:
	D_POSIX_DELAYTIMER_MAX                           = 32                   // posix1_lim.h:48:1:
	D_POSIX_FD_SETSIZE                               = 20                   // posix1_lim.h:93:1:
	D_POSIX_HIWAT                                    = 512                  // posix1_lim.h:150:1:
	D_POSIX_HOST_NAME_MAX                            = 255                  // posix1_lim.h:52:1:
	D_POSIX_LINK_MAX                                 = 8                    // posix1_lim.h:55:1:
	D_POSIX_LOGIN_NAME_MAX                           = 9                    // posix1_lim.h:58:1:
	D_POSIX_MAX_CANON                                = 255                  // posix1_lim.h:61:1:
	D_POSIX_MAX_INPUT                                = 255                  // posix1_lim.h:65:1:
	D_POSIX_MQ_OPEN_MAX                              = 8                    // posix1_lim.h:68:1:
	D_POSIX_MQ_PRIO_MAX                              = 32                   // posix1_lim.h:71:1:
	D_POSIX_NAME_MAX                                 = 14                   // posix1_lim.h:74:1:
	D_POSIX_NGROUPS_MAX                              = 8                    // posix1_lim.h:78:1:
	D_POSIX_OPEN_MAX                                 = 20                   // posix1_lim.h:85:1:
	D_POSIX_PATH_MAX                                 = 256                  // posix1_lim.h:97:1:
	D_POSIX_PIPE_BUF                                 = 512                  // posix1_lim.h:100:1:
	D_POSIX_PTHREAD_SEMANTICS                        = 1                    // config.h:388:1:
	D_POSIX_QLIMIT                                   = 1                    // posix1_lim.h:146:1:
	D_POSIX_RE_DUP_MAX                               = 255                  // posix1_lim.h:104:1:
	D_POSIX_RTSIG_MAX                                = 8                    // posix1_lim.h:107:1:
	D_POSIX_SEM_NSEMS_MAX                            = 256                  // posix1_lim.h:110:1:
	D_POSIX_SEM_VALUE_MAX                            = 32767                // posix1_lim.h:113:1:
	D_POSIX_SIGQUEUE_MAX                             = 32                   // posix1_lim.h:116:1:
	D_POSIX_SOURCE                                   = 1                    // features.h:289:1:
	D_POSIX_SSIZE_MAX                                = 32767                // posix1_lim.h:119:1:
	D_POSIX_STREAM_MAX                               = 8                    // posix1_lim.h:122:1:
	D_POSIX_SYMLINK_MAX                              = 255                  // posix1_lim.h:125:1:
	D_POSIX_SYMLOOP_MAX                              = 8                    // posix1_lim.h:129:1:
	D_POSIX_THREAD_DESTRUCTOR_ITERATIONS             = 4                    // local_lim.h:67:1:
	D_POSIX_THREAD_KEYS_MAX                          = 128                  // local_lim.h:62:1:
	D_POSIX_THREAD_THREADS_MAX                       = 64                   // local_lim.h:72:1:
	D_POSIX_TIMER_MAX                                = 32                   // posix1_lim.h:132:1:
	D_POSIX_TTY_NAME_MAX                             = 9                    // posix1_lim.h:135:1:
	D_POSIX_TZNAME_MAX                               = 6                    // posix1_lim.h:139:1:
	D_POSIX_UIO_MAXIOV                               = 16                   // posix1_lim.h:153:1:
	D_PRINTF_NAN_LEN_MAX                             = 4                    // stdio.h:138:1:
	D_PTRDIFF_T                                      = 0                    // stddef.h:132:1:
	D_PTRDIFF_T_                                     = 0                    // stddef.h:136:1:
	D_PTRDIFF_T_DECLARED                             = 0                    // stddef.h:140:1:
	D_RWLOCK_INTERNAL_H                              = 0                    // struct_rwlock.h:21:1:
	D_SIZET_                                         = 0                    // stddef.h:201:1:
	D_SIZE_T                                         = 0                    // stddef.h:187:1:
	D_SIZE_T_                                        = 0                    // stddef.h:192:1:
	D_SIZE_T_DECLARED                                = 0                    // stddef.h:197:1:
	D_SIZE_T_DEFINED                                 = 0                    // stddef.h:195:1:
	D_SIZE_T_DEFINED_                                = 0                    // stddef.h:194:1:
	D_STDC_PREDEF_H                                  = 1                    // <predefined>:182:1:
	D_STDDEF_H                                       = 0                    // stddef.h:39:1:
	D_STDDEF_H_                                      = 0                    // stddef.h:40:1:
	D_STDINT_H                                       = 1                    // stdint.h:23:1:
	D_STDIO_H                                        = 1                    // stdio.h:24:1:
	D_STDLIB_H                                       = 1                    // stdlib.h:36:1:
	D_STRINGS_H                                      = 1                    // strings.h:19:1:
	D_STRING_H                                       = 1                    // string.h:23:1:
	D_STRUCT_TIMESPEC                                = 1                    // struct_timespec.h:3:1:
	D_SYS_CDEFS_H                                    = 1                    // cdefs.h:20:1:
	D_SYS_SELECT_H                                   = 1                    // select.h:22:1:
	D_SYS_SIZE_T_H                                   = 0                    // stddef.h:188:1:
	D_SYS_TYPES_H                                    = 1                    // types.h:23:1:
	D_TANDEM_SOURCE                                  = 1                    // config.h:420:1:
	D_THREAD_MUTEX_INTERNAL_H                        = 1                    // struct_mutex.h:20:1:
	D_THREAD_SHARED_TYPES_H                          = 1                    // thread-shared-types.h:20:1:
	D_T_PTRDIFF                                      = 0                    // stddef.h:134:1:
	D_T_PTRDIFF_                                     = 0                    // stddef.h:133:1:
	D_T_SIZE                                         = 0                    // stddef.h:190:1:
	D_T_SIZE_                                        = 0                    // stddef.h:189:1:
	D_T_WCHAR                                        = 0                    // stddef.h:271:1:
	D_T_WCHAR_                                       = 0                    // stddef.h:270:1:
	D_VA_LIST_DEFINED                                = 0                    // stdio.h:53:1:
	D_WCHAR_T                                        = 0                    // stddef.h:269:1:
	D_WCHAR_T_                                       = 0                    // stddef.h:273:1:
	D_WCHAR_T_DECLARED                               = 0                    // stddef.h:281:1:
	D_WCHAR_T_DEFINED                                = 0                    // stddef.h:276:1:
	D_WCHAR_T_DEFINED_                               = 0                    // stddef.h:275:1:
	D_WCHAR_T_H                                      = 0                    // stddef.h:277:1:
	D_XOPEN_IOV_MAX                                  = 16                   // xopen_lim.h:62:1:
	D_XOPEN_LIM_H                                    = 1                    // xopen_lim.h:30:1:
	D_XOPEN_SOURCE                                   = 700                  // features.h:215:1:
	D_XOPEN_SOURCE_EXTENDED                          = 1                    // features.h:217:1:
	Dcbit_cntrl                                      = 288                  // pcre2_internal.h:572:1:
	Dcbit_digit                                      = 64                   // pcre2_internal.h:565:1:
	Dcbit_graph                                      = 192                  // pcre2_internal.h:569:1:
	Dcbit_length                                     = 320                  // pcre2_internal.h:573:1:
	Dcbit_lower                                      = 128                  // pcre2_internal.h:567:1:
	Dcbit_print                                      = 224                  // pcre2_internal.h:570:1:
	Dcbit_punct                                      = 256                  // pcre2_internal.h:571:1:
	Dcbit_space                                      = 0                    // pcre2_internal.h:563:1:
	Dcbit_upper                                      = 96                   // pcre2_internal.h:566:1:
	Dcbit_word                                       = 160                  // pcre2_internal.h:568:1:
	Dcbit_xdigit                                     = 32                   // pcre2_internal.h:564:1:
	Dcbits_offset                                    = 512                  // pcre2_internal.h:590:1:
	Dctype_digit                                     = 0x08                 // pcre2_internal.h:582:1:
	Dctype_lcletter                                  = 0x04                 // pcre2_internal.h:581:1:
	Dctype_letter                                    = 0x02                 // pcre2_internal.h:580:1:
	Dctype_space                                     = 0x01                 // pcre2_internal.h:579:1:
	Dctype_word                                      = 0x10                 // pcre2_internal.h:583:1:
	Dctypes_offset                                   = 832                  // pcre2_internal.h:591:1:
	Dfcc_offset                                      = 256                  // pcre2_internal.h:589:1:
	Dlcc_offset                                      = 0                    // pcre2_internal.h:588:1:
	Dlinux                                           = 1                    // <predefined>:270:1:
	Ducd_boolprop_sets_item_size                     = 2                    // pcre2_ucp.h:164:1:
	Ducd_script_sets_item_size                       = 3                    // pcre2_ucp.h:390:1:
	Dunix                                            = 1                    // <predefined>:202:1:
	DCOMPILE_WORK_SIZE                               = 6000                 // pcre2_compile.c:166:1:
	DESCAPES_FIRST                                   = 48                   // pcre2_compile.c:507:1:
	DESCAPES_LAST                                    = 122                  // pcre2_compile.c:508:1:
	DGI_FIXED_LENGTH_MASK                            = 0x0000ffff           // pcre2_compile.c:402:1:
	DGI_NOT_FIXED_LENGTH                             = 0x40000000           // pcre2_compile.c:401:1:
	DGI_SET_FIXED_LENGTH                             = 0x80000000           // pcre2_compile.c:400:1:
	DGROUPINFO_DEFAULT_SIZE                          = 256                  // pcre2_compile.c:175:1:
	DMAX_GROUP_NUMBER                                = 65535                // pcre2_compile.c:147:1:
	DMAX_REPEAT_COUNT                                = 65535                // pcre2_compile.c:148:1:
	DMETA_ACCEPT                                     = 0x802a0000           // pcre2_compile.c:266:1:
	DMETA_ALT                                        = 0x80010000           // pcre2_compile.c:213:1:
	DMETA_ASTERISK                                   = 0x80340000           // pcre2_compile.c:279:1:
	DMETA_ASTERISK_PLUS                              = 0x80350000           // pcre2_compile.c:280:1:
	DMETA_ASTERISK_QUERY                             = 0x80360000           // pcre2_compile.c:281:1:
	DMETA_ATOMIC                                     = 0x80020000           // pcre2_compile.c:214:1:
	DMETA_ATOMIC_SCRIPT_RUN                          = 0x8fff0000           // pcre2_compile.c:300:1:
	DMETA_BACKREF                                    = 0x80030000           // pcre2_compile.c:215:1:
	DMETA_BACKREF_BYNAME                             = 0x80040000           // pcre2_compile.c:216:1:
	DMETA_BIGVALUE                                   = 0x80050000           // pcre2_compile.c:217:1:
	DMETA_CALLOUT_NUMBER                             = 0x80060000           // pcre2_compile.c:218:1:
	DMETA_CALLOUT_STRING                             = 0x80070000           // pcre2_compile.c:219:1:
	DMETA_CAPTURE                                    = 0x80080000           // pcre2_compile.c:220:1:
	DMETA_CIRCUMFLEX                                 = 0x80090000           // pcre2_compile.c:221:1:
	DMETA_CLASS                                      = 0x800a0000           // pcre2_compile.c:222:1:
	DMETA_CLASS_EMPTY                                = 0x800b0000           // pcre2_compile.c:223:1:
	DMETA_CLASS_EMPTY_NOT                            = 0x800c0000           // pcre2_compile.c:224:1:
	DMETA_CLASS_END                                  = 0x800d0000           // pcre2_compile.c:225:1:
	DMETA_CLASS_NOT                                  = 0x800e0000           // pcre2_compile.c:226:1:
	DMETA_COMMIT                                     = 0x802c0000           // pcre2_compile.c:268:1:
	DMETA_COMMIT_ARG                                 = 0x802d0000           // pcre2_compile.c:269:1:
	DMETA_COND_ASSERT                                = 0x800f0000           // pcre2_compile.c:227:1:
	DMETA_COND_DEFINE                                = 0x80100000           // pcre2_compile.c:228:1:
	DMETA_COND_NAME                                  = 0x80110000           // pcre2_compile.c:229:1:
	DMETA_COND_NUMBER                                = 0x80120000           // pcre2_compile.c:230:1:
	DMETA_COND_RNAME                                 = 0x80130000           // pcre2_compile.c:231:1:
	DMETA_COND_RNUMBER                               = 0x80140000           // pcre2_compile.c:232:1:
	DMETA_COND_VERSION                               = 0x80150000           // pcre2_compile.c:233:1:
	DMETA_DOLLAR                                     = 0x80160000           // pcre2_compile.c:234:1:
	DMETA_DOT                                        = 0x80170000           // pcre2_compile.c:235:1:
	DMETA_END                                        = 0x80000000           // pcre2_compile.c:211:1:
	DMETA_ESCAPE                                     = 0x80180000           // pcre2_compile.c:236:1:
	DMETA_FAIL                                       = 0x802b0000           // pcre2_compile.c:267:1:
	DMETA_FIRST_QUANTIFIER                           = 2150891520           // pcre2_compile.c:292:1:
	DMETA_KET                                        = 0x80190000           // pcre2_compile.c:237:1:
	DMETA_LAST_QUANTIFIER                            = 2151612416           // pcre2_compile.c:293:1:
	DMETA_LOOKAHEAD                                  = 0x80230000           // pcre2_compile.c:251:1:
	DMETA_LOOKAHEADNOT                               = 0x80240000           // pcre2_compile.c:252:1:
	DMETA_LOOKAHEAD_NA                               = 0x80270000           // pcre2_compile.c:258:1:
	DMETA_LOOKBEHIND                                 = 0x80250000           // pcre2_compile.c:253:1:
	DMETA_LOOKBEHINDNOT                              = 0x80260000           // pcre2_compile.c:254:1:
	DMETA_LOOKBEHIND_NA                              = 0x80280000           // pcre2_compile.c:259:1:
	DMETA_MARK                                       = 0x80290000           // pcre2_compile.c:265:1:
	DMETA_MINMAX                                     = 0x803d0000           // pcre2_compile.c:288:1:
	DMETA_MINMAX_PLUS                                = 0x803e0000           // pcre2_compile.c:289:1:
	DMETA_MINMAX_QUERY                               = 0x803f0000           // pcre2_compile.c:290:1:
	DMETA_NOCAPTURE                                  = 0x801a0000           // pcre2_compile.c:238:1:
	DMETA_OPTIONS                                    = 0x801b0000           // pcre2_compile.c:239:1:
	DMETA_PLUS                                       = 0x80370000           // pcre2_compile.c:282:1:
	DMETA_PLUS_PLUS                                  = 0x80380000           // pcre2_compile.c:283:1:
	DMETA_PLUS_QUERY                                 = 0x80390000           // pcre2_compile.c:284:1:
	DMETA_POSIX                                      = 0x801c0000           // pcre2_compile.c:240:1:
	DMETA_POSIX_NEG                                  = 0x801d0000           // pcre2_compile.c:241:1:
	DMETA_PRUNE                                      = 0x802e0000           // pcre2_compile.c:270:1:
	DMETA_PRUNE_ARG                                  = 0x802f0000           // pcre2_compile.c:271:1:
	DMETA_QUERY                                      = 0x803a0000           // pcre2_compile.c:285:1:
	DMETA_QUERY_PLUS                                 = 0x803b0000           // pcre2_compile.c:286:1:
	DMETA_QUERY_QUERY                                = 0x803c0000           // pcre2_compile.c:287:1:
	DMETA_RANGE_ESCAPED                              = 0x801e0000           // pcre2_compile.c:242:1:
	DMETA_RANGE_LITERAL                              = 0x801f0000           // pcre2_compile.c:243:1:
	DMETA_RECURSE                                    = 0x80200000           // pcre2_compile.c:244:1:
	DMETA_RECURSE_BYNAME                             = 0x80210000           // pcre2_compile.c:245:1:
	DMETA_SCRIPT_RUN                                 = 0x80220000           // pcre2_compile.c:246:1:
	DMETA_SKIP                                       = 0x80300000           // pcre2_compile.c:272:1:
	DMETA_SKIP_ARG                                   = 0x80310000           // pcre2_compile.c:273:1:
	DMETA_THEN                                       = 0x80320000           // pcre2_compile.c:274:1:
	DMETA_THEN_ARG                                   = 0x80330000           // pcre2_compile.c:275:1:
	DNAMED_GROUP_LIST_SIZE                           = 20                   // pcre2_compile.c:187:1:
	DNSF_ATOMICSR                                    = 0x0004               // pcre2_compile.c:2567:1:
	DNSF_CONDASSERT                                  = 0x0002               // pcre2_compile.c:2566:1:
	DNSF_RESET                                       = 0x0001               // pcre2_compile.c:2565:1:
	DOFLOW_MAX                                       = 2147483627           // pcre2_compile.c:200:1:
	DPARSED_PATTERN_DEFAULT_SIZE                     = 1024                 // pcre2_compile.c:193:1:
	DPARSE_TRACKED_OPTIONS                           = 17048808             // pcre2_compile.c:2574:1:
	DPC_GRAPH                                        = 8                    // pcre2_compile.c:709:1:
	DPC_PRINT                                        = 9                    // pcre2_compile.c:710:1:
	DPC_PUNCT                                        = 10                   // pcre2_compile.c:711:1:
	DPUBLIC_COMPILE_EXTRA_OPTIONS                    = 127                  // pcre2_compile.c:784:1:
	DPUBLIC_COMPILE_OPTIONS                          = 3892314111           // pcre2_compile.c:772:1:
	DPUBLIC_LITERAL_COMPILE_EXTRA_OPTIONS            = 12                   // pcre2_compile.c:781:1:
	DPUBLIC_LITERAL_COMPILE_OPTIONS                  = 3867738380           // pcre2_compile.c:767:1:
	DREPEAT_UNLIMITED                                = 65536                // pcre2_compile.c:149:1:
	DREQ_CASELESS                                    = 0x00000001           // pcre2_compile.c:395:1:
	DREQ_NONE                                        = 0xfffffffe           // pcre2_compile.c:394:1:
	DREQ_UNSET                                       = 0xffffffff           // pcre2_compile.c:393:1:
	DREQ_VARY                                        = 0x00000002           // pcre2_compile.c:396:1:
	DRSCAN_CACHE_SIZE                                = 8                    // pcre2_compile.c:10361:1:
	DSIZEOFFSET                                      = 2                    // pcre2_compile.c:108:1:
	DWORK_SIZE_SAFETY_MARGIN                         = 100                  // pcre2_compile.c:180:1:
	DALL_OPTIONS                                     = 127                  // pcre2_convert.c:51:1:
	DDUMMY_BUFFER_SIZE                               = 100                  // pcre2_convert.c:56:1:
	DTYPE_OPTIONS                                    = 28                   // pcre2_convert.c:48:1:
	DOP_ANYNL_EXTRA                                  = 340                  // pcre2_dfa_match.c:103:1:
	DOP_EXTUNI_EXTRA                                 = 320                  // pcre2_dfa_match.c:102:1:
	DOP_HSPACE_EXTRA                                 = 360                  // pcre2_dfa_match.c:104:1:
	DOP_PROP_EXTRA                                   = 300                  // pcre2_dfa_match.c:101:1:
	DOP_VSPACE_EXTRA                                 = 380                  // pcre2_dfa_match.c:105:1:
	DPUBLIC_DFA_MATCH_OPTIONS                        = 3758113023           // pcre2_dfa_match.c:85:1:
	DRWS_RSIZE                                       = 1000                 // pcre2_dfa_match.c:318:1:
	DINCLUDED_FROM_PCRE2_JIT_COMPILE                 = 0                    // pcre2_jit_compile.c:14502:1:
	DPUBLIC_JIT_COMPILE_OPTIONS                      = 263                  // pcre2_jit_compile.c:14378:1:
	DGF_CAPTURE                                      = 0x00010000           // pcre2_match.c:106:1:
	DGF_CONDASSERT                                   = 0x00030000           // pcre2_match.c:108:1:
	DGF_NOCAPTURE                                    = 0x00020000           // pcre2_match.c:107:1:
	DGF_RECURSE                                      = 0x00040000           // pcre2_match.c:109:1:
	DMATCH_ACCEPT                                    = -999                 // pcre2_match.c:88:1:
	DMATCH_BACKTRACK_MAX                             = -993                 // pcre2_match.c:97:1:
	DMATCH_BACKTRACK_MIN                             = -997                 // pcre2_match.c:98:1:
	DMATCH_COMMIT                                    = -997                 // pcre2_match.c:92:1:
	DMATCH_KETRPOS                                   = -998                 // pcre2_match.c:89:1:
	DMATCH_MATCH                                     = 1                    // pcre2_match.c:82:1:
	DMATCH_NOMATCH                                   = 0                    // pcre2_match.c:83:1:
	DMATCH_PRUNE                                     = -996                 // pcre2_match.c:93:1:
	DMATCH_SKIP                                      = -995                 // pcre2_match.c:94:1:
	DMATCH_SKIP_ARG                                  = -994                 // pcre2_match.c:95:1:
	DMATCH_THEN                                      = -993                 // pcre2_match.c:96:1:
	DPUBLIC_JIT_MATCH_OPTIONS                        = 1073758271           // pcre2_match.c:74:1:
	DPUBLIC_MATCH_OPTIONS                            = 3758121023           // pcre2_match.c:69:1:
	DRECURSE_UNSET                                   = 0xffffffff           // pcre2_match.c:65:1:
	DFOUND_BOPOMOFO                                  = 1                    // pcre2_script_run.c:199:1:
	DFOUND_HANGUL                                    = 8                    // pcre2_script_run.c:202:1:
	DFOUND_HIRAGANA                                  = 2                    // pcre2_script_run.c:200:1:
	DFOUND_KATAKANA                                  = 4                    // pcre2_script_run.c:201:1:
	DSERIALIZED_DATA_MAGIC                           = 0x50523253           // pcre2_serialize.c:54:1:
	DSERIALIZED_DATA_VERSION                         = 2752522              // pcre2_serialize.c:59:1:
	DMAX_CACHE_BACKREF                               = 128                  // pcre2_study.c:53:1:
	DPTR_STACK_SIZE                                  = 20                   // pcre2_substitute.c:48:1:
	DSUBSTITUTE_OPTIONS                              = 237312               // pcre2_substitute.c:50:1:
)

// Seconds since the Epoch, visible to user code when time_t is too
//    narrow only for consistency with the old way of widening too-narrow
//    types.  User code should never use __time64_t.

// These are all the characteristics of characters.
//    If there get to be more than 16 distinct characteristics,
//    many things must be changed that use `unsigned short int's.
//
//    The characteristics are stored always in network byte order (big
//    endian).  We define the bit value interpretations here dependent on the
//    machine's byte order.

// Endian macros for string.h functions
//    Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// Definitions for byte order, according to significance of bytes,
//    from low addresses to high addresses.  The value is what you get by
//    putting '4' in the most significant byte, '3' in the second most
//    significant byte, '2' in the second least significant byte, and '1'
//    in the least significant byte, and then writing down one digit for
//    each byte, starting with the byte at the lowest address at the left,
//    and proceeding to the byte with the highest address at the right.

// This file defines `__BYTE_ORDER' for the particular machine.

// i386/x86_64 are little-endian.

// Some machines may need to use a different endianness for floating point
//    values.

const ( /* ctype.h:46:1: */
	_ISupper  = 256   // UPPERCASE.
	_ISlower  = 512   // lowercase.
	_ISalpha  = 1024  // Alphabetic.
	_ISdigit  = 2048  // Numeric.
	_ISxdigit = 4096  // Hexadecimal numeric.
	_ISspace  = 8192  // Whitespace.
	_ISprint  = 16384 // Printing.
	_ISgraph  = 32768 // Graphical.
	_ISblank  = 1     // Blank (usually SPC and TAB).
	_IScntrl  = 2     // Control character.
	_ISpunct  = 4     // Punctuation.
	_ISalnum  = 8
)

// Options that are changeable within the pattern must be tracked during
// parsing. Some (e.g. PCRE2_EXTENDED) are implemented entirely during parsing,
// but all must be tracked so that META_OPTIONS items set the correct values for
// the main compiling phase.

// States used for analyzing ranges in character classes. The two OK values
// must be last.

const ( /* pcre2_compile.c:2581:1: */
	RANGE_NO         = 0
	RANGE_STARTED    = 1
	RANGE_OK_ESCAPED = 2
	RANGE_OK_LITERAL = 3
)

// Types for skipping parts of a parsed pattern.

const ( /* pcre2_compile.c:375:1: */
	PSKIP_ALT   = 0
	PSKIP_CLASS = 1
	PSKIP_KET   = 2
)

// Masks for checking option settings. When PCRE2_LITERAL is set, only a subset
// are allowed.

// Compile time error code numbers. They are given names so that they can more
// easily be tracked. When a new number is added, the tables called eint1 and
// eint2 in pcre2posix.c may need to be updated, and a new error text must be
// added to compile_error_texts in pcre2_error.c. Also, the error codes in
// pcre2.h.in must be updated - their values are exactly 100 greater than these
// values.

const ( /* pcre2_compile.c:797:1: */
	ERR0  = 100
	ERR1  = 101
	ERR2  = 102
	ERR3  = 103
	ERR4  = 104
	ERR5  = 105
	ERR6  = 106
	ERR7  = 107
	ERR8  = 108
	ERR9  = 109
	ERR10 = 110
	ERR11 = 111
	ERR12 = 112
	ERR13 = 113
	ERR14 = 114
	ERR15 = 115
	ERR16 = 116
	ERR17 = 117
	ERR18 = 118
	ERR19 = 119
	ERR20 = 120
	ERR21 = 121
	ERR22 = 122
	ERR23 = 123
	ERR24 = 124
	ERR25 = 125
	ERR26 = 126
	ERR27 = 127
	ERR28 = 128
	ERR29 = 129
	ERR30 = 130
	ERR31 = 131
	ERR32 = 132
	ERR33 = 133
	ERR34 = 134
	ERR35 = 135
	ERR36 = 136
	ERR37 = 137
	ERR38 = 138
	ERR39 = 139
	ERR40 = 140
	ERR41 = 141
	ERR42 = 142
	ERR43 = 143
	ERR44 = 144
	ERR45 = 145
	ERR46 = 146
	ERR47 = 147
	ERR48 = 148
	ERR49 = 149
	ERR50 = 150
	ERR51 = 151
	ERR52 = 152
	ERR53 = 153
	ERR54 = 154
	ERR55 = 155
	ERR56 = 156
	ERR57 = 157
	ERR58 = 158
	ERR59 = 159
	ERR60 = 160
	ERR61 = 161
	ERR62 = 162
	ERR63 = 163
	ERR64 = 164
	ERR65 = 165
	ERR66 = 166
	ERR67 = 167
	ERR68 = 168
	ERR69 = 169
	ERR70 = 170
	ERR71 = 171
	ERR72 = 172
	ERR73 = 173
	ERR74 = 174
	ERR75 = 175
	ERR76 = 176
	ERR77 = 177
	ERR78 = 178
	ERR79 = 179
	ERR80 = 180
	ERR81 = 181
	ERR82 = 182
	ERR83 = 183
	ERR84 = 184
	ERR85 = 185
	ERR86 = 186
	ERR87 = 187
	ERR88 = 188
	ERR89 = 189
	ERR90 = 190
	ERR91 = 191
	ERR92 = 192
	ERR93 = 193
	ERR94 = 194
	ERR95 = 195
	ERR96 = 196
	ERR97 = 197
	ERR98 = 198
	ERR99 = 199
)

// This is a table of start-of-pattern options such as (*UTF) and settings such
// as (*LIMIT_MATCH=nnnn) and (*CRLF). For completeness and backward
// compatibility, (*UTFn) is supported in the relevant libraries, but (*UTF) is
// generic and always supported.

const ( /* pcre2_compile.c:814:1: */
	PSO_OPT  = 0 // Value is an option bit
	PSO_FLG  = 1 // Value is a flag bit
	PSO_NL   = 2 // Value is a newline type
	PSO_BSR  = 3 // Value is a \R type
	PSO_LIMH = 4 // Read integer value for heap limit
	PSO_LIMM = 5 // Read integer value for match limit
	PSO_LIMD = 6
)

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Generated pattern fragments

// States for POSIX processing

const ( /* pcre2_convert.c:70:1: */
	POSIX_START_REGEX       = 0
	POSIX_ANCHORED          = 1
	POSIX_NOT_BRACKET       = 2
	POSIX_CLASS_NOT_STARTED = 3
	POSIX_CLASS_STARTING    = 4
	POSIX_CLASS_STARTED     = 5
) // pcre2_jit_match()

// Values for the flags field in a match data block.

// Magic number to provide a small check against being handed junk.

// The maximum remaining length of subject we are prepared to search for a
// req_unit match from an anchored pattern. In 8-bit mode, memchr() is used and is
// much faster than the search loop that has to be used in 16-bit and 32-bit
// modes.

// Offsets for the bitmap tables in the cbits set of tables. Each table
// contains a set of bits for a class map. Some classes are built by combining
// these tables.

// Bit definitions for entries in the ctypes table. Do not change these values
// without checking pcre2_jit_compile.c, which has an assertion to ensure that
// ctype_word has the value 16.

// Offsets of the various tables from the base tables pointer, and
// total length of the tables.

// -------------------- Character and string names ------------------------

// If PCRE2 is to support UTF-8 on EBCDIC platforms, we cannot use normal
// character constants like '*' because the compiler would emit their EBCDIC code,
// which is different from their ASCII/UTF-8 code. Instead we define macros for
// the characters so that they always use the ASCII/UTF-8 code when UTF-8 support
// is enabled. When UTF-8 support is not enabled, the definitions use character
// literals. Both character and string versions of each character are needed, and
// there are some longer strings as well.
//
// This means that, on EBCDIC platforms, the PCRE2 library can handle either
// EBCDIC, or UTF-8, but not both. To support both in the same compiled library
// would need different lookups depending on whether PCRE2_UTF was set or not.
// This would make it impossible to use characters in switch/case statements,
// which would reduce performance. For a theoretical use (which nobody has asked
// for) in a minority area (EBCDIC platforms), this is not sensible. Any
// application that did need both could compile two versions of the library, using
// macros to give the functions distinct names.

// UTF-8 support is enabled; always use UTF-8 (=ASCII) character codes. This
// works in both modes non-EBCDIC platforms, and on EBCDIC platforms in UTF-8 mode
// only.

// -------------------- End of character and string names -------------------

// -------------------- Definitions for compiled patterns -------------------

// Codes for different types of Unicode property. If these definitions are
// changed, the autopossessifying table in pcre2_auto_possess.c must be updated to
// match.

// The following special properties are used only in XCLASS items, when POSIX
// classes are specified and PCRE2_UCP is set - in other words, for Unicode
// handling of these classes. They are not available via the \p or \P escapes like
// those in the above list, and so they do not take part in the autopossessifying
// table.

// This value is used when parsing \p and \P escapes to indicate that neither
// \p{script:...} nor \p{scx:...} has been encountered.

// Flag bits and data types for the extended class (OP_XCLASS) for classes that
// contain characters with values greater than 255.

// These are escaped items that aren't just an encoding of a particular data
// value such as \n. They must have non-zero values, as check_escape() returns 0
// for a data character. In the escapes[] table in pcre2_compile.c their values
// are negated in order to distinguish them from data values.
//
// They must appear here in the same order as in the opcode definitions below, up
// to ESC_z. There's a dummy for OP_ALLANY because it corresponds to "." in DOTALL
// mode rather than an escape sequence. It is also used for [^] in JavaScript
// compatibility mode, and for \C in non-utf mode. In non-DOTALL mode, "." behaves
// like \N.
//
// Negative numbers are used to encode a backreference (\1, \2, \3, etc.) in
// check_escape(). There are tests in the code for an escape greater than ESC_b
// and less than ESC_Z to detect the types that may be repeated. These are the
// types that consume characters. If any new escapes are put in between that don't
// consume a character, that code will have to change.

const ( /* pcre2_internal.h:1336:1: */
	ESC_A   = 1
	ESC_G   = 2
	ESC_K   = 3
	ESC_B   = 4
	ESC_b   = 5
	ESC_D   = 6
	ESC_d   = 7
	ESC_S   = 8
	ESC_s   = 9
	ESC_W   = 10
	ESC_w   = 11
	ESC_N   = 12
	ESC_dum = 13
	ESC_C   = 14
	ESC_P   = 15
	ESC_p   = 16
	ESC_R   = 17
	ESC_H   = 18
	ESC_h   = 19
	ESC_V   = 20
	ESC_v   = 21
	ESC_X   = 22
	ESC_Z   = 23
	ESC_z   = 24
	ESC_E   = 25
	ESC_Q   = 26
	ESC_g   = 27
	ESC_k   = 28
)

//********************* Opcode definitions *****************

//***** NOTE NOTE NOTE ******
//
// Starting from 1 (i.e. after OP_END), the values up to OP_EOD must correspond in
// order to the list of escapes immediately above. Furthermore, values up to
// OP_DOLLM must not be changed without adjusting the table called autoposstab in
// pcre2_auto_possess.c.
//
// Whenever this list is updated, the two macro definitions that follow must be
// updated to match. The possessification table called "opcode_possessify" in
// pcre2_compile.c must also be updated, and also the tables called "coptable"
// and "poptable" in pcre2_dfa_match.c.
//
// ****** NOTE NOTE NOTE *****

// The values between FIRST_AUTOTAB_OP and LAST_AUTOTAB_RIGHT_OP, inclusive,
// are used in a table for deciding whether a repeated character type can be
// auto-possessified.

const ( /* pcre2_internal.h:1367:1: */
	OP_END = 0 // 0 End of pattern

	// Values corresponding to backslashed metacharacters

	OP_SOD               = 1  // 1 Start of data: \A
	OP_SOM               = 2  // 2 Start of match (subject + offset): \G
	OP_SET_SOM           = 3  // 3 Set start of match (\K)
	OP_NOT_WORD_BOUNDARY = 4  //  4 \B
	OP_WORD_BOUNDARY     = 5  //  5 \b
	OP_NOT_DIGIT         = 6  //  6 \D
	OP_DIGIT             = 7  //  7 \d
	OP_NOT_WHITESPACE    = 8  //  8 \S
	OP_WHITESPACE        = 9  //  9 \s
	OP_NOT_WORDCHAR      = 10 // 10 \W
	OP_WORDCHAR          = 11 // 11 \w

	OP_ANY        = 12 // 12 Match any character except newline (\N)
	OP_ALLANY     = 13 // 13 Match any character
	OP_ANYBYTE    = 14 // 14 Match any byte (\C); different to OP_ANY for UTF-8
	OP_NOTPROP    = 15 // 15 \P (not Unicode property)
	OP_PROP       = 16 // 16 \p (Unicode property)
	OP_ANYNL      = 17 // 17 \R (any newline sequence)
	OP_NOT_HSPACE = 18 // 18 \H (not horizontal whitespace)
	OP_HSPACE     = 19 // 19 \h (horizontal whitespace)
	OP_NOT_VSPACE = 20 // 20 \V (not vertical whitespace)
	OP_VSPACE     = 21 // 21 \v (vertical whitespace)
	OP_EXTUNI     = 22 // 22 \X (extended Unicode sequence
	OP_EODN       = 23 // 23 End of data or \n at end of data (\Z)
	OP_EOD        = 24 // 24 End of data (\z)

	// Line end assertions

	OP_DOLL  = 25 // 25 End of line - not multiline
	OP_DOLLM = 26 // 26 End of line - multiline
	OP_CIRC  = 27 // 27 Start of line - not multiline
	OP_CIRCM = 28 // 28 Start of line - multiline

	// Single characters; caseful must precede the caseless ones, and these
	//   must remain in this order, and adjacent.

	OP_CHAR  = 29 // 29 Match one character, casefully
	OP_CHARI = 30 // 30 Match one character, caselessly
	OP_NOT   = 31 // 31 Match one character, not the given one, casefully
	OP_NOTI  = 32 // 32 Match one character, not the given one, caselessly

	// The following sets of 13 opcodes must always be kept in step because
	//   the offset from the first one is used to generate the others.

	// Repeated characters; caseful must precede the caseless ones

	OP_STAR     = 33 // 33 The maximizing and minimizing versions of
	OP_MINSTAR  = 34 // 34 these six opcodes must come in pairs, with
	OP_PLUS     = 35 // 35 the minimizing one second.
	OP_MINPLUS  = 36 // 36
	OP_QUERY    = 37 // 37
	OP_MINQUERY = 38 // 38

	OP_UPTO    = 39 // 39 From 0 to n matches of one character, caseful
	OP_MINUPTO = 40 // 40
	OP_EXACT   = 41 // 41 Exactly n matches

	OP_POSSTAR  = 42 // 42 Possessified star, caseful
	OP_POSPLUS  = 43 // 43 Possessified plus, caseful
	OP_POSQUERY = 44 // 44 Posesssified query, caseful
	OP_POSUPTO  = 45 // 45 Possessified upto, caseful

	// Repeated characters; caseless must follow the caseful ones

	OP_STARI     = 46 // 46
	OP_MINSTARI  = 47 // 47
	OP_PLUSI     = 48 // 48
	OP_MINPLUSI  = 49 // 49
	OP_QUERYI    = 50 // 50
	OP_MINQUERYI = 51 // 51

	OP_UPTOI    = 52 // 52 From 0 to n matches of one character, caseless
	OP_MINUPTOI = 53 // 53
	OP_EXACTI   = 54 // 54

	OP_POSSTARI  = 55 // 55 Possessified star, caseless
	OP_POSPLUSI  = 56 // 56 Possessified plus, caseless
	OP_POSQUERYI = 57 // 57 Posesssified query, caseless
	OP_POSUPTOI  = 58 // 58 Possessified upto, caseless

	// The negated ones must follow the non-negated ones, and match them
	// Negated repeated character, caseful; must precede the caseless ones

	OP_NOTSTAR     = 59 // 59 The maximizing and minimizing versions of
	OP_NOTMINSTAR  = 60 // 60 these six opcodes must come in pairs, with
	OP_NOTPLUS     = 61 // 61 the minimizing one second. They must be in
	OP_NOTMINPLUS  = 62 // 62 exactly the same order as those above.
	OP_NOTQUERY    = 63 // 63
	OP_NOTMINQUERY = 64 // 64

	OP_NOTUPTO    = 65 // 65 From 0 to n matches, caseful
	OP_NOTMINUPTO = 66 // 66
	OP_NOTEXACT   = 67 // 67 Exactly n matches

	OP_NOTPOSSTAR  = 68 // 68 Possessified versions, caseful
	OP_NOTPOSPLUS  = 69 // 69
	OP_NOTPOSQUERY = 70 // 70
	OP_NOTPOSUPTO  = 71 // 71

	// Negated repeated character, caseless; must follow the caseful ones

	OP_NOTSTARI     = 72 // 72
	OP_NOTMINSTARI  = 73 // 73
	OP_NOTPLUSI     = 74 // 74
	OP_NOTMINPLUSI  = 75 // 75
	OP_NOTQUERYI    = 76 // 76
	OP_NOTMINQUERYI = 77 // 77

	OP_NOTUPTOI    = 78 // 78 From 0 to n matches, caseless
	OP_NOTMINUPTOI = 79 // 79
	OP_NOTEXACTI   = 80 // 80 Exactly n matches

	OP_NOTPOSSTARI  = 81 // 81 Possessified versions, caseless
	OP_NOTPOSPLUSI  = 82 // 82
	OP_NOTPOSQUERYI = 83 // 83
	OP_NOTPOSUPTOI  = 84 // 84

	// Character types

	OP_TYPESTAR     = 85 // 85 The maximizing and minimizing versions of
	OP_TYPEMINSTAR  = 86 // 86 these six opcodes must come in pairs, with
	OP_TYPEPLUS     = 87 // 87 the minimizing one second. These codes must
	OP_TYPEMINPLUS  = 88 // 88 be in exactly the same order as those above.
	OP_TYPEQUERY    = 89 // 89
	OP_TYPEMINQUERY = 90 // 90

	OP_TYPEUPTO    = 91 // 91 From 0 to n matches
	OP_TYPEMINUPTO = 92 // 92
	OP_TYPEEXACT   = 93 // 93 Exactly n matches

	OP_TYPEPOSSTAR  = 94 // 94 Possessified versions
	OP_TYPEPOSPLUS  = 95 // 95
	OP_TYPEPOSQUERY = 96 // 96
	OP_TYPEPOSUPTO  = 97 // 97

	// These are used for character classes and back references; only the
	//   first six are the same as the sets above.

	OP_CRSTAR     = 98  // 98 The maximizing and minimizing versions of
	OP_CRMINSTAR  = 99  // 99 all these opcodes must come in pairs, with
	OP_CRPLUS     = 100 // 100 the minimizing one second. These codes must
	OP_CRMINPLUS  = 101 // 101 be in exactly the same order as those above.
	OP_CRQUERY    = 102 // 102
	OP_CRMINQUERY = 103 // 103

	OP_CRRANGE    = 104 // 104 These are different to the three sets above.
	OP_CRMINRANGE = 105 // 105

	OP_CRPOSSTAR  = 106 // 106 Possessified versions
	OP_CRPOSPLUS  = 107 // 107
	OP_CRPOSQUERY = 108 // 108
	OP_CRPOSRANGE = 109 // 109

	// End of quantifier opcodes

	OP_CLASS  = 110 // 110 Match a character class, chars < 256 only
	OP_NCLASS = 111 // 111 Same, but the bitmap was created from a negative
	//                               class - the difference is relevant only when a
	//                               character > 255 is encountered.
	OP_XCLASS = 112 // 112 Extended class for handling > 255 chars within the
	//                               class. This does both positive and negative.
	OP_REF         = 113 // 113 Match a back reference, casefully
	OP_REFI        = 114 // 114 Match a back reference, caselessly
	OP_DNREF       = 115 // 115 Match a duplicate name backref, casefully
	OP_DNREFI      = 116 // 116 Match a duplicate name backref, caselessly
	OP_RECURSE     = 117 // 117 Match a numbered subpattern (possibly recursive)
	OP_CALLOUT     = 118 // 118 Call out to external function if provided
	OP_CALLOUT_STR = 119 // 119 Call out with string argument

	OP_ALT     = 120 // 120 Start of alternation
	OP_KET     = 121 // 121 End of group that doesn't have an unbounded repeat
	OP_KETRMAX = 122 // 122 These two must remain together and in this
	OP_KETRMIN = 123 // 123 order. They are for groups the repeat for ever.
	OP_KETRPOS = 124 // 124 Possessive unlimited repeat.

	// The assertions must come before BRA, CBRA, ONCE, and COND.

	OP_REVERSE        = 125 // 125 Move pointer back - used in lookbehind assertions
	OP_ASSERT         = 126 // 126 Positive lookahead
	OP_ASSERT_NOT     = 127 // 127 Negative lookahead
	OP_ASSERTBACK     = 128 // 128 Positive lookbehind
	OP_ASSERTBACK_NOT = 129 // 129 Negative lookbehind
	OP_ASSERT_NA      = 130 // 130 Positive non-atomic lookahead
	OP_ASSERTBACK_NA  = 131 // 131 Positive non-atomic lookbehind

	// ONCE, SCRIPT_RUN, BRA, BRAPOS, CBRA, CBRAPOS, and COND must come
	//   immediately after the assertions, with ONCE first, as there's a test for >=
	//   ONCE for a subpattern that isn't an assertion. The POS versions must
	//   immediately follow the non-POS versions in each case.

	OP_ONCE       = 132 // 132 Atomic group, contains captures
	OP_SCRIPT_RUN = 133 // 133 Non-capture, but check characters' scripts
	OP_BRA        = 134 // 134 Start of non-capturing bracket
	OP_BRAPOS     = 135 // 135 Ditto, with unlimited, possessive repeat
	OP_CBRA       = 136 // 136 Start of capturing bracket
	OP_CBRAPOS    = 137 // 137 Ditto, with unlimited, possessive repeat
	OP_COND       = 138 // 138 Conditional group

	// These five must follow the previous five, in the same order. There's a
	//   check for >= SBRA to distinguish the two sets.

	OP_SBRA     = 139 // 139 Start of non-capturing bracket, check empty
	OP_SBRAPOS  = 140 // 149 Ditto, with unlimited, possessive repeat
	OP_SCBRA    = 141 // 141 Start of capturing bracket, check empty
	OP_SCBRAPOS = 142 // 142 Ditto, with unlimited, possessive repeat
	OP_SCOND    = 143 // 143 Conditional group, check empty

	// The next two pairs must (respectively) be kept together.

	OP_CREF   = 144 // 144 Used to hold a capture number as condition
	OP_DNCREF = 145 // 145 Used to point to duplicate names as a condition
	OP_RREF   = 146 // 146 Used to hold a recursion number as condition
	OP_DNRREF = 147 // 147 Used to point to duplicate names as a condition
	OP_FALSE  = 148 // 148 Always false (used by DEFINE and VERSION)
	OP_TRUE   = 149 // 149 Always true (used by VERSION)

	OP_BRAZERO    = 150 // 150 These two must remain together and in this
	OP_BRAMINZERO = 151 // 151 order.
	OP_BRAPOSZERO = 152 // 152

	// These are backtracking control verbs

	OP_MARK       = 153 // 153 always has an argument
	OP_PRUNE      = 154 // 154
	OP_PRUNE_ARG  = 155 // 155 same, but with argument
	OP_SKIP       = 156 // 156
	OP_SKIP_ARG   = 157 // 157 same, but with argument
	OP_THEN       = 158 // 158
	OP_THEN_ARG   = 159 // 159 same, but with argument
	OP_COMMIT     = 160 // 160
	OP_COMMIT_ARG = 161 // 161 same, but with argument

	// These are forced failure and success verbs. FAIL and ACCEPT do accept an
	//   argument, but these cases can be compiled as, for example, (*MARK:X)(*FAIL)
	//   without the need for a special opcode.

	OP_FAIL          = 162 // 162
	OP_ACCEPT        = 163 // 163
	OP_ASSERT_ACCEPT = 164 // 164 Used inside assertions
	OP_CLOSE         = 165 // 165 Used before OP_ACCEPT to close open captures

	// This is used to skip a subpattern with a {0} quantifier

	OP_SKIPZERO = 166 // 166

	// This is used to identify a DEFINE group during compilation so that it can
	//   be checked for having only one branch. It is changed to OP_FALSE before
	//   compilation finishes.

	OP_DEFINE = 167 // 167

	// This is not an opcode, but is used to check that tables indexed by opcode
	//   are the correct length, in order to catch updating errors - there have been
	//   some in the past.

	OP_TABLE_LENGTH = 168
)

// Size of entries in ucd_script_sets[]

// End of pcre2_ucp.h

// When PCRE2 is compiled as a C++ library, the subject pointer can be replaced
// with a custom type. This makes it possible, for example, to allow pcre2_match()
// to process subject strings that are discontinuous by using a smart pointer
// class. It must always be possible to inspect all of the subject string in
// pcre2_match() because of the way it backtracks.

// WARNING: This is as yet untested for PCRE2.

// When checking for integer overflow in pcre2_compile(), we need to handle
// large integers. If a 64-bit integer type is available, we can use that.
// Otherwise we have to cast to double, which of course requires floating point
// arithmetic. Handle this by defining a macro for the appropriate type.

// External (in the C sense) functions and tables that are private to the
// libraries are always referenced using the PRIV macro. This makes it possible
// for pcre2test.c to include some of the source files from the libraries using a
// different PRIV definition to avoid name clashes. It also makes it clear in the
// code that a non-static object is being referenced.

// When compiling for use with the Virtual Pascal compiler, these functions
// need to have their names changed. PCRE2 must be compiled with the -DVPCOMPAT
// option on the command line.

// Otherwise, to cope with SunOS4 and other systems that lack memmove(), define
// a macro that calls an emulating function.

// This is an unsigned int value that no UTF character can ever have, as
// Unicode doesn't go beyond 0x0010ffff.

// This is the largest valid UTF/Unicode code point.

// Compile-time positive error numbers (all except UTF errors, which are
// negative) start at this value. It should probably never be changed, in case
// some application is checking for specific numbers. There is a copy of this
// #define in pcre2posix.c (which now no longer includes this file). Ideally, a
// way of having a single definition should be found, but as the number is
// unlikely to change, this is not a pressing issue. The original reason for
// having a base other than 0 was to keep the absolute values of compile-time and
// run-time error numbers numerically different, but in the event the code does
// not rely on this.

// The initial frames vector for remembering pcre2_match() backtracking points
// is allocated on the heap, of this size (bytes) or ten times the frame size if
// larger, unless the heap limit is smaller. Typical frame sizes are a few hundred
// bytes (it depends on the number of capturing parentheses) so 20KiB handles
// quite a few frames. A larger vector on the heap is obtained for matches that
// need more frames, subject to the heap limit.

// For DFA matching, an initial internal workspace vector is allocated on the
// stack. The heap is used only if this turns out to be too small.

// Define the default BSR convention.

// ---------------- Basic UTF-8 macros ----------------

// These UTF-8 macros are always defined because they are used in pcre2test for
// handling wide characters in 16-bit and 32-bit modes, even if an 8-bit library
// is not supported.

// Tests whether a UTF-8 code point needs extra bytes to decode.

// The following macros were originally written in the form of loops that used
// data from the tables whose names start with PRIV(utf8_table). They were
// rewritten by a user so as not to use loops, because in some environments this
// gives a significant performance advantage, and it seems never to do any harm.

// Base macro to pick up the remaining bytes of a UTF-8 character, not
// advancing the pointer.

// Base macro to pick up the remaining bytes of a UTF-8 character, advancing
// the pointer.

// Base macro to pick up the remaining bytes of a UTF-8 character, not
// advancing the pointer, incrementing the length.

// --------------- Whitespace macros ----------------

// Tests for Unicode horizontal and vertical whitespace characters must check a
// number of different values. Using a switch statement for this generates the
// fastest code (no loop, no memory access), and there are several places in the
// interpreter code where this happens. In order to ensure that all the case lists
// remain in step, we use macros so that there is only one place where the lists
// are defined.
//
// These values are also required as lists in pcre2_compile.c when processing \h,
// \H, \v and \V in a character class. The lists are defined in pcre2_tables.c,
// but macros that define the values are here so that all the definitions are
// together. The lists must be in ascending character order, terminated by
// NOTACHAR (which is 0xffffffff).
//
// Any changes should ensure that the various macros are kept in step with each
// other. NOTE: The values also appear in pcre2_jit_compile.c.

// -------------- ASCII/Unicode environments --------------

// Character U+180E (Mongolian Vowel Separator) is not included in the list of
// spaces in the Unicode file PropList.txt, and Perl does not recognize it as a
// space. However, in many other sources it is listed as a space and has been in
// PCRE (both APIs) for a long time.

// -------------- EBCDIC environments --------------

// -------------- End of whitespace macros --------------

// PCRE2 is able to support several different kinds of newline (CR, LF, CRLF,
// "any" and "anycrlf" at present). The following macros are used to package up
// testing for newlines. NLBLOCK, PSSTART, and PSEND are defined in the various
// modules to indicate in which datablock the parameters exist, and what the
// start/end of string field names are.

// This macro checks for a newline at the given position

// This macro checks for a newline immediately preceding the given position

// Private flags containing information about the compiled pattern. The first
// three must not be changed, because whichever is set is actually the number of
// bytes in a code unit in that mode.

// Values for the matchedby field in a match data block.

const ( /* pcre2_internal.h:536:1: */
	PCRE2_MATCHEDBY_INTERPRETER     = 0 // pcre2_match()
	PCRE2_MATCHEDBY_DFA_INTERPRETER = 1 // pcre2_dfa_match()
	PCRE2_MATCHEDBY_JIT             = 2
)

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Masks for identifying the public options that are permitted at match time.

// Non-error returns from and within the match() function. Error returns are
// externally defined PCRE2_ERROR_xxx codes, which are all negative.

// Special internal returns used in the match() function. Make them
// sufficiently negative to avoid the external error codes.

// The next 5 must be kept together and in sequence so that a test that checks
// for any one of them can use a range.

// Group frame type values. Zero means the frame is not a group frame. The
// lower 16 bits are used for data (e.g. the capture number). Group frames are
// used for most groups so that information about the start is easily available at
// the end without having to scan back through intermediate frames (backtrack
// points).

// Masks for the identity and data parts of the group frame type.

// Repetition types

const ( /* pcre2_match.c:118:1: */
	REPTYPE_MIN = 0
	REPTYPE_MAX = 1
	REPTYPE_POS = 2
) // OP_CRPOSQUERY, OP_CRPOSRANGE

// Numbers for RMATCH calls at backtracking points. When these lists are
// changed, the code at RETURN_SWITCH below must be updated in sync.

const ( /* pcre2_match.c:150:1: */
	RM1  = 1
	RM2  = 2
	RM3  = 3
	RM4  = 4
	RM5  = 5
	RM6  = 6
	RM7  = 7
	RM8  = 8
	RM9  = 9
	RM10 = 10
	RM11 = 11
	RM12 = 12
	RM13 = 13
	RM14 = 14
	RM15 = 15
	RM16 = 16
	RM17 = 17
	RM18 = 18
	RM19 = 19
	RM20 = 20
	RM21 = 21
	RM22 = 22
	RM23 = 23
	RM24 = 24
	RM25 = 25
	RM26 = 26
	RM27 = 27
	RM28 = 28
	RM29 = 29
	RM30 = 30
	RM31 = 31
	RM32 = 32
	RM33 = 33
	RM34 = 34
	RM35 = 35
	RM36 = 36
)

const ( /* pcre2_match.c:156:1: */
	RM100 = 100
	RM101 = 101
)

const ( /* pcre2_match.c:160:1: */
	RM200 = 200
	RM201 = 201
	RM202 = 202
	RM203 = 203
	RM204 = 204
	RM205 = 205
	RM206 = 206
	RM207 = 207
	RM208 = 208
	RM209 = 209
	RM210 = 210
	RM211 = 211
	RM212 = 212
	RM213 = 213
	RM214 = 214
	RM215 = 215
	RM216 = 216
	RM217 = 217
	RM218 = 218
	RM219 = 219
	RM220 = 220
	RM221 = 221
	RM222 = 222
	RM223 = 223
	RM224 = 224
	RM225 = 225
)

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//                Check script run                *
//

// A script run is conceptually a sequence of characters all in the same
// Unicode script. However, it isn't quite that simple. There are special rules
// for scripts that are commonly used together, and also special rules for digits.
// This function implements the appropriate checks, which is possible only when
// PCRE2 is compiled with Unicode support. The function returns TRUE if there is
// no Unicode support; however, it should never be called in that circumstance
// because an error is given by pcre2_compile() if a script run is called for in a
// version of PCRE2 compiled without Unicode support.
//
// Arguments:
//   pgr       point to the first character
//   endptr    point after the last character
//   utf       TRUE if in UTF mode
//
// Returns:    TRUE if this is a valid script run

// These are states in the checking process.

const ( /* pcre2_script_run.c:73:1: */
	SCRIPT_UNSET       = 0 // Requirement as yet unknown
	SCRIPT_MAP         = 1 // Bitmap contains acceptable scripts
	SCRIPT_HANPENDING  = 2 // Have had only Han characters
	SCRIPT_HANHIRAKATA = 3 // Expect Han or Hirikata
	SCRIPT_HANBOPOMOFO = 4 // Expect Han or Bopomofo
	SCRIPT_HANHANGUL   = 5
)

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// The maximum remembered capturing brackets minimum.

// Set a bit in the starting code unit bit map.

// Returns from set_start_bits()

const ( /* pcre2_study.c:61:1: */
	SSB_FAIL     = 0
	SSB_DONE     = 1
	SSB_CONTINUE = 2
	SSB_UNKNOWN  = 3
	SSB_TOODEEP  = 4
)

// These are Boolean properties.

const ( /* pcre2_ucp.h:105:1: */
	ucp_ASCII                        = 0
	ucp_ASCII_Hex_Digit              = 1
	ucp_Alphabetic                   = 2
	ucp_Bidi_Control                 = 3
	ucp_Bidi_Mirrored                = 4
	ucp_Case_Ignorable               = 5
	ucp_Cased                        = 6
	ucp_Changes_When_Casefolded      = 7
	ucp_Changes_When_Casemapped      = 8
	ucp_Changes_When_Lowercased      = 9
	ucp_Changes_When_Titlecased      = 10
	ucp_Changes_When_Uppercased      = 11
	ucp_Dash                         = 12
	ucp_Default_Ignorable_Code_Point = 13
	ucp_Deprecated                   = 14
	ucp_Diacritic                    = 15
	ucp_Emoji                        = 16
	ucp_Emoji_Component              = 17
	ucp_Emoji_Modifier               = 18
	ucp_Emoji_Modifier_Base          = 19
	ucp_Emoji_Presentation           = 20
	ucp_Extended_Pictographic        = 21
	ucp_Extender                     = 22
	ucp_Grapheme_Base                = 23
	ucp_Grapheme_Extend              = 24
	ucp_Grapheme_Link                = 25
	ucp_Hex_Digit                    = 26
	ucp_IDS_Binary_Operator          = 27
	ucp_IDS_Trinary_Operator         = 28
	ucp_ID_Continue                  = 29
	ucp_ID_Start                     = 30
	ucp_Ideographic                  = 31
	ucp_Join_Control                 = 32
	ucp_Logical_Order_Exception      = 33
	ucp_Lowercase                    = 34
	ucp_Math                         = 35
	ucp_Noncharacter_Code_Point      = 36
	ucp_Pattern_Syntax               = 37
	ucp_Pattern_White_Space          = 38
	ucp_Prepended_Concatenation_Mark = 39
	ucp_Quotation_Mark               = 40
	ucp_Radical                      = 41
	ucp_Regional_Indicator           = 42
	ucp_Sentence_Terminal            = 43
	ucp_Soft_Dotted                  = 44
	ucp_Terminal_Punctuation         = 45
	ucp_Unified_Ideograph            = 46
	ucp_Uppercase                    = 47
	ucp_Variation_Selector           = 48
	ucp_White_Space                  = 49
	ucp_XID_Continue                 = 50
	ucp_XID_Start                    = 51
	// This must be last
	ucp_Bprop_Count = 52
)

// Size of entries in ucd_boolprop_sets[]

// These are the bidi class values.

const ( /* pcre2_ucp.h:168:1: */
	ucp_bidiAL  = 0  // Arabic letter
	ucp_bidiAN  = 1  // Arabic number
	ucp_bidiB   = 2  // Paragraph separator
	ucp_bidiBN  = 3  // Boundary neutral
	ucp_bidiCS  = 4  // Common separator
	ucp_bidiEN  = 5  // European number
	ucp_bidiES  = 6  // European separator
	ucp_bidiET  = 7  // European terminator
	ucp_bidiFSI = 8  // First strong isolate
	ucp_bidiL   = 9  // Left to right
	ucp_bidiLRE = 10 // Left to right embedding
	ucp_bidiLRI = 11 // Left to right isolate
	ucp_bidiLRO = 12 // Left to right override
	ucp_bidiNSM = 13 // Non-spacing mark
	ucp_bidiON  = 14 // Other neutral
	ucp_bidiPDF = 15 // Pop directional format
	ucp_bidiPDI = 16 // Pop directional isolate
	ucp_bidiR   = 17 // Right to left
	ucp_bidiRLE = 18 // Right to left embedding
	ucp_bidiRLI = 19 // Right to left isolate
	ucp_bidiRLO = 20 // Right to left override
	ucp_bidiS   = 21 // Segment separator
	ucp_bidiWS  = 22
)

// These are grapheme break properties. The Extended Pictographic property
// comes from the emoji-data.txt file.

const ( /* pcre2_ucp.h:197:1: */
	ucp_gbCR                    = 0  //  0
	ucp_gbLF                    = 1  //  1
	ucp_gbControl               = 2  //  2
	ucp_gbExtend                = 3  //  3
	ucp_gbPrepend               = 4  //  4
	ucp_gbSpacingMark           = 5  //  5
	ucp_gbL                     = 6  //  6 Hangul syllable type L
	ucp_gbV                     = 7  //  7 Hangul syllable type V
	ucp_gbT                     = 8  //  8 Hangul syllable type T
	ucp_gbLV                    = 9  //  9 Hangul syllable type LV
	ucp_gbLVT                   = 10 // 10 Hangul syllable type LVT
	ucp_gbRegional_Indicator    = 11 // 11
	ucp_gbOther                 = 12 // 12
	ucp_gbZWJ                   = 13 // 13
	ucp_gbExtended_Pictographic = 14
)

// These are the script identifications.

const ( /* pcre2_ucp.h:217:1: */
	// Scripts which has characters in other scripts.
	ucp_Latin           = 0
	ucp_Greek           = 1
	ucp_Cyrillic        = 2
	ucp_Arabic          = 3
	ucp_Syriac          = 4
	ucp_Thaana          = 5
	ucp_Devanagari      = 6
	ucp_Bengali         = 7
	ucp_Gurmukhi        = 8
	ucp_Gujarati        = 9
	ucp_Oriya           = 10
	ucp_Tamil           = 11
	ucp_Telugu          = 12
	ucp_Kannada         = 13
	ucp_Malayalam       = 14
	ucp_Sinhala         = 15
	ucp_Myanmar         = 16
	ucp_Georgian        = 17
	ucp_Hangul          = 18
	ucp_Mongolian       = 19
	ucp_Hiragana        = 20
	ucp_Katakana        = 21
	ucp_Bopomofo        = 22
	ucp_Han             = 23
	ucp_Yi              = 24
	ucp_Tagalog         = 25
	ucp_Hanunoo         = 26
	ucp_Buhid           = 27
	ucp_Tagbanwa        = 28
	ucp_Limbu           = 29
	ucp_Tai_Le          = 30
	ucp_Linear_B        = 31
	ucp_Cypriot         = 32
	ucp_Buginese        = 33
	ucp_Coptic          = 34
	ucp_Glagolitic      = 35
	ucp_Syloti_Nagri    = 36
	ucp_Phags_Pa        = 37
	ucp_Nko             = 38
	ucp_Kayah_Li        = 39
	ucp_Javanese        = 40
	ucp_Kaithi          = 41
	ucp_Mandaic         = 42
	ucp_Chakma          = 43
	ucp_Sharada         = 44
	ucp_Takri           = 45
	ucp_Duployan        = 46
	ucp_Grantha         = 47
	ucp_Khojki          = 48
	ucp_Linear_A        = 49
	ucp_Mahajani        = 50
	ucp_Manichaean      = 51
	ucp_Modi            = 52
	ucp_Old_Permic      = 53
	ucp_Psalter_Pahlavi = 54
	ucp_Khudawadi       = 55
	ucp_Tirhuta         = 56
	ucp_Multani         = 57
	ucp_Adlam           = 58
	ucp_Masaram_Gondi   = 59
	ucp_Dogra           = 60
	ucp_Gunjala_Gondi   = 61
	ucp_Hanifi_Rohingya = 62
	ucp_Sogdian         = 63
	ucp_Nandinagari     = 64
	ucp_Yezidi          = 65
	ucp_Cypro_Minoan    = 66
	ucp_Old_Uyghur      = 67

	// Scripts which has no characters in other scripts.
	ucp_Unknown                = 68
	ucp_Common                 = 69
	ucp_Armenian               = 70
	ucp_Hebrew                 = 71
	ucp_Thai                   = 72
	ucp_Lao                    = 73
	ucp_Tibetan                = 74
	ucp_Ethiopic               = 75
	ucp_Cherokee               = 76
	ucp_Canadian_Aboriginal    = 77
	ucp_Ogham                  = 78
	ucp_Runic                  = 79
	ucp_Khmer                  = 80
	ucp_Old_Italic             = 81
	ucp_Gothic                 = 82
	ucp_Deseret                = 83
	ucp_Inherited              = 84
	ucp_Ugaritic               = 85
	ucp_Shavian                = 86
	ucp_Osmanya                = 87
	ucp_Braille                = 88
	ucp_New_Tai_Lue            = 89
	ucp_Tifinagh               = 90
	ucp_Old_Persian            = 91
	ucp_Kharoshthi             = 92
	ucp_Balinese               = 93
	ucp_Cuneiform              = 94
	ucp_Phoenician             = 95
	ucp_Sundanese              = 96
	ucp_Lepcha                 = 97
	ucp_Ol_Chiki               = 98
	ucp_Vai                    = 99
	ucp_Saurashtra             = 100
	ucp_Rejang                 = 101
	ucp_Lycian                 = 102
	ucp_Carian                 = 103
	ucp_Lydian                 = 104
	ucp_Cham                   = 105
	ucp_Tai_Tham               = 106
	ucp_Tai_Viet               = 107
	ucp_Avestan                = 108
	ucp_Egyptian_Hieroglyphs   = 109
	ucp_Samaritan              = 110
	ucp_Lisu                   = 111
	ucp_Bamum                  = 112
	ucp_Meetei_Mayek           = 113
	ucp_Imperial_Aramaic       = 114
	ucp_Old_South_Arabian      = 115
	ucp_Inscriptional_Parthian = 116
	ucp_Inscriptional_Pahlavi  = 117
	ucp_Old_Turkic             = 118
	ucp_Batak                  = 119
	ucp_Brahmi                 = 120
	ucp_Meroitic_Cursive       = 121
	ucp_Meroitic_Hieroglyphs   = 122
	ucp_Miao                   = 123
	ucp_Sora_Sompeng           = 124
	ucp_Caucasian_Albanian     = 125
	ucp_Bassa_Vah              = 126
	ucp_Elbasan                = 127
	ucp_Pahawh_Hmong           = 128
	ucp_Mende_Kikakui          = 129
	ucp_Mro                    = 130
	ucp_Old_North_Arabian      = 131
	ucp_Nabataean              = 132
	ucp_Palmyrene              = 133
	ucp_Pau_Cin_Hau            = 134
	ucp_Siddham                = 135
	ucp_Warang_Citi            = 136
	ucp_Ahom                   = 137
	ucp_Anatolian_Hieroglyphs  = 138
	ucp_Hatran                 = 139
	ucp_Old_Hungarian          = 140
	ucp_SignWriting            = 141
	ucp_Bhaiksuki              = 142
	ucp_Marchen                = 143
	ucp_Newa                   = 144
	ucp_Osage                  = 145
	ucp_Tangut                 = 146
	ucp_Nushu                  = 147
	ucp_Soyombo                = 148
	ucp_Zanabazar_Square       = 149
	ucp_Makasar                = 150
	ucp_Medefaidrin            = 151
	ucp_Old_Sogdian            = 152
	ucp_Elymaic                = 153
	ucp_Nyiakeng_Puachue_Hmong = 154
	ucp_Wancho                 = 155
	ucp_Chorasmian             = 156
	ucp_Dives_Akuru            = 157
	ucp_Khitan_Small_Script    = 158
	ucp_Tangsa                 = 159
	ucp_Toto                   = 160
	ucp_Vithkuqi               = 161

	// This must be last
	ucp_Script_Count = 162
)

// Undefine the list macros; they are no longer needed.

// PCRE2_CODE_UNIT_WIDTH must be defined. If it is 8, 16, or 32, redefine
// PCRE2_SUFFIX to use it. If it is 0, undefine the other macros and make
// PCRE2_SUFFIX a no-op. Otherwise, generate an error.

// End of pcre2.h
// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// This module is auto-generated from Unicode data files. DO NOT EDIT MANUALLY!
// Instead, modify the maint/GenerateUcpHeader.py script and run it to generate
// a new version of this code.
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// This file contains definitions of the Unicode property values that are
// returned by the UCD access macros and used throughout PCRE2.
//
// IMPORTANT: The specific values of the first two enums (general and particular
// character categories) are assumed by the table called catposstab in the file
// pcre2_auto_possess.c. They are unlikely to change, but should be checked after
// an update.

// These are the general character categories.

const ( /* pcre2_ucp.h:58:1: */
	ucp_C = 0
	ucp_L = 1
	ucp_M = 2
	ucp_N = 3
	ucp_P = 4
	ucp_S = 5
	ucp_Z = 6
)

// These are the particular character categories.

const ( /* pcre2_ucp.h:70:1: */
	ucp_Cc = 0  // Control
	ucp_Cf = 1  // Format
	ucp_Cn = 2  // Unassigned
	ucp_Co = 3  // Private use
	ucp_Cs = 4  // Surrogate
	ucp_Ll = 5  // Lower case letter
	ucp_Lm = 6  // Modifier letter
	ucp_Lo = 7  // Other letter
	ucp_Lt = 8  // Title case letter
	ucp_Lu = 9  // Upper case letter
	ucp_Mc = 10 // Spacing mark
	ucp_Me = 11 // Enclosing mark
	ucp_Mn = 12 // Non-spacing mark
	ucp_Nd = 13 // Decimal number
	ucp_Nl = 14 // Letter number
	ucp_No = 15 // Other number
	ucp_Pc = 16 // Connector punctuation
	ucp_Pd = 17 // Dash punctuation
	ucp_Pe = 18 // Close punctuation
	ucp_Pf = 19 // Final punctuation
	ucp_Pi = 20 // Initial punctuation
	ucp_Po = 21 // Other punctuation
	ucp_Ps = 22 // Open punctuation
	ucp_Sc = 23 // Currency symbol
	ucp_Sk = 24 // Modifier symbol
	ucp_Sm = 25 // Mathematical symbol
	ucp_So = 26 // Other symbol
	ucp_Zl = 27 // Line separator
	ucp_Zp = 28 // Paragraph separator
	ucp_Zs = 29
)

type Tptrdiff_t = int64 /* <builtin>:3:26 */

type Tsize_t = uint64 /* <builtin>:9:23 */

type Twchar_t = int32 /* <builtin>:15:24 */

type T__int128_t = struct {
	Flo int64
	Fhi int64
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type T__uint128_t = struct {
	Flo uint64
	Fhi uint64
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type T__builtin_va_list = uintptr /* <builtin>:46:14 */
type T__float128 = float64        /* <builtin>:47:21 */

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// This module contains functions that scan a compiled pattern and change
// repeats into possessive repeats where possible.

// src/config.h.  Generated from config.h.in by configure.
// src/config.h.in.  Generated from configure.ac by autoheader.

// PCRE2 is written in Standard C, but there are a few non-standard things it
// can cope with, allowing it to run on SunOS4 and other "close to standard"
// systems.
//
// In environments that support the GNU autotools, config.h.in is converted into
// config.h by the "configure" script. In environments that use CMake,
// config-cmake.in is converted into config.h. If you are going to build PCRE2 "by
// hand" without using "configure" or CMake, you should copy the distributed
// config.h.generic to config.h, and edit the macro definitions to be the way you
// need them. You must then add -DHAVE_CONFIG_H to all of your compile commands,
// so that config.h is included at the start of every source.
//
// Alternatively, you can avoid editing by using -D on the compiler command line
// to set the macro values. In this case, you do not have to set -DHAVE_CONFIG_H,
// but if you do, default values will be taken from config.h for non-boolean
// macros that are not defined on the command line.
//
// Boolean macros such as HAVE_STDLIB_H and SUPPORT_PCRE2_8 should either be
// defined (conventionally to 1) for TRUE, and not defined at all for FALSE. All
// such macros are listed as a commented #undef in config.h.generic. Macros such
// as MATCH_LIMIT, whose actual value is relevant, have defaults defined, but are
// surrounded by #ifndef/#endif lines so that the value can be overridden by -D.
//
// PCRE2 uses memmove() if HAVE_MEMMOVE is defined; otherwise it uses bcopy() if
// HAVE_BCOPY is defined. If your system has neither bcopy() nor memmove(), make
// sure both macros are undefined; an emulation function will then be used.

// By default, the \R escape sequence matches any Unicode line ending
//    character or sequence of characters. If BSR_ANYCRLF is defined (to any
//    value), this is changed so that backslash-R matches only CR, LF, or CRLF.
//    The build-time default can be overridden by the user of PCRE2 at runtime.
//
// #undef BSR_ANYCRLF

// Define to any value to disable the use of the z and t modifiers in
//    formatting settings such as %zu or %td (this is rarely needed).
// #undef DISABLE_PERCENT_ZT

// If you are compiling for a system that uses EBCDIC instead of ASCII
//    character codes, define this macro to any value. When EBCDIC is set, PCRE2
//    assumes that all input strings are in EBCDIC. If you do not define this
//    macro, PCRE2 will assume input strings are ASCII or UTF-8/16/32 Unicode. It
//    is not possible to build a version of PCRE2 that supports both EBCDIC and
//    UTF-8/16/32.
// #undef EBCDIC

// In an EBCDIC environment, define this macro to any value to arrange for the
//    NL character to be 0x25 instead of the default 0x15. NL plays the role that
//    LF does in an ASCII/Unicode environment.
// #undef EBCDIC_NL25

// Define this if your compiler supports __attribute__((uninitialized))

// Define to 1 if you have the `bcopy' function.

// Define to 1 if you have the <bzlib.h> header file.

// Define to 1 if you have the <dirent.h> header file.

// Define to 1 if you have the <dlfcn.h> header file.

// Define to 1 if you have the <editline/readline.h> header file.
// #undef HAVE_EDITLINE_READLINE_H

// Define to 1 if you have the <edit/readline/readline.h> header file.
// #undef HAVE_EDIT_READLINE_READLINE_H

// Define to 1 if you have the <inttypes.h> header file.

// Define to 1 if you have the <limits.h> header file.

// Define to 1 if you have the `memfd_create' function.

// Define to 1 if you have the `memmove' function.

// Define to 1 if you have the <minix/config.h> header file.
// #undef HAVE_MINIX_CONFIG_H

// Define to 1 if you have the `mkostemp' function.

// Define if you have POSIX threads libraries and header files.
// #undef HAVE_PTHREAD

// Have PTHREAD_PRIO_INHERIT.
// #undef HAVE_PTHREAD_PRIO_INHERIT

// Define to 1 if you have the <readline.h> header file.
// #undef HAVE_READLINE_H

// Define to 1 if you have the <readline/history.h> header file.
// #undef HAVE_READLINE_HISTORY_H

// Define to 1 if you have the <readline/readline.h> header file.
// #undef HAVE_READLINE_READLINE_H

// Define to 1 if you have the `realpath' function.

// Define to 1 if you have the `secure_getenv' function.

// Define to 1 if you have the <stdint.h> header file.

// Define to 1 if you have the <stdio.h> header file.

// Define to 1 if you have the <stdlib.h> header file.

// Define to 1 if you have the `strerror' function.

// Define to 1 if you have the <strings.h> header file.

// Define to 1 if you have the <string.h> header file.

// Define to 1 if you have the <sys/stat.h> header file.

// Define to 1 if you have the <sys/types.h> header file.

// Define to 1 if you have the <sys/wait.h> header file.

// Define to 1 if you have the <unistd.h> header file.

// Define to 1 if the compiler supports simple visibility declarations.

// Define to 1 if you have the <wchar.h> header file.

// Define to 1 if you have the <windows.h> header file.
// #undef HAVE_WINDOWS_H

// Define to 1 if you have the <zlib.h> header file.

// This limits the amount of memory that may be used while matching a pattern.
//    It applies to both pcre2_match() and pcre2_dfa_match(). It does not apply
//    to JIT matching. The value is in kibibytes (units of 1024 bytes).

// The value of LINK_SIZE determines the number of bytes used to store links
//    as offsets within the compiled regex. The default is 2, which allows for
//    compiled patterns up to 65535 code units long. This covers the vast
//    majority of cases. However, PCRE2 can also be compiled to use 3 or 4 bytes
//    instead. This allows for longer patterns in extreme cases.

// Define to the sub-directory where libtool stores uninstalled libraries.

// The value of MATCH_LIMIT determines the default number of times the
//    pcre2_match() function can record a backtrack position during a single
//    matching attempt. The value is also used to limit a loop counter in
//    pcre2_dfa_match(). There is a runtime interface for setting a different
//    limit. The limit exists in order to catch runaway regular expressions that
//    take for ever to determine that they do not match. The default is set very
//    large so that it does not accidentally catch legitimate cases.

// The above limit applies to all backtracks, whether or not they are nested.
//    In some environments it is desirable to limit the nesting of backtracking
//    (that is, the depth of tree that is searched) more strictly, in order to
//    restrict the maximum amount of heap memory that is used. The value of
//    MATCH_LIMIT_DEPTH provides this facility. To have any useful effect, it
//    must be less than the value of MATCH_LIMIT. The default is to use the same
//    value as MATCH_LIMIT. There is a runtime method for setting a different
//    limit. In the case of pcre2_dfa_match(), this limit controls the depth of
//    the internal nested function calls that are used for pattern recursions,
//    lookarounds, and atomic groups.

// This limit is parameterized just in case anybody ever wants to change it.
//    Care must be taken if it is increased, because it guards against integer
//    overflow caused by enormously large patterns.

// This limit is parameterized just in case anybody ever wants to change it.
//    Care must be taken if it is increased, because it guards against integer
//    overflow caused by enormously large patterns.

// Defining NEVER_BACKSLASH_C locks out the use of \C in all patterns.
// #undef NEVER_BACKSLASH_C

// The value of NEWLINE_DEFAULT determines the default newline character
//    sequence. PCRE2 client programs can override this by selecting other values
//    at run time. The valid values are 1 (CR), 2 (LF), 3 (CRLF), 4 (ANY), 5
//    (ANYCRLF), and 6 (NUL).

// Name of package

// Define to the address where bug reports for this package should be sent.

// Define to the full name of this package.

// Define to the full name and version of this package.

// Define to the one symbol short name of this package.

// Define to the home page for this package.

// Define to the version of this package.

// The value of PARENS_NEST_LIMIT specifies the maximum depth of nested
//    parentheses (of any kind) in a pattern. This limits the amount of system
//    stack that is used while compiling a pattern.

// The value of PCRE2GREP_BUFSIZE is the starting size of the buffer used by
//    pcre2grep to hold parts of the file it is searching. The buffer will be
//    expanded up to PCRE2GREP_MAX_BUFSIZE if necessary, for files containing
//    very long lines. The actual amount of memory used by pcre2grep is three
//    times this number, because it allows for the buffering of "before" and
//    "after" lines.

// The value of PCRE2GREP_MAX_BUFSIZE specifies the maximum size of the buffer
//    used by pcre2grep to hold parts of the file it is searching. The actual
//    amount of memory used by pcre2grep is three times this number, because it
//    allows for the buffering of "before" and "after" lines.

// to make a symbol visible

// to make a symbol visible

// Define to any value to include debugging code.
// #undef PCRE2_DEBUG

// to make a symbol visible

// If you are compiling for a system other than a Unix-like system or
//    Win32, and it needs some magic to be inserted before the definition
//    of a function that is exported by the library, define this macro to
//    contain the relevant magic. If you do not define this macro, a suitable
//     __declspec value is used for Windows systems; in other environments
//    "extern" is used for a C compiler and "extern C" for a C++ compiler.
//    This macro apears at the start of every exported function that is part
//    of the external API. It does not appear on functions that are "external"
//    in the C sense, but which are internal to the library.

// Define to any value if linking statically (TODO: make nice with Libtool)

// Define to necessary symbol if this constant uses a non-standard name on
//    your system.
// #undef PTHREAD_CREATE_JOINABLE

// Define to any non-zero number to enable support for SELinux compatible
//    executable memory allocator in JIT. Note that this will have no effect
//    unless SUPPORT_JIT is also defined.
// #undef SLJIT_PROT_EXECUTABLE_ALLOCATOR

// Define to 1 if all of the C90 standard headers exist (not just the ones
//    required in a freestanding environment). This macro is provided for
//    backward compatibility; new code need not use it.

// Define to any value to enable support for Just-In-Time compiling.
// #undef SUPPORT_JIT

// Define to any value to allow pcre2grep to be linked with libbz2, so that it
//    is able to handle .bz2 files.
// #undef SUPPORT_LIBBZ2

// Define to any value to allow pcre2test to be linked with libedit.
// #undef SUPPORT_LIBEDIT

// Define to any value to allow pcre2test to be linked with libreadline.
// #undef SUPPORT_LIBREADLINE

// Define to any value to allow pcre2grep to be linked with libz, so that it
//    is able to handle .gz files.
// #undef SUPPORT_LIBZ

// Define to any value to enable callout script support in pcre2grep.

// Define to any value to enable fork support in pcre2grep callout scripts.
//    This will have no effect unless SUPPORT_PCRE2GREP_CALLOUT is also defined.
//

// Define to any value to enable JIT support in pcre2grep. Note that this will
//    have no effect unless SUPPORT_JIT is also defined.
// #undef SUPPORT_PCRE2GREP_JIT

// Define to any value to enable the 16 bit PCRE2 library.
// #undef SUPPORT_PCRE2_16

// Define to any value to enable the 32 bit PCRE2 library.
// #undef SUPPORT_PCRE2_32

// Define to any value to enable the 8 bit PCRE2 library.

// Define to any value to enable support for Unicode and UTF encoding. This
//    will work even in an EBCDIC environment, but it is incompatible with the
//    EBCDIC macro. That is, PCRE2 can support *either* EBCDIC code *or*
//    ASCII/Unicode, but not both at once.

// Define to any value for valgrind support to find invalid memory reads.
// #undef SUPPORT_VALGRIND

// Enable extensions on AIX 3, Interix.
// Enable general extensions on macOS.
// Enable general extensions on Solaris.
// Enable GNU extensions on systems that have them.
// Enable X/Open compliant socket functions that do not require linking
//    with -lxnet on HP-UX 11.11.
// Identify the host operating system as Minix.
//    This macro does not affect the system headers' behavior.
//    A future release of Autoconf may stop defining this macro.
// # undef _MINIX
// Enable general extensions on NetBSD.
//    Enable NetBSD compatibility extensions on Minix.
// Enable OpenBSD compatibility extensions on NetBSD.
//    Oddly enough, this does nothing on OpenBSD.
// Define to 1 if needed for POSIX-compatible behavior.
// # undef _POSIX_SOURCE
// Define to 2 if needed for POSIX-compatible behavior.
// # undef _POSIX_1_SOURCE
// Enable POSIX-compatible threading on Solaris.
// Enable extensions specified by ISO/IEC TS 18661-5:2014.
// Enable extensions specified by ISO/IEC TS 18661-1:2014.
// Enable extensions specified by ISO/IEC TS 18661-2:2015.
// Enable extensions specified by ISO/IEC TS 18661-4:2015.
// Enable extensions specified by ISO/IEC TS 18661-3:2015.
// Enable extensions specified by ISO/IEC TR 24731-2:2010.
// Enable extensions specified by ISO/IEC 24747:2009.
// Enable extensions on HP NonStop.
// Enable X/Open extensions.  Define to 500 only if necessary
//    to make mbstate_t available.
// # undef _XOPEN_SOURCE

// Version number of package

// Number of bits in a file offset, on hosts where this is settable.
// #undef _FILE_OFFSET_BITS

// Define for large files, on AIX-style hosts.
// #undef _LARGE_FILES

// Define to empty if `const' does not conform to ANSI C.
// #undef const

// Define to the type of a signed integer type of width exactly 64 bits if
//    such a type exists and the standard includes do not define it.
// #undef int64_t

// Define to `unsigned int' if <sys/types.h> does not define.
// #undef size_t

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE2 is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// We do not support both EBCDIC and Unicode at the same time. The "configure"
// script prevents both being selected, but not everybody uses "configure". EBCDIC
// is only supported for the 8-bit library, but the check for this has to be later
// in this file, because the first part is not width-dependent, and is included by
// pcre2test.c with CODE_UNIT_WIDTH == 0.

// Standard C headers

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard 7.4: Character handling	<ctype.h>

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These are defined by the user (or the compiler)
//    to specify the desired environment:
//
//    __STRICT_ANSI__	ISO Standard C.
//    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
//    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
//    _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
//    __STDC_WANT_LIB_EXT2__
// 			Extensions to ISO C99 from TR 27431-2:2010.
//    __STDC_WANT_IEC_60559_BFP_EXT__
// 			Extensions to ISO C11 from TS 18661-1:2014.
//    __STDC_WANT_IEC_60559_FUNCS_EXT__
// 			Extensions to ISO C11 from TS 18661-4:2015.
//    __STDC_WANT_IEC_60559_TYPES_EXT__
// 			Extensions to ISO C11 from TS 18661-3:2015.
//    __STDC_WANT_IEC_60559_EXT__
// 			ISO C2X interfaces defined only in Annex F.
//
//    _POSIX_SOURCE	IEEE Std 1003.1.
//    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
// 			if >=199309L, add IEEE Std 1003.1b-1993;
// 			if >=199506L, add IEEE Std 1003.1c-1995;
// 			if >=200112L, all of IEEE 1003.1-2004
// 			if >=200809L, all of IEEE 1003.1-2008
//    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
// 			Single Unix conformance is wanted, to 600 for the
// 			sixth revision, to 700 for the seventh revision.
//    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
//    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
//    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
//    _FILE_OFFSET_BITS=N	Select default filesystem interface.
//    _ATFILE_SOURCE	Additional *at interfaces.
//    _DYNAMIC_STACK_SIZE_SOURCE Select correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    _GNU_SOURCE		All of the above, plus GNU extensions.
//    _DEFAULT_SOURCE	The default set of features (taking precedence over
// 			__STRICT_ANSI__).
//
//    _FORTIFY_SOURCE	Add security hardening to many library functions.
// 			Set to 1, 2 or 3; 3 performs stricter checks than 2, which
// 			performs stricter checks than 1.
//
//    _REENTRANT, _THREAD_SAFE
// 			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.
//
//    The `-ansi' switch to the GNU C compiler, and standards conformance
//    options such as `-std=c99', define __STRICT_ANSI__.  If none of
//    these are defined, or if _DEFAULT_SOURCE is defined, the default is
//    to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
//    200809L, as well as enabling miscellaneous functions from BSD and
//    SVID.  If more than one of these are defined, they accumulate.  For
//    example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
//    give you ISO C, 1003.1, and 1003.2, but nothing else.
//
//    These are defined by this file and are used by the
//    header files to decide what to declare or define:
//
//    __GLIBC_USE (F)	Define things from feature set F.  This is defined
// 			to 1 or 0; the subsequent macros are either defined
// 			or undefined, and those tests should be moved to
// 			__GLIBC_USE.
//    __USE_ISOC11		Define ISO C11 things.
//    __USE_ISOC99		Define ISO C99 things.
//    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
//    __USE_ISOCXX11	Define ISO C++11 things.
//    __USE_POSIX		Define IEEE Std 1003.1 things.
//    __USE_POSIX2		Define IEEE Std 1003.2 things.
//    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
//    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
//    __USE_XOPEN		Define XPG things.
//    __USE_XOPEN_EXTENDED	Define X/Open Unix things.
//    __USE_UNIX98		Define Single Unix V2 things.
//    __USE_XOPEN2K        Define XPG6 things.
//    __USE_XOPEN2KXSI     Define XPG6 XSI things.
//    __USE_XOPEN2K8       Define XPG7 things.
//    __USE_XOPEN2K8XSI    Define XPG7 XSI things.
//    __USE_LARGEFILE	Define correct standard I/O things.
//    __USE_LARGEFILE64	Define LFS things with separate names.
//    __USE_FILE_OFFSET64	Define 64bit interface as default.
//    __USE_MISC		Define things from 4.3BSD or System V Unix.
//    __USE_ATFILE		Define *at interfaces and AT_* constants for them.
//    __USE_DYNAMIC_STACK_SIZE Define correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    __USE_GNU		Define GNU extensions.
//    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
//
//    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
//    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
//    only for compatibility.  All new code should use the other symbols
//    to test for features.
//
//    All macros listed above as possibly being defined by this file are
//    explicitly undefined if they are not explicitly defined.
//    Feature-test macros that are not defined by the user or compiler
//    but are implied by the other feature-test macros defined (or by the
//    lack of any definitions) are defined by the file.
//
//    ISO C feature test macros depend on the definition of the macro
//    when an affected header is included, not when the first system
//    header is included, and so they are handled in
//    <bits/libc-header-start.h>, which does not have a multiple include
//    guard.  Feature test macros that can be handled from the first
//    system header included are handled here.

// Undefine everything, so we get a clean slate.

// Suppress kernel-name space pollution unless user expressedly asks
//    for it.

// Convenience macro to test the version of gcc.
//    Use like this:
//    #if __GNUC_PREREQ (2,8)
//    ... code requiring gcc 2.8 or later ...
//    #endif
//    Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
//    added in 2.0.

// Similarly for clang.  Features added to GCC after version 4.2 may
//    or may not also be available in clang, and clang's definitions of
//    __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
//    features can be queried via __has_extension/__has_feature.

// Whether to use feature set F.

// _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
//    _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
//    issue a warning; the expectation is that the source is being
//    transitioned to use the new macro.

// If _GNU_SOURCE was defined by the user, turn on all the other features.

// If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
//    define _DEFAULT_SOURCE.

// This is to enable the ISO C2X extension.

// This is to enable the ISO C11 extension.

// This is to enable the ISO C99 extension.

// This is to enable the ISO C90 Amendment 1:1995 extension.

// If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
//    is defined, use POSIX.1-2008 (or another version depending on
//    _XOPEN_SOURCE).

// Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
//    defined in all multithreaded code.  GNU libc has not required this
//    for many years.  We now treat them as compatibility synonyms for
//    _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
//    comprehensive support for multithreaded code.  Using them never
//    lowers the selected level of POSIX conformance, only raises it.

// Features part to handle 64-bit time_t support.
//    Copyright (C) 2021-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We need to know the word size in order to check the time size.
// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// For others, time size is word size.

// The function 'gets' existed in C89, but is impossible to use
//    safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
//    compatibility with various implementations of <cstdio>, this test
//    must consider only the value of __cplusplus when compiling C++.

// GNU formerly extended the scanf functions with modified format
//    specifiers %as, %aS, and %a[...] that allocate a buffer for the
//    input using malloc.  This extension conflicts with ISO C99, which
//    defines %a as a standalone format specifier that reads a floating-
//    point number; moreover, POSIX.1-2008 provides the same feature
//    using the modifier letter 'm' instead (%ms, %mS, %m[...]).
//
//    We now follow C99 unless GNU extensions are active and the compiler
//    is specifically in C89 or C++98 mode (strict or not).  For
//    instance, with GCC, -std=gnu11 will have C99-compliant scanf with
//    or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
//    old extension.

// Get definitions of __STDC_* predefined macros, if the compiler has
//    not preincluded this header automatically.
// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This macro indicates that the installed library is the GNU C Library.
//    For historic reasons the value now is 6 and this will stay from now
//    on.  The use of this variable is deprecated.  Use __GLIBC__ and
//    __GLIBC_MINOR__ now (see below) when you want to test for a specific
//    GNU C library version and use the values in <gnu/lib-names.h> to get
//    the sonames of the shared libraries.

// Major and minor version number of the GNU C library package.  Use
//    these macros to test for features in specific releases.

// This is here only because every header file already includes this one.
// Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We are almost always included from features.h.

// The GNU libc does not support any K&R compilers or the traditional mode
//    of ISO C compilers anymore.  Check for some of the combinations not
//    supported anymore.

// Some user header file might have defined this before.

// Compilers that lack __has_attribute may object to
//        #if defined __has_attribute && __has_attribute (...)
//    even though they do not need to evaluate the right-hand side of the &&.
//    Similarly for __has_builtin, etc.

// All functions, except those with callbacks or those that
//    synchronize memory, are leaf functions.

// GCC can always grok prototypes.  For C++ programs we add throw()
//    to help it optimize the function calls.  But this only works with
//    gcc 2.8.x and egcs.  For gcc 3.4 and up we even mark C functions
//    as non-throwing using a function attribute since programs can use
//    the -fexceptions options for C code as well.

// These two macros are not used in glibc anymore.  They are kept here
//    only because some other projects expect the macros to be defined.

// For these things, GCC behaves the ANSI way normally,
//    and the non-ANSI way under -traditional.

// This is not a typedef so `const __ptr_t' does the right thing.

// C++ needs to know that types and declarations are C, not C++.

// Fortify support.

// Use __builtin_dynamic_object_size at _FORTIFY_SOURCE=3 when available.

// Support for flexible arrays.
//    Headers that should use flexible arrays only if they're "real"
//    (e.g. only if they won't affect sizeof()) should test
//    #if __glibc_c99_flexarr_available.

// __asm__ ("xyz") is used throughout the headers to rename functions
//    at the assembly language level.  This is wrapped by the __REDIRECT
//    macro, in order to support compilers that can do this some other
//    way.  When compilers don't support asm-names at all, we have to do
//    preprocessor tricks instead (which don't have exactly the right
//    semantics, but it's the best we can do).
//
//    Example:
//    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid);

//
// #elif __SOME_OTHER_COMPILER__
//
// # define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)

// GCC and clang have various useful declarations that can be made with
//    the '__attribute__' syntax.  All of the ways we use this do fine if
//    they are omitted for compilers that don't understand it.

// At some point during the gcc 2.96 development the `malloc' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Tell the compiler which arguments to an allocation function
//    indicate the size of the allocation.

// Tell the compiler which argument to an allocation function
//    indicates the alignment of the allocation.

// At some point during the gcc 2.96 development the `pure' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// This declaration tells the compiler that the value is constant.

// At some point during the gcc 3.1 development the `used' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Since version 3.2, gcc allows marking deprecated functions.

// Since version 4.5, gcc also allows one to specify the message printed
//    when a deprecated function is used.  clang claims to be gcc 4.2, but
//    may also support this feature.

// At some point during the gcc 2.8 development the `format_arg' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.
//    If several `format_arg' attributes are given for the same function, in
//    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
//    all designated arguments are considered.

// At some point during the gcc 2.97 development the `strfmon' format
//    attribute for functions was introduced.  We don't want to use it
//    unconditionally (although this would be possible) since it
//    generates warnings.

// The nonnull function attribute marks pointer parameters that
//    must not be NULL.  This has the name __nonnull in glibc,
//    and __attribute_nonnull__ in files shared with Gnulib to avoid
//    collision with a different __nonnull in DragonFlyBSD 5.9.

// The returns_nonnull function attribute marks the return type of the function
//    as always being non-null.

// If fortification mode, we warn about unused results of certain
//    function calls which can lead to problems.

// Forces a function to be always inlined.
// The Linux kernel defines __always_inline in stddef.h (283d7573), and
//    it conflicts with this definition.  Therefore undefine it first to
//    allow either header to be included first.

// Associate error messages with the source location of the call site rather
//    than with the source location inside the function.

// GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
//    inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
//    or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
//    older than 4.3 may define these macros and still not guarantee GNU inlining
//    semantics.
//
//    clang++ identifies itself as gcc-4.2, but has support for GNU inlining
//    semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and
//    __GNUC_GNU_INLINE__ macro definitions.

// GCC 4.3 and above allow passing all anonymous arguments of an
//    __extern_always_inline function to some other vararg function.

// It is possible to compile containing GCC extensions even if GCC is
//    run in pedantic mode if the uses are carefully marked using the
//    `__extension__' keyword.  But this is not generally available before
//    version 2.8.

// __restrict is known in EGCS 1.2 and above, and in clang.
//    It works also in C++ mode (outside of arrays), but only when spelled
//    as '__restrict', not 'restrict'.

// ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
//      array_name[restrict]
//    GCC 3.1 and clang support this.
//    This syntax is not usable in C++ mode.

// Describes a char array whose address can safely be passed as the first
//    argument to strncpy and strncat, as the char array is not necessarily
//    a NUL-terminated string.

// Undefine (also defined in libc-symbols.h).
// Copies attributes from the declaration or type referenced by
//    the argument.

// Gnulib avoids including these, as they don't work on non-glibc or
//    older glibc platforms.
// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
//    intended for use in preprocessor macros.
//
//    Note: MESSAGE must be a _single_ string; concatenation of string
//    literals is not supported.

// Generic selection (ISO C11) is a C-only feature, available in GCC
//    since version 4.9.  Previous versions do not provide generic
//    selection, even though they might set __STDC_VERSION__ to 201112L,
//    when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
//    when testing __STDC_VERSION__ for generic selection support.
//    On the other hand, Clang also defines __GNUC__, so a clang-specific
//    check is required to enable the use of generic selection.

// Designates a 1-based positional argument ref-index of pointer type
//    that can be used to access size-index elements of the pointed-to
//    array according to access mode, or at least one element when
//    size-index is not provided:
//      access (access-mode, <ref-index> [, <size-index>])
// For _FORTIFY_SOURCE == 3 we use __builtin_dynamic_object_size, which may
//    use the access attribute to get object sizes from function definition
//    arguments, so we can't use them on functions we fortify.  Drop the object
//    size hints for such functions.

// Designates dealloc as a function to call to deallocate objects
//    allocated by the declared function.

// Specify that a function such as setjmp or vfork may return
//    twice.

// If we don't have __REDIRECT, prototypes will be missing if
//    __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].

// Decide whether we can define 'extern inline' functions in headers.

// This is here only because every header file already includes this one.
//    Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
//    <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
//    that will always return failure (and set errno to ENOSYS).
// This file is automatically generated.
//    This file selects the right generated file of `__stub_FUNCTION' macros
//    based on the architecture being compiled for.

// This file is automatically generated.
//    It defines a symbol `__stub_FUNCTION' for each function
//    in the C library which is a stub, meaning it will fail
//    every time called, usually setting errno to ENOSYS.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// For others, time size is word size.

// Convenience types.
type T__u_char = uint8   /* types.h:31:23 */
type T__u_short = uint16 /* types.h:32:28 */
type T__u_int = uint32   /* types.h:33:22 */
type T__u_long = uint64  /* types.h:34:27 */

// Fixed-size types, underlying types depend on word size and compiler.
type T__int8_t = int8     /* types.h:37:21 */
type T__uint8_t = uint8   /* types.h:38:23 */
type T__int16_t = int16   /* types.h:39:26 */
type T__uint16_t = uint16 /* types.h:40:28 */
type T__int32_t = int32   /* types.h:41:20 */
type T__uint32_t = uint32 /* types.h:42:22 */
type T__int64_t = int64   /* types.h:44:25 */
type T__uint64_t = uint64 /* types.h:45:27 */

// Smallest types with at least a given width.
type T__int_least8_t = int8     /* types.h:52:18 */
type T__uint_least8_t = uint8   /* types.h:53:19 */
type T__int_least16_t = int16   /* types.h:54:19 */
type T__uint_least16_t = uint16 /* types.h:55:20 */
type T__int_least32_t = int32   /* types.h:56:19 */
type T__uint_least32_t = uint32 /* types.h:57:20 */
type T__int_least64_t = int64   /* types.h:58:19 */
type T__uint_least64_t = uint64 /* types.h:59:20 */

// quad_t is also 64 bits.
type T__quad_t = int64    /* types.h:63:18 */
type T__u_quad_t = uint64 /* types.h:64:27 */

// Largest integral types.
type T__intmax_t = int64   /* types.h:72:18 */
type T__uintmax_t = uint64 /* types.h:73:27 */

// The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
//    macros for each of the OS types we define below.  The definitions
//    of those macros must use the following macros for underlying types.
//    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
//    variants of each of the following integer types on this machine.
//
// 	16		-- "natural" 16-bit type (always short)
// 	32		-- "natural" 32-bit type (always int)
// 	64		-- "natural" 64-bit type (long or long long)
// 	LONG32		-- 32-bit type, traditionally long
// 	QUAD		-- 64-bit type, traditionally long long
// 	WORD		-- natural type of __WORDSIZE bits (int or long)
// 	LONGWORD	-- type of __WORDSIZE bits, traditionally long
//
//    We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
//    conventional uses of `long' or `long long' type modifiers match the
//    types we define, even when a less-adorned type would be the same size.
//    This matters for (somewhat) portably writing printf/scanf formats for
//    these types, where using the appropriate l or ll format modifiers can
//    make the typedefs and the formats match up across all GNU platforms.  If
//    we used `long' when it's 64 bits where `long long' is expected, then the
//    compiler would warn about the formats not matching the argument types,
//    and the programmer changing them to shut up the compiler would break the
//    program's portability.
//
//    Here we assume what is presently the case in all the GCC configurations
//    we support: long long is always 64 bits, long is always word/address size,
//    and int is always 32 bits.

// No need to mark the typedef with __extension__.
// bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
//    Copyright (C) 2012-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// See <bits/types.h> for the meaning of these macros.  This file exists so
//    that <bits/types.h> need not vary across different GNU platforms.

// X32 kernel interface is 64-bit.

// Tell the libc code that off_t and off64_t are actually the same type
//    for all ABI purposes, even if possibly expressed as different base types
//    for C type-checking purposes.

// Same for ino_t and ino64_t.

// And for __rlim_t and __rlim64_t.

// And for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.

// And for getitimer, setitimer and rusage

// Number of descriptors that can fit in an `fd_set'.

// bits/time64.h -- underlying types for __time64_t.  Generic version.
//    Copyright (C) 2018-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define __TIME64_T_TYPE so that it is always a 64-bit type.

// If we already have 64-bit time type then use it.

type T__dev_t = uint64                     /* types.h:145:25 */ // Type of device numbers.
type T__uid_t = uint32                     /* types.h:146:25 */ // Type of user identifications.
type T__gid_t = uint32                     /* types.h:147:25 */ // Type of group identifications.
type T__ino_t = uint64                     /* types.h:148:25 */ // Type of file serial numbers.
type T__ino64_t = uint64                   /* types.h:149:27 */ // Type of file serial numbers (LFS).
type T__mode_t = uint32                    /* types.h:150:26 */ // Type of file attribute bitmasks.
type T__nlink_t = uint64                   /* types.h:151:27 */ // Type of file link counts.
type T__off_t = int64                      /* types.h:152:25 */ // Type of file sizes and offsets.
type T__off64_t = int64                    /* types.h:153:27 */ // Type of file sizes and offsets (LFS).
type T__pid_t = int32                      /* types.h:154:25 */ // Type of process identifications.
type T__fsid_t = struct{ F__val [2]int32 } /* types.h:155:26 */ // Type of file system IDs.
type T__clock_t = int64                    /* types.h:156:27 */ // Type of CPU usage counts.
type T__rlim_t = uint64                    /* types.h:157:26 */ // Type for resource measurement.
type T__rlim64_t = uint64                  /* types.h:158:28 */ // Type for resource measurement (LFS).
type T__id_t = uint32                      /* types.h:159:24 */ // General type for IDs.
type T__time_t = int64                     /* types.h:160:26 */ // Seconds since the Epoch.
type T__useconds_t = uint32                /* types.h:161:30 */ // Count of microseconds.
type T__suseconds_t = int64                /* types.h:162:31 */ // Signed count of microseconds.
type T__suseconds64_t = int64              /* types.h:163:33 */

type T__daddr_t = int32 /* types.h:165:27 */ // The type of a disk address.
type T__key_t = int32   /* types.h:166:25 */ // Type of an IPC key.

// Clock ID used in clock and timer functions.
type T__clockid_t = int32 /* types.h:169:29 */

// Timer ID returned by `timer_create'.
type T__timer_t = uintptr /* types.h:172:12 */

// Type to represent block size.
type T__blksize_t = int64 /* types.h:175:29 */

// Types from the Large File Support interface.

// Type to count number of disk blocks.
type T__blkcnt_t = int64   /* types.h:180:28 */
type T__blkcnt64_t = int64 /* types.h:181:30 */

// Type to count file system blocks.
type T__fsblkcnt_t = uint64   /* types.h:184:30 */
type T__fsblkcnt64_t = uint64 /* types.h:185:32 */

// Type to count file system nodes.
type T__fsfilcnt_t = uint64   /* types.h:188:30 */
type T__fsfilcnt64_t = uint64 /* types.h:189:32 */

// Type of miscellaneous file system fields.
type T__fsword_t = int64 /* types.h:192:28 */

type T__ssize_t = int64 /* types.h:194:27 */ // Type of a byte count, or error.

// Signed long type used in system calls.
type T__syscall_slong_t = int64 /* types.h:197:33 */
// Unsigned long type used in system calls.
type T__syscall_ulong_t = uint64 /* types.h:199:33 */

// These few don't really vary by system, they always correspond
//
//	to one of the other defined types.
type T__loff_t = int64    /* types.h:203:19 */ // Type of file sizes and offsets (LFS).
type T__caddr_t = uintptr /* types.h:204:14 */

// Duplicates info from stdint.h but this is used in unistd.h.
type T__intptr_t = int64 /* types.h:207:25 */

// Duplicate info from sys/socket.h.
type T__socklen_t = uint32 /* types.h:210:23 */

// C99: An integer type that can be accessed as an atomic entity,
//
//	even in the presence of asynchronous interrupts.
//	It is not currently necessary for this to be machine-specific.
type T__sig_atomic_t = int32 /* types.h:215:13 */

// This code is needed for the optimized mapping functions.

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type S__locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
} /* __locale_t.h:27:1 */

type T__locale_t = uintptr /* __locale_t.h:41:32 */

type Tlocale_t = uintptr /* locale_t.h:24:20 */

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//
//	as great as that of any standard type not using alignment
//	specifiers.
type Tmax_align_t = struct {
	F__max_align_ll int64
	F__max_align_ld float64
} /* stddef.h:436:3 */

// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Copyright (C) 1989-2023 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Copyright (C) 1989-2023 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type T__gnuc_va_list = uintptr /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Integral type unchanged by default argument promotions that can
//    hold any value corresponding to members of the extended character
//    set, as well as at least one value that does not correspond to any
//    member of the extended character set.

// Conversion state information.
type T__mbstate_t = struct {
	F__count int32
	F__value struct{ F__wch uint32 }
} /* __mbstate_t.h:21:3 */

// The tag name of this struct is _G_fpos_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t arguments.
//	That name should not be used in new code.
type S_G_fpos_t = struct {
	F__pos   int64
	F__state T__mbstate_t
} /* __fpos_t.h:10:9 */

// The tag name of this struct is _G_fpos_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t arguments.
//	That name should not be used in new code.
type T__fpos_t = S_G_fpos_t /* __fpos_t.h:14:3 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t and/or fpos64_t
//	arguments.  That name should not be used in new code.
type S_G_fpos64_t = struct {
	F__pos   int64
	F__state T__mbstate_t
} /* __fpos64_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t and/or fpos64_t
//	arguments.  That name should not be used in new code.
type T__fpos64_t = S_G_fpos64_t /* __fpos64_t.h:14:3 */

type S_IO_FILE = struct {
	F_flags          int32
	F__ccgo_pad1     [4]byte
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     int64
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F__ccgo_pad2     [4]byte
	F_lock           uintptr
	F_offset         int64
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          uint64
	F_mode           int32
	F_unused2        [20]int8
} /* __FILE.h:4:1 */

type T__FILE = S_IO_FILE /* __FILE.h:5:25 */

// The opaque type of streams.  This is the definition used elsewhere.
type TFILE = S_IO_FILE /* FILE.h:7:25 */

// The structure with the cookie function pointers.
//
//	The tag name of this struct is _IO_cookie_io_functions_t to
//	preserve historic C++ mangled names for functions taking
//	cookie_io_functions_t arguments.  That name should not be used in
//	new code.
type S_IO_cookie_io_functions_t = struct {
	Fread  uintptr
	Fwrite uintptr
	Fseek  uintptr
	Fclose uintptr
} /* cookie_io_functions_t.h:55:9 */

// The structure with the cookie function pointers.
//
//	The tag name of this struct is _IO_cookie_io_functions_t to
//	preserve historic C++ mangled names for functions taking
//	cookie_io_functions_t arguments.  That name should not be used in
//	new code.
type Tcookie_io_functions_t = S_IO_cookie_io_functions_t /* cookie_io_functions_t.h:61:3 */

type Tva_list = uintptr /* stdio.h:52:24 */

type Toff_t = int64   /* stdio.h:65:19 */
type Toff64_t = int64 /* stdio.h:70:19 */

type Tssize_t = int64 /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type Tfpos_t = T__fpos64_t   /* stdio.h:86:20 */
type Tfpos64_t = T__fpos64_t /* stdio.h:89:20 */

// The following headers provide asm redirections.  These redirections must
//    appear before the first usage of these functions, e.g. in bits/stdio.h.

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get size_t, wchar_t and NULL from <stddef.h>.
// Copyright (C) 1989-2023 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Returned by `div'.
type Tdiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:63:5 */

// Returned by `ldiv'.
type Tldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:71:5 */

// Returned by `lldiv'.
type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:81:5 */

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tu_char = uint8     /* types.h:33:18 */
type Tu_short = uint16   /* types.h:34:19 */
type Tu_int = uint32     /* types.h:35:17 */
type Tu_long = uint64    /* types.h:36:18 */
type Tquad_t = int64     /* types.h:37:18 */
type Tu_quad_t = uint64  /* types.h:38:20 */
type Tfsid_t = T__fsid_t /* types.h:39:18 */
type Tloff_t = int64     /* types.h:42:18 */

type Tino_t = uint64   /* types.h:49:19 */
type Tino64_t = uint64 /* types.h:54:19 */

type Tdev_t = uint64 /* types.h:59:17 */

type Tgid_t = uint32 /* types.h:64:17 */

type Tmode_t = uint32 /* types.h:69:18 */

type Tnlink_t = uint64 /* types.h:74:19 */

type Tuid_t = uint32 /* types.h:79:17 */

type Tpid_t = int32 /* types.h:97:17 */

type Tid_t = uint32 /* types.h:103:16 */

type Tdaddr_t = int32   /* types.h:114:19 */
type Tcaddr_t = uintptr /* types.h:115:19 */

type Tkey_t = int32 /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type Tclock_t = int64 /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type Tclockid_t = int32 /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type Ttime_t = int64 /* time_t.h:10:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type Ttimer_t = uintptr /* timer_t.h:7:19 */

type Tuseconds_t = uint32 /* types.h:134:22 */
type Tsuseconds_t = int64 /* types.h:138:23 */

// Copyright (C) 1989-2023 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Old compatibility names for C types.
type Tulong = uint64  /* types.h:148:27 */
type Tushort = uint16 /* types.h:149:28 */
type Tuint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tint8_t = int8   /* stdint-intn.h:24:18 */
type Tint16_t = int16 /* stdint-intn.h:25:19 */
type Tint32_t = int32 /* stdint-intn.h:26:19 */
type Tint64_t = int64 /* stdint-intn.h:27:19 */

// These were defined by ISO C without the first `_'.
type Tu_int8_t = uint8   /* types.h:158:19 */
type Tu_int16_t = uint16 /* types.h:159:20 */
type Tu_int32_t = uint32 /* types.h:160:20 */
type Tu_int64_t = uint64 /* types.h:161:20 */

type Tregister_t = int32 /* types.h:164:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We don't use `memset' because this would require a prototype and
//    the array isn't too big.

// Get sigset_t.

type T__sigset_t = struct{ F__val [16]uint64 } /* __sigset_t.h:8:3 */

// A set of signals to be blocked, unblocked, or waited for.
type Tsigset_t = T__sigset_t /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//
//	microsecond but also has a range of years.
type Stimeval = struct {
	Ftv_sec  int64
	Ftv_usec int64
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Endian macros for string.h functions
//    Copyright (C) 1992-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//
//	has nanoseconds instead of microseconds.
type Stimespec = struct {
	Ftv_sec  int64
	Ftv_nsec int64
} /* struct_timespec.h:11:1 */

// The fd_set member is required to be an array of longs.
type T__fd_mask = int64 /* select.h:49:18 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type Tfd_set = struct{ Ffds_bits [16]int64 } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type Tfd_mask = int64 /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type Tblksize_t = int64 /* types.h:185:21 */

// Types from the Large File Support interface.
type Tblkcnt_t = int64    /* types.h:205:22 */ // Type to count number of disk blocks.
type Tfsblkcnt_t = uint64 /* types.h:209:24 */ // Type to count file system blocks.
type Tfsfilcnt_t = uint64 /* types.h:213:24 */ // Type to count file system inodes.

type Tblkcnt64_t = int64    /* types.h:219:22 */ // Type to count number of disk blocks.
type Tfsblkcnt64_t = uint64 /* types.h:220:24 */ // Type to count file system blocks.
type Tfsfilcnt64_t = uint64 /* types.h:221:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Monotonically increasing wide counters (at least 62 bits).
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Counter that is monotonically increasing (by less than 2**31 per
//
//	increment), with a single writer, and an arbitrary number of
//	readers.
type T__atomic_wide_counter = struct{ F__value64 uint64 } /* atomic_wide_counter.h:33:3 */

// Common definition of pthread_mutex_t.

type S__pthread_internal_list = struct {
	F__prev uintptr
	F__next uintptr
} /* thread-shared-types.h:51:9 */

// Common definition of pthread_mutex_t.

type T__pthread_list_t = S__pthread_internal_list /* thread-shared-types.h:55:3 */

type S__pthread_internal_slist = struct{ F__next uintptr } /* thread-shared-types.h:57:9 */

type T__pthread_slist_t = S__pthread_internal_slist /* thread-shared-types.h:60:3 */

// Arch-specific mutex definitions.  A generic implementation is provided
//    by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
//    can override it by defining:
//
//    1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
//       definition).  It should contains at least the internal members
//       defined in the generic version.
//
//    2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
//       atomic operations.
//
//    3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
//       It should initialize the mutex internal flag.

// x86 internal mutex struct definitions.
//    Copyright (C) 2019-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_mutex_s = struct {
	F__lock    int32
	F__count   uint32
	F__owner   int32
	F__nusers  uint32
	F__kind    int32
	F__spins   int16
	F__elision int16
	F__list    T__pthread_list_t
} /* struct_mutex.h:22:1 */

// Arch-sepecific read-write lock definitions.  A generic implementation is
//    provided by struct_rwlock.h.  If required, an architecture can override it
//    by defining:
//
//    1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
//       It should contain at least the internal members defined in the
//       generic version.
//
//    2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
//       It should initialize the rwlock internal type.

// x86 internal rwlock struct definitions.
//    Copyright (C) 2019-2023 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__cur_writer    int32
	F__shared        int32
	F__rwelision     int8
	F__pad1          [7]uint8
	F__pad2          uint64
	F__flags         uint32
	F__ccgo_pad1     [4]byte
} /* struct_rwlock.h:23:1 */

// Common definition of pthread_cond_t.

type S__pthread_cond_s = struct {
	F__wseq         T__atomic_wide_counter
	F__g1_start     T__atomic_wide_counter
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
} /* thread-shared-types.h:94:1 */

type T__tss_t = uint32  /* thread-shared-types.h:105:22 */
type T__thrd_t = uint64 /* thread-shared-types.h:106:27 */

type T__once_flag = struct{ F__data int32 } /* thread-shared-types.h:111:3 */

// Thread identifiers.  The structure of the attribute type is not
//
//	exposed on purpose.
type Tpthread_t = uint64 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//
//	type is not exposed on purpose.
type Tpthread_mutexattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//
//	the attribute type is not exposed on purpose.
type Tpthread_condattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type Tpthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type Tpthread_once_t = int32 /* pthreadtypes.h:53:30 */

type Spthread_attr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [56]int8
} /* pthreadtypes.h:56:1 */

type Tpthread_attr_t = Spthread_attr_t /* pthreadtypes.h:62:30 */

type Tpthread_mutex_t = struct{ F__data S__pthread_mutex_s } /* pthreadtypes.h:72:3 */

type Tpthread_cond_t = struct{ F__data S__pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//
//	structure of the attribute type is deliberately not exposed.
type Tpthread_rwlock_t = struct{ F__data S__pthread_rwlock_arch_t } /* pthreadtypes.h:91:3 */

type Tpthread_rwlockattr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type Tpthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//
//	deliberately not exposed.
type Tpthread_barrier_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [32]int8
} /* pthreadtypes.h:112:3 */

type Tpthread_barrierattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:118:3 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type Srandom_data = struct {
	Ffptr        uintptr
	Frptr        uintptr
	Fstate       uintptr
	Frand_type   int32
	Frand_deg    int32
	Frand_sep    int32
	F__ccgo_pad1 [4]byte
	Fend_ptr     uintptr
} /* stdlib.h:424:1 */

// Data structure for communication with thread safe versions.  This
//
//	type is to be regarded as opaque.  It's only exported because users
//	have to allocate objects of this type.
type Sdrand48_data = struct {
	F__x     [3]uint16
	F__old_x [3]uint16
	F__c     uint16
	F__init  uint16
	F__a     uint64
} /* stdlib.h:491:1 */

// Shorthand for type of comparison functions.
type T__compar_fn_t = uintptr /* stdlib.h:829:13 */

type Tcomparison_fn_t = uintptr /* stdlib.h:832:23 */
type T__compar_d_fn_t = uintptr /* stdlib.h:836:13 */

// Macros to make boolean values more obvious. The #ifndef is to pacify
// compiler warnings in environments where these macros are defined elsewhere.
// Unfortunately, there is no way to do the same for the typedef.

type TBOOL = int32 /* pcre2_internal.h:67:13 */

// Valgrind (memcheck) support

// -ftrivial-auto-var-init support supports initializing all local variables
// to avoid some classes of bug, but this can cause an unacceptable slowdown
// for large on-stack arrays in hot functions. This macro lets us annotate
// such arrays.

// Older versions of MSVC lack snprintf(). This define allows for
// warning/error-free compilation and testing with MSVC compilers back to at least
// MSVC 10/2010. Except for VC6 (which is missing some fundamentals and fails).

// When compiling a DLL for Windows, the exported symbols have to be declared
// using some MS magic. I found some useful information on this web page:
// http://msdn2.microsoft.com/en-us/library/y4h7bcy6(VS.80).aspx. According to the
// information there, using __declspec(dllexport) without "extern" we have a
// definition; with "extern" we have a declaration. The settings here override the
// setting in pcre2.h (which is included below); it defines only PCRE2_EXP_DECL,
// which is all that is needed for applications (they just import the symbols). We
// use:
//
//   PCRE2_EXP_DECL    for declarations
//   PCRE2_EXP_DEFN    for definitions
//
// The reason for wrapping this in #ifndef PCRE2_EXP_DECL is so that pcre2test,
// which is an application, but needs to import this file in order to "peek" at
// internals, can #include pcre2.h first to get an application's-eye view.
//
// In principle, people compiling for non-Windows, non-Unix-like (i.e. uncommon,
// special-purpose environments) might want to stick other stuff in front of
// exported symbols. That's why, in the non-Windows case, we set PCRE2_EXP_DEFN
// only if it is not already set.

// Include the public PCRE2 header and the definitions of UCP character
// property values. This must follow the setting of PCRE2_EXP_DECL above.

// ************************************************
//
//       Perl-Compatible Regular Expressions      *
//

// This is the public header file for the PCRE library, second API, to be
// #included by applications that call PCRE2 functions.
//
//            Copyright (c) 2016-2021 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// The current PCRE version information.

// When an application links to a PCRE DLL in Windows, the symbols that are
// imported have to be identified as such. When building PCRE2, the appropriate
// export setting is defined in pcre2_internal.h, which includes this file. So we
// don't change existing definitions of PCRE2_EXP_DECL.

// By default, we use the standard "extern" declarations.

// When compiling with the MSVC compiler, it is sometimes necessary to include
// a "calling convention" before exported function names. (This is secondhand
// information; I know nothing about MSVC myself). For example, something like
//
//   void __cdecl function(....)
//
// might be needed. In order so make this easy, all the exported functions have
// PCRE2_CALL_CONVENTION just before their names. It is rarely needed; if not
// set, we ensure here that it has no effect.

// Have to include limits.h, stdlib.h, and inttypes.h to ensure that size_t and
// uint8_t, UCHAR_MAX, etc are defined. Some systems that do have inttypes.h do
// not have stdint.h, which is why we use inttypes.h, which according to the C
// standard is a superset of stdint.h. If inttypes.h is not available the build
// will break and the relevant values must be provided by some other means.

// Copyright (C) 1992-2023 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1997-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get the type definitions.
// Copyright (C) 1997-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// wchar_t type related definitions.
//    Copyright (C) 2000-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//    are not defined, give the right value and type as long as both int
//    and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//    ensures that the type is correct; it is necessary to use (L'\0' +
//    0) rather than just L'\0' so that the type in C++ is the promoted
//    version of wchar_t rather than the distinct wchar_t type itself.
//    Because wchar_t in preprocessor #if expressions is treated as
//    intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//    wrong value for WCHAR_MAX in such expressions and so cannot be used
//    to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Exact integral types.

// Signed.
// Define intN_t types.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2023 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tuint8_t = uint8   /* stdint-uintn.h:24:19 */
type Tuint16_t = uint16 /* stdint-uintn.h:25:20 */
type Tuint32_t = uint32 /* stdint-uintn.h:26:20 */
type Tuint64_t = uint64 /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type Tint_least8_t = int8   /* stdint.h:43:24 */
type Tint_least16_t = int16 /* stdint.h:44:25 */
type Tint_least32_t = int32 /* stdint.h:45:25 */
type Tint_least64_t = int64 /* stdint.h:46:25 */

// Unsigned.
type Tuint_least8_t = uint8   /* stdint.h:49:25 */
type Tuint_least16_t = uint16 /* stdint.h:50:26 */
type Tuint_least32_t = uint32 /* stdint.h:51:26 */
type Tuint_least64_t = uint64 /* stdint.h:52:26 */

// Fast types.

// Signed.
type Tint_fast8_t = int8   /* stdint.h:58:22 */
type Tint_fast16_t = int64 /* stdint.h:60:19 */
type Tint_fast32_t = int64 /* stdint.h:61:19 */
type Tint_fast64_t = int64 /* stdint.h:62:19 */

// Unsigned.
type Tuint_fast8_t = uint8   /* stdint.h:71:24 */
type Tuint_fast16_t = uint64 /* stdint.h:73:27 */
type Tuint_fast32_t = uint64 /* stdint.h:74:27 */
type Tuint_fast64_t = uint64 /* stdint.h:75:27 */

// Types for `void *' pointers.
type Tintptr_t = int64   /* stdint.h:87:19 */
type Tuintptr_t = uint64 /* stdint.h:90:27 */

// Largest integral types.
type Tintmax_t = int64   /* stdint.h:101:21 */
type Tuintmax_t = uint64 /* stdint.h:102:22 */

// Limits of integral types.

// Minimum of signed integral types.
// Maximum of signed integral types.

// Maximum of unsigned integral types.

// Minimum of signed integral types having a minimum size.
// Maximum of signed integral types having a minimum size.

// Maximum of unsigned integral types having a minimum size.

// Minimum of fast signed integral types having a minimum size.
// Maximum of fast signed integral types having a minimum size.

// Maximum of fast unsigned integral types having a minimum size.

// Values to test for integral types holding `void *' pointer.

// Minimum for largest signed integral type.
// Maximum for largest signed integral type.

// Maximum for largest unsigned integral type.

// Limits of other integer types.

// Limits of `ptrdiff_t' type.

// Limits of `sig_atomic_t'.

// Limit of `size_t' type.

// Limits of `wchar_t'.
// These constants might also be defined in <wchar.h>.

// Limits of `wint_t'.

// Signed.

// Unsigned.

// Maximal type.

// Get a definition for wchar_t.  But we must not define wchar_t itself.
type T__gwchar_t = int32 /* inttypes.h:34:24 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `ldiv_t'.
type Timaxdiv_t = struct {
	Fquot int64
	Frem  int64
} /* inttypes.h:275:5 */

// Allow for C++ users compiling this directly.

// The following option bits can be passed to pcre2_compile(), pcre2_match(),
// or pcre2_dfa_match(). PCRE2_NO_UTF_CHECK affects only the function to which it
// is passed. Put these bits at the most significant end of the options word so
// others can be added next to them

// The following option bits can be passed only to pcre2_compile(). However,
// they may affect compilation, JIT compilation, and/or interpretive execution.
// The following tags indicate which:
//
// C   alters what is compiled by pcre2_compile()
// J   alters what is compiled by pcre2_jit_compile()
// M   is inspected during pcre2_match() execution
// D   is inspected during pcre2_dfa_match() execution

// An additional compile options word is available in the compile context.

// These are for pcre2_jit_compile().

// These are for pcre2_match(), pcre2_dfa_match(), pcre2_jit_match(), and
// pcre2_substitute(). Some are allowed only for one of the functions, and in
// these cases it is noted below. Note that PCRE2_ANCHORED, PCRE2_ENDANCHORED and
// PCRE2_NO_UTF_CHECK can also be passed to these functions (though
// pcre2_jit_match() ignores the latter since it bypasses all sanity checks).

// Options for pcre2_pattern_convert().

// Newline and \R settings, for use in compile contexts. The newline values
// must be kept in step with values set in config.h and both sets must all be
// greater than zero.

// Error codes for pcre2_compile(). Some of these are also used by
// pcre2_pattern_convert().

// Error 159 is obsolete and should now never occur

// "Expected" matching error codes: no match and partial match.

// Error codes for UTF-8 validity checks

// Error codes for UTF-16 validity checks

// Error codes for UTF-32 validity checks

// Miscellaneous error codes for pcre2[_dfa]_match(), substring extraction
// functions, context functions, and serializing functions. They are in numerical
// order. Originally they were in alphabetical order too, but now that PCRE2 is
// released, the numbers must not be changed.

// Request types for pcre2_pattern_info()

// Request types for pcre2_config().

// Types for code units in patterns and subject strings.

type TPCRE2_UCHAR8 = uint8   /* pcre2.h:458:18 */
type TPCRE2_UCHAR16 = uint16 /* pcre2.h:459:18 */
type TPCRE2_UCHAR32 = uint32 /* pcre2.h:460:18 */

type TPCRE2_SPTR8 = uintptr  /* pcre2.h:462:29 */
type TPCRE2_SPTR16 = uintptr /* pcre2.h:463:29 */
type TPCRE2_SPTR32 = uintptr /* pcre2.h:464:29 */

// The PCRE2_SIZE type is used for all string lengths and offsets in PCRE2,
// including pattern offsets for errors and subject offsets after a match. We
// define special values to indicate zero-terminated strings and unset offsets in
// the offset vector (ovector).

// Generic types for opaque structures and JIT callback functions. These
// declarations are defined in a macro that is expanded for each width later.

// The structures for passing out data via callout functions. We use structures
// so that new fields can be added on the end in future versions, without changing
// the API of the function, thereby allowing old clients to work without
// modification. Define the generic versions in a macro; the width-specific
// versions are generated from this macro below.

// Flags for the callout_flags field. These are cleared after a callout.

// List the generic forms of all other functions in macros, which will be
// expanded for each width below. Start with functions that give general
// information.

// Functions for manipulating contexts.

// Functions concerned with compiling a pattern to PCRE internal code.

// Functions that give information about a compiled pattern.

// Functions for running a match and inspecting the result.

// Convenience functions for handling matched substrings.

// Functions for serializing / deserializing compiled patterns.

// Convenience function for match + substitute.

// Functions for converting pattern source strings.

// Functions for JIT processing

// Other miscellaneous functions.

// Define macros that generate width-specific names from generic versions. The
// three-level macro scheme is necessary to get the macros expanded when we want
// them to be. First we get the width from PCRE2_LOCAL_WIDTH, which is used for
// generating three versions of everything below. After that, PCRE2_SUFFIX will be
// re-defined to use PCRE2_CODE_UNIT_WIDTH, for use when macros such as
// pcre2_compile are called by application code.

// Data types

// Data blocks

// Functions: the complete list in alphabetical order

// Keep this old function name for backwards compatibility

// Keep this obsolete function for backwards compatibility: it is now a noop.

// Now generate all three sets of width-specific structures and function
// prototypes.

type Spcre2_real_general_context_8 = struct{ Fmemctl Tpcre2_memctl } /* pcre2.h:935:1 */

type Tpcre2_general_context_8 = Spcre2_real_general_context_8 /* pcre2.h:935:1 */
type Spcre2_real_compile_context_8 = struct {
	Fmemctl             Tpcre2_memctl
	Fstack_guard        uintptr
	Fstack_guard_data   uintptr
	Ftables             uintptr
	Fmax_pattern_length uint64
	Fbsr_convention     uint16
	Fnewline_convention uint16
	Fparens_nest_limit  uint32
	Fextra_options      uint32
	F__ccgo_pad1        [4]byte
} /* pcre2.h:935:1 */

type Tpcre2_compile_context_8 = Spcre2_real_compile_context_8 /* pcre2.h:935:1 */
type Spcre2_real_match_context_8 = struct {
	Fmemctl                  Tpcre2_memctl
	Fcallout                 uintptr
	Fcallout_data            uintptr
	Fsubstitute_callout      uintptr
	Fsubstitute_callout_data uintptr
	Foffset_limit            uint64
	Fheap_limit              uint32
	Fmatch_limit             uint32
	Fdepth_limit             uint32
	F__ccgo_pad1             [4]byte
} /* pcre2.h:935:1 */

type Tpcre2_match_context_8 = Spcre2_real_match_context_8 /* pcre2.h:935:1 */
type Spcre2_real_convert_context_8 = struct {
	Fmemctl         Tpcre2_memctl
	Fglob_separator uint32
	Fglob_escape    uint32
} /* pcre2.h:935:1 */

type Tpcre2_convert_context_8 = Spcre2_real_convert_context_8 /* pcre2.h:935:1 */
type Spcre2_real_code_8 = struct {
	Fmemctl             Tpcre2_memctl
	Ftables             uintptr
	Fexecutable_jit     uintptr
	Fstart_bitmap       [32]uint8
	Fblocksize          uint64
	Fmagic_number       uint32
	Fcompile_options    uint32
	Foverall_options    uint32
	Fextra_options      uint32
	Fflags              uint32
	Flimit_heap         uint32
	Flimit_match        uint32
	Flimit_depth        uint32
	Ffirst_codeunit     uint32
	Flast_codeunit      uint32
	Fbsr_convention     uint16
	Fnewline_convention uint16
	Fmax_lookbehind     uint16
	Fminlength          uint16
	Ftop_bracket        uint16
	Ftop_backref        uint16
	Fname_entry_size    uint16
	Fname_count         uint16
} /* pcre2.h:935:1 */

type Tpcre2_code_8 = Spcre2_real_code_8 /* pcre2.h:935:1 */
type Spcre2_real_match_data_8 = struct {
	Fmemctl          Tpcre2_memctl
	Fcode            uintptr
	Fsubject         uintptr
	Fmark            uintptr
	Fheapframes      uintptr
	Fheapframes_size uint64
	Fleftchar        uint64
	Frightchar       uint64
	Fstartchar       uint64
	Fmatchedby       uint8
	Fflags           uint8
	Foveccount       uint16
	Frc              int32
	Fovector         [131072]uint64
} /* pcre2.h:935:1 */

type Tpcre2_match_data_8 = Spcre2_real_match_data_8 /* pcre2.h:935:1 */
type Spcre2_real_jit_stack_8 = struct {
	Fmemctl Tpcre2_memctl
	Fstack  uintptr
} /* pcre2.h:935:1 */

type Tpcre2_jit_stack_8 = Spcre2_real_jit_stack_8 /* pcre2.h:935:1 */
type Tpcre2_jit_callback_8 = uintptr              /* pcre2.h:935:1 */
type Spcre2_callout_block_8 = struct {
	Fversion               uint32
	Fcallout_number        uint32
	Fcapture_top           uint32
	Fcapture_last          uint32
	Foffset_vector         uintptr
	Fmark                  uintptr
	Fsubject               uintptr
	Fsubject_length        uint64
	Fstart_match           uint64
	Fcurrent_position      uint64
	Fpattern_position      uint64
	Fnext_item_length      uint64
	Fcallout_string_offset uint64
	Fcallout_string_length uint64
	Fcallout_string        uintptr
	Fcallout_flags         uint32
	F__ccgo_pad1           [4]byte
} /* pcre2.h:935:1 */

type Tpcre2_callout_block_8 = Spcre2_callout_block_8 /* pcre2.h:935:1 */
type Spcre2_callout_enumerate_block_8 = struct {
	Fversion               uint32
	F__ccgo_pad1           [4]byte
	Fpattern_position      uint64
	Fnext_item_length      uint64
	Fcallout_number        uint32
	F__ccgo_pad2           [4]byte
	Fcallout_string_offset uint64
	Fcallout_string_length uint64
	Fcallout_string        uintptr
} /* pcre2.h:935:1 */

type Tpcre2_callout_enumerate_block_8 = Spcre2_callout_enumerate_block_8 /* pcre2.h:935:1 */
type Spcre2_substitute_callout_block_8 = struct {
	Fversion        uint32
	F__ccgo_pad1    [4]byte
	Finput          uintptr
	Foutput         uintptr
	Foutput_offsets [2]uint64
	Fovector        uintptr
	Foveccount      uint32
	Fsubscount      uint32
} /* pcre2.h:935:1 */

type Tpcre2_substitute_callout_block_8 = Spcre2_substitute_callout_block_8 /* pcre2.h:935:1 */
type Tpcre2_jit_callback_16 = uintptr                                      /* pcre2.h:939:1 */
type Spcre2_callout_block_16 = struct {
	Fversion               uint32
	Fcallout_number        uint32
	Fcapture_top           uint32
	Fcapture_last          uint32
	Foffset_vector         uintptr
	Fmark                  uintptr
	Fsubject               uintptr
	Fsubject_length        uint64
	Fstart_match           uint64
	Fcurrent_position      uint64
	Fpattern_position      uint64
	Fnext_item_length      uint64
	Fcallout_string_offset uint64
	Fcallout_string_length uint64
	Fcallout_string        uintptr
	Fcallout_flags         uint32
	F__ccgo_pad1           [4]byte
} /* pcre2.h:939:1 */

type Tpcre2_callout_block_16 = Spcre2_callout_block_16 /* pcre2.h:939:1 */
type Spcre2_callout_enumerate_block_16 = struct {
	Fversion               uint32
	F__ccgo_pad1           [4]byte
	Fpattern_position      uint64
	Fnext_item_length      uint64
	Fcallout_number        uint32
	F__ccgo_pad2           [4]byte
	Fcallout_string_offset uint64
	Fcallout_string_length uint64
	Fcallout_string        uintptr
} /* pcre2.h:939:1 */

type Tpcre2_callout_enumerate_block_16 = Spcre2_callout_enumerate_block_16 /* pcre2.h:939:1 */
type Spcre2_substitute_callout_block_16 = struct {
	Fversion        uint32
	F__ccgo_pad1    [4]byte
	Finput          uintptr
	Foutput         uintptr
	Foutput_offsets [2]uint64
	Fovector        uintptr
	Foveccount      uint32
	Fsubscount      uint32
} /* pcre2.h:939:1 */

type Tpcre2_substitute_callout_block_16 = Spcre2_substitute_callout_block_16 /* pcre2.h:939:1 */
type Tpcre2_jit_callback_32 = uintptr                                        /* pcre2.h:943:1 */
type Spcre2_callout_block_32 = struct {
	Fversion               uint32
	Fcallout_number        uint32
	Fcapture_top           uint32
	Fcapture_last          uint32
	Foffset_vector         uintptr
	Fmark                  uintptr
	Fsubject               uintptr
	Fsubject_length        uint64
	Fstart_match           uint64
	Fcurrent_position      uint64
	Fpattern_position      uint64
	Fnext_item_length      uint64
	Fcallout_string_offset uint64
	Fcallout_string_length uint64
	Fcallout_string        uintptr
	Fcallout_flags         uint32
	F__ccgo_pad1           [4]byte
} /* pcre2.h:943:1 */

type Tpcre2_callout_block_32 = Spcre2_callout_block_32 /* pcre2.h:943:1 */
type Spcre2_callout_enumerate_block_32 = struct {
	Fversion               uint32
	F__ccgo_pad1           [4]byte
	Fpattern_position      uint64
	Fnext_item_length      uint64
	Fcallout_number        uint32
	F__ccgo_pad2           [4]byte
	Fcallout_string_offset uint64
	Fcallout_string_length uint64
	Fcallout_string        uintptr
} /* pcre2.h:943:1 */

type Tpcre2_callout_enumerate_block_32 = Spcre2_callout_enumerate_block_32 /* pcre2.h:943:1 */
type Spcre2_substitute_callout_block_32 = struct {
	Fversion        uint32
	F__ccgo_pad1    [4]byte
	Finput          uintptr
	Foutput         uintptr
	Foutput_offsets [2]uint64
	Fovector        uintptr
	Foveccount      uint32
	Fsubscount      uint32
} /* pcre2.h:943:1 */

type Tpcre2_substitute_callout_block_32 = Spcre2_substitute_callout_block_32 /* pcre2.h:943:1 */

// *** NOTE NOTE NOTE *** Whenever the list above is updated, the two macro
// definitions that follow must also be updated to match. There are also tables
// called "opcode_possessify" in pcre2_compile.c and "coptable" and "poptable" in
// pcre2_dfa_match.c that must be updated.

// This macro defines textual names for all the opcodes. These are used only
// for debugging, and some of them are only partial names. The macro is referenced
// only in pcre2_printint.c, which fills out the full names in many cases (and in
// some cases doesn't actually use these names at all).

// This macro defines the length of fixed length operations in the compiled
// regex. The lengths are used when searching for specific things, and also in the
// debugging printing of a compiled regex. We use a macro so that it can be
// defined close to the definitions of the opcodes themselves.
//
// As things have been extended, some of these are no longer fixed lenths, but are
// minima instead. For example, the length of a single-character repeat may vary
// in UTF-8 mode. The code that uses this table must know about such things.

// A magic value for OP_RREF to indicate the "any recursion" condition.

// ---------- Private structures that are mode-independent. ----------

// Structure to hold data for custom memory management.

type Spcre2_memctl = struct {
	Fmalloc      uintptr
	Ffree        uintptr
	Fmemory_data uintptr
} /* pcre2.h:935:1 */

// *** NOTE NOTE NOTE *** Whenever the list above is updated, the two macro
// definitions that follow must also be updated to match. There are also tables
// called "opcode_possessify" in pcre2_compile.c and "coptable" and "poptable" in
// pcre2_dfa_match.c that must be updated.

// This macro defines textual names for all the opcodes. These are used only
// for debugging, and some of them are only partial names. The macro is referenced
// only in pcre2_printint.c, which fills out the full names in many cases (and in
// some cases doesn't actually use these names at all).

// This macro defines the length of fixed length operations in the compiled
// regex. The lengths are used when searching for specific things, and also in the
// debugging printing of a compiled regex. We use a macro so that it can be
// defined close to the definitions of the opcodes themselves.
//
// As things have been extended, some of these are no longer fixed lenths, but are
// minima instead. For example, the length of a single-character repeat may vary
// in UTF-8 mode. The code that uses this table must know about such things.

// A magic value for OP_RREF to indicate the "any recursion" condition.

// ---------- Private structures that are mode-independent. ----------

// Structure to hold data for custom memory management.

type Tpcre2_memctl = Spcre2_memctl /* pcre2_internal.h:1793:3 */

// Structure for building a chain of open capturing subpatterns during
// compiling, so that instructions to close them can be compiled when (*ACCEPT) is
// encountered.

type Sopen_capitem = struct {
	Fnext         uintptr
	Fnumber       uint16
	Fassert_depth uint16
	F__ccgo_pad1  [4]byte
} /* pcre2_internal.h:1799:9 */

// Structure for building a chain of open capturing subpatterns during
// compiling, so that instructions to close them can be compiled when (*ACCEPT) is
// encountered.

type Topen_capitem = Sopen_capitem /* pcre2_internal.h:1803:3 */

// Layout of the UCP type table that translates property names into types and
// codes. Each entry used to point directly to a name, but to reduce the number of
// relocations in shared libraries, it now has an offset into a single string
// instead.

type Tucp_type_table = struct {
	Fname_offset uint16
	Ftype        uint16
	Fvalue       uint16
} /* pcre2_internal.h:1814:3 */

// Unicode character database (UCD) record format

type Tucd_record = struct {
	Fscript            uint8
	Fchartype          uint8
	Fgbprop            uint8
	Fcaseset           uint8
	Fother_case        int32
	Fscriptx_bidiclass uint16
	Fbprops            uint16
} /* pcre2_internal.h:1826:3 */

// UCD access macros

// The "scriptx" and bprops fields contain offsets into vectors of 32-bit words
// that form a bitmap representing a list of scripts or boolean properties. These
// macros test or set a bit in the map by number.

// Header for serialized pcre2 codes.

type Spcre2_serialized_data = struct {
	Fmagic           uint32
	Fversion         uint32
	Fconfig          uint32
	Fnumber_of_codes int32
} /* pcre2_internal.h:1869:9 */

// UCD access macros

// The "scriptx" and bprops fields contain offsets into vectors of 32-bit words
// that form a bitmap representing a list of scripts or boolean properties. These
// macros test or set a bit in the map by number.

// Header for serialized pcre2 codes.

type Tpcre2_serialized_data = Spcre2_serialized_data /* pcre2_internal.h:1874:3 */

// Mode-dependent macros and hidden and private structures are defined in a
// separate file so that pcre2test can include them at all supported widths. When
// compiling the library, PCRE2_CODE_UNIT_WIDTH will be defined, and we can
// include them at the appropriate width, after setting up suffix macros for the
// private structures.

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// This module contains mode-dependent macro and structure definitions. The
// file is #included by pcre2_internal.h if PCRE2_CODE_UNIT_WIDTH is defined.
// These mode-dependent items are kept in a separate file so that they can also be
// #included multiple times for different code unit widths by pcre2test in order
// to have access to the hidden structures at all supported widths.
//
// Some of the mode-dependent macros are required at different widths for
// different parts of the pcre2test code (in particular, the included
// pcre_printint.c file). We undefine them here so that they can be re-defined for
// multiple inclusions. Not all of these are used in pcre2test, but it's easier
// just to undefine them all.

// -------------------------- MACROS -----------------------------

// PCRE keeps offsets in its compiled code as at least 16-bit quantities
// (always stored in big-endian order in 8-bit mode) by default. These are used,
// for example, to link from the start of a subpattern to its alternatives and its
// end. The use of 16 bits per offset limits the size of an 8-bit compiled regex
// to around 64K, which is big enough for almost everybody. However, I received a
// request for an even bigger limit. For this reason, and also to make the code
// easier to maintain, the storing and loading of offsets from the compiled code
// unit string is now handled by the macros that are defined here.
//
// The macros are controlled by the value of LINK_SIZE. This defaults to 2, but
// values of 3 or 4 are also supported.

// ------------------- 8-bit support  ------------------

// ------------------- 16-bit support  ------------------

// --------------- Other mode-specific macros -----------------

// PCRE uses some other (at least) 16-bit quantities that do not change when
// the size of offsets changes. There are used for repeat counts and for other
// things such as capturing parenthesis numbers in back references.
//
// Define the number of code units required to hold a 16-bit count/offset, and
// macros to load and store such a value. For reasons that I do not understand,
// the expression in the 8-bit GET2 macro is treated by gcc as a signed
// expression, even when a is declared as unsigned. It seems that any kind of
// arithmetic results in a signed value. Hence the cast.

// Other macros that are different for 8-bit mode. The MAX_255 macro checks
// whether its argument, which is assumed to be one code unit, is less than 256.
// The CHMAX_255 macro does not assume one code unit. The maximum length of a MARK
// name must fit in one code unit; currently it is set to 255 or 65535. The
// TABLE_GET macro is used to access elements of tables containing exactly 256
// items. Its argument is a code unit. When code points can be greater than 255, a
// check is needed before accessing these tables.

// ----------------- Character-handling macros -----------------

// There is a proposed future special "UTF-21" mode, in which only the lowest
// 21 bits of a 32-bit character are interpreted as UTF, with the remaining 11
// high-order bits available to the application for other uses. In preparation for
// the future implementation of this mode, there are macros that load a data item
// and, if in this special mode, mask it to 21 bits. These macros all have names
// starting with UCHAR21. In all other modes, including the normal 32-bit
// library, the macros all have the same simple definitions. When the new mode is
// implemented, it is expected that these definitions will be varied appropriately
// using #ifdef when compiling the library that supports the special mode.

// When UTF encoding is being used, a character is no longer just a single
// byte in 8-bit mode or a single short in 16-bit mode. The macros for character
// handling generate simple sequences when used in the basic mode, and more
// complicated ones for UTF characters. GETCHARLENTEST and other macros are not
// used when UTF is not supported. To make sure they can never even appear when
// UTF support is omitted, we don't even define them.

// ------------------- 8-bit support  ------------------

// The largest UTF code point that can be encoded as a single code unit.

// Tests whether the code point needs extra characters to decode.

// Returns with the additional number of characters if IS_MULTICHAR(c) is TRUE.
// Otherwise it has an undefined behaviour.

// Returns TRUE, if the given value is not the first code unit of a UTF
// sequence.

// Get the next UTF-8 character, not advancing the pointer. This is called when
// we know we are in UTF-8 mode.

// Get the next UTF-8 character, testing for UTF-8 mode, and not advancing the
// pointer.

// Get the next UTF-8 character, advancing the pointer. This is called when we
// know we are in UTF-8 mode.

// Get the next character, testing for UTF-8 mode, and advancing the pointer.
// This is called when we don't know if we are in UTF-8 mode.

// Get the next UTF-8 character, not advancing the pointer, incrementing length
// if there are extra bytes. This is called when we know we are in UTF-8 mode.

// Get the next UTF-8 character, testing for UTF-8 mode, not advancing the
// pointer, incrementing length if there are extra bytes. This is called when we
// do not know if we are in UTF-8 mode.

// If the pointer is not at the start of a character, move it back until
// it is. This is called only in UTF-8 mode - we don't put a test within the macro
// because almost all calls are already within a block of UTF-8 only code.

// Same as above, just in the other direction.

// Same as above, but it allows a fully customizable form.

// Deposit a character into memory, returning the number of code units.

// ------------------- 16-bit support  ------------------

// Mode-dependent macros that have the same definition in all modes.

// ----------------------- HIDDEN STRUCTURES -----------------------------

// NOTE: All these structures *must* start with a pcre2_memctl structure. The
// code that uses them is simpler because it assumes this.

// The real general context structure. At present it holds only data for custom
// memory control.

type Tpcre2_real_general_context_8 = Spcre2_real_general_context_8 /* pcre2_intmodedep.h:561:3 */

// The real compile context structure

type Tpcre2_real_compile_context_8 = Spcre2_real_compile_context_8 /* pcre2_intmodedep.h:575:3 */

// The real match context structure.

type Tpcre2_real_match_context_8 = Spcre2_real_match_context_8 /* pcre2_intmodedep.h:593:3 */

// The real convert context structure.

type Tpcre2_real_convert_context_8 = Spcre2_real_convert_context_8 /* pcre2_intmodedep.h:601:3 */

// The real compiled code structure. The type for the blocksize field is
// defined specially because it is required in pcre2_serialize_decode() when
// copying the size from possibly unaligned memory into a variable of the same
// type. Use a macro rather than a typedef to avoid compiler warnings when this
// file is included multiple times by pcre2test. LOOKBEHIND_MAX specifies the
// largest lookbehind that is supported. (OP_REVERSE in a pattern has a 16-bit
// argument in 8-bit and 16-bit modes, so we need no more than a 16-bit field
// here.)

type Tpcre2_real_code_8 = Spcre2_real_code_8 /* pcre2_intmodedep.h:642:3 */

// The real match data structure. Define ovector as large as it can ever
// actually be so that array bound checkers don't grumble. Memory for this
// structure is obtained by calling pcre2_match_data_create(), which sets the size
// as the offset of ovector plus a pair of elements for each capturable string, so
// the size varies from call to call. As the maximum number of capturing
// subpatterns is 65535 we must allow for 65536 strings to include the overall
// match. (See also the heapframe structure below.)

type Sheapframe = struct {
	Fecode             uintptr
	Ftemp_sptr         [2]uintptr
	Flength            uint64
	Fback_frame        uint64
	Ftemp_size         uint64
	Frdepth            uint32
	Fgroup_frame_type  uint32
	Ftemp_32           [4]uint32
	Freturn_id         uint8
	Fop                uint8
	Foccu              [6]uint8
	Feptr              uintptr
	Fstart_match       uintptr
	Fmark              uintptr
	Fcurrent_recurse   uint32
	Fcapture_last      uint32
	Flast_group_offset uint64
	Foffset_top        uint64
	Fovector           [131072]uint64
} /* pcre2.h:935:1 */

// Forward reference

type Tpcre2_real_match_data_8 = Spcre2_real_match_data_8 /* pcre2_intmodedep.h:669:3 */

// ----------------------- PRIVATE STRUCTURES -----------------------------

// These structures are not needed for pcre2test.

// Structures for checking for mutual recursion when scanning compiled or
// parsed code.

type Srecurse_check = struct {
	Fprev  uintptr
	Fgroup uintptr
} /* pcre2_intmodedep.h:681:9 */

// ----------------------- PRIVATE STRUCTURES -----------------------------

// These structures are not needed for pcre2test.

// Structures for checking for mutual recursion when scanning compiled or
// parsed code.

type Trecurse_check = Srecurse_check /* pcre2_intmodedep.h:684:3 */

type Sparsed_recurse_check = struct {
	Fprev     uintptr
	Fgroupptr uintptr
} /* pcre2_intmodedep.h:686:9 */

type Tparsed_recurse_check = Sparsed_recurse_check /* pcre2_intmodedep.h:689:3 */

// Structure for building a cache when filling in recursion offsets.

type Srecurse_cache = struct {
	Fgroup       uintptr
	Fgroupnumber int32
	F__ccgo_pad1 [4]byte
} /* pcre2_intmodedep.h:693:9 */

// Structure for building a cache when filling in recursion offsets.

type Trecurse_cache = Srecurse_cache /* pcre2_intmodedep.h:696:3 */

// Structure for maintaining a chain of pointers to the currently incomplete
// branches, for testing for left recursion while compiling.

type Sbranch_chain_8 = struct {
	Fouter          uintptr
	Fcurrent_branch uintptr
} /* pcre2_intmodedep.h:701:9 */

// Structure for maintaining a chain of pointers to the currently incomplete
// branches, for testing for left recursion while compiling.

type Tbranch_chain_8 = Sbranch_chain_8 /* pcre2_intmodedep.h:704:3 */

// Structure for building a list of named groups during the first pass of
// compiling.

type Snamed_group_8 = struct {
	Fname   uintptr
	Fnumber uint32
	Flength uint16
	Fisdup  uint16
} /* pcre2_intmodedep.h:709:9 */

// Structure for building a list of named groups during the first pass of
// compiling.

type Tnamed_group_8 = Snamed_group_8 /* pcre2_intmodedep.h:714:3 */

// Structure for passing "static" information around between the functions
// doing the compiling, so that they are thread-safe.

type Scompile_block_8 = struct {
	Fcx                    uintptr
	Flcc                   uintptr
	Ffcc                   uintptr
	Fcbits                 uintptr
	Fctypes                uintptr
	Fstart_workspace       uintptr
	Fstart_code            uintptr
	Fstart_pattern         uintptr
	Fend_pattern           uintptr
	Fname_table            uintptr
	Fworkspace_size        uint64
	Fsmall_ref_offset      [10]uint64
	Ferroroffset           uint64
	Fnames_found           uint16
	Fname_entry_size       uint16
	Fparens_depth          uint16
	Fassert_depth          uint16
	Fopen_caps             uintptr
	Fnamed_groups          uintptr
	Fnamed_group_list_size uint32
	Fexternal_options      uint32
	Fexternal_flags        uint32
	Fbracount              uint32
	Flastcapture           uint32
	F__ccgo_pad1           [4]byte
	Fparsed_pattern        uintptr
	Fparsed_pattern_end    uintptr
	Fgroupinfo             uintptr
	Ftop_backref           uint32
	Fbackref_map           uint32
	Fnltype                uint32
	Fnllen                 uint32
	Fclass_range_start     uint32
	Fclass_range_end       uint32
	Fnl                    [4]uint8
	Freq_varyopt           uint32
	Fmax_lookbehind        int32
	Fhad_accept            int32
	Fhad_pruneorskip       int32
	Fhad_recurse           int32
	Fdupnames              int32
	F__ccgo_pad2           [4]byte
} /* pcre2_intmodedep.h:719:9 */

// Structure for passing "static" information around between the functions
// doing the compiling, so that they are thread-safe.

type Tcompile_block_8 = Scompile_block_8 /* pcre2_intmodedep.h:760:3 */

// Structure for keeping the properties of the in-memory stack used
// by the JIT matcher.

type Tpcre2_real_jit_stack_8 = Spcre2_real_jit_stack_8 /* pcre2_intmodedep.h:768:3 */

// Structure for items in a linked list that represents an explicit recursive
// call within the pattern when running pcre2_dfa_match().

type Sdfa_recursion_info = struct {
	Fprevrec          uintptr
	Fsubject_position uintptr
	Fgroup_num        uint32
	F__ccgo_pad1      [4]byte
} /* pcre2_intmodedep.h:773:9 */

// Structure for items in a linked list that represents an explicit recursive
// call within the pattern when running pcre2_dfa_match().

type Tdfa_recursion_info = Sdfa_recursion_info /* pcre2_intmodedep.h:777:3 */

// Structure for "stack" frames that are used for remembering backtracking
// positions during matching. As these are used in a vector, with the ovector item
// being extended, the size of the structure must be a multiple of PCRE2_SIZE. The
// only way to check this at compile time is to force an error by generating an
// array with a negative size. By putting this in a typedef (which is never used),
// we don't generate any code when all is well.

type Theapframe = Sheapframe /* pcre2_intmodedep.h:837:3 */

// This typedef is a check that the size of the heapframe structure is a
// multiple of PCRE2_SIZE. See various comments above.

type Tcheck_heapframe_size = [1]int8 /* pcre2_intmodedep.h:842:14 */

// Structure for computing the alignment of heapframe.

type Sheapframe_align = struct {
	Funalign     int8
	F__ccgo_pad1 [7]byte
	Fframe       Theapframe
} /* pcre2_intmodedep.h:847:9 */

// Structure for computing the alignment of heapframe.

type Theapframe_align = Sheapframe_align /* pcre2_intmodedep.h:850:3 */

// This define is the minimum alignment required for a heapframe, in bytes.

// Structure for passing "static" information around between the functions
// doing traditional NFA matching (pcre2_match() and friends).

type Smatch_block_8 = struct {
	Fmemctl               Tpcre2_memctl
	Fheap_limit           uint64
	Fmatch_limit          uint32
	Fmatch_limit_depth    uint32
	Fmatch_call_count     uint32
	Fhitend               int32
	Fhasthen              int32
	Fallowemptypartial    int32
	Flcc                  uintptr
	Ffcc                  uintptr
	Fctypes               uintptr
	Fstart_offset         uint64
	Fend_offset_top       uint64
	Fpartial              uint16
	Fbsr_convention       uint16
	Fname_count           uint16
	Fname_entry_size      uint16
	Fname_table           uintptr
	Fstart_code           uintptr
	Fstart_subject        uintptr
	Fcheck_subject        uintptr
	Fend_subject          uintptr
	Fend_match_ptr        uintptr
	Fstart_used_ptr       uintptr
	Flast_used_ptr        uintptr
	Fmark                 uintptr
	Fnomatch_mark         uintptr
	Fverb_ecode_ptr       uintptr
	Fverb_skip_ptr        uintptr
	Fverb_current_recurse uint32
	Fmoptions             uint32
	Fpoptions             uint32
	Fskip_arg_count       uint32
	Fignore_skip_arg      uint32
	Fnltype               uint32
	Fnllen                uint32
	Fnl                   [4]uint8
	Fcb                   uintptr
	Fcallout_data         uintptr
	Fcallout              uintptr
} /* pcre2_intmodedep.h:859:9 */

// This define is the minimum alignment required for a heapframe, in bytes.

// Structure for passing "static" information around between the functions
// doing traditional NFA matching (pcre2_match() and friends).

type Tmatch_block_8 = Smatch_block_8 /* pcre2_intmodedep.h:900:3 */

// A similar structure is used for the same purpose by the DFA matching
// functions.

type Sdfa_match_block_8 = struct {
	Fmemctl            Tpcre2_memctl
	Fstart_code        uintptr
	Fstart_subject     uintptr
	Fend_subject       uintptr
	Fstart_used_ptr    uintptr
	Flast_used_ptr     uintptr
	Ftables            uintptr
	Fstart_offset      uint64
	Fheap_limit        uint64
	Fheap_used         uint64
	Fmatch_limit       uint32
	Fmatch_limit_depth uint32
	Fmatch_call_count  uint32
	Fmoptions          uint32
	Fpoptions          uint32
	Fnltype            uint32
	Fnllen             uint32
	Fallowemptypartial int32
	Fnl                [4]uint8
	Fbsr_convention    uint16
	F__ccgo_pad1       [2]byte
	Fcb                uintptr
	Fcallout_data      uintptr
	Fcallout           uintptr
	Frecursive         uintptr
} /* pcre2_intmodedep.h:905:9 */

// A similar structure is used for the same purpose by the DFA matching
// functions.

type Tdfa_match_block_8 = Sdfa_match_block_8 /* pcre2_intmodedep.h:930:3 */

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//        Tables for auto-possessification        *
//

// This table is used to check whether auto-possessification is possible
// between adjacent character-type opcodes. The left-hand (repeated) opcode is
// used to select the row, and the right-hand opcode is use to select the column.
// A value of 1 means that auto-possessification is OK. For example, the second
// value in the first row means that \D+\d can be turned into \D++\d.
//
// The Unicode property types (\P and \p) have to be present to fill out the table
// because of what their opcode values are, but the table values should always be
// zero because property types are handled separately in the code. The last four
// columns apply to items that cannot be repeated, so there is no need to have
// rows for them. Note that OP_DIGIT etc. are generated only when PCRE_UCP is
// *not* set. When it is set, \d etc. are converted into OP_(NOT_)PROP codes.

var autoposstab = [17][21]uint8{
	// \D \d \S \s \W \w  . .+ \C \P \p \R \H \h \V \v \X \Z \z  $ $M
	{uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \D
	{uint8(1), uint8(0), uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(1), uint8(0), uint8(1), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1)}, // \d
	{uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(1), uint8(0), uint8(1), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1)}, // \S
	{uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \s
	{uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \W
	{uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(1), uint8(0), uint8(1), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1)}, // \w
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // .
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // .+
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \C
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)}, // \P
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)}, // \p
	{uint8(0), uint8(1), uint8(0), uint8(1), uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \R
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \H
	{uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \h
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \V
	{uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \v
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(0)}, // \X
} /* pcre2_auto_possess.c:73:22 */

// This table is used to check whether auto-possessification is possible
// between adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP). The
// left-hand (repeated) opcode is used to select the row, and the right-hand
// opcode is used to select the column. The values are as follows:
//
//   0   Always return FALSE (never auto-possessify)
//   1   Character groups are distinct (possessify if both are OP_PROP)
//   2   Check character categories in the same group (general or particular)
//   3   TRUE if the two opcodes are not the same (PROP vs NOTPROP)
//
//   4   Check left general category vs right particular category
//   5   Check right general category vs left particular category
//
//   6   Left alphanum vs right general category
//   7   Left space vs right general category
//   8   Left word vs right general category
//
//   9   Right alphanum vs left general category
//  10   Right space vs left general category
//  11   Right word vs left general category
//
//  12   Left alphanum vs right particular category
//  13   Left space vs right particular category
//  14   Left word vs right particular category
//
//  15   Right alphanum vs left particular category
//  16   Right space vs left particular category
//  17   Right word vs left particular category

var propposstab = [14][14]uint8{
	// ANY LAMP GC  PC  SC  SCX ALNUM SPACE PXSPACE WORD CLIST UCNC BIDICL BOOL
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)},     // PT_ANY
	{uint8(0), uint8(3), uint8(0), uint8(0), uint8(0), uint8(0), uint8(3), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)},     // PT_LAMP
	{uint8(0), uint8(0), uint8(2), uint8(4), uint8(0), uint8(0), uint8(9), uint8(10), uint8(10), uint8(11), uint8(0), uint8(0), uint8(0), uint8(0)},  // PT_GC
	{uint8(0), uint8(0), uint8(5), uint8(2), uint8(0), uint8(0), uint8(15), uint8(16), uint8(16), uint8(17), uint8(0), uint8(0), uint8(0), uint8(0)}, // PT_PC
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(2), uint8(2), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)},     // PT_SC
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(2), uint8(2), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)},     // PT_SCX
	{uint8(0), uint8(3), uint8(6), uint8(12), uint8(0), uint8(0), uint8(3), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)},    // PT_ALNUM
	{uint8(0), uint8(1), uint8(7), uint8(13), uint8(0), uint8(0), uint8(1), uint8(3), uint8(3), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0)},    // PT_SPACE
	{uint8(0), uint8(1), uint8(7), uint8(13), uint8(0), uint8(0), uint8(1), uint8(3), uint8(3), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0)},    // PT_PXSPACE
	{uint8(0), uint8(0), uint8(8), uint8(14), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(3), uint8(0), uint8(0), uint8(0), uint8(0)},    // PT_WORD
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)},     // PT_CLIST
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(3), uint8(0), uint8(0)},     // PT_UCNC
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)},     // PT_BIDICL
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)},     // PT_BOOL
} /* pcre2_auto_possess.c:125:22 */

// This table is used to check whether auto-possessification is possible
// between adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP) when one
// specifies a general category and the other specifies a particular category. The
// row is selected by the general category and the column by the particular
// category. The value is 1 if the particular category is not part of the general
// category.

var catposstab = [7][30]uint8{
	// Cc Cf Cn Co Cs Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs
	{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1)}, // C
	{uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1)}, // L
	{uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1)}, // M
	{uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1)}, // N
	{uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1)}, // P
	{uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(1)}, // S
	{uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0)}, // Z
} /* pcre2_auto_possess.c:150:22 */

// This table is used when checking ALNUM, (PX)SPACE, SPACE, and WORD against
// a general or particular category. The properties in each row are those
// that apply to the character set in question. Duplication means that a little
// unnecessary work is done when checking, but this keeps things much simpler
// because they can all use the same code. For more details see the comment where
// this table is used.
//
// Note: SPACE and PXSPACE used to be different because Perl excluded VT from
// "space", but from Perl 5.18 it's included, so both categories are treated the
// same here.

var posspropstab = [3][4]uint8{
	{ucp_L, ucp_N, ucp_N, ucp_Nl}, // ALNUM, 3rd and 4th values redundant
	{ucp_Z, ucp_Z, ucp_C, ucp_Cc}, // SPACE and PXSPACE, 2nd value redundant
	{ucp_L, ucp_N, ucp_P, ucp_Po}, // WORD
} /* pcre2_auto_possess.c:172:22 */

// ************************************************
//
//        Check a character and a property        *
//

// This function is called by compare_opcodes() when a property item is
// adjacent to a fixed character.
//
// Arguments:
//   c            the character
//   ptype        the property type
//   pdata        the data for the type
//   negated      TRUE if it's a negated property (\P or \p{^)
//
// Returns:       TRUE if auto-possessifying is OK

func check_char_prop(tls *libc.TLS, c uint32, ptype uint32, pdata uint32, negated int32) int32 { /* pcre2_auto_possess.c:199:1: */
	var ok int32
	var p uintptr
	var prop uintptr = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12

	switch ptype {
	case uint32(DPT_LAMP):
		return libc.Bool32(libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lt) == negated)

	case uint32(DPT_GC):
		return libc.Bool32(libc.Bool32(pdata == X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype]) == negated)

	case uint32(DPT_PC):
		return libc.Bool32(libc.Bool32(pdata == uint32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype)) == negated)

	case uint32(DPT_SC):
		return libc.Bool32(libc.Bool32(pdata == uint32((*Tucd_record)(unsafe.Pointer(prop)).Fscript)) == negated)

	case uint32(DPT_SCX):
		ok = libc.Bool32(pdata == uint32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) ||
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(pdata/uint32(32))*4))&(uint32(1)<<(pdata%uint32(32))) != uint32(0))
		return libc.Bool32(ok == negated)

	// These are specials

	case uint32(DPT_ALNUM):
		return libc.Bool32(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N) == negated)

	// Perl space used to exclude VT, but from Perl 5.18 it is included, which
	//   means that Perl space and POSIX space are now identical. PCRE was changed
	//   at release 8.34.

	case uint32(DPT_SPACE):
		fallthrough // Perl space
	case uint32(DPT_PXSPACE): // POSIX space
		switch c {
		case uint32('\011'):
			fallthrough
		case uint32('\040'):
			fallthrough
		case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
			fallthrough
		case uint32(0x1680):
			fallthrough /* OGHAM SPACE MARK */
		case uint32(0x180e):
			fallthrough /* MONGOLIAN VOWEL SEPARATOR */
		case uint32(0x2000):
			fallthrough /* EN QUAD */
		case uint32(0x2001):
			fallthrough /* EM QUAD */
		case uint32(0x2002):
			fallthrough /* EN SPACE */
		case uint32(0x2003):
			fallthrough /* EM SPACE */
		case uint32(0x2004):
			fallthrough /* THREE-PER-EM SPACE */
		case uint32(0x2005):
			fallthrough /* FOUR-PER-EM SPACE */
		case uint32(0x2006):
			fallthrough /* SIX-PER-EM SPACE */
		case uint32(0x2007):
			fallthrough /* FIGURE SPACE */
		case uint32(0x2008):
			fallthrough /* PUNCTUATION SPACE */
		case uint32(0x2009):
			fallthrough /* THIN SPACE */
		case uint32(0x200A):
			fallthrough /* HAIR SPACE */
		case uint32(0x202f):
			fallthrough /* NARROW NO-BREAK SPACE */
		case uint32(0x205f):
			fallthrough /* MEDIUM MATHEMATICAL SPACE */
		case uint32(0x3000):
			fallthrough
		case uint32('\012'):
			fallthrough
		case uint32('\013'):
			fallthrough
		case uint32('\014'):
			fallthrough
		case uint32('\015'):
			fallthrough
		case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
			fallthrough
		case uint32(0x2028):
			fallthrough /* LINE SEPARATOR */
		case uint32(0x2029):
			return negated

		default:
			return libc.Bool32(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_Z) == negated)
		}
		break // Control never reaches here

	case uint32(DPT_WORD):
		return libc.Bool32(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N || c == uint32('\137')) == negated)

	case uint32(DPT_CLIST):
		p = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr((*Tucd_record)(unsafe.Pointer(prop)).Fcaseset)*4
		for {
			if c < *(*uint32)(unsafe.Pointer(p)) {
				return libc.BoolInt32(!(negated != 0))
			}
			if c == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&p, 4))) {
				return negated
			}
		}
		break // Control never reaches here

	// Haven't yet thought these through.

	case uint32(DPT_BIDICL):
		return DFALSE

	case uint32(DPT_BOOL):
		return DFALSE
	}

	return DFALSE
}

// ************************************************
//
//        Base opcode of repeated opcodes         *
//

// Returns the base opcode for repeated single character type opcodes. If the
// opcode is not a repeated character type, it returns with the original value.
//
// Arguments:  c opcode
// Returns:    base opcode for the type

func get_repeat_base(tls *libc.TLS, c uint8) uint8 { /* pcre2_auto_possess.c:291:1: */
	if int32(c) > OP_TYPEPOSUPTO {
		return c
	}
	if int32(c) >= OP_TYPESTAR {
		return OP_TYPESTAR
	}
	if int32(c) >= OP_NOTSTARI {
		return OP_NOTSTARI
	}
	if int32(c) >= OP_NOTSTAR {
		return OP_NOTSTAR
	}
	if int32(c) >= OP_STARI {
		return OP_STARI
	}
	return OP_STAR
}

// ************************************************
//
//        Fill the character property list        *
//

// Checks whether the code points to an opcode that can take part in auto-
// possessification, and if so, fills a list with its properties.
//
// Arguments:
//   code        points to start of expression
//   utf         TRUE if in UTF mode
//   ucp         TRUE if in UCP mode
//   fcc         points to the case-flipping table
//   list        points to output list
//               list[0] will be filled with the opcode
//               list[1] will be non-zero if this opcode
//                 can match an empty character string
//               list[2..7] depends on the opcode
//
// Returns:      points to the start of the next opcode if *code is accepted
//               NULL if *code is not accepted

func get_chr_property_list(tls *libc.TLS, code uintptr, utf int32, ucp int32, fcc uintptr, list uintptr) uintptr { /* pcre2_auto_possess.c:325:1: */
	var c uint8 = *(*uint8)(unsafe.Pointer(code))
	var base uint8
	var end uintptr
	var chr uint32
	var clist_dest uintptr
	var clist_src uintptr

	*(*uint32)(unsafe.Pointer(list)) = uint32(c)
	*(*uint32)(unsafe.Pointer(list + 1*4)) = uint32(DFALSE)
	code++

	if int32(c) >= OP_STAR && int32(c) <= OP_TYPEPOSUPTO {
		base = get_repeat_base(tls, c)
		c = uint8(int32(c) - (int32(base) - OP_STAR))

		if int32(c) == OP_UPTO || int32(c) == OP_MINUPTO || int32(c) == OP_EXACT || int32(c) == OP_POSUPTO {
			code += uintptr(DIMM2_SIZE)
		}

		*(*uint32)(unsafe.Pointer(list + 1*4)) = uint32(libc.Bool32(int32(c) != OP_PLUS && int32(c) != OP_MINPLUS && int32(c) != OP_EXACT && int32(c) != OP_POSPLUS))

		switch int32(base) {
		case OP_STAR:
			*(*uint32)(unsafe.Pointer(list)) = OP_CHAR
			break
			fallthrough

		case OP_STARI:
			*(*uint32)(unsafe.Pointer(list)) = OP_CHARI
			break
			fallthrough

		case OP_NOTSTAR:
			*(*uint32)(unsafe.Pointer(list)) = OP_NOT
			break
			fallthrough

		case OP_NOTSTARI:
			*(*uint32)(unsafe.Pointer(list)) = OP_NOTI
			break
			fallthrough

		case OP_TYPESTAR:
			*(*uint32)(unsafe.Pointer(list)) = uint32(*(*uint8)(unsafe.Pointer(code)))
			code++
			break
		}
		c = uint8(*(*uint32)(unsafe.Pointer(list)))
	}

	switch int32(c) {
	case OP_NOT_DIGIT:
		fallthrough
	case OP_DIGIT:
		fallthrough
	case OP_NOT_WHITESPACE:
		fallthrough
	case OP_WHITESPACE:
		fallthrough
	case OP_NOT_WORDCHAR:
		fallthrough
	case OP_WORDCHAR:
		fallthrough
	case OP_ANY:
		fallthrough
	case OP_ALLANY:
		fallthrough
	case OP_ANYNL:
		fallthrough
	case OP_NOT_HSPACE:
		fallthrough
	case OP_HSPACE:
		fallthrough
	case OP_NOT_VSPACE:
		fallthrough
	case OP_VSPACE:
		fallthrough
	case OP_EXTUNI:
		fallthrough
	case OP_EODN:
		fallthrough
	case OP_EOD:
		fallthrough
	case OP_DOLL:
		fallthrough
	case OP_DOLLM:
		return code

	case OP_CHAR:
		fallthrough
	case OP_NOT:
		chr = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))))
		if utf != 0 && chr >= 0xc0 {
			if chr&0x20 == uint32(0) {
				chr = chr&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))))&0x3f
			} else if chr&0x10 == uint32(0) {
				chr = chr&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(code)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + 1)))&0x3f
				code += uintptr(2)
			} else if chr&0x08 == uint32(0) {
				chr = chr&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(code)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + 2)))&0x3f
				code += uintptr(3)
			} else if chr&0x04 == uint32(0) {
				chr = chr&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(code)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(code + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + 3)))&0x3f
				code += uintptr(4)
			} else {
				chr = chr&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(code)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(code + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(code + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + 4)))&0x3f
				code += uintptr(5)
			}
		}

		*(*uint32)(unsafe.Pointer(list + 2*4)) = chr
		*(*uint32)(unsafe.Pointer(list + 3*4)) = DNOTACHAR
		return code

	case OP_CHARI:
		fallthrough
	case OP_NOTI:
		*(*uint32)(unsafe.Pointer(list)) = func() uint32 {
			if int32(c) == OP_CHARI {
				return OP_CHAR
			}
			return OP_NOT
		}()
		chr = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))))
		if utf != 0 && chr >= 0xc0 {
			if chr&0x20 == uint32(0) {
				chr = chr&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))))&0x3f
			} else if chr&0x10 == uint32(0) {
				chr = chr&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(code)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + 1)))&0x3f
				code += uintptr(2)
			} else if chr&0x08 == uint32(0) {
				chr = chr&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(code)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + 2)))&0x3f
				code += uintptr(3)
			} else if chr&0x04 == uint32(0) {
				chr = chr&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(code)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(code + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + 3)))&0x3f
				code += uintptr(4)
			} else {
				chr = chr&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(code)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(code + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(code + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + 4)))&0x3f
				code += uintptr(5)
			}
		}

		*(*uint32)(unsafe.Pointer(list + 2*4)) = chr

		if chr < uint32(128) || chr < uint32(256) && !(utf != 0) && !(ucp != 0) {
			*(*uint32)(unsafe.Pointer(list + 3*4)) = uint32(*(*uint8)(unsafe.Pointer(fcc + uintptr(chr))))
		} else {
			*(*uint32)(unsafe.Pointer(list + 3*4)) = uint32(int32(chr) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(chr)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(chr)%DUCD_BLOCK_SIZE])*12)).Fother_case)
		}

		// The othercase might be the same value.

		if chr == *(*uint32)(unsafe.Pointer(list + 3*4)) {
			*(*uint32)(unsafe.Pointer(list + 3*4)) = DNOTACHAR
		} else {
			*(*uint32)(unsafe.Pointer(list + 4*4)) = DNOTACHAR
		}
		return code

	case OP_PROP:
		fallthrough
	case OP_NOTPROP:
		if int32(*(*uint8)(unsafe.Pointer(code))) != DPT_CLIST {
			*(*uint32)(unsafe.Pointer(list + 2*4)) = uint32(*(*uint8)(unsafe.Pointer(code)))
			*(*uint32)(unsafe.Pointer(list + 3*4)) = uint32(*(*uint8)(unsafe.Pointer(code + 1)))
			return code + uintptr(2)
		}

		// Convert only if we have enough space.

		clist_src = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint8)(unsafe.Pointer(code + 1)))*4
		clist_dest = list + uintptr(2)*4
		code += uintptr(2)

		for __ccgo := true; __ccgo; __ccgo = *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&clist_src, 4))) != DNOTACHAR {
			if clist_dest >= list+uintptr(8)*4 {
				// Early return if there is not enough space. This should never
				//        happen, since all clists are shorter than 5 character now.
				*(*uint32)(unsafe.Pointer(list + 2*4)) = uint32(*(*uint8)(unsafe.Pointer(code)))
				*(*uint32)(unsafe.Pointer(list + 3*4)) = uint32(*(*uint8)(unsafe.Pointer(code + 1)))
				return code
			}
			*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&clist_dest, 4))) = *(*uint32)(unsafe.Pointer(clist_src))
		}

		// All characters are stored. The terminating NOTACHAR is copied from the
		//   clist itself.

		*(*uint32)(unsafe.Pointer(list)) = func() uint32 {
			if int32(c) == OP_PROP {
				return OP_CHAR
			}
			return OP_NOT
		}()
		return code

	case OP_NCLASS:
		fallthrough
	case OP_CLASS:
		fallthrough
	case OP_XCLASS:
		if int32(c) == OP_XCLASS {
			end = code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 1))))) - uintptr(1)
		} else {
			end = code + uintptr(uint64(32)/uint64(unsafe.Sizeof(uint8(0))))
		}

		switch int32(*(*uint8)(unsafe.Pointer(end))) {
		case OP_CRSTAR:
			fallthrough
		case OP_CRMINSTAR:
			fallthrough
		case OP_CRQUERY:
			fallthrough
		case OP_CRMINQUERY:
			fallthrough
		case OP_CRPOSSTAR:
			fallthrough
		case OP_CRPOSQUERY:
			*(*uint32)(unsafe.Pointer(list + 1*4)) = uint32(DTRUE)
			end++
			break

		case OP_CRPLUS:
			fallthrough
		case OP_CRMINPLUS:
			fallthrough
		case OP_CRPOSPLUS:
			end++
			break

		case OP_CRRANGE:
			fallthrough
		case OP_CRMINRANGE:
			fallthrough
		case OP_CRPOSRANGE:
			*(*uint32)(unsafe.Pointer(list + 1*4)) = uint32(libc.Bool32(uint32(int32(*(*uint8)(unsafe.Pointer(end + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(end + 2)))) == uint32(0)))
			end += uintptr(1 + 2*DIMM2_SIZE)
			break
		}
		*(*uint32)(unsafe.Pointer(list + 2*4)) = uint32((int64(end) - int64(code)) / 1)
		return end
	}

	return uintptr(0) // Opcode not accepted
}

// ************************************************
//
//    Scan further character sets for match       *
//

// Checks whether the base and the current opcode have a common character, in
// which case the base cannot be possessified.
//
// Arguments:
//   code        points to the byte code
//   utf         TRUE in UTF mode
//   ucp         TRUE in UCP mode
//   cb          compile data block
//   base_list   the data list of the base opcode
//   base_end    the end of the base opcode
//   rec_limit   points to recursion depth counter
//
// Returns:      TRUE if the auto-possessification is possible

func compare_opcodes(tls *libc.TLS, code uintptr, utf int32, ucp int32, cb uintptr, base_list uintptr, base_end uintptr, rec_limit uintptr) int32 { /* pcre2_auto_possess.c:536:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var c uint8
	// var list [8]uint32 at bp, 32

	var chr_ptr uintptr
	var ochr_ptr uintptr
	var list_ptr uintptr
	var next_code uintptr
	var xclass_flags uintptr
	var class_bitset uintptr
	var set1 uintptr
	var set2 uintptr
	var set_end uintptr
	var chr uint32
	var accepted int32
	var invert_bits int32
	var entered_a_group int32 = DFALSE

	if libc.PreDecInt32(&*(*int32)(unsafe.Pointer(rec_limit)), 1) <= 0 {
		return DFALSE
	} // Recursion has gone too deep

	// Note: the base_list[1] contains whether the current opcode has a greedy
	// (represented by a non-zero value) quantifier. This is a different from
	// other character type lists, which store here that the character iterator
	// matches to an empty string (also represented by a non-zero value).

	for {
		// All operations move the code pointer forward.
		//   Therefore infinite recursions are not possible.

		c = *(*uint8)(unsafe.Pointer(code))

		// Skip over callouts

		if int32(c) == OP_CALLOUT {
			code += uintptr(X_pcre2_OP_lengths_8[c])
			continue
		}

		if int32(c) == OP_CALLOUT_STR {
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 6)))))
			continue
		}

		// At the end of a branch, skip to the end of the group.

		if int32(c) == OP_ALT {
			for __ccgo := true; __ccgo; __ccgo = int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT {
				code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
			}
			c = *(*uint8)(unsafe.Pointer(code))
		}

		// Inspect the next opcode.

		switch int32(c) {
		// We can always possessify a greedy iterator at the end of the pattern,
		//     which is reached after skipping over the final OP_KET. A non-greedy
		//     iterator must never be possessified.

		case OP_END:
			return libc.Bool32(*(*uint32)(unsafe.Pointer(base_list + 1*4)) != uint32(0))

		// When an iterator is at the end of certain kinds of group we can inspect
		//     what follows the group by skipping over the closing ket. Note that this
		//     does not apply to OP_KETRMAX or OP_KETRMIN because what follows any given
		//     iteration is variable (could be another iteration or could be the next
		//     item). As these two opcodes are not listed in the next switch, they will
		//     end up as the next code to inspect, and return FALSE by virtue of being
		//     unsupported.

		case OP_KET:
			fallthrough
		case OP_KETRPOS:
			// The non-greedy case cannot be converted to a possessive form.

			if *(*uint32)(unsafe.Pointer(base_list + 1*4)) == uint32(0) {
				return DFALSE
			}

			// If the bracket is capturing it might be referenced by an OP_RECURSE
			//     so its last iterator can never be possessified if the pattern contains
			//     recursions. (This could be improved by keeping a list of group numbers that
			//     are called by recursion.)

			switch int32(*(*uint8)(unsafe.Pointer(code - uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))))) {
			case OP_CBRA:
				fallthrough
			case OP_SCBRA:
				fallthrough
			case OP_CBRAPOS:
				fallthrough
			case OP_SCBRAPOS:
				if (*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_recurse != 0 {
					return DFALSE
				}
				break

			// A script run might have to backtrack if the iterated item can match
			//       characters from more than one script. So give up unless repeating an
			//       explicit character.

			case OP_SCRIPT_RUN:
				if *(*uint32)(unsafe.Pointer(base_list)) != OP_CHAR && *(*uint32)(unsafe.Pointer(base_list)) != OP_CHARI {
					return DFALSE
				}
				break

			// Atomic sub-patterns and assertions can always auto-possessify their
			//       last iterator. However, if the group was entered as a result of checking
			//       a previous iterator, this is not possible.

			case OP_ASSERT:
				fallthrough
			case OP_ASSERT_NOT:
				fallthrough
			case OP_ASSERTBACK:
				fallthrough
			case OP_ASSERTBACK_NOT:
				fallthrough
			case OP_ONCE:
				return libc.BoolInt32(!(entered_a_group != 0))

			// Non-atomic assertions - don't possessify last iterator. This needs
			//       more thought.

			case OP_ASSERT_NA:
				fallthrough
			case OP_ASSERTBACK_NA:
				return DFALSE
			}

			// Skip over the bracket and inspect what comes next.

			code += uintptr(X_pcre2_OP_lengths_8[c])
			continue

		// Handle cases where the next item is a group.

		case OP_ONCE:
			fallthrough
		case OP_BRA:
			fallthrough
		case OP_CBRA:
			next_code = code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))
			code += uintptr(X_pcre2_OP_lengths_8[c])

			// Check each branch. We have to recurse a level for all but the last
			//     branch.

			for int32(*(*uint8)(unsafe.Pointer(next_code))) == OP_ALT {
				if !(compare_opcodes(tls, code, utf, ucp, cb, base_list, base_end, rec_limit) != 0) {
					return DFALSE
				}
				code = next_code + uintptr(1) + uintptr(DLINK_SIZE)
				next_code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(next_code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(next_code + 2)))))
			}

			entered_a_group = DTRUE
			continue

		case OP_BRAZERO:
			fallthrough
		case OP_BRAMINZERO:

			next_code = code + uintptr(1)
			if int32(*(*uint8)(unsafe.Pointer(next_code))) != OP_BRA && int32(*(*uint8)(unsafe.Pointer(next_code))) != OP_CBRA && int32(*(*uint8)(unsafe.Pointer(next_code))) != OP_ONCE {
				return DFALSE
			}

			for __ccgo1 := true; __ccgo1; __ccgo1 = int32(*(*uint8)(unsafe.Pointer(next_code))) == OP_ALT {
				next_code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(next_code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(next_code + 2)))))
			}

			// The bracket content will be checked by the OP_BRA/OP_CBRA case above.

			next_code += uintptr(1 + DLINK_SIZE)
			if !(compare_opcodes(tls, next_code, utf, ucp, cb, base_list, base_end,
				rec_limit) != 0) {
				return DFALSE
			}

			code += uintptr(X_pcre2_OP_lengths_8[c])
			continue

		// The next opcode does not need special handling; fall through and use it
		//     to see if the base can be possessified.

		default:
			break
		}

		// We now have the next appropriate opcode to compare with the base. Check
		//   for a supported opcode, and load its properties.

		code = get_chr_property_list(tls, code, utf, ucp, (*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc, bp)
		if code == uintptr(0) {
			return DFALSE
		} // Unsupported

		// If either opcode is a small character list, set pointers for comparing
		//   characters from that list with another list, or with a property.

		if *(*uint32)(unsafe.Pointer(base_list)) == OP_CHAR {
			chr_ptr = base_list + uintptr(2)*4
			list_ptr = bp /* &list[0] */
		} else if *(*uint32)(unsafe.Pointer(bp)) == OP_CHAR {
			chr_ptr = bp + uintptr(2)*4
			list_ptr = base_list
		} else if *(*uint32)(unsafe.Pointer(base_list)) == OP_CLASS || *(*uint32)(unsafe.Pointer(bp)) == OP_CLASS ||

			!(utf != 0) && (*(*uint32)(unsafe.Pointer(base_list)) == OP_NCLASS || *(*uint32)(unsafe.Pointer(bp)) == OP_NCLASS) {
			if *(*uint32)(unsafe.Pointer(base_list)) == OP_CLASS || !(utf != 0) && *(*uint32)(unsafe.Pointer(base_list)) == OP_NCLASS {
				set1 = base_end - uintptr(*(*uint32)(unsafe.Pointer(base_list + 2*4)))
				list_ptr = bp /* &list[0] */
			} else {
				set1 = code - uintptr(*(*uint32)(unsafe.Pointer(bp + 2*4)))
				list_ptr = base_list
			}

			invert_bits = DFALSE
			switch *(*uint32)(unsafe.Pointer(list_ptr)) {
			case OP_CLASS:
				fallthrough
			case OP_NCLASS:
				set2 = func() uintptr {
					if list_ptr == bp {
						return code
					}
					return base_end
				}() - uintptr(*(*uint32)(unsafe.Pointer(list_ptr + 2*4)))
				break
				fallthrough

			case OP_XCLASS:
				xclass_flags = func() uintptr {
					if list_ptr == bp {
						return code
					}
					return base_end
				}() - uintptr(*(*uint32)(unsafe.Pointer(list_ptr + 2*4))) + uintptr(DLINK_SIZE)
				if int32(*(*uint8)(unsafe.Pointer(xclass_flags)))&DXCL_HASPROP != 0 {
					return DFALSE
				}
				if int32(*(*uint8)(unsafe.Pointer(xclass_flags)))&DXCL_MAP == 0 {
					// No bits are set for characters < 256.
					if *(*uint32)(unsafe.Pointer(bp + 1*4)) == uint32(0) {
						return libc.Bool32(int32(*(*uint8)(unsafe.Pointer(xclass_flags)))&DXCL_NOT == 0)
					}
					// Might be an empty repeat.
					continue
				}
				set2 = xclass_flags + uintptr(1)
				break
				fallthrough

			case OP_NOT_DIGIT:
				invert_bits = DTRUE
				fallthrough
			// Fall through
			case OP_DIGIT:
				set2 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fcbits + uintptr(Dcbit_digit)
				break
				fallthrough

			case OP_NOT_WHITESPACE:
				invert_bits = DTRUE
				fallthrough
			// Fall through
			case OP_WHITESPACE:
				set2 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fcbits + uintptr(Dcbit_space)
				break
				fallthrough

			case OP_NOT_WORDCHAR:
				invert_bits = DTRUE
				fallthrough
			// Fall through
			case OP_WORDCHAR:
				set2 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fcbits + uintptr(Dcbit_word)
				break
				fallthrough

			default:
				return DFALSE
			}

			// Because the bit sets are unaligned bytes, we need to perform byte
			//     comparison here.

			set_end = set1 + uintptr(32)
			if invert_bits != 0 {
				for __ccgo2 := true; __ccgo2; __ccgo2 = set1 < set_end {
					if int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&set1, 1)))) & ^int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&set2, 1)))) != 0 {
						return DFALSE
					}
				}
			} else {
				for __ccgo3 := true; __ccgo3; __ccgo3 = set1 < set_end {
					if int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&set1, 1))))&int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&set2, 1)))) != 0 {
						return DFALSE
					}
				}
			}

			if *(*uint32)(unsafe.Pointer(bp + 1*4)) == uint32(0) {
				return DTRUE
			}
			// Might be an empty repeat.
			continue
		} else {
			var leftop uint32
			var rightop uint32

			leftop = *(*uint32)(unsafe.Pointer(base_list))
			rightop = *(*uint32)(unsafe.Pointer(bp))

			accepted = DFALSE // Always set in non-unicode case.
			if leftop == OP_PROP || leftop == OP_NOTPROP {
				if rightop == OP_EOD {
					accepted = DTRUE
				} else if rightop == OP_PROP || rightop == OP_NOTPROP {
					var n int32
					var p uintptr
					var same int32 = libc.Bool32(leftop == rightop)
					var lisprop int32 = libc.Bool32(leftop == OP_PROP)
					var risprop int32 = libc.Bool32(rightop == OP_PROP)
					var bothprop int32 = libc.Bool32(lisprop != 0 && risprop != 0)

					// There's a table that specifies how each combination is to be
					//         processed:
					//           0   Always return FALSE (never auto-possessify)
					//           1   Character groups are distinct (possessify if both are OP_PROP)
					//           2   Check character categories in the same group (general or particular)
					//           3   Return TRUE if the two opcodes are not the same
					//           ... see comments below
					//

					n = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&propposstab)) + uintptr(*(*uint32)(unsafe.Pointer(base_list + 2*4)))*14 + uintptr(*(*uint32)(unsafe.Pointer(bp + 2*4))))))
					switch n {
					case 0:
						break
						fallthrough
					case 1:
						accepted = bothprop
						break
						fallthrough
					case 2:
						accepted = libc.Bool32(libc.Bool32(*(*uint32)(unsafe.Pointer(base_list + 3*4)) == *(*uint32)(unsafe.Pointer(bp + 3*4))) != same)
						break
						fallthrough
					case 3:
						accepted = libc.BoolInt32(!(same != 0))
						break
						fallthrough

					case 4: // Left general category, right particular category
						accepted = libc.Bool32(risprop != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*uint32)(unsafe.Pointer(base_list + 3*4)))*30 + uintptr(*(*uint32)(unsafe.Pointer(bp + 3*4)))))) == same)
						break
						fallthrough

					case 5: // Right general category, left particular category
						accepted = libc.Bool32(lisprop != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*uint32)(unsafe.Pointer(bp + 3*4)))*30 + uintptr(*(*uint32)(unsafe.Pointer(base_list + 3*4)))))) == same)
						break
						fallthrough

					// This code is logically tricky. Think hard before fiddling with it.
					//           The posspropstab table has four entries per row. Each row relates to
					//           one of PCRE's special properties such as ALNUM or SPACE or WORD.
					//           Only WORD actually needs all four entries, but using repeats for the
					//           others means they can all use the same code below.
					//
					//           The first two entries in each row are Unicode general categories, and
					//           apply always, because all the characters they include are part of the
					//           PCRE character set. The third and fourth entries are a general and a
					//           particular category, respectively, that include one or more relevant
					//           characters. One or the other is used, depending on whether the check
					//           is for a general or a particular category. However, in both cases the
					//           category contains more characters than the specials that are defined
					//           for the property being tested against. Therefore, it cannot be used
					//           in a NOTPROP case.
					//
					//           Example: the row for WORD contains ucp_L, ucp_N, ucp_P, ucp_Po.
					//           Underscore is covered by ucp_P or ucp_Po.

					case 6:
						fallthrough // Left alphanum vs right general category
					case 7:
						fallthrough // Left space vs right general category
					case 8: // Left word vs right general category
						p = uintptr(unsafe.Pointer(&posspropstab)) + uintptr(n-6)*4
						accepted = libc.Bool32(risprop != 0 && lisprop == libc.Bool32(*(*uint32)(unsafe.Pointer(bp + 3*4)) != uint32(*(*uint8)(unsafe.Pointer(p))) && *(*uint32)(unsafe.Pointer(bp + 3*4)) != uint32(*(*uint8)(unsafe.Pointer(p + 1))) && (*(*uint32)(unsafe.Pointer(bp + 3*4)) != uint32(*(*uint8)(unsafe.Pointer(p + 2))) || !(lisprop != 0))))
						break
						fallthrough

					case 9:
						fallthrough // Right alphanum vs left general category
					case 10:
						fallthrough // Right space vs left general category
					case 11: // Right word vs left general category
						p = uintptr(unsafe.Pointer(&posspropstab)) + uintptr(n-9)*4
						accepted = libc.Bool32(lisprop != 0 && risprop == libc.Bool32(*(*uint32)(unsafe.Pointer(base_list + 3*4)) != uint32(*(*uint8)(unsafe.Pointer(p))) && *(*uint32)(unsafe.Pointer(base_list + 3*4)) != uint32(*(*uint8)(unsafe.Pointer(p + 1))) && (*(*uint32)(unsafe.Pointer(base_list + 3*4)) != uint32(*(*uint8)(unsafe.Pointer(p + 2))) || !(risprop != 0))))
						break
						fallthrough

					case 12:
						fallthrough // Left alphanum vs right particular category
					case 13:
						fallthrough // Left space vs right particular category
					case 14: // Left word vs right particular category
						p = uintptr(unsafe.Pointer(&posspropstab)) + uintptr(n-12)*4
						accepted = libc.Bool32(risprop != 0 && lisprop == libc.Bool32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*uint8)(unsafe.Pointer(p)))*30 + uintptr(*(*uint32)(unsafe.Pointer(bp + 3*4))))) != 0 && *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*uint8)(unsafe.Pointer(p + 1)))*30 + uintptr(*(*uint32)(unsafe.Pointer(bp + 3*4))))) != 0 && (*(*uint32)(unsafe.Pointer(bp + 3*4)) != uint32(*(*uint8)(unsafe.Pointer(p + 3))) || !(lisprop != 0))))
						break
						fallthrough

					case 15:
						fallthrough // Right alphanum vs left particular category
					case 16:
						fallthrough // Right space vs left particular category
					case 17: // Right word vs left particular category
						p = uintptr(unsafe.Pointer(&posspropstab)) + uintptr(n-15)*4
						accepted = libc.Bool32(lisprop != 0 && risprop == libc.Bool32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*uint8)(unsafe.Pointer(p)))*30 + uintptr(*(*uint32)(unsafe.Pointer(base_list + 3*4))))) != 0 && *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&catposstab)) + uintptr(*(*uint8)(unsafe.Pointer(p + 1)))*30 + uintptr(*(*uint32)(unsafe.Pointer(base_list + 3*4))))) != 0 && (*(*uint32)(unsafe.Pointer(base_list + 3*4)) != uint32(*(*uint8)(unsafe.Pointer(p + 3))) || !(risprop != 0))))
						break
					}
				}
			} else {

				accepted = libc.Bool32(leftop >= OP_NOT_DIGIT && leftop <= OP_EXTUNI && rightop >= OP_NOT_DIGIT && rightop <= OP_DOLLM && *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&autoposstab)) + uintptr(leftop-OP_NOT_DIGIT)*21 + uintptr(rightop-OP_NOT_DIGIT))) != 0)
			}

			if !(accepted != 0) {
				return DFALSE
			}

			if *(*uint32)(unsafe.Pointer(bp + 1*4)) == uint32(0) {
				return DTRUE
			}
			// Might be an empty repeat.
			continue
		}

		// Control reaches here only if one of the items is a small character list.
		//   All characters are checked against the other side.

		for __ccgo4 := true; __ccgo4; __ccgo4 = *(*uint32)(unsafe.Pointer(chr_ptr)) != DNOTACHAR {
			chr = *(*uint32)(unsafe.Pointer(chr_ptr))

			switch *(*uint32)(unsafe.Pointer(list_ptr)) {
			case OP_CHAR:
				ochr_ptr = list_ptr + uintptr(2)*4
				for __ccgo5 := true; __ccgo5; __ccgo5 = *(*uint32)(unsafe.Pointer(ochr_ptr)) != DNOTACHAR {
					if chr == *(*uint32)(unsafe.Pointer(ochr_ptr)) {
						return DFALSE
					}
					ochr_ptr += 4
				}
				break

			case OP_NOT:
				ochr_ptr = list_ptr + uintptr(2)*4
				for __ccgo6 := true; __ccgo6; __ccgo6 = *(*uint32)(unsafe.Pointer(ochr_ptr)) != DNOTACHAR {
					if chr == *(*uint32)(unsafe.Pointer(ochr_ptr)) {
						break
					}
					ochr_ptr += 4
				}
				if *(*uint32)(unsafe.Pointer(ochr_ptr)) == DNOTACHAR {
					return DFALSE
				} // Not found
				break

			// Note that OP_DIGIT etc. are generated only when PCRE2_UCP is *not*
			//       set. When it is set, \d etc. are converted into OP_(NOT_)PROP codes.

			case OP_DIGIT:
				if chr < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_digit != 0 {
					return DFALSE
				}
				break

			case OP_NOT_DIGIT:
				if chr > uint32(255) || int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_digit == 0 {
					return DFALSE
				}
				break

			case OP_WHITESPACE:
				if chr < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_space != 0 {
					return DFALSE
				}
				break

			case OP_NOT_WHITESPACE:
				if chr > uint32(255) || int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_space == 0 {
					return DFALSE
				}
				break

			case OP_WORDCHAR:
				if chr < uint32(255) && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_word != 0 {
					return DFALSE
				}
				break

			case OP_NOT_WORDCHAR:
				if chr > uint32(255) || int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(chr))))&Dctype_word == 0 {
					return DFALSE
				}
				break

			case OP_HSPACE:
				switch chr {
				case uint32('\011'):
					fallthrough
				case uint32('\040'):
					fallthrough
				case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
					fallthrough
				case uint32(0x1680):
					fallthrough /* OGHAM SPACE MARK */
				case uint32(0x180e):
					fallthrough /* MONGOLIAN VOWEL SEPARATOR */
				case uint32(0x2000):
					fallthrough /* EN QUAD */
				case uint32(0x2001):
					fallthrough /* EM QUAD */
				case uint32(0x2002):
					fallthrough /* EN SPACE */
				case uint32(0x2003):
					fallthrough /* EM SPACE */
				case uint32(0x2004):
					fallthrough /* THREE-PER-EM SPACE */
				case uint32(0x2005):
					fallthrough /* FOUR-PER-EM SPACE */
				case uint32(0x2006):
					fallthrough /* SIX-PER-EM SPACE */
				case uint32(0x2007):
					fallthrough /* FIGURE SPACE */
				case uint32(0x2008):
					fallthrough /* PUNCTUATION SPACE */
				case uint32(0x2009):
					fallthrough /* THIN SPACE */
				case uint32(0x200A):
					fallthrough /* HAIR SPACE */
				case uint32(0x202f):
					fallthrough /* NARROW NO-BREAK SPACE */
				case uint32(0x205f):
					fallthrough /* MEDIUM MATHEMATICAL SPACE */
				case uint32(0x3000):
					return DFALSE
				default:
					break
				}
				break

			case OP_NOT_HSPACE:
				switch chr {
				case uint32('\011'):
					fallthrough
				case uint32('\040'):
					fallthrough
				case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
					fallthrough
				case uint32(0x1680):
					fallthrough /* OGHAM SPACE MARK */
				case uint32(0x180e):
					fallthrough /* MONGOLIAN VOWEL SEPARATOR */
				case uint32(0x2000):
					fallthrough /* EN QUAD */
				case uint32(0x2001):
					fallthrough /* EM QUAD */
				case uint32(0x2002):
					fallthrough /* EN SPACE */
				case uint32(0x2003):
					fallthrough /* EM SPACE */
				case uint32(0x2004):
					fallthrough /* THREE-PER-EM SPACE */
				case uint32(0x2005):
					fallthrough /* FOUR-PER-EM SPACE */
				case uint32(0x2006):
					fallthrough /* SIX-PER-EM SPACE */
				case uint32(0x2007):
					fallthrough /* FIGURE SPACE */
				case uint32(0x2008):
					fallthrough /* PUNCTUATION SPACE */
				case uint32(0x2009):
					fallthrough /* THIN SPACE */
				case uint32(0x200A):
					fallthrough /* HAIR SPACE */
				case uint32(0x202f):
					fallthrough /* NARROW NO-BREAK SPACE */
				case uint32(0x205f):
					fallthrough /* MEDIUM MATHEMATICAL SPACE */
				case uint32(0x3000):
					break
				default:
					return DFALSE
				}
				break

			case OP_ANYNL:
				fallthrough
			case OP_VSPACE:
				switch chr {
				case uint32('\012'):
					fallthrough
				case uint32('\013'):
					fallthrough
				case uint32('\014'):
					fallthrough
				case uint32('\015'):
					fallthrough
				case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
					fallthrough
				case uint32(0x2028):
					fallthrough /* LINE SEPARATOR */
				case uint32(0x2029):
					return DFALSE
				default:
					break
				}
				break

			case OP_NOT_VSPACE:
				switch chr {
				case uint32('\012'):
					fallthrough
				case uint32('\013'):
					fallthrough
				case uint32('\014'):
					fallthrough
				case uint32('\015'):
					fallthrough
				case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
					fallthrough
				case uint32(0x2028):
					fallthrough /* LINE SEPARATOR */
				case uint32(0x2029):
					break
				default:
					return DFALSE
				}
				break

			case OP_DOLL:
				fallthrough
			case OP_EODN:
				switch chr {
				case uint32('\015'):
					fallthrough
				case uint32('\012'):
					fallthrough
				case uint32('\013'):
					fallthrough
				case uint32('\014'):
					fallthrough
				case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
					fallthrough
				case uint32(0x2028):
					fallthrough
				case uint32(0x2029):
					return DFALSE
				}
				break

			case OP_EOD: // Can always possessify before \z
				break

			case OP_PROP:
				fallthrough
			case OP_NOTPROP:
				if !(check_char_prop(tls, chr, *(*uint32)(unsafe.Pointer(list_ptr + 2*4)), *(*uint32)(unsafe.Pointer(list_ptr + 3*4)),
					libc.Bool32(*(*uint32)(unsafe.Pointer(list_ptr)) == OP_NOTPROP)) != 0) {
					return DFALSE
				}
				break

			case OP_NCLASS:
				if chr > uint32(255) {
					return DFALSE
				}
				fallthrough
			// Fall through

			case OP_CLASS:
				if chr > uint32(255) {
					break
				}
				class_bitset = func() uintptr {
					if list_ptr == bp {
						return code
					}
					return base_end
				}() - uintptr(*(*uint32)(unsafe.Pointer(list_ptr + 2*4)))
				if uint32(*(*uint8)(unsafe.Pointer(class_bitset + uintptr(chr>>3))))&(uint32(1)<<(chr&uint32(7))) != uint32(0) {
					return DFALSE
				}
				break

			case OP_XCLASS:
				if X_pcre2_xclass_8(tls, chr, func() uintptr {
					if list_ptr == bp {
						return code
					}
					return base_end
				}()-uintptr(*(*uint32)(unsafe.Pointer(list_ptr + 2*4)))+uintptr(DLINK_SIZE), utf) != 0 {
					return DFALSE
				}
				break

			default:
				return DFALSE
			}

			chr_ptr += 4
		}

		// At least one character must be matched from this opcode.

		if *(*uint32)(unsafe.Pointer(bp + 1*4)) == uint32(0) {
			return DTRUE
		}
	}
	return int32(0)

	// Control never reaches here. There used to be a fail-save return FALSE; here,
	// but some compilers complain about an unreachable statement.
}

// ************************************************
//
//    Scan compiled regex for auto-possession     *
//

// Replaces single character iterations with their possessive alternatives
// if appropriate. This function modifies the compiled opcode! Hitting a
// non-existent opcode may indicate a bug in PCRE2, but it can also be caused if a
// bad UTF string was compiled with PCRE2_NO_UTF_CHECK. The rec_limit catches
// overly complicated or large patterns. In these cases, the check just stops,
// leaving the remainder of the pattern unpossessified.
//
// Arguments:
//   code        points to start of the byte code
//   cb          compile data block
//
// Returns:      0 for success
//               -1 if a non-existant opcode is encountered

func X_pcre2_auto_possessify_8(tls *libc.TLS, code uintptr, cb uintptr) int32 { /* pcre2_auto_possess.c:1132:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var c uint8
	var end uintptr
	var repeat_opcode uintptr
	// var list [8]uint32 at bp, 32

	*(*int32)(unsafe.Pointer(bp + 32 /* rec_limit */)) = 1000 // Was 10,000 but clang+ASAN uses a lot of stack.
	var utf int32 = libc.Bool32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_UTF != uint32(0))
	var ucp int32 = libc.Bool32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_UCP != uint32(0))

	for {
		c = *(*uint8)(unsafe.Pointer(code))

		if int32(c) >= OP_TABLE_LENGTH {
			return -1
		} // Something gone wrong

		if int32(c) >= OP_STAR && int32(c) <= OP_TYPEPOSUPTO {
			c = uint8(int32(c) - (int32(get_repeat_base(tls, c)) - OP_STAR))
			if int32(c) <= OP_MINUPTO {
				end = get_chr_property_list(tls, code, utf, ucp, (*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc, bp)
			} else {
				end = uintptr(0)
			}
			*(*uint32)(unsafe.Pointer(bp + 1*4)) = uint32(libc.Bool32(int32(c) == OP_STAR || int32(c) == OP_PLUS || int32(c) == OP_QUERY || int32(c) == OP_UPTO))

			if end != uintptr(0) && compare_opcodes(tls, end, utf, ucp, cb, bp, end,
				bp+32) != 0 {
				switch int32(c) {
				case OP_STAR:
					*(*uint8)(unsafe.Pointer(code)) += uint8(OP_POSSTAR - OP_STAR)
					break
					fallthrough

				case OP_MINSTAR:
					*(*uint8)(unsafe.Pointer(code)) += uint8(OP_POSSTAR - OP_MINSTAR)
					break
					fallthrough

				case OP_PLUS:
					*(*uint8)(unsafe.Pointer(code)) += uint8(OP_POSPLUS - OP_PLUS)
					break
					fallthrough

				case OP_MINPLUS:
					*(*uint8)(unsafe.Pointer(code)) += uint8(OP_POSPLUS - OP_MINPLUS)
					break
					fallthrough

				case OP_QUERY:
					*(*uint8)(unsafe.Pointer(code)) += uint8(OP_POSQUERY - OP_QUERY)
					break
					fallthrough

				case OP_MINQUERY:
					*(*uint8)(unsafe.Pointer(code)) += uint8(OP_POSQUERY - OP_MINQUERY)
					break
					fallthrough

				case OP_UPTO:
					*(*uint8)(unsafe.Pointer(code)) += uint8(OP_POSUPTO - OP_UPTO)
					break
					fallthrough

				case OP_MINUPTO:
					*(*uint8)(unsafe.Pointer(code)) += uint8(OP_POSUPTO - OP_MINUPTO)
					break
				}
			}
			c = *(*uint8)(unsafe.Pointer(code))
		} else if int32(c) == OP_CLASS || int32(c) == OP_NCLASS || int32(c) == OP_XCLASS {
			if int32(c) == OP_XCLASS {
				repeat_opcode = code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))
			} else {
				repeat_opcode = code + uintptr(1) + uintptr(uint64(32)/uint64(unsafe.Sizeof(uint8(0))))
			}

			c = *(*uint8)(unsafe.Pointer(repeat_opcode))
			if int32(c) >= OP_CRSTAR && int32(c) <= OP_CRMINRANGE {
				// The return from get_chr_property_list() will never be NULL when
				// code (aka c) is one of the three class opcodes. However, gcc with
				//       -fanalyzer notes that a NULL return is possible, and grumbles. Hence we
				//       put in a check.

				end = get_chr_property_list(tls, code, utf, ucp, (*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc, bp)
				*(*uint32)(unsafe.Pointer(bp + 1*4)) = uint32(libc.Bool32(int32(c)&1 == 0))

				if end != uintptr(0) && compare_opcodes(tls, end, utf, ucp, cb, bp, end, bp+32) != 0 {
					switch int32(c) {
					case OP_CRSTAR:
						fallthrough
					case OP_CRMINSTAR:
						*(*uint8)(unsafe.Pointer(repeat_opcode)) = OP_CRPOSSTAR
						break
						fallthrough

					case OP_CRPLUS:
						fallthrough
					case OP_CRMINPLUS:
						*(*uint8)(unsafe.Pointer(repeat_opcode)) = OP_CRPOSPLUS
						break
						fallthrough

					case OP_CRQUERY:
						fallthrough
					case OP_CRMINQUERY:
						*(*uint8)(unsafe.Pointer(repeat_opcode)) = OP_CRPOSQUERY
						break
						fallthrough

					case OP_CRRANGE:
						fallthrough
					case OP_CRMINRANGE:
						*(*uint8)(unsafe.Pointer(repeat_opcode)) = OP_CRPOSRANGE
						break
					}
				}
			}
			c = *(*uint8)(unsafe.Pointer(code))
		}

		switch int32(c) {
		case OP_END:
			return 0

		case OP_TYPESTAR:
			fallthrough
		case OP_TYPEMINSTAR:
			fallthrough
		case OP_TYPEPLUS:
			fallthrough
		case OP_TYPEMINPLUS:
			fallthrough
		case OP_TYPEQUERY:
			fallthrough
		case OP_TYPEMINQUERY:
			fallthrough
		case OP_TYPEPOSSTAR:
			fallthrough
		case OP_TYPEPOSPLUS:
			fallthrough
		case OP_TYPEPOSQUERY:
			if int32(*(*uint8)(unsafe.Pointer(code + 1))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(code + 1))) == OP_NOTPROP {
				code += uintptr(2)
			}
			break

		case OP_TYPEUPTO:
			fallthrough
		case OP_TYPEMINUPTO:
			fallthrough
		case OP_TYPEEXACT:
			fallthrough
		case OP_TYPEPOSUPTO:
			if int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_NOTPROP {
				code += uintptr(2)
			}
			break

		case OP_CALLOUT_STR:
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 6)))))
			break

		case OP_XCLASS:
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
			break

		case OP_MARK:
			fallthrough
		case OP_COMMIT_ARG:
			fallthrough
		case OP_PRUNE_ARG:
			fallthrough
		case OP_SKIP_ARG:
			fallthrough
		case OP_THEN_ARG:
			code += uintptr(*(*uint8)(unsafe.Pointer(code + 1)))
			break
		}

		// Add in the fixed length from the table

		code += uintptr(X_pcre2_OP_lengths_8[c])

		// In UTF-8 and UTF-16 modes, opcodes that are followed by a character may be
		//   followed by a multi-byte character. The length in the table is a minimum, so
		//   we have to arrange to skip the extra code units.

		if utf != 0 {
			switch int32(c) {
			case OP_CHAR:
				fallthrough
			case OP_CHARI:
				fallthrough
			case OP_NOT:
				fallthrough
			case OP_NOTI:
				fallthrough
			case OP_STAR:
				fallthrough
			case OP_MINSTAR:
				fallthrough
			case OP_PLUS:
				fallthrough
			case OP_MINPLUS:
				fallthrough
			case OP_QUERY:
				fallthrough
			case OP_MINQUERY:
				fallthrough
			case OP_UPTO:
				fallthrough
			case OP_MINUPTO:
				fallthrough
			case OP_EXACT:
				fallthrough
			case OP_POSSTAR:
				fallthrough
			case OP_POSPLUS:
				fallthrough
			case OP_POSQUERY:
				fallthrough
			case OP_POSUPTO:
				fallthrough
			case OP_STARI:
				fallthrough
			case OP_MINSTARI:
				fallthrough
			case OP_PLUSI:
				fallthrough
			case OP_MINPLUSI:
				fallthrough
			case OP_QUERYI:
				fallthrough
			case OP_MINQUERYI:
				fallthrough
			case OP_UPTOI:
				fallthrough
			case OP_MINUPTOI:
				fallthrough
			case OP_EXACTI:
				fallthrough
			case OP_POSSTARI:
				fallthrough
			case OP_POSPLUSI:
				fallthrough
			case OP_POSQUERYI:
				fallthrough
			case OP_POSUPTOI:
				fallthrough
			case OP_NOTSTAR:
				fallthrough
			case OP_NOTMINSTAR:
				fallthrough
			case OP_NOTPLUS:
				fallthrough
			case OP_NOTMINPLUS:
				fallthrough
			case OP_NOTQUERY:
				fallthrough
			case OP_NOTMINQUERY:
				fallthrough
			case OP_NOTUPTO:
				fallthrough
			case OP_NOTMINUPTO:
				fallthrough
			case OP_NOTEXACT:
				fallthrough
			case OP_NOTPOSSTAR:
				fallthrough
			case OP_NOTPOSPLUS:
				fallthrough
			case OP_NOTPOSQUERY:
				fallthrough
			case OP_NOTPOSUPTO:
				fallthrough
			case OP_NOTSTARI:
				fallthrough
			case OP_NOTMINSTARI:
				fallthrough
			case OP_NOTPLUSI:
				fallthrough
			case OP_NOTMINPLUSI:
				fallthrough
			case OP_NOTQUERYI:
				fallthrough
			case OP_NOTMINQUERYI:
				fallthrough
			case OP_NOTUPTOI:
				fallthrough
			case OP_NOTMINUPTOI:
				fallthrough
			case OP_NOTEXACTI:
				fallthrough
			case OP_NOTPOSSTARI:
				fallthrough
			case OP_NOTPOSPLUSI:
				fallthrough
			case OP_NOTPOSQUERYI:
				fallthrough
			case OP_NOTPOSUPTOI:
				if int32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1)))) >= 0xc0 {
					code += uintptr(X_pcre2_utf8_table4[uint32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))&0x3f])
				}
				break
			}
		}
	}
	return int32(0)
}

// End of pcre2_auto_possess.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

var X_pcre2_default_tables_8 = [1088]uint8{

	// This table is a lower casing table.

	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7),
	uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15),
	uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23),
	uint8(24), uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31),
	uint8(32), uint8(33), uint8(34), uint8(35), uint8(36), uint8(37), uint8(38), uint8(39),
	uint8(40), uint8(41), uint8(42), uint8(43), uint8(44), uint8(45), uint8(46), uint8(47),
	uint8(48), uint8(49), uint8(50), uint8(51), uint8(52), uint8(53), uint8(54), uint8(55),
	uint8(56), uint8(57), uint8(58), uint8(59), uint8(60), uint8(61), uint8(62), uint8(63),
	uint8(64), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103),
	uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111),
	uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119),
	uint8(120), uint8(121), uint8(122), uint8(91), uint8(92), uint8(93), uint8(94), uint8(95),
	uint8(96), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103),
	uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111),
	uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119),
	uint8(120), uint8(121), uint8(122), uint8(123), uint8(124), uint8(125), uint8(126), uint8(127),
	uint8(128), uint8(129), uint8(130), uint8(131), uint8(132), uint8(133), uint8(134), uint8(135),
	uint8(136), uint8(137), uint8(138), uint8(139), uint8(140), uint8(141), uint8(142), uint8(143),
	uint8(144), uint8(145), uint8(146), uint8(147), uint8(148), uint8(149), uint8(150), uint8(151),
	uint8(152), uint8(153), uint8(154), uint8(155), uint8(156), uint8(157), uint8(158), uint8(159),
	uint8(160), uint8(161), uint8(162), uint8(163), uint8(164), uint8(165), uint8(166), uint8(167),
	uint8(168), uint8(169), uint8(170), uint8(171), uint8(172), uint8(173), uint8(174), uint8(175),
	uint8(176), uint8(177), uint8(178), uint8(179), uint8(180), uint8(181), uint8(182), uint8(183),
	uint8(184), uint8(185), uint8(186), uint8(187), uint8(188), uint8(189), uint8(190), uint8(191),
	uint8(192), uint8(193), uint8(194), uint8(195), uint8(196), uint8(197), uint8(198), uint8(199),
	uint8(200), uint8(201), uint8(202), uint8(203), uint8(204), uint8(205), uint8(206), uint8(207),
	uint8(208), uint8(209), uint8(210), uint8(211), uint8(212), uint8(213), uint8(214), uint8(215),
	uint8(216), uint8(217), uint8(218), uint8(219), uint8(220), uint8(221), uint8(222), uint8(223),
	uint8(224), uint8(225), uint8(226), uint8(227), uint8(228), uint8(229), uint8(230), uint8(231),
	uint8(232), uint8(233), uint8(234), uint8(235), uint8(236), uint8(237), uint8(238), uint8(239),
	uint8(240), uint8(241), uint8(242), uint8(243), uint8(244), uint8(245), uint8(246), uint8(247),
	uint8(248), uint8(249), uint8(250), uint8(251), uint8(252), uint8(253), uint8(254), uint8(255),

	// This table is a case flipping table.

	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7),
	uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15),
	uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23),
	uint8(24), uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31),
	uint8(32), uint8(33), uint8(34), uint8(35), uint8(36), uint8(37), uint8(38), uint8(39),
	uint8(40), uint8(41), uint8(42), uint8(43), uint8(44), uint8(45), uint8(46), uint8(47),
	uint8(48), uint8(49), uint8(50), uint8(51), uint8(52), uint8(53), uint8(54), uint8(55),
	uint8(56), uint8(57), uint8(58), uint8(59), uint8(60), uint8(61), uint8(62), uint8(63),
	uint8(64), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103),
	uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111),
	uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119),
	uint8(120), uint8(121), uint8(122), uint8(91), uint8(92), uint8(93), uint8(94), uint8(95),
	uint8(96), uint8(65), uint8(66), uint8(67), uint8(68), uint8(69), uint8(70), uint8(71),
	uint8(72), uint8(73), uint8(74), uint8(75), uint8(76), uint8(77), uint8(78), uint8(79),
	uint8(80), uint8(81), uint8(82), uint8(83), uint8(84), uint8(85), uint8(86), uint8(87),
	uint8(88), uint8(89), uint8(90), uint8(123), uint8(124), uint8(125), uint8(126), uint8(127),
	uint8(128), uint8(129), uint8(130), uint8(131), uint8(132), uint8(133), uint8(134), uint8(135),
	uint8(136), uint8(137), uint8(138), uint8(139), uint8(140), uint8(141), uint8(142), uint8(143),
	uint8(144), uint8(145), uint8(146), uint8(147), uint8(148), uint8(149), uint8(150), uint8(151),
	uint8(152), uint8(153), uint8(154), uint8(155), uint8(156), uint8(157), uint8(158), uint8(159),
	uint8(160), uint8(161), uint8(162), uint8(163), uint8(164), uint8(165), uint8(166), uint8(167),
	uint8(168), uint8(169), uint8(170), uint8(171), uint8(172), uint8(173), uint8(174), uint8(175),
	uint8(176), uint8(177), uint8(178), uint8(179), uint8(180), uint8(181), uint8(182), uint8(183),
	uint8(184), uint8(185), uint8(186), uint8(187), uint8(188), uint8(189), uint8(190), uint8(191),
	uint8(192), uint8(193), uint8(194), uint8(195), uint8(196), uint8(197), uint8(198), uint8(199),
	uint8(200), uint8(201), uint8(202), uint8(203), uint8(204), uint8(205), uint8(206), uint8(207),
	uint8(208), uint8(209), uint8(210), uint8(211), uint8(212), uint8(213), uint8(214), uint8(215),
	uint8(216), uint8(217), uint8(218), uint8(219), uint8(220), uint8(221), uint8(222), uint8(223),
	uint8(224), uint8(225), uint8(226), uint8(227), uint8(228), uint8(229), uint8(230), uint8(231),
	uint8(232), uint8(233), uint8(234), uint8(235), uint8(236), uint8(237), uint8(238), uint8(239),
	uint8(240), uint8(241), uint8(242), uint8(243), uint8(244), uint8(245), uint8(246), uint8(247),
	uint8(248), uint8(249), uint8(250), uint8(251), uint8(252), uint8(253), uint8(254), uint8(255),

	// This table contains bit maps for various character classes. Each map is 32
	// bytes long and the bits run from the least significant end of each byte. The
	// classes that have their own maps are: space, xdigit, digit, upper, lower, word,
	// graph, print, punct, and cntrl. Other classes are built from combinations.

	uint8(0x00), uint8(0x3e), uint8(0x00), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00), uint8(0x00), // space
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0xff), uint8(0x03), // xdigit
	uint8(0x7e), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x7e), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0xff), uint8(0x03), // digit
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // upper
	uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x07), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // lower
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x07),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0xff), uint8(0x03), // word
	uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x07),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0xff), // graph
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0x7f),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // print
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0x7f),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0xfe), uint8(0xff), uint8(0x00), uint8(0xfc), // punct
	uint8(0x01), uint8(0x00), uint8(0x00), uint8(0xf8), uint8(0x01), uint8(0x00), uint8(0x00), uint8(0x78),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // cntrl
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x80),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00),

	// This table identifies various classes of character by individual bits:
	//   0x01   white space character
	//   0x02   letter
	//   0x04   lower case letter
	//   0x08   decimal digit
	//   0x10   alphanumeric or '_'

	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), //   0-  7
	uint8(0x00), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x00), uint8(0x00), //   8- 15
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), //  16- 23
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), //  24- 31
	uint8(0x01), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), //    - '
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), //  ( - /
	uint8(0x18), uint8(0x18), uint8(0x18), uint8(0x18), uint8(0x18), uint8(0x18), uint8(0x18), uint8(0x18), //  0 - 7
	uint8(0x18), uint8(0x18), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), //  8 - ?
	uint8(0x00), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), //  @ - G
	uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), //  H - O
	uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x12), //  P - W
	uint8(0x12), uint8(0x12), uint8(0x12), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x10), //  X - _
	uint8(0x00), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), //  ` - g
	uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), //  h - o
	uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x16), //  p - w
	uint8(0x16), uint8(0x16), uint8(0x16), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), //  x -127
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 128-135
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 136-143
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 144-151
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 152-159
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 160-167
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 168-175
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 176-183
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 184-191
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 192-199
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 200-207
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 208-215
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 216-223
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 224-231
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 232-239
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 240-247
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00)} /* pcre2_chartables.c:34:15 */ // 248-255

// End of pcre2_chartables.c

// ************************************************
//
//      Code parameters and static tables         *
//

// COMPILE_WORK_SIZE specifies the size of stack workspace, which is used in
// different ways in the different pattern scans. The parsing and group-
// identifying pre-scan uses it to handle nesting, and needs it to be 16-bit
// aligned for this. Having defined the size in code units, we set up
// C16_WORK_SIZE as the number of elements in the 16-bit vector.
//
// During the first compiling phase, when determining how much memory is required,
// the regex is partly compiled into this space, but the compiled parts are
// discarded as soon as they can be, so that hopefully there will never be an
// overrun. The code does, however, check for an overrun, which can occur for
// pathological patterns. The size of the workspace depends on LINK_SIZE because
// the length of compiled items varies with this.
//
// In the real compile phase, this workspace is not currently used.

// A uint32_t vector is used for caching information about the size of
// capturing groups, to improve performance. A default is created on the stack of
// this size.

// The overrun tests check for a slightly smaller size so that they detect the
// overrun before it actually does run off the end of the data block.

// This value determines the size of the initial vector that is used for
// remembering named groups during the pre-compile. It is allocated on the stack,
// but if it is too small, it is expanded, in a similar way to the workspace. The
// value is the number of slots in the list.

// The pre-compiling pass over the pattern creates a parsed pattern in a vector
// of uint32_t. For short patterns this lives on the stack, with this size. Heap
// memory is used for longer patterns.

// Maximum length value to check against when making sure that the variable
// that holds the compiled pattern length does not overflow. We make it a bit less
// than INT_MAX to allow for adding in group terminating code units, so that we
// don't have to check them every time.

// Code values for parsed patterns, which are stored in a vector of 32-bit
// unsigned ints. Values less than META_END are literal data values. The coding
// for identifying the item is in the top 16-bits, leaving 16 bits for the
// additional data that some of them need. The META_CODE, META_DATA, and META_DIFF
// macros are used to manipulate parsed pattern elements.
//
// NOTE: When these definitions are changed, the table of extra lengths for each
// code (meta_extra_lengths, just below) must be updated to remain in step.

// These must be kept together to make it easy to check that an assertion
// is present where expected in a conditional group.

// These cannot be conditions

// These must be kept in this order, with consecutive values, and the _ARG
// versions of COMMIT, PRUNE, SKIP, and THEN immediately after their non-argument
// versions.

// These must be kept in groups of adjacent 3 values, and all together.

// This is a special "meta code" that is used only to distinguish (*asr: from
// (*sr: in the table of aphabetic assertions. It is never stored in the parsed
// pattern because (*asr: is turned into (*sr:(*atomic: at that stage. There is
// therefore no need for it to have a length entry, so use a high value.

// Table of extra lengths for each of the meta codes. Must be kept in step with
// the definitions above. For some items these values are a basic length to which
// a variable amount has to be added.

var meta_extra_lengths = [64]uint8{
	uint8(0), // META_END
	uint8(0), // META_ALT
	uint8(0), // META_ATOMIC
	uint8(0), // META_BACKREF - more if group is >= 10
	uint8(1 + DSIZEOFFSET),
	uint8(1), // META_BIGVALUE
	uint8(3), // META_CALLOUT_NUMBER
	uint8(3 + DSIZEOFFSET),
	uint8(0),           // META_CAPTURE
	uint8(0),           // META_CIRCUMFLEX
	uint8(0),           // META_CLASS
	uint8(0),           // META_CLASS_EMPTY
	uint8(0),           // META_CLASS_EMPTY_NOT
	uint8(0),           // META_CLASS_END
	uint8(0),           // META_CLASS_NOT
	uint8(0),           // META_COND_ASSERT
	uint8(DSIZEOFFSET), // META_COND_DEFINE
	uint8(1 + DSIZEOFFSET),
	uint8(1 + DSIZEOFFSET),
	uint8(1 + DSIZEOFFSET),
	uint8(1 + DSIZEOFFSET),
	uint8(3),           // META_COND_VERSION
	uint8(0),           // META_DOLLAR
	uint8(0),           // META_DOT
	uint8(0),           // META_ESCAPE - more for ESC_P, ESC_p, ESC_g, ESC_k
	uint8(0),           // META_KET
	uint8(0),           // META_NOCAPTURE
	uint8(1),           // META_OPTIONS
	uint8(1),           // META_POSIX
	uint8(1),           // META_POSIX_NEG
	uint8(0),           // META_RANGE_ESCAPED
	uint8(0),           // META_RANGE_LITERAL
	uint8(DSIZEOFFSET), // META_RECURSE
	uint8(1 + DSIZEOFFSET),
	uint8(0),           // META_SCRIPT_RUN
	uint8(0),           // META_LOOKAHEAD
	uint8(0),           // META_LOOKAHEADNOT
	uint8(DSIZEOFFSET), // META_LOOKBEHIND
	uint8(DSIZEOFFSET), // META_LOOKBEHINDNOT
	uint8(0),           // META_LOOKAHEAD_NA
	uint8(DSIZEOFFSET), // META_LOOKBEHIND_NA
	uint8(1),           // META_MARK - plus the string length
	uint8(0),           // META_ACCEPT
	uint8(0),           // META_FAIL
	uint8(0),           // META_COMMIT
	uint8(1),           // META_COMMIT_ARG - plus the string length
	uint8(0),           // META_PRUNE
	uint8(1),           // META_PRUNE_ARG - plus the string length
	uint8(0),           // META_SKIP
	uint8(1),           // META_SKIP_ARG - plus the string length
	uint8(0),           // META_THEN
	uint8(1),           // META_THEN_ARG - plus the string length
	uint8(0),           // META_ASTERISK
	uint8(0),           // META_ASTERISK_PLUS
	uint8(0),           // META_ASTERISK_QUERY
	uint8(0),           // META_PLUS
	uint8(0),           // META_PLUS_PLUS
	uint8(0),           // META_PLUS_QUERY
	uint8(0),           // META_QUERY
	uint8(0),           // META_QUERY_PLUS
	uint8(0),           // META_QUERY_QUERY
	uint8(2),           // META_MINMAX
	uint8(2),           // META_MINMAX_PLUS
	uint8(2),           // META_MINMAX_QUERY
} /* pcre2_compile.c:306:22 */

// Macro for setting individual bits in class bitmaps. It took some
// experimenting to figure out how to stop gcc 5.3.0 from warning with
// -Wconversion. This version gets a warning:
//
//   #define SETBIT(a,b) a[(b)/8] |= (uint8_t)(1u << ((b)&7))
//
// Let's hope the apparently less efficient version isn't actually so bad if the
// compiler is clever with identical subexpressions.

// Values and flags for the unsigned xxcuflags variables that accompany xxcu
// variables, which are concerned with first and required code units. A value
// greater than or equal to REQ_NONE means "no code unit set"; otherwise the
// matching xxcu variable is set, and the low valued bits are relevant.

// These flags are used in the groupinfo vector.

// This simple test for a decimal digit works for both ASCII/Unicode and EBCDIC
// and is fast (a good compiler can turn it into a subtraction and unsigned
// comparison).

// Table to identify hex digits. The tables in chartables are dependent on the
// locale, and may mark arbitrary characters as digits. We want to recognize only
// 0-9, a-z, and A-Z as hex digits, which is why we have a private table here. It
// costs 256 bytes, but it is a lot faster than doing character value tests (at
// least in some simple cases I timed), and in some applications one wants PCRE2
// to compile efficiently as well as match efficiently. The value in the table is
// the binary hex digit value, or 0xff for non-hex digits.

// This is the "normal" case, for ASCII systems, and EBCDIC systems running in
// UTF-8 mode.

var xdigitab = [256]uint8{
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //   0-  7
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //   8- 15
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  16- 23
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  24- 31
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //    - '
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  ( - /
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07), //  0 - 7
	uint8(0x08), uint8(0x09), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  8 - ?
	uint8(0xff), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f), uint8(0xff), //  @ - G
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  H - O
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  P - W
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  X - _
	uint8(0xff), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f), uint8(0xff), //  ` - g
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  h - o
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  p - w
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), //  x -127
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 128-135
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 136-143
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 144-151
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 152-159
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 160-167
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 168-175
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 176-183
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 184-191
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 192-199
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 2ff-207
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 208-215
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 216-223
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 224-231
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 232-239
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), // 240-247
	uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff), uint8(0xff)} /* pcre2_compile.c:422:22 */ // 248-255

// Table for handling alphanumeric escaped characters. Positive returns are
// simple data values; negative values are for special things like \d and so on.
// Zero means further processing is needed (for things like \x), or the escape is
// invalid.

// This is the "normal" table for ASCII systems or for EBCDIC systems running
// in UTF-8 mode. It runs from '0' to 'z'.

var escapes = [75]int16{
	int16(0), int16(0),
	int16(0), int16(0),
	int16(0), int16(0),
	int16(0), int16(0),
	int16(0), int16(0),
	int16('\072'), int16('\073'),
	int16('\074'), int16('\075'),
	int16('\076'), int16('\077'),
	int16('\100'), int16(-ESC_A),
	int16(-ESC_B), int16(-ESC_C),
	int16(-ESC_D), int16(-ESC_E),
	int16(0), int16(-ESC_G),
	int16(-ESC_H), int16(0),
	int16(0), int16(-ESC_K),
	int16(0), int16(0),
	int16(-ESC_N), int16(0),
	int16(-ESC_P), int16(-ESC_Q),
	int16(-ESC_R), int16(-ESC_S),
	int16(0), int16(0),
	int16(-ESC_V), int16(-ESC_W),
	int16(-ESC_X), int16(0),
	int16(-ESC_Z), int16('\133'),
	int16('\134'), int16('\135'),
	int16('\136'), int16('\137'),
	int16('\140'), int16('\007'),
	int16(-ESC_b), int16(0),
	int16(-ESC_d), int16('\033'),
	int16('\014'), int16(0),
	int16(-ESC_h), int16(0),
	int16(0), int16(-ESC_k),
	int16(0), int16(0),
	int16('\012'), int16(0),
	int16(-ESC_p), int16(0),
	int16('\015'), int16(-ESC_s),
	int16('\011'), int16(0),
	int16(-ESC_v), int16(-ESC_w),
	int16(0), int16(0),
	int16(-ESC_z),
} /* pcre2_compile.c:511:24 */

// Table of special "verbs" like (*PRUNE). This is a short table, so it is
// searched linearly. Put all the names into a single string, in order to reduce
// the number of relocations when a shared library is dynamically linked. The
// string is built from string macros so that it works in UTF-8 mode on EBCDIC
// platforms.

type Sverbitem = struct {
	Flen     uint32
	Fmeta    uint32
	Fhas_arg int32
} /* pcre2_compile.c:602:9 */

// Table of special "verbs" like (*PRUNE). This is a short table, so it is
// searched linearly. Put all the names into a single string, in order to reduce
// the number of relocations when a shared library is dynamically linked. The
// string is built from string macros so that it works in UTF-8 mode on EBCDIC
// platforms.

type Tverbitem = Sverbitem /* pcre2_compile.c:606:3 */

var verbnames =
// Empty name is a shorthand for MARK

*(*[43]int8)(unsafe.Pointer(ts)) /* pcre2_compile.c:608:19 */

var verbs = [9]Tverbitem{
	{Fmeta: DMETA_MARK, Fhas_arg: +1}, // > 0 => must have an argument
	{Flen: uint32(4), Fmeta: DMETA_MARK, Fhas_arg: +1},
	{Flen: uint32(6), Fmeta: DMETA_ACCEPT, Fhas_arg: -1}, // < 0 => Optional argument, convert to pre-MARK
	{Flen: uint32(1), Fmeta: DMETA_FAIL, Fhas_arg: -1},
	{Flen: uint32(4), Fmeta: DMETA_FAIL, Fhas_arg: -1},
	{Flen: uint32(6), Fmeta: DMETA_COMMIT},
	{Flen: uint32(5), Fmeta: DMETA_PRUNE}, // Optional argument; bump META code if found
	{Flen: uint32(4), Fmeta: DMETA_SKIP},
	{Flen: uint32(4), Fmeta: DMETA_THEN},
} /* pcre2_compile.c:619:23 */

var verbcount int32 = int32(uint64(unsafe.Sizeof(verbs)) / uint64(unsafe.Sizeof(Tverbitem{}))) /* pcre2_compile.c:631:18 */

// Verb opcodes, indexed by their META code offset from META_MARK.

var verbops = [11]uint32{
	OP_MARK, OP_ACCEPT, OP_FAIL, OP_COMMIT, OP_COMMIT_ARG, OP_PRUNE,
	OP_PRUNE_ARG, OP_SKIP, OP_SKIP_ARG, OP_THEN, OP_THEN_ARG} /* pcre2_compile.c:635:23 */

// Table of "alpha assertions" like (*pla:...), similar to the (*VERB) table.

type Salasitem = struct {
	Flen  uint32
	Fmeta uint32
} /* pcre2_compile.c:641:9 */

// Table of "alpha assertions" like (*pla:...), similar to the (*VERB) table.

type Talasitem = Salasitem /* pcre2_compile.c:644:3 */

var alasnames = *(*[210]int8)(unsafe.Pointer(ts + 43)) /* pcre2_compile.c:646:19 */

var alasmeta = [17]Talasitem{
	{Flen: uint32(3), Fmeta: DMETA_LOOKAHEAD},
	{Flen: uint32(3), Fmeta: DMETA_LOOKBEHIND},
	{Flen: uint32(5), Fmeta: DMETA_LOOKAHEAD_NA},
	{Flen: uint32(5), Fmeta: DMETA_LOOKBEHIND_NA},
	{Flen: uint32(3), Fmeta: DMETA_LOOKAHEADNOT},
	{Flen: uint32(3), Fmeta: DMETA_LOOKBEHINDNOT},
	{Flen: uint32(18), Fmeta: DMETA_LOOKAHEAD},
	{Flen: uint32(19), Fmeta: DMETA_LOOKBEHIND},
	{Flen: uint32(29), Fmeta: DMETA_LOOKAHEAD_NA},
	{Flen: uint32(30), Fmeta: DMETA_LOOKBEHIND_NA},
	{Flen: uint32(18), Fmeta: DMETA_LOOKAHEADNOT},
	{Flen: uint32(19), Fmeta: DMETA_LOOKBEHINDNOT},
	{Flen: uint32(6), Fmeta: DMETA_ATOMIC},
	{Flen: uint32(2), Fmeta: DMETA_SCRIPT_RUN},         // sr = script run
	{Flen: uint32(3), Fmeta: DMETA_ATOMIC_SCRIPT_RUN},  // asr = atomic script run
	{Flen: uint32(10), Fmeta: DMETA_SCRIPT_RUN},        // script run
	{Flen: uint32(17), Fmeta: DMETA_ATOMIC_SCRIPT_RUN}, // atomic script run
} /* pcre2_compile.c:665:23 */

var alascount int32 = int32(uint64(unsafe.Sizeof(alasmeta)) / uint64(unsafe.Sizeof(Talasitem{}))) /* pcre2_compile.c:685:18 */

// Offsets from OP_STAR for case-independent and negative repeat opcodes.

var chartypeoffset = [4]uint32{
	uint32(OP_STAR - OP_STAR), uint32(OP_STARI - OP_STAR),
	uint32(OP_NOTSTAR - OP_STAR), uint32(OP_NOTSTARI - OP_STAR)} /* pcre2_compile.c:689:17 */

// Tables of names of POSIX character classes and their lengths. The names are
// now all in a single string, to reduce the number of relocations when a shared
// library is dynamically loaded. The list of lengths is terminated by a zero
// length entry. The first three must be alpha, lower, upper, as this is assumed
// for handling case independence. The indices for graph, print, and punct are
// needed, so identify them.

var posix_names = *(*[84]int8)(unsafe.Pointer(ts + 253)) /* pcre2_compile.c:700:19 */

var posix_name_lengths = [15]uint8{
	uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(4), uint8(6), uint8(0)} /* pcre2_compile.c:706:22 */

// Table of class bit maps for each POSIX class. Each class is formed from a
// base map, with an optional addition or removal of another map. Then, for some
// classes, there is some additional tweaking: for [:blank:] the vertical space
// characters are removed, and for [:alpha:] and [:alnum:] the underscore
// character is removed. The triples in the table consist of the base map offset,
// second map offset or -1 if no second map, and a non-negative value for map
// addition or a negative value for map subtraction (if there are two maps). The
// absolute value of the third field has these meanings: 0 => no tweaking, 1 =>
// remove vertical space characters, 2 => remove underscore.

var posix_class_maps = [42]int32{
	Dcbit_word, Dcbit_digit, -2, // alpha
	Dcbit_lower, -1, 0, // lower
	Dcbit_upper, -1, 0, // upper
	Dcbit_word, -1, 2, // alnum - word without underscore
	Dcbit_print, Dcbit_cntrl, 0, // ascii
	Dcbit_space, -1, 1, // blank - a GNU extension
	Dcbit_cntrl, -1, 0, // cntrl
	Dcbit_digit, -1, 0, // digit
	Dcbit_graph, -1, 0, // graph
	Dcbit_print, -1, 0, // print
	Dcbit_punct, -1, 0, // punct
	Dcbit_space, -1, 0, // space
	Dcbit_word, -1, 0, // word - a Perl extension
	Dcbit_xdigit, -1, 0, // xdigit
} /* pcre2_compile.c:723:18 */

// The POSIX class Unicode property substitutes that are used in UCP mode must
// be in the order of the POSIX class names, defined above.

var posix_substitutes = [28]int32{
	DPT_GC, ucp_L, // alpha
	DPT_PC, ucp_Ll, // lower
	DPT_PC, ucp_Lu, // upper
	DPT_ALNUM, 0, // alnum
	-1, 0, // ascii, treat as non-UCP
	-1, 1, // blank, treat as \h
	DPT_PC, ucp_Cc, // cntrl
	DPT_PC, ucp_Nd, // digit
	DPT_PXGRAPH, 0, // graph
	DPT_PXPRINT, 0, // print
	DPT_PXPUNCT, 0, // punct
	DPT_PXSPACE, 0, /* space */ // Xps is POSIX space, but from 8.34
	DPT_WORD, 0, /* word  */ // Perl and POSIX space are the same
	-1, 0, // xdigit, treat as non-UCP
} /* pcre2_compile.c:745:12 */ // Read integer value for depth limit

type Spso = struct {
	Fname   uintptr
	Flength uint16
	Ftype   uint16
	Fvalue  uint32
} /* pcre2_compile.c:822:9 */

// Read integer value for depth limit

type Tpso = Spso /* pcre2_compile.c:827:3 */

// NB: STRING_UTFn_RIGHTPAR contains the length as well

var pso_list = [21]Tpso{
	{Fname: uintptr(ts + 337), Flength: uint16(5), Fvalue: DPCRE2_UTF},
	{Fname: uintptr(ts + 343), Flength: uint16(4), Fvalue: DPCRE2_UTF},
	{Fname: uintptr(ts + 348), Flength: uint16(4), Fvalue: DPCRE2_UCP},
	{Fname: uintptr(ts + 353), Flength: uint16(9), Ftype: PSO_FLG, Fvalue: uint32(DPCRE2_NOTEMPTY_SET)},
	{Fname: uintptr(ts + 363), Flength: uint16(17), Ftype: PSO_FLG, Fvalue: uint32(DPCRE2_NE_ATST_SET)},
	{Fname: uintptr(ts + 381), Flength: uint16(16), Fvalue: DPCRE2_NO_AUTO_POSSESS},
	{Fname: uintptr(ts + 398), Flength: uint16(18), Fvalue: DPCRE2_NO_DOTSTAR_ANCHOR},
	{Fname: uintptr(ts + 417), Flength: uint16(7), Ftype: PSO_FLG, Fvalue: uint32(DPCRE2_NOJIT)},
	{Fname: uintptr(ts + 425), Flength: uint16(13), Fvalue: DPCRE2_NO_START_OPTIMIZE},
	{Fname: uintptr(ts + 439), Flength: uint16(11), Ftype: PSO_LIMH},
	{Fname: uintptr(ts + 451), Flength: uint16(12), Ftype: PSO_LIMM},
	{Fname: uintptr(ts + 464), Flength: uint16(12), Ftype: PSO_LIMD},
	{Fname: uintptr(ts + 477), Flength: uint16(16), Ftype: PSO_LIMD},
	{Fname: uintptr(ts + 494), Flength: uint16(3), Ftype: PSO_NL, Fvalue: uint32(DPCRE2_NEWLINE_CR)},
	{Fname: uintptr(ts + 498), Flength: uint16(3), Ftype: PSO_NL, Fvalue: uint32(DPCRE2_NEWLINE_LF)},
	{Fname: uintptr(ts + 502), Flength: uint16(5), Ftype: PSO_NL, Fvalue: uint32(DPCRE2_NEWLINE_CRLF)},
	{Fname: uintptr(ts + 508), Flength: uint16(4), Ftype: PSO_NL, Fvalue: uint32(DPCRE2_NEWLINE_ANY)},
	{Fname: uintptr(ts + 513), Flength: uint16(4), Ftype: PSO_NL, Fvalue: uint32(DPCRE2_NEWLINE_NUL)},
	{Fname: uintptr(ts + 518), Flength: uint16(8), Ftype: PSO_NL, Fvalue: uint32(DPCRE2_NEWLINE_ANYCRLF)},
	{Fname: uintptr(ts + 527), Flength: uint16(12), Ftype: PSO_BSR, Fvalue: uint32(DPCRE2_BSR_ANYCRLF)},
	{Fname: uintptr(ts + 540), Flength: uint16(12), Ftype: PSO_BSR, Fvalue: uint32(DPCRE2_BSR_UNICODE)},
} /* pcre2_compile.c:831:12 */

// This table is used when converting repeating opcodes into possessified
// versions as a result of an explicit possessive quantifier such as ++. A zero
// value means there is no possessified version - in those cases the item in
// question must be wrapped in ONCE brackets. The table is truncated at OP_CALLOUT
// because all relevant opcodes are less than that.

var opcode_possessify = [119]uint8{
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // 0 - 15
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // 16 - 31

	uint8(0),             // NOTI
	OP_POSSTAR, uint8(0), // STAR, MINSTAR
	OP_POSPLUS, uint8(0), // PLUS, MINPLUS
	OP_POSQUERY, uint8(0), // QUERY, MINQUERY
	OP_POSUPTO, uint8(0), // UPTO, MINUPTO
	uint8(0),                               // EXACT
	uint8(0), uint8(0), uint8(0), uint8(0), // POS{STAR,PLUS,QUERY,UPTO}

	OP_POSSTARI, uint8(0), // STARI, MINSTARI
	OP_POSPLUSI, uint8(0), // PLUSI, MINPLUSI
	OP_POSQUERYI, uint8(0), // QUERYI, MINQUERYI
	OP_POSUPTOI, uint8(0), // UPTOI, MINUPTOI
	uint8(0),                               // EXACTI
	uint8(0), uint8(0), uint8(0), uint8(0), // POS{STARI,PLUSI,QUERYI,UPTOI}

	OP_NOTPOSSTAR, uint8(0), // NOTSTAR, NOTMINSTAR
	OP_NOTPOSPLUS, uint8(0), // NOTPLUS, NOTMINPLUS
	OP_NOTPOSQUERY, uint8(0), // NOTQUERY, NOTMINQUERY
	OP_NOTPOSUPTO, uint8(0), // NOTUPTO, NOTMINUPTO
	uint8(0),                               // NOTEXACT
	uint8(0), uint8(0), uint8(0), uint8(0), // NOTPOS{STAR,PLUS,QUERY,UPTO}

	OP_NOTPOSSTARI, uint8(0), // NOTSTARI, NOTMINSTARI
	OP_NOTPOSPLUSI, uint8(0), // NOTPLUSI, NOTMINPLUSI
	OP_NOTPOSQUERYI, uint8(0), // NOTQUERYI, NOTMINQUERYI
	OP_NOTPOSUPTOI, uint8(0), // NOTUPTOI, NOTMINUPTOI
	uint8(0),                               // NOTEXACTI
	uint8(0), uint8(0), uint8(0), uint8(0), // NOTPOS{STARI,PLUSI,QUERYI,UPTOI}

	OP_TYPEPOSSTAR, uint8(0), // TYPESTAR, TYPEMINSTAR
	OP_TYPEPOSPLUS, uint8(0), // TYPEPLUS, TYPEMINPLUS
	OP_TYPEPOSQUERY, uint8(0), // TYPEQUERY, TYPEMINQUERY
	OP_TYPEPOSUPTO, uint8(0), // TYPEUPTO, TYPEMINUPTO
	uint8(0),                               // TYPEEXACT
	uint8(0), uint8(0), uint8(0), uint8(0), // TYPEPOS{STAR,PLUS,QUERY,UPTO}

	OP_CRPOSSTAR, uint8(0), // CRSTAR, CRMINSTAR
	OP_CRPOSPLUS, uint8(0), // CRPLUS, CRMINPLUS
	OP_CRPOSQUERY, uint8(0), // CRQUERY, CRMINQUERY
	OP_CRPOSRANGE, uint8(0), // CRRANGE, CRMINRANGE
	uint8(0), uint8(0), uint8(0), uint8(0), // CRPOS{STAR,PLUS,QUERY,RANGE}

	uint8(0), uint8(0), uint8(0), // CLASS, NCLASS, XCLASS
	uint8(0), uint8(0), // REF, REFI
	uint8(0), uint8(0), // DNREF, DNREFI
	uint8(0), uint8(0), // RECURSE, CALLOUT
} /* pcre2_compile.c:861:22 */

// ************************************************
//
//               Copy compiled code               *
//

// Compiled JIT code cannot be copied, so the new compiled block has no
// associated JIT data.

func Xpcre2_code_copy_8(tls *libc.TLS, code uintptr) uintptr { /* pcre2_compile.c:1193:27: */
	var ref_count uintptr
	var newcode uintptr

	if code == uintptr(0) {
		return uintptr(0)
	}
	newcode = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmalloc})).f(tls, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fblocksize, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
	if newcode == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, newcode, code, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fblocksize)
	(*Tpcre2_code_8)(unsafe.Pointer(newcode)).Fexecutable_jit = uintptr(0)

	// If the code is one that has been deserialized, increment the reference count
	// in the decoded tables.

	if (*Tpcre2_code_8)(unsafe.Pointer(code)).Fflags&uint32(DPCRE2_DEREF_TABLES) != uint32(0) {
		ref_count = (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset+Dcbit_length+256)
		*(*uint64)(unsafe.Pointer(ref_count))++
	}

	return newcode
}

// ************************************************
//
//     Copy compiled code and character tables    *
//

// Compiled JIT code cannot be copied, so the new compiled block has no
// associated JIT data. This version of code_copy also makes a separate copy of
// the character tables.

func Xpcre2_code_copy_with_tables_8(tls *libc.TLS, code uintptr) uintptr { /* pcre2_compile.c:1227:27: */
	var ref_count uintptr
	var newcode uintptr
	var newtables uintptr

	if code == uintptr(0) {
		return uintptr(0)
	}
	newcode = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmalloc})).f(tls, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fblocksize, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
	if newcode == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, newcode, code, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fblocksize)
	(*Tpcre2_code_8)(unsafe.Pointer(newcode)).Fexecutable_jit = uintptr(0)

	newtables = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmalloc})).f(tls, uint64(Dcbits_offset+Dcbit_length+256)+uint64(unsafe.Sizeof(uint64(0))),
		(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
	if newtables == uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Ffree})).f(tls, newcode, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
		return uintptr(0)
	}
	libc.Xmemcpy(tls, newtables, (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables, uint64(Dcbits_offset+Dcbit_length+256))
	ref_count = newtables + uintptr(Dcbits_offset+Dcbit_length+256)
	*(*uint64)(unsafe.Pointer(ref_count)) = uint64(1)

	(*Tpcre2_code_8)(unsafe.Pointer(newcode)).Ftables = newtables
	*(*uint32)(unsafe.Pointer(newcode + 96)) |= uint32(DPCRE2_DEREF_TABLES)
	return newcode
}

// ************************************************
//
//               Free compiled code               *
//

func Xpcre2_code_free_8(tls *libc.TLS, code uintptr) { /* pcre2_compile.c:1263:1: */
	var ref_count uintptr

	if code != uintptr(0) {

		if (*Tpcre2_code_8)(unsafe.Pointer(code)).Fflags&uint32(DPCRE2_DEREF_TABLES) != uint32(0) {
			// Decoded tables belong to the codes after deserialization, and they must
			//     be freed when there are no more references to them. The *ref_count should
			//     always be > 0.

			ref_count = (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset+Dcbit_length+256)
			if *(*uint64)(unsafe.Pointer(ref_count)) > uint64(0) {
				*(*uint64)(unsafe.Pointer(ref_count))--
				if *(*uint64)(unsafe.Pointer(ref_count)) == uint64(0) {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr)
					})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Ffree})).f(tls, (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
				}
			}
		}

		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Ffree})).f(tls, code, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fmemctl.Fmemory_data)
	}
}

// ************************************************
//
//         Read a number, possibly signed         *
//

// This function is used to read numbers in the pattern. The initial pointer
// must be the sign or first digit of the number. When relative values (introduced
// by + or -) are allowed, they are relative group numbers, and the result must be
// greater than zero.
//
// Arguments:
//   ptrptr      points to the character pointer variable
//   ptrend      points to the end of the input string
//   allow_sign  if < 0, sign not allowed; if >= 0, sign is relative to this
//   max_value   the largest number allowed
//   max_error   the error to give for an over-large number
//   intptr      where to put the result
//   errcodeptr  where to put an error code
//
// Returns:      TRUE  - a number was read
//               FALSE - errorcode == 0 => no number was found
//                       errorcode != 0 => an error occurred

func read_number(tls *libc.TLS, ptrptr uintptr, ptrend uintptr, allow_sign int32, max_value uint32, max_error uint32, intptr uintptr, errorcodeptr uintptr) int32 { /* pcre2_compile.c:1319:1: */
	var sign int32
	var n uint32
	var ptr uintptr
	var yield int32
	sign = 0
	n = uint32(0)
	ptr = *(*uintptr)(unsafe.Pointer(ptrptr))
	yield = DFALSE

	*(*int32)(unsafe.Pointer(errorcodeptr)) = 0

	if !(allow_sign >= 0 && ptr < ptrend) {
		goto __1
	}

	if !(int32(*(*uint8)(unsafe.Pointer(ptr))) == '\053') {
		goto __2
	}

	sign = +1
	max_value = max_value - uint32(allow_sign)
	ptr++
	goto __3
__2:
	if !(int32(*(*uint8)(unsafe.Pointer(ptr))) == '\055') {
		goto __4
	}

	sign = -1
	ptr++
__4:
	;
__3:
	;
__1:
	;

	if !(ptr >= ptrend || !(int32(*(*uint8)(unsafe.Pointer(ptr))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(ptr))) <= '\071')) {
		goto __5
	}
	return DFALSE
__5:
	;
__6:
	if !(ptr < ptrend && (int32(*(*uint8)(unsafe.Pointer(ptr))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(ptr))) <= '\071')) {
		goto __7
	}

	n = n*uint32(10) + uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))) - uint32('\060')
	if !(n > max_value) {
		goto __8
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = int32(max_error)
	goto EXIT
__8:
	;
	goto __6
__7:
	;

	if !(allow_sign >= 0 && sign != 0) {
		goto __9
	}

	if !(n == uint32(0)) {
		goto __10
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR26 // +0 and -0 are not allowed
	goto EXIT
__10:
	;

	if !(sign > 0) {
		goto __11
	}
	n = n + uint32(allow_sign)
	goto __12
__11:
	if !(int32(n) > allow_sign) {
		goto __13
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15 // Non-existent subpattern
	goto EXIT
	goto __14
__13:
	n = uint32(allow_sign+1) - n
__14:
	;
__12:
	;
__9:
	;

	yield = DTRUE

EXIT:
	*(*int32)(unsafe.Pointer(intptr)) = int32(n)
	*(*uintptr)(unsafe.Pointer(ptrptr)) = ptr
	return yield
}

// ************************************************
//
//         Read repeat counts                     *
//

// Read an item of the form {n,m} and return the values if non-NULL pointers
// are supplied. Repeat counts must be less than 65536 (MAX_REPEAT_COUNT); a
// larger value is used for "unlimited". We have to use signed arguments for
// read_number() because it is capable of returning a signed value.
//
// Arguments:
//   ptrptr         points to pointer to character after'{'
//   ptrend         pointer to end of input
//   minp           if not NULL, pointer to int for min
//   maxp           if not NULL, pointer to int for max (-1 if no max)
//                  returned as -1 if no max
//   errorcodeptr   points to error code variable
//
// Returns:         FALSE if not a repeat quantifier, errorcode set zero
//                  FALSE on error, with errorcode set non-zero
//                  TRUE on success, with pointer updated to point after '}'

func read_repeat_counts(tls *libc.TLS, ptrptr uintptr, ptrend uintptr, minp uintptr, maxp uintptr, errorcodeptr uintptr) int32 { /* pcre2_compile.c:1405:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var p uintptr at bp, 8

	var yield int32
	var had_comma int32
	// var min int32 at bp+8, 4

	// var max int32 at bp+12, 4

	var c uint32
	yield = DFALSE
	had_comma = DFALSE
	*(*int32)(unsafe.Pointer(bp + 8 /* min */)) = 0
	*(*int32)(unsafe.Pointer(bp + 12 /* max */)) = int32(DMAX_REPEAT_COUNT + uint32(1)) // This value is larger than MAX_REPEAT_COUNT

	// Check the syntax

	*(*int32)(unsafe.Pointer(errorcodeptr)) = 0
	*(*uintptr)(unsafe.Pointer(bp /* p */)) = *(*uintptr)(unsafe.Pointer(ptrptr))
__1:
	;

	if !(*(*uintptr)(unsafe.Pointer(bp)) >= ptrend) {
		goto __4
	}
	return DFALSE
__4:
	;
	c = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))))
	if !(c >= uint32('\060') && c <= uint32('\071')) {
		goto __5
	}
	goto __2
__5:
	;
	if !(c == uint32('\175')) {
		goto __6
	}
	goto __3
__6:
	;
	if !(c == uint32('\054')) {
		goto __7
	}

	if !(had_comma != 0) {
		goto __9
	}
	return DFALSE
__9:
	;
	had_comma = DTRUE
	goto __8
__7:
	return DFALSE
__8:
	;
	goto __2
__2:
	*(*uintptr)(unsafe.Pointer(bp /* p */))++
	goto __1
	goto __3
__3:
	;

	// The only error from read_number() is for a number that is too big.

	*(*uintptr)(unsafe.Pointer(bp /* p */)) = *(*uintptr)(unsafe.Pointer(ptrptr))
	if !!(read_number(tls, bp, ptrend, -1, DMAX_REPEAT_COUNT, ERR5, bp+8, errorcodeptr) != 0) {
		goto __10
	}
	goto EXIT
__10:
	;

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\175') {
		goto __11
	}

	*(*uintptr)(unsafe.Pointer(bp /* p */))++
	*(*int32)(unsafe.Pointer(bp + 12 /* max */)) = *(*int32)(unsafe.Pointer(bp + 8 /* min */))
	goto __12
__11:

	if !(int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != '\175') {
		goto __13
	}

	if !!(read_number(tls, bp, ptrend, -1, DMAX_REPEAT_COUNT, ERR5, bp+12,
		errorcodeptr) != 0) {
		goto __14
	}
	goto EXIT
__14:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 12)) < *(*int32)(unsafe.Pointer(bp + 8))) {
		goto __15
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR4
	goto EXIT
__15:
	;
__13:
	;
	*(*uintptr)(unsafe.Pointer(bp /* p */))++
__12:
	;

	yield = DTRUE
	if !(minp != uintptr(0)) {
		goto __16
	}
	*(*uint32)(unsafe.Pointer(minp)) = uint32(*(*int32)(unsafe.Pointer(bp + 8 /* min */)))
__16:
	;
	if !(maxp != uintptr(0)) {
		goto __17
	}
	*(*uint32)(unsafe.Pointer(maxp)) = uint32(*(*int32)(unsafe.Pointer(bp + 12 /* max */)))
__17:
	;

	// Update the pattern pointer

EXIT:
	*(*uintptr)(unsafe.Pointer(ptrptr)) = *(*uintptr)(unsafe.Pointer(bp /* p */))
	return yield
}

// ************************************************
//
//            Handle escapes                      *
//

// This function is called when a \ has been encountered. It either returns a
// positive value for a simple escape such as \d, or 0 for a data character, which
// is placed in chptr. A backreference to group n is returned as negative n. On
// entry, ptr is pointing at the character after \. On exit, it points after the
// final code unit of the escape sequence.
//
// This function is also called from pcre2_substitute() to handle escape sequences
// in replacement strings. In this case, the cb argument is NULL, and in the case
// of escapes that have further processing, only sequences that define a data
// character are recognised. The isclass argument is not relevant; the options
// argument is the final value of the compiled pattern's options.
//
// Arguments:
//   ptrptr         points to the input position pointer
//   ptrend         points to the end of the input
//   chptr          points to a returned data character
//   errorcodeptr   points to the errorcode variable (containing zero)
//   options        the current options bits
//   isclass        TRUE if inside a character class
//   cb             compile data block or NULL when called from pcre2_substitute()
//
// Returns:         zero => a data character
//                  positive => a special escape sequence
//                  negative => a numerical back reference
//                  on error, errorcodeptr is set non-zero

func X_pcre2_check_escape_8(tls *libc.TLS, ptrptr uintptr, ptrend uintptr, chptr uintptr, errorcodeptr uintptr, options uint32, extra_options uint32, isclass int32, cb uintptr) int32 { /* pcre2_compile.c:1504:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var utf int32
	// var ptr uintptr at bp+24, 8

	var c uint32
	var cc uint32
	var escape int32
	var i int32
	// var p uintptr at bp, 8

	var hptr uintptr
	var xc uint32
	// var p1 uintptr at bp+8, 8

	var xc1 uint32
	// var s int32 at bp+16, 4

	var oldptr uintptr
	var overflow int32
	var alt_bsux int32
	utf = libc.Bool32(options&DPCRE2_UTF != uint32(0))
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) = *(*uintptr)(unsafe.Pointer(ptrptr))
	escape = 0

	// If backslash is at the end of the string, it's an error.

	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) >= ptrend) {
		goto __1
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR1
	return 0
__1:
	;

	c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)), 1))))
	if !(utf != 0 && c >= 0xc0) {
		goto __2
	}
	if !(c&0x20 == uint32(0)) {
		goto __3
	}
	c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24)), 1))))&0x3f
	goto __4
__3:
	if !(c&0x10 == uint32(0)) {
		goto __5
	}
	c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)))))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(2)
	goto __6
__5:
	if !(c&0x08 == uint32(0)) {
		goto __7
	}
	c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)))))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(3)
	goto __8
__7:
	if !(c&0x04 == uint32(0)) {
		goto __9
	}
	c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)))))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(4)
	goto __10
__9:
	c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)))))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(5)
__10:
	;
__8:
	;
__6:
	;
__4:
	;
__2:
	;

	// Get character value, increment pointer
	*(*int32)(unsafe.Pointer(errorcodeptr)) = 0 // Be optimistic

	// Non-alphanumerics are literals, so we just leave the value in c. An initial
	// value test saves a memory lookup for code points outside the alphanumeric
	// range.

	if !(c < uint32('\060') || c > uint32('\172')) {
		goto __11
	}
	goto __12
__11:
	if !(libc.AssignInt32(&i, int32(escapes[c-uint32('\060')])) != 0) {
		goto __13
	}

	if !(i > 0) {
		goto __15
	}

	c = uint32(i)
	if !(c == uint32('\015') && extra_options&DPCRE2_EXTRA_ESCAPED_CR_IS_LF != uint32(0)) {
		goto __17
	}
	c = uint32('\012')
__17:
	;
	goto __16
__15: /* Negative table entry */

	escape = -i // Else return a special escape
	if !(cb != uintptr(0) && (escape == ESC_P || escape == ESC_p || escape == ESC_X)) {
		goto __18
	}
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_HASBKPORX)
__18:
	; // Note \P, \p, or \X

	// Perl supports \N{name} for character names and \N{U+dddd} for numerical
	//     Unicode code points, as well as plain \N for "not newline". PCRE does not
	//     support \N{name}. However, it does support quantification such as \N{2,3},
	//     so if \N{ is not followed by U+dddd we check for a quantifier.

	if !(escape == ESC_N && *(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == '\173') {
		goto __19
	}

	*(*uintptr)(unsafe.Pointer(bp /* p */)) = *(*uintptr)(unsafe.Pointer(bp + 24)) + uintptr(1)

	// \N{U+ can be handled by the \x{ code. However, this construction is
	//       not valid in EBCDIC environments because it specifies a Unicode
	//       character, not a codepoint in the local code. For example \N{U+0041}
	//       must be "A" in all environments. Also, in Perl, \N{U+ forces Unicode
	//       casing semantics for the entire pattern, so allow it only in UTF (i.e.
	//       Unicode) mode.

	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp))))/1 > int64(1) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\125' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1))) == '\053') {
		goto __20
	}

	if !(utf != 0) {
		goto __22
	}

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) = *(*uintptr)(unsafe.Pointer(bp)) + uintptr(1)
	escape = 0 // Not a fancy escape after all
	goto COME_FROM_NU
	goto __23
__22:
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR93
__23:
	;
	goto __21
__20:

	if !(!(read_repeat_counts(tls, bp, ptrend, uintptr(0), uintptr(0), errorcodeptr) != 0) && *(*int32)(unsafe.Pointer(errorcodeptr)) == 0) {
		goto __24
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR37
__24:
	;
__21:
	;
__19:
	;
__16:
	;
	goto __14
__13:
	alt_bsux =
		libc.Bool32(options&DPCRE2_ALT_BSUX|extra_options&DPCRE2_EXTRA_ALT_BSUX != uint32(0))

	// Filter calls from pcre2_substitute().

	if !(cb == uintptr(0)) {
		goto __25
	}

	if !(c != uint32('\143') && c != uint32('\157') && c != uint32('\170')) {
		goto __26
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR3
	return 0
__26:
	;
	alt_bsux = DFALSE // Do not modify \x handling
__25:
	;

	switch c {
	// A number of Perl escapes are not handled by PCRE. We give an explicit
	//     error.

	case uint32('\106'):
		goto __28
	case uint32('\154'):
		goto __29
	case uint32('\114'):
		goto __30

	// \u is unrecognized when neither PCRE2_ALT_BSUX nor PCRE2_EXTRA_ALT_BSUX
	//     is set. Otherwise, \u must be followed by exactly four hex digits or, if
	//     PCRE2_EXTRA_ALT_BSUX is set, by any number of hex digits in braces.
	//     Otherwise it is a lowercase u letter. This gives some compatibility with
	//     ECMAScript (aka JavaScript).

	case uint32('\165'):
		goto __31

	// \U is unrecognized unless PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set,
	//     in which case it is an upper case letter.

	case uint32('\125'):
		goto __32

	// In a character class, \g is just a literal "g". Outside a character
	//     class, \g must be followed by one of a number of specific things:
	//
	//     (1) A number, either plain or braced. If positive, it is an absolute
	//     backreference. If negative, it is a relative backreference. This is a Perl
	//     5.10 feature.
	//
	//     (2) Perl 5.10 also supports \g{name} as a reference to a named group. This
	//     is part of Perl's movement towards a unified syntax for back references. As
	//     this is synonymous with \k{name}, we fudge it up by pretending it really
	//     was \k{name}.
	//
	//     (3) For Oniguruma compatibility we also support \g followed by a name or a
	//     number either in angle brackets or in single quotes. However, these are
	//     (possibly recursive) subroutine calls, _not_ backreferences. We return
	//     the ESC_g code.
	//
	//     Summary: Return a negative number for a numerical back reference, ESC_k for
	//     a named back reference, and ESC_g for a named or numbered subroutine call.
	//

	case uint32('\147'):
		goto __33

	// The handling of escape sequences consisting of a string of digits
	//     starting with one that is not zero is not straightforward. Perl has changed
	//     over the years. Nowadays \g{} for backreferences and \o{} for octal are
	//     recommended to avoid the ambiguities in the old syntax.
	//
	//     Outside a character class, the digits are read as a decimal number. If the
	//     number is less than 10, or if there are that many previous extracting left
	//     brackets, it is a back reference. Otherwise, up to three octal digits are
	//     read to form an escaped character code. Thus \123 is likely to be octal 123
	//     (cf \0123, which is octal 012 followed by the literal 3).
	//
	//     Inside a character class, \ followed by a digit is always either a literal
	//     8 or 9 or an octal number.

	case uint32('\061'):
		goto __34
	case uint32('\062'):
		goto __35
	case uint32('\063'):
		goto __36
	case uint32('\064'):
		goto __37
	case uint32('\065'):
		goto __38
	case uint32('\066'):
		goto __39
	case uint32('\067'):
		goto __40
	case uint32('\070'):
		goto __41
	case uint32('\071'):
		goto __42

	// Fall through

	// \0 always starts an octal number, but we may drop through to here with a
	//     larger first octal digit. The original code used just to take the least
	//     significant 8 bits of octal numbers (I think this is what early Perls used
	//     to do). Nowadays we allow for larger numbers in UTF-8 mode and 16-bit mode,
	//     but no more than 3 octal digits.

	case uint32('\060'):
		goto __43

	// \o is a relatively new Perl feature, supporting a more general way of
	//     specifying character codes in octal. The only supported form is \o{ddd}.

	case uint32('\157'):
		goto __44

	// When PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set, \x must be followed
	//     by two hexadecimal digits. Otherwise it is a lowercase x letter.

	case uint32('\170'):
		goto __45

	// The handling of \c is different in ASCII and EBCDIC environments. In an
	//     ASCII (or Unicode) environment, an error is given if the character
	//     following \c is not a printable ASCII character. Otherwise, the following
	//     character is upper-cased if it is a letter, and after that the 0x40 bit is
	//     flipped. The result is the value of the escape.
	//
	//     In an EBCDIC environment the handling of \c is compatible with the
	//     specification in the perlebcdic document. The following character must be
	//     a letter or one of small number of special characters. These provide a
	//     means of defining the character values 0-31.
	//
	//     For testing the EBCDIC handling of \c in an ASCII environment, recognize
	//     the EBCDIC value of 'c' explicitly.

	case uint32('\143'):
		goto __46

	// Any other alphanumeric following \ is an error. Perl gives an error only
	//     if in warning mode, but PCRE doesn't have a warning mode.

	default:
		goto __47
	}
	goto __27

	// A number of Perl escapes are not handled by PCRE. We give an explicit
	//     error.

__28:
__29:
__30:
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR37
	goto __27

	// \u is unrecognized when neither PCRE2_ALT_BSUX nor PCRE2_EXTRA_ALT_BSUX
	//     is set. Otherwise, \u must be followed by exactly four hex digits or, if
	//     PCRE2_EXTRA_ALT_BSUX is set, by any number of hex digits in braces.
	//     Otherwise it is a lowercase u letter. This gives some compatibility with
	//     ECMAScript (aka JavaScript).

__31:
	if !!(alt_bsux != 0) {
		goto __48
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR37
	goto __49
__48:

	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) >= ptrend) {
		goto __50
	}
	goto __27
__50:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == '\173' && extra_options&DPCRE2_EXTRA_ALT_BSUX != uint32(0)) {
		goto __51
	}

	hptr = *(*uintptr)(unsafe.Pointer(bp + 24)) + uintptr(1)
	cc = uint32(0)

__53:
	if !(hptr < ptrend && libc.AssignUint32(&xc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(hptr))])) != uint32(0xff)) {
		goto __54
	}

	if !(cc&0xf0000000 != uint32(0)) {
		goto __55
	} /* Test for 32-bit overflow */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR77
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) = hptr // Show where
	goto __54                                             // *hptr != } will cause another break below
__55:
	;
	cc = cc<<4 | xc
	hptr++
	goto __53
__54:
	;

	if !(hptr == *(*uintptr)(unsafe.Pointer(bp + 24))+uintptr(1) || hptr >= ptrend || int32(*(*uint8)(unsafe.Pointer(hptr))) != '\175') {
		goto __56
	} // No } terminator
	goto __27
__56:
	; // Hex escape not recognized

	c = cc // Accept the code point
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) = hptr + uintptr(1)
	goto __52
__51: /* Must be exactly 4 hex digits */

	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 24))))/1 < int64(4)) {
		goto __57
	}
	goto __27
__57:
	; // Less than 4 chars
	if !(libc.AssignUint32(&cc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))])) == uint32(0xff)) {
		goto __58
	}
	goto __27
__58:
	; // Not a hex digit
	if !(libc.AssignUint32(&xc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 1))])) == uint32(0xff)) {
		goto __59
	}
	goto __27
__59:
	; // Not a hex digit
	cc = cc<<4 | xc
	if !(libc.AssignUint32(&xc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 2))])) == uint32(0xff)) {
		goto __60
	}
	goto __27
__60:
	; // Not a hex digit
	cc = cc<<4 | xc
	if !(libc.AssignUint32(&xc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 3))])) == uint32(0xff)) {
		goto __61
	}
	goto __27
__61:
	; // Not a hex digit
	c = cc<<4 | xc
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(4)
__52:
	;

	if !(utf != 0) {
		goto __62
	}

	if !(c > 0x10ffff) {
		goto __64
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR77
	goto __65
__64:
	if !(c >= uint32(0xd800) && c <= uint32(0xdfff) && extra_options&DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES == uint32(0)) {
		goto __66
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR73
__66:
	;
__65:
	;
	goto __63
__62:
	if !(c > uint32(0xffffffff)>>(32-DPCRE2_CODE_UNIT_WIDTH)) {
		goto __67
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR77
__67:
	;
__63:
	;
__49:
	;
	goto __27

	// \U is unrecognized unless PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set,
	//     in which case it is an upper case letter.

__32:
	if !!(alt_bsux != 0) {
		goto __68
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR37
__68:
	;
	goto __27

	// In a character class, \g is just a literal "g". Outside a character
	//     class, \g must be followed by one of a number of specific things:
	//
	//     (1) A number, either plain or braced. If positive, it is an absolute
	//     backreference. If negative, it is a relative backreference. This is a Perl
	//     5.10 feature.
	//
	//     (2) Perl 5.10 also supports \g{name} as a reference to a named group. This
	//     is part of Perl's movement towards a unified syntax for back references. As
	//     this is synonymous with \k{name}, we fudge it up by pretending it really
	//     was \k{name}.
	//
	//     (3) For Oniguruma compatibility we also support \g followed by a name or a
	//     number either in angle brackets or in single quotes. However, these are
	//     (possibly recursive) subroutine calls, _not_ backreferences. We return
	//     the ESC_g code.
	//
	//     Summary: Return a negative number for a numerical back reference, ESC_k for
	//     a named back reference, and ESC_g for a named or numbered subroutine call.
	//

__33:
	if !(isclass != 0) {
		goto __69
	}
	goto __27
__69:
	;

	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) >= ptrend) {
		goto __70
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR57
	goto __27
__70:
	;

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == '\074' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == '\047') {
		goto __71
	}

	escape = ESC_g
	goto __27
__71:
	;

	// If there is a brace delimiter, try to read a numerical reference. If
	//     there isn't one, assume we have a name and treat it as \k.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == '\173') {
		goto __72
	}

	*(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)) = *(*uintptr)(unsafe.Pointer(bp + 24)) + uintptr(1)
	if !!(read_number(tls, bp+8, ptrend, int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount), DMAX_GROUP_NUMBER, ERR61, bp+16,
		errorcodeptr) != 0) {
		goto __74
	}

	if !(*(*int32)(unsafe.Pointer(errorcodeptr)) == 0) {
		goto __75
	}
	escape = ESC_k
__75:
	; // No number found
	goto __27
__74:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\175') {
		goto __76
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR57
	goto __27
__76:
	;
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(1)
	goto __73
__72:

	if !!(read_number(tls, bp+24, ptrend, int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount), DMAX_GROUP_NUMBER, ERR61, bp+16,
		errorcodeptr) != 0) {
		goto __77
	}

	if !(*(*int32)(unsafe.Pointer(errorcodeptr)) == 0) {
		goto __78
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR57
__78:
	; // No number found
	goto __27
__77:
	;
__73:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 16)) <= 0) {
		goto __79
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15
	goto __27
__79:
	;

	escape = -*(*int32)(unsafe.Pointer(bp + 16 /* s */))
	goto __27

	// The handling of escape sequences consisting of a string of digits
	//     starting with one that is not zero is not straightforward. Perl has changed
	//     over the years. Nowadays \g{} for backreferences and \o{} for octal are
	//     recommended to avoid the ambiguities in the old syntax.
	//
	//     Outside a character class, the digits are read as a decimal number. If the
	//     number is less than 10, or if there are that many previous extracting left
	//     brackets, it is a back reference. Otherwise, up to three octal digits are
	//     read to form an escaped character code. Thus \123 is likely to be octal 123
	//     (cf \0123, which is octal 012 followed by the literal 3).
	//
	//     Inside a character class, \ followed by a digit is always either a literal
	//     8 or 9 or an octal number.

__34:
__35:
__36:
__37:
__38:
__39:
__40:
__41:
__42:

	if !!(isclass != 0) {
		goto __80
	}

	oldptr = *(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))-- // Back to the digit

	// As we know we are at a digit, the only possible error from
	//       read_number() is a number that is too large to be a group number. In this
	//       case we fall through handle this as not a group reference. If we have
	//       read a small enough number, check for a back reference.
	//
	//       \1 to \9 are always back references. \8x and \9x are too; \1x to \7x
	//       are octal escapes if there are not that many previous captures.

	if !(read_number(tls, bp+24, ptrend, -1, uint32(0x7fffffff/10-1), uint32(0), bp+16, errorcodeptr) != 0 && (*(*int32)(unsafe.Pointer(bp + 16)) < 10 || int32(*(*uint8)(unsafe.Pointer(oldptr + libc.UintptrFromInt32(-1)))) >= '\070' || *(*int32)(unsafe.Pointer(bp + 16)) <= int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount))) {
		goto __81
	}

	if !(*(*int32)(unsafe.Pointer(bp + 16)) > int32(DMAX_GROUP_NUMBER)) {
		goto __82
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR61
	goto __83
__82:
	escape = -*(*int32)(unsafe.Pointer(bp + 16 /* s */))
__83:
	; // Indicates a back reference
	goto __27
__81:
	;

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) = oldptr // Put the pointer back and fall through
__80:
	;

	// Handle a digit following \ when the number is not a back reference, or
	//     we are within a character class. If the first digit is 8 or 9, Perl used to
	//     generate a binary zero and then treat the digit as a following literal. At
	//     least by Perl 5.18 this changed so as not to insert the binary zero.

	if !(c >= uint32('\070')) {
		goto __84
	}
	goto __27
__84:
	;

	// Fall through

	// \0 always starts an octal number, but we may drop through to here with a
	//     larger first octal digit. The original code used just to take the least
	//     significant 8 bits of octal numbers (I think this is what early Perls used
	//     to do). Nowadays we allow for larger numbers in UTF-8 mode and 16-bit mode,
	//     but no more than 3 octal digits.

__43:
	c = c - uint32('\060')
__85:
	if !(libc.PostIncInt32(&i, 1) < 2 && *(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) <= '\067') {
		goto __86
	}
	c = c*uint32(8) + uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24)), 1)))) - uint32('\060')
	goto __85
__86:
	;
	if !(!(utf != 0) && c > uint32(0xff)) {
		goto __87
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR51
__87:
	;
	goto __27

	// \o is a relatively new Perl feature, supporting a more general way of
	//     specifying character codes in octal. The only supported form is \o{ddd}.

__44:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24)), 1)))) != '\173') {
		goto __88
	}

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR55
	goto __89
__88:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == '\175') {
		goto __90
	}
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR78
	goto __91
__90:

	c = uint32(0)
	overflow = DFALSE
__92:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) <= '\067') {
		goto __93
	}

	cc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)), 1))))
	if !(c == uint32(0) && cc == uint32('\060')) {
		goto __94
	}
	goto __92
__94:
	; // Leading zeroes
	c = c<<3 + (cc - uint32('\060'))
	if !(c > func() uint32 {
		if utf != 0 {
			return 0x10ffff
		}
		return 0xff
	}()) {
		goto __95
	}
	overflow = DTRUE
	goto __93
__95:
	;
	goto __92
__93:
	;
	if !(overflow != 0) {
		goto __96
	}

__98:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) <= '\067') {
		goto __99
	}
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))++
	goto __98
__99:
	;
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR34
	goto __97
__96:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24)), 1)))) == '\175') {
		goto __100
	}

	if !(utf != 0 && c >= uint32(0xd800) && c <= uint32(0xdfff) && extra_options&DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES == uint32(0)) {
		goto __102
	}

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR73
__102:
	;
	goto __101
__100:

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR64
__101:
	;
__97:
	;
__91:
	;
__89:
	;
	goto __27

	// When PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set, \x must be followed
	//     by two hexadecimal digits. Otherwise it is a lowercase x letter.

__45:
	if !(alt_bsux != 0) {
		goto __103
	}

	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 24))))/1 < int64(2)) {
		goto __105
	}
	goto __27
__105:
	; // Less than 2 characters
	if !(libc.AssignUint32(&cc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))])) == uint32(0xff)) {
		goto __106
	}
	goto __27
__106:
	; // Not a hex digit
	if !(libc.AssignUint32(&xc1, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 1))])) == uint32(0xff)) {
		goto __107
	}
	goto __27
__107:
	; // Not a hex digit
	c = cc<<4 | xc1
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)) += uintptr(2)
	goto __104
__103:

	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == '\173') {
		goto __108
	}

COME_FROM_NU:
	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24)), 1) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == '\175') {
		goto __110
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR78
	goto __27
__110:
	;
	c = uint32(0)
	overflow = DFALSE

__111:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && libc.AssignUint32(&cc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))])) != uint32(0xff)) {
		goto __112
	}

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))++
	if !(c == uint32(0) && cc == uint32(0)) {
		goto __113
	}
	goto __111
__113:
	; // Leading zeroes
	c = c<<4 | cc
	if !(utf != 0 && c > 0x10ffff || !(utf != 0) && c > uint32(0xffffffff)>>(32-DPCRE2_CODE_UNIT_WIDTH)) {
		goto __114
	}

	overflow = DTRUE
	goto __112
__114:
	;
	goto __111
__112:
	;

	if !(overflow != 0) {
		goto __115
	}

__117:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && int32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))]) != 0xff) {
		goto __118
	}
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))++
	goto __117
__118:
	;
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR34
	goto __116
__115:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) < ptrend && int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24)), 1)))) == '\175') {
		goto __119
	}

	if !(utf != 0 && c >= uint32(0xd800) && c <= uint32(0xdfff) && extra_options&DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES == uint32(0)) {
		goto __121
	}

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR73
__121:
	;
	goto __120
__119:

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))--
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR67
__120:
	;
__116:
	;
	goto __109
__108:

	c = uint32(0)
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) >= ptrend || libc.AssignUint32(&cc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))])) == uint32(0xff)) {
		goto __122
	}
	goto __27
__122:
	; // Not a hex digit
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))++
	c = cc
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) >= ptrend || libc.AssignUint32(&cc, uint32(xdigitab[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))])) == uint32(0xff)) {
		goto __123
	}
	goto __27
__123:
	; // Not a hex digit
	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))++
	c = c<<4 | cc
__109:
	; // End of \xdd handling
__104:
	; // End of Perl-style \x handling
	goto __27

	// The handling of \c is different in ASCII and EBCDIC environments. In an
	//     ASCII (or Unicode) environment, an error is given if the character
	//     following \c is not a printable ASCII character. Otherwise, the following
	//     character is upper-cased if it is a letter, and after that the 0x40 bit is
	//     flipped. The result is the value of the escape.
	//
	//     In an EBCDIC environment the handling of \c is compatible with the
	//     specification in the perlebcdic document. The following character must be
	//     a letter or one of small number of special characters. These provide a
	//     means of defining the character values 0-31.
	//
	//     For testing the EBCDIC handling of \c in an ASCII environment, recognize
	//     the EBCDIC value of 'c' explicitly.

__46:
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) >= ptrend) {
		goto __124
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR2
	goto __27
__124:
	;
	c = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */)))))
	if !(c >= uint32('\141') && c <= uint32('\172')) {
		goto __125
	}
	c = c - uint32(32)
__125:
	;

	// Handle \c in an ASCII/Unicode environment.

	if !(c < uint32(32) || c > uint32(126)) {
		goto __126
	} /* Excludes all non-printable ASCII */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR68
	goto __27
__126:
	;
	c = c ^ uint32(0x40)

	// Handle \c in an EBCDIC environment. The special case \c? is converted to
	//     255 (0xff) or 95 (0x5f) if other characters suggest we are using the
	//     POSIX-BC encoding. (This is the way Perl indicates that it handles \c?.)
	//     The other valid sequences correspond to a list of specific characters.

	*(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))++
	goto __27

	// Any other alphanumeric following \ is an error. Perl gives an error only
	//     if in warning mode, but PCRE doesn't have a warning mode.

__47:
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR3
	*(*uintptr)(unsafe.Pointer(ptrptr)) = *(*uintptr)(unsafe.Pointer(bp + 24)) - uintptr(1) // Point to the character at fault
	return 0
__27:
	;
__14:
	;
__12:
	;

	// Set the pointer to the next character before returning.

	*(*uintptr)(unsafe.Pointer(ptrptr)) = *(*uintptr)(unsafe.Pointer(bp + 24 /* ptr */))
	*(*uint32)(unsafe.Pointer(chptr)) = c
	return escape
}

// ************************************************
//
//               Handle \P and \p                 *
//

// This function is called after \P or \p has been encountered, provided that
// PCRE2 is compiled with support for UTF and Unicode properties. On entry, the
// contents of ptrptr are pointing after the P or p. On exit, it is left pointing
// after the final code unit of the escape sequence.
//
// Arguments:
//   ptrptr         the pattern position pointer
//   negptr         a boolean that is set TRUE for negation else FALSE
//   ptypeptr       an unsigned int that is set to the type value
//   pdataptr       an unsigned int that is set to the detailed property value
//   errorcodeptr   the error code variable
//   cb             the compile data
//
// Returns:         TRUE if the type value was found, or FALSE for an invalid type

func get_ucp(tls *libc.TLS, ptrptr uintptr, negptr uintptr, ptypeptr uintptr, pdataptr uintptr, errorcodeptr uintptr, cb uintptr) int32 { /* pcre2_compile.c:2089:1: */
	bp := tls.Alloc(58)
	defer tls.Free(58)

	var c uint8
	var i uint64
	var bot uint64
	var top uint64
	var ptr uintptr
	// var name [50]uint8 at bp, 50

	var vptr uintptr
	var ptscript uint16
	var offset int32
	// var sname [8]uint8 at bp+50, 8

	var r int32
	ptr = *(*uintptr)(unsafe.Pointer(ptrptr))
	vptr = uintptr(0)
	ptscript = uint16(DPT_NOTSCRIPT)

	if !(ptr >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern) {
		goto __1
	}
	goto ERROR_RETURN
__1:
	;
	c = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))
	*(*int32)(unsafe.Pointer(negptr)) = DFALSE

	// \P or \p can be followed by a name in {}, optionally preceded by ^ for
	// negation.

	if !(int32(c) == '\173') {
		goto __2
	}

	if !(ptr >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern) {
		goto __4
	}
	goto ERROR_RETURN
__4:
	;

	if !(int32(*(*uint8)(unsafe.Pointer(ptr))) == '\136') {
		goto __5
	}

	*(*int32)(unsafe.Pointer(negptr)) = DTRUE
	ptr++
__5:
	;

	i = uint64(0)
__6:
	if !(i < uint64(int32(uint64(unsafe.Sizeof([50]uint8{}))/uint64(unsafe.Sizeof(uint8(0))))-1)) {
		goto __8
	}

	if !(ptr >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern) {
		goto __9
	}
	goto ERROR_RETURN
__9:
	;
	c = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))
__10:
	if !(int32(c) == '_' || int32(c) == '-' || int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2)))&int32(_ISspace) != 0) {
		goto __11
	}

	if !(ptr >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern) {
		goto __12
	}
	goto ERROR_RETURN
__12:
	;
	c = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))
	goto __10
__11:
	;
	if !(int32(c) == 0) {
		goto __13
	}
	goto ERROR_RETURN
__13:
	;
	if !(int32(c) == '\175') {
		goto __14
	}
	goto __8
__14:
	;
	*(*uint8)(unsafe.Pointer(bp + uintptr(i))) = uint8(libc.Xtolower(tls, int32(c)))
	if !((int32(c) == ':' || int32(c) == '=') && vptr == uintptr(0)) {
		goto __15
	}
	vptr = bp + uintptr(i)
__15:
	;
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;

	if !(int32(c) != '\175') {
		goto __16
	}
	goto ERROR_RETURN
__16:
	;
	*(*uint8)(unsafe.Pointer(bp + uintptr(i))) = uint8(0)
	goto __3
__2:
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(c))))&Dctype_letter != 0) {
		goto __17
	}

	*(*uint8)(unsafe.Pointer(bp)) = uint8(libc.Xtolower(tls, int32(c)))
	*(*uint8)(unsafe.Pointer(bp + 1)) = uint8(0)
	goto __18
__17:
	goto ERROR_RETURN
__18:
	;
__3:
	;

	*(*uintptr)(unsafe.Pointer(ptrptr)) = ptr

	// If the property contains ':' or '=' we have class name and value separately
	// specified. The following are supported:
	//
	//   . Bidi_Class (synonym bc), for which the property names are "bidi<name>".
	//   . Script (synonym sc) for which the property name is the script name
	//   . Script_Extensions (synonym scx), ditto
	//
	// As this is a small number, we currently just check the names directly. If this
	// grows, a sorted table and a switch will be neater.
	//
	// For both the script properties, set a PT_xxx value so that (1) they can be
	// distinguished and (2) invalid script names that happen to be the name of
	// another property can be diagnosed.

	if !(vptr != uintptr(0)) {
		goto __19
	}

	offset = 0

	*(*uint8)(unsafe.Pointer(vptr)) = uint8(0) // Terminate property name
	if !(X_pcre2_strcmp_c8_8(tls, bp, ts+553) == 0 || X_pcre2_strcmp_c8_8(tls, bp, ts+563) == 0) {
		goto __20
	}

	offset = 4
	*(*uint8)(unsafe.Pointer(bp + 50)) = uint8('\142')
	*(*uint8)(unsafe.Pointer(bp + 50 + 1)) = uint8('\151') // There is no strcpy_c8 function
	*(*uint8)(unsafe.Pointer(bp + 50 + 2)) = uint8('\144')
	*(*uint8)(unsafe.Pointer(bp + 50 + 3)) = uint8('\151')
	goto __21
__20:
	if !(X_pcre2_strcmp_c8_8(tls, bp, ts+566) == 0 || X_pcre2_strcmp_c8_8(tls, bp, ts+573) == 0) {
		goto __22
	}
	ptscript = uint16(DPT_SC)
	goto __23
__22:
	if !(X_pcre2_strcmp_c8_8(tls, bp, ts+576) == 0 || X_pcre2_strcmp_c8_8(tls, bp, ts+593) == 0) {
		goto __24
	}
	ptscript = uint16(DPT_SCX)
	goto __25
__24:

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR47
	return DFALSE
__25:
	;
__23:
	;
__21:
	;

	// Adjust the string in name[] as needed

	libc.Xmemmove(tls, bp+uintptr(offset), vptr+uintptr(1), uint64((int64(bp+uintptr(i))-int64(vptr))/1)*uint64(unsafe.Sizeof(uint8(0))))
	if !(offset != 0) {
		goto __26
	}
	libc.Xmemmove(tls, bp, bp+50, uint64(offset)*uint64(unsafe.Sizeof(uint8(0))))
__26:
	;
__19:
	;

	// Search for a recognized property using binary chop.

	bot = uint64(0)
	top = X_pcre2_utt_size_8

__27:
	if !(bot < top) {
		goto __28
	}

	i = (bot + top) >> 1
	r = X_pcre2_strcmp_c8_8(tls, bp, uintptr(unsafe.Pointer(&X_pcre2_utt_names_8))+uintptr(X_pcre2_utt_8[i].Fname_offset))

	// When a matching property is found, some extra checking is needed when the
	//   \p{xx:yy} syntax is used and xx is either sc or scx.

	if !(r == 0) {
		goto __29
	}

	*(*uint16)(unsafe.Pointer(pdataptr)) = X_pcre2_utt_8[i].Fvalue
	if !(vptr == uintptr(0) || int32(ptscript) == DPT_NOTSCRIPT) {
		goto __30
	}

	*(*uint16)(unsafe.Pointer(ptypeptr)) = X_pcre2_utt_8[i].Ftype
	return DTRUE
__30:
	;

	switch int32(X_pcre2_utt_8[i].Ftype) {
	case DPT_SC:
		goto __32

	case DPT_SCX:
		goto __33
	}
	goto __31

__32:
	*(*uint16)(unsafe.Pointer(ptypeptr)) = uint16(DPT_SC)
	return DTRUE

__33:
	*(*uint16)(unsafe.Pointer(ptypeptr)) = ptscript
	return DTRUE
__31:
	;

	goto __28 // Non-script found
__29:
	;

	if !(r > 0) {
		goto __34
	}
	bot = i + uint64(1)
	goto __35
__34:
	top = i
__35:
	;
	goto __27
__28:
	;

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR47 // Unrecognized property
	return DFALSE

ERROR_RETURN: // Malformed \P or \p
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR46
	*(*uintptr)(unsafe.Pointer(ptrptr)) = ptr
	return DFALSE
}

// ************************************************
//
//           Check for POSIX class syntax         *
//

// This function is called when the sequence "[:" or "[." or "[=" is
// encountered in a character class. It checks whether this is followed by a
// sequence of characters terminated by a matching ":]" or ".]" or "=]". If we
// reach an unescaped ']' without the special preceding character, return FALSE.
//
// Originally, this function only recognized a sequence of letters between the
// terminators, but it seems that Perl recognizes any sequence of characters,
// though of course unknown POSIX names are subsequently rejected. Perl gives an
// "Unknown POSIX class" error for [:f\oo:] for example, where previously PCRE
// didn't consider this to be a POSIX class. Likewise for [:1234:].
//
// The problem in trying to be exactly like Perl is in the handling of escapes. We
// have to be sure that [abc[:x\]pqr] is *not* treated as containing a POSIX
// class, but [abc[:x\]pqr:]] is (so that an error can be generated). The code
// below handles the special cases \\ and \], but does not try to do any other
// escape processing. This makes it different from Perl for cases such as
// [:l\ower:] where Perl recognizes it as the POSIX class "lower" but PCRE does
// not recognize "l\ower". This is a lesser evil than not diagnosing bad classes
// when Perl does, I think.
//
// A user pointed out that PCRE was rejecting [:a[:digit:]] whereas Perl was not.
// It seems that the appearance of a nested POSIX class supersedes an apparent
// external class. For example, [:a[:digit:]b:] matches "a", "b", ":", or
// a digit. This is handled by returning FALSE if the start of a new group with
// the same terminator is encountered, since the next closing sequence must close
// the nested group, not the outer one.
//
// In Perl, unescaped square brackets may also appear as part of class names. For
// example, [:a[:abc]b:] gives unknown POSIX class "[:abc]b:]". However, for
// [:a[:abc]b][b:] it gives unknown POSIX class "[:abc]b][b:]", which does not
// seem right at all. PCRE does not allow closing square brackets in POSIX class
// names.
//
// Arguments:
//   ptr      pointer to the character after the initial [ (colon, dot, equals)
//   ptrend   pointer to the end of the pattern
//   endptr   where to return a pointer to the terminating ':', '.', or '='
//
// Returns:   TRUE or FALSE

func check_posix_syntax(tls *libc.TLS, ptr uintptr, ptrend uintptr, endptr uintptr) int32 { /* pcre2_compile.c:2295:1: */
	var terminator uint8                                                 // Don't combine these lines; the Solaris cc
	terminator = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))) // compiler warns about "non-constant" initializer.

	for ; (int64(ptrend)-int64(ptr))/1 >= int64(2); ptr++ {
		if int32(*(*uint8)(unsafe.Pointer(ptr))) == '\134' && (int32(*(*uint8)(unsafe.Pointer(ptr + 1))) == '\135' || int32(*(*uint8)(unsafe.Pointer(ptr + 1))) == '\134') {
			ptr++
		} else if int32(*(*uint8)(unsafe.Pointer(ptr))) == '\133' && int32(*(*uint8)(unsafe.Pointer(ptr + 1))) == int32(terminator) || int32(*(*uint8)(unsafe.Pointer(ptr))) == '\135' {
			return DFALSE
		} else if int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(terminator) && int32(*(*uint8)(unsafe.Pointer(ptr + 1))) == '\135' {
			*(*uintptr)(unsafe.Pointer(endptr)) = ptr
			return DTRUE
		}
	}

	return DFALSE
}

// ************************************************
//
//          Check POSIX class name                *
//

// This function is called to check the name given in a POSIX-style class entry
// such as [:alnum:].
//
// Arguments:
//   ptr        points to the first letter
//   len        the length of the name
//
// Returns:     a value representing the name, or -1 if unknown

func check_posix_name(tls *libc.TLS, ptr uintptr, len int32) int32 { /* pcre2_compile.c:2336:1: */
	var pn uintptr = uintptr(unsafe.Pointer(&posix_names))
	var yield int32 = 0
	for int32(posix_name_lengths[yield]) != 0 {
		if len == int32(posix_name_lengths[yield]) && X_pcre2_strncmp_c8_8(tls, ptr, pn, uint64(uint32(len))) == 0 {
			return yield
		}
		pn += uintptr(int32(posix_name_lengths[yield]) + 1)
		yield++
	}
	return -1
}

// ************************************************
//
//       Read a subpattern or VERB name           *
//

// This function is called from parse_regex() below whenever it needs to read
// the name of a subpattern or a (*VERB) or an (*alpha_assertion). The initial
// pointer must be to the character before the name. If that character is '*' we
// are reading a verb or alpha assertion name. The pointer is updated to point
// after the name, for a VERB or alpha assertion name, or after tha name's
// terminator for a subpattern name. Returning both the offset and the name
// pointer is redundant information, but some callers use one and some the other,
// so it is simplest just to return both.
//
// Arguments:
//   ptrptr      points to the character pointer variable
//   ptrend      points to the end of the input string
//   utf         true if the input is UTF-encoded
//   terminator  the terminator of a subpattern name must be this
//   offsetptr   where to put the offset from the start of the pattern
//   nameptr     where to put a pointer to the name in the input
//   namelenptr  where to put the length of the name
//   errcodeptr  where to put an error code
//   cb          pointer to the compile data block
//
// Returns:    TRUE if a name was read
//             FALSE otherwise, with error code set

func read_name(tls *libc.TLS, ptrptr uintptr, ptrend uintptr, utf int32, terminator uint32, offsetptr uintptr, nameptr uintptr, namelenptr uintptr, errorcodeptr uintptr, cb uintptr) int32 { /* pcre2_compile.c:2381:1: */
	var ptr uintptr
	var is_group int32
	var c uint32
	var type1 uint32
	ptr = *(*uintptr)(unsafe.Pointer(ptrptr))
	is_group = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(ptr))) != '\052')

	if !(libc.PreIncUintptr(&ptr, 1) >= ptrend) {
		goto __1
	} /* No characters in name */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = func() int32 {
		if is_group != 0 {
			return ERR62
		}
		return ERR60
	}() // Verb not recognized or malformed
	goto FAILED
__1:
	;

	*(*uintptr)(unsafe.Pointer(nameptr)) = ptr
	*(*uint64)(unsafe.Pointer(offsetptr)) = uint64((int64(ptr) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)

	// In UTF mode, a group name may contain letters and decimal digits as defined
	// by Unicode properties, and underscores, but must not start with a digit.

	if !(utf != 0 && is_group != 0) {
		goto __2
	}

	c = uint32(*(*uint8)(unsafe.Pointer(ptr)))
	if !(c >= 0xc0) {
		goto __4
	}
	if !(c&0x20 == uint32(0)) {
		goto __5
	}
	c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f
	goto __6
__5:
	if !(c&0x10 == uint32(0)) {
		goto __7
	}
	c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f
	goto __8
__7:
	if !(c&0x08 == uint32(0)) {
		goto __9
	}
	c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f
	goto __10
__9:
	if !(c&0x04 == uint32(0)) {
		goto __11
	}
	c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f
	goto __12
__11:
	c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 5)))&0x3f
__12:
	;
__10:
	;
__8:
	;
__6:
	;
__4:
	;

	type1 = uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fchartype)

	if !(type1 == ucp_Nd) {
		goto __13
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR44
	goto FAILED
__13:
	;

__14:

	if !(type1 != ucp_Nd && X_pcre2_ucp_gentype_8[type1] != ucp_L && c != uint32('\137')) {
		goto __17
	}
	goto __16
__17:
	;
	ptr++
__18:
	if !(ptr < ptrend && uint32(*(*uint8)(unsafe.Pointer(ptr)))&0xc0 == 0x80) {
		goto __19
	}
	ptr++
	goto __18
__19:
	;
	if !(ptr >= ptrend) {
		goto __20
	}
	goto __16
__20:
	;
	c = uint32(*(*uint8)(unsafe.Pointer(ptr)))
	if !(c >= 0xc0) {
		goto __21
	}
	if !(c&0x20 == uint32(0)) {
		goto __22
	}
	c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f
	goto __23
__22:
	if !(c&0x10 == uint32(0)) {
		goto __24
	}
	c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f
	goto __25
__24:
	if !(c&0x08 == uint32(0)) {
		goto __26
	}
	c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f
	goto __27
__26:
	if !(c&0x04 == uint32(0)) {
		goto __28
	}
	c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f
	goto __29
__28:
	c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 5)))&0x3f
__29:
	;
__27:
	;
__25:
	;
__23:
	;
__21:
	;

	type1 = uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fchartype)
	goto __15
__15:
	goto __14
	goto __16
__16:
	;
	goto __3
__2:

	/* Handle non-group names and group names in non-UTF modes. A group name must
	   not start with a digit. If either of the others start with a digit it just
	   won't be recognized. */

	if !(is_group != 0 && (int32(*(*uint8)(unsafe.Pointer(ptr))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(ptr))) <= '\071')) {
		goto __30
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR44
	goto FAILED
__30:
	;

__31:
	if !(ptr < ptrend && 1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer(ptr))))))&Dctype_word != 0) {
		goto __32
	}

	ptr++
	goto __31
__32:
	;
__3:
	;

	// Check name length

	if !(ptr > *(*uintptr)(unsafe.Pointer(nameptr))+uintptr(DMAX_NAME_SIZE)) {
		goto __33
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR48
	goto FAILED
__33:
	;
	*(*uint32)(unsafe.Pointer(namelenptr)) = uint32((int64(ptr) - int64(*(*uintptr)(unsafe.Pointer(nameptr)))) / 1)

	// Subpattern names must not be empty, and their terminator is checked here.
	// (What follows a verb or alpha assertion name is checked separately.)

	if !(is_group != 0) {
		goto __34
	}

	if !(ptr == *(*uintptr)(unsafe.Pointer(nameptr))) {
		goto __35
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR62 // Subpattern name expected
	goto FAILED
__35:
	;
	if !(ptr >= ptrend || int32(*(*uint8)(unsafe.Pointer(ptr))) != int32(uint8(terminator))) {
		goto __36
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR42
	goto FAILED
__36:
	;
	ptr++
__34:
	;

	*(*uintptr)(unsafe.Pointer(ptrptr)) = ptr
	return DTRUE

FAILED:
	*(*uintptr)(unsafe.Pointer(ptrptr)) = ptr
	return DFALSE
}

// ************************************************
//
//          Manage callouts at start of cycle     *
//

// At the start of a new item in parse_regex() we are able to record the
// details of the previous item in a prior callout, and also to set up an
// automatic callout if enabled. Avoid having two adjacent automatic callouts,
// which would otherwise happen for items such as \Q that contribute nothing to
// the parsed pattern.
//
// Arguments:
//   ptr              current pattern pointer
//   pcalloutptr      points to a pointer to previous callout, or NULL
//   auto_callout     TRUE if auto_callouts are enabled
//   parsed_pattern   the parsed pattern pointer
//   cb               compile block
//
// Returns: possibly updated parsed_pattern pointer.

func manage_callouts(tls *libc.TLS, ptr uintptr, pcalloutptr uintptr, auto_callout int32, parsed_pattern uintptr, cb uintptr) uintptr { /* pcre2_compile.c:2505:17: */
	var previous_callout uintptr = *(*uintptr)(unsafe.Pointer(pcalloutptr))

	if previous_callout != uintptr(0) {
		*(*uint32)(unsafe.Pointer(previous_callout + 2*4)) = uint32(uint64((int64(ptr)-int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern))/1) - uint64(*(*uint32)(unsafe.Pointer(previous_callout + 1*4))))
	}

	if !(auto_callout != 0) {
		previous_callout = uintptr(0)
	} else {
		if previous_callout == uintptr(0) || previous_callout != parsed_pattern-uintptr(4)*4 || *(*uint32)(unsafe.Pointer(previous_callout + 3*4)) != uint32(255) {
			previous_callout = parsed_pattern // Set up new automatic callout
			parsed_pattern += 4 * uintptr(4)
			*(*uint32)(unsafe.Pointer(previous_callout)) = DMETA_CALLOUT_NUMBER
			*(*uint32)(unsafe.Pointer(previous_callout + 2*4)) = uint32(0)
			*(*uint32)(unsafe.Pointer(previous_callout + 3*4)) = uint32(255)
		}
		*(*uint32)(unsafe.Pointer(previous_callout + 1*4)) = uint32((int64(ptr) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	}

	*(*uintptr)(unsafe.Pointer(pcalloutptr)) = previous_callout
	return parsed_pattern
}

// ************************************************
//
//      Parse regex and identify named groups     *
//

// This function is called first of all. It scans the pattern and does two
// things: (1) It identifies capturing groups and makes a table of named capturing
// groups so that information about them is fully available to both the compiling
// scans. (2) It writes a parsed version of the pattern with comments omitted and
// escapes processed into the parsed_pattern vector.
//
// Arguments:
//   ptr             points to the start of the pattern
//   options         compiling dynamic options (may change during the scan)
//   has_lookbehind  points to a boolean, set TRUE if a lookbehind is found
//   cb              pointer to the compile data block
//
// Returns:   zero on success or a non-zero error code, with the
//              error offset placed in the cb field

// A structure and some flags for dealing with nested groups.

type Snest_save = struct {
	Fnest_depth  uint16
	Freset_group uint16
	Fmax_group   uint16
	Fflags       uint16
	Foptions     uint32
} /* pcre2_compile.c:2557:9 */

// ************************************************
//
//      Parse regex and identify named groups     *
//

// This function is called first of all. It scans the pattern and does two
// things: (1) It identifies capturing groups and makes a table of named capturing
// groups so that information about them is fully available to both the compiling
// scans. (2) It writes a parsed version of the pattern with comments omitted and
// escapes processed into the parsed_pattern vector.
//
// Arguments:
//   ptr             points to the start of the pattern
//   options         compiling dynamic options (may change during the scan)
//   has_lookbehind  points to a boolean, set TRUE if a lookbehind is found
//   cb              pointer to the compile data block
//
// Returns:   zero on success or a non-zero error code, with the
//              error offset placed in the cb field

// A structure and some flags for dealing with nested groups.

type Tnest_save = Snest_save /* pcre2_compile.c:2563:3 */

// Only in 32-bit mode can there be literals > META_END. A macro encapsulates
// the storing of literal values in the main parsed pattern, where they can always
// be quantified.

// Here's the actual function.

func parse_regex(tls *libc.TLS, ptr uintptr, options uint32, has_lookbehind uintptr, cb uintptr) int32 { /* pcre2_compile.c:2600:12: */
	bp := tls.Alloc(104)
	defer tls.Free(104)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = ptr

	// var c uint32 at bp+16, 4

	var delimiter uint32
	// var namelen uint32 at bp+72, 4

	var class_range_state uint32
	var verblengthptr uintptr // Value avoids compiler warning
	var verbstartptr uintptr
	// var previous_callout uintptr at bp, 8

	var parsed_pattern uintptr
	var parsed_pattern_end uintptr
	var meta_quantifier uint32
	var add_after_mark uint32
	var extra_options uint32
	var nest_depth uint16
	var after_manual_callout int32
	var expect_cond_assert int32
	// var errorcode int32 at bp+20, 4

	var escape int32
	// var i int32 at bp+48, 4

	var inescq int32
	var inverbname int32
	var utf int32
	var auto_callout int32
	var isdupname int32
	var negate_class int32
	var okquantifier int32
	var thisptr uintptr
	// var name uintptr at bp+64, 8

	var ptrend uintptr
	var verbnamestart uintptr // Value avoids compiler warning
	var ng uintptr
	var top_nest uintptr
	var end_nests uintptr
	var verbnamelength uint64
	var ok int32
	// var negated int32 at bp+32, 4

	// var ptype uint16 at bp+36, 2

	// var pdata uint16 at bp+38, 2

	// var p uintptr at bp+40, 8

	var p1 uintptr
	var ptype1 int32
	var pvalue int32
	var posix_negate int32
	var posix_class int32
	// var negated1 int32 at bp+84, 4

	// var ptype2 uint16 at bp+88, 2

	// var pdata1 uint16 at bp+90, 2

	var char_is_literal int32
	var meta uint32
	var vn uintptr
	var hyphenok int32
	var oldoptions uint32
	var calloutlength uint64
	var startptr uintptr
	var n int32
	var ge uint32
	// var major int32 at bp+100, 4

	var minor int32
	var was_r_ampersand int32
	var newsize uint32
	var newspace uintptr
	var prev_expect_cond_assert int32
	// var min_repeat uint32 at bp+76, 4

	// var max_repeat uint32 at bp+80, 4

	// var set uint32 at bp+92, 4

	// var unset uint32 at bp+96, 4

	var optset uintptr
	var terminator uint32
	var prev_meta_quantifier uint32
	var prev_okquantifier int32
	// var tempptr uintptr at bp+24, 8

	// var offset uint64 at bp+56, 8
	verblengthptr = uintptr(0)
	verbstartptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp /* previous_callout */)) = uintptr(0)
	parsed_pattern = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fparsed_pattern
	parsed_pattern_end = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fparsed_pattern_end
	meta_quantifier = uint32(0)
	add_after_mark = uint32(0)
	extra_options = (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options
	nest_depth = uint16(0)
	after_manual_callout = 0
	expect_cond_assert = 0
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = 0
	inescq = DFALSE
	inverbname = DFALSE
	utf = libc.Bool32(options&DPCRE2_UTF != uint32(0))
	auto_callout = libc.Bool32(options&DPCRE2_AUTO_CALLOUT != uint32(0))
	okquantifier = DFALSE
	ptrend = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern
	verbnamestart = uintptr(0)

	// Insert leading items for word and line matching (features provided for the
	// benefit of pcre2grep).

	if !(extra_options&DPCRE2_EXTRA_MATCH_LINE != uint32(0)) {
		goto __1
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CIRCUMFLEX
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
	goto __2
__1:
	if !(extra_options&DPCRE2_EXTRA_MATCH_WORD != uint32(0)) {
		goto __3
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_b
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
__3:
	;
__2:
	;

	// If the pattern is actually a literal string, process it separately to avoid
	// cluttering up the main loop.

	if !(options&DPCRE2_LITERAL != uint32(0)) {
		goto __4
	}

__5:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __6
	}

	if !(parsed_pattern >= parsed_pattern_end) {
		goto __7
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR63 // Internal error (parsed pattern overflow)
	goto FAILED
__7:
	;
	thisptr = *(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __8
	}
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x20 == uint32(0)) {
		goto __9
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __10
__9:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x10 == uint32(0)) {
		goto __11
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __12
__11:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x08 == uint32(0)) {
		goto __13
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __14
__13:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x04 == uint32(0)) {
		goto __15
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __16
__15:
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__16:
	;
__14:
	;
__12:
	;
__10:
	;
__8:
	;

	if !(auto_callout != 0) {
		goto __17
	}
	parsed_pattern = manage_callouts(tls, thisptr, bp,
		auto_callout, parsed_pattern, cb)
__17:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

	goto __5
__6:
	;
	goto PARSED_END
__4:
	;

	// Process a real regex which may contain meta-characters.

	top_nest = uintptr(0)
	end_nests = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fworkspace_size)

	// The size of the nest_save structure might not be a factor of the size of the
	// workspace. Therefore we must round down end_nests so as to correctly avoid
	// creating a nest_save that spans the end of the workspace.

	end_nests = end_nests - uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fworkspace_size*uint64(unsafe.Sizeof(uint8(0)))%uint64(unsafe.Sizeof(Tnest_save{})))

	// PCRE2_EXTENDED_MORE implies PCRE2_EXTENDED

	if !(options&DPCRE2_EXTENDED_MORE != uint32(0)) {
		goto __18
	}
	options = options | DPCRE2_EXTENDED
__18:
	;

	// Now scan the pattern

__19:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __20
	}
	*(*uint32)(unsafe.Pointer(bp + 76 /* min_repeat */)) = uint32(0)
	*(*uint32)(unsafe.Pointer(bp + 80 /* max_repeat */)) = uint32(0)

	if !(parsed_pattern >= parsed_pattern_end) {
		goto __21
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR63 // Internal error (parsed pattern overflow)
	goto FAILED
__21:
	;

	if !(uint32(nest_depth) > (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fparens_nest_limit) {
		goto __22
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR19
	goto FAILED // Parentheses too deeply nested
__22:
	;

	// Get next input character, save its position for callout handling.

	thisptr = *(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __23
	}
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x20 == uint32(0)) {
		goto __24
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __25
__24:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x10 == uint32(0)) {
		goto __26
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __27
__26:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x08 == uint32(0)) {
		goto __28
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __29
__28:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x04 == uint32(0)) {
		goto __30
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __31
__30:
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__31:
	;
__29:
	;
__27:
	;
__25:
	;
__23:
	;

	// Copy quoted literals until \E, allowing for the possibility of automatic
	//   callouts, except when processing a (*VERB) "name".

	if !(inescq != 0) {
		goto __32
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\134') && *(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\105') {
		goto __33
	}

	inescq = DFALSE
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++ // Skip E
	goto __34
__33:

	if !(expect_cond_assert > 0) {
		goto __35
	} /* A literal is not allowed if we are */
	// expecting a conditional assertion,
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))-- // but an empty \Q\E sequence is OK.
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR28
	goto FAILED
__35:
	;
	if !(inverbname != 0) {
		goto __36
	}
	// Don't use PARSED_LITERAL() because it
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	goto __37
__36:

	if !(libc.PostDecInt32(&after_manual_callout, 1) <= 0) {
		goto __38
	}
	parsed_pattern = manage_callouts(tls, thisptr, bp,
		auto_callout, parsed_pattern, cb)
__38:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

__37:
	;
	meta_quantifier = uint32(0)
__34:
	;
	goto __19 // Next character
__32:
	;

	// If we are processing the "name" part of a (*VERB:NAME) item, all
	//   characters up to the closing parenthesis are literals except when
	//   PCRE2_ALT_VERBNAMES is set. That causes backslash interpretation, but only \Q
	//   and \E and escaped characters are allowed (no character types such as \d). If
	//   PCRE2_EXTENDED is also set, we must ignore white space and # comments. Do
	//   this by not entering the special (*VERB:NAME) processing - they are then
	//   picked up below. Note that c is a character, not a code unit, so we must not
	//   use MAX_255 to test its size because MAX_255 tests code units and is assumed
	//   TRUE in 8-bit mode.

	if !(inverbname != 0 && (options&(DPCRE2_EXTENDED|DPCRE2_ALT_VERBNAMES) != DPCRE2_EXTENDED|DPCRE2_ALT_VERBNAMES || *(*uint32)(unsafe.Pointer(bp + 16)) > uint32(255) && *(*uint32)(unsafe.Pointer(bp + 16))|uint32(1) != uint32(0x200f) && *(*uint32)(unsafe.Pointer(bp + 16))|uint32(1) != uint32(0x2029) || *(*uint32)(unsafe.Pointer(bp + 16)) < uint32(256) && *(*uint32)(unsafe.Pointer(bp + 16)) != uint32('\043') && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*uint32)(unsafe.Pointer(bp + 16))))))&Dctype_space == 0 &&

		*(*uint32)(unsafe.Pointer(bp + 16)) != libc.Uint32FromUint8(libc.Uint8FromInt32(133)))) {
		goto __39
	}

	switch *(*uint32)(unsafe.Pointer(bp + 16 /* c */)) {
	default:
		goto __41

	case uint32('\051'):
		goto __42

	case uint32('\134'):
		goto __43
	}
	goto __40

__41: // Don't use PARSED_LITERAL() because it
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	goto __40

__42:
	inverbname = DFALSE
	// This is the length in characters
	verbnamelength = uint64((int64(parsed_pattern)-int64(verblengthptr))/4 - int64(1))
	// But the limit on the length is in code units
	if !((int64(*(*uintptr)(unsafe.Pointer(bp + 8)))-int64(verbnamestart))/1-int64(1) > int64(int32(uint32(1)<<8-uint32(1)))) {
		goto __44
	}

	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))--
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR76
	goto FAILED
__44:
	;
	*(*uint32)(unsafe.Pointer(verblengthptr)) = uint32(verbnamelength)

	// If this name was on a verb such as (*ACCEPT) which does not continue,
	//       a (*MARK) was generated for the name. We now add the original verb as the
	//       next item.

	if !(add_after_mark != uint32(0)) {
		goto __45
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = add_after_mark
	add_after_mark = uint32(0)
__45:
	;
	goto __40

__43:
	if !(options&DPCRE2_ALT_VERBNAMES != uint32(0)) {
		goto __46
	}

	escape = X_pcre2_check_escape_8(tls, bp+8, ptrend, bp+16, bp+20, options,
		(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options, DFALSE, cb)
	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __48
	}
	goto FAILED
__48:
	;
	goto __47
__46:
	escape = 0
__47:
	; // Treat all as literal

	switch escape {
	case 0:
		goto __50

	case ESC_Q:
		goto __51

	case ESC_E:
		goto __52

	default:
		goto __53
	}
	goto __49

__50: // Don't use PARSED_LITERAL() because it
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	goto __49

__51:
	inescq = DTRUE
	goto __49

__52: // Ignore
	goto __49

__53:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR40 // Invalid in verb name
	goto FAILED
__49:
	;
__40:
	;
	goto __19 // Next character in pattern
__39:
	;

	// Not a verb name character. At this point we must process everything that
	//   must not change the quantification state. This is mainly comments, but we
	//   handle \Q and \E here as well, so that an item such as A\Q\E+ is treated as
	//   A+, as in Perl. An isolated \E is ignored.

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\134') && *(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __54
	}

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\121' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\105') {
		goto __55
	}

	inescq = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\121')
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __19
__55:
	;
__54:
	;

	// Skip over whitespace and # comments in extended mode. Note that c is a
	//   character, not a code unit, so we must not use MAX_255 to test its size
	//   because MAX_255 tests code units and is assumed TRUE in 8-bit mode. The
	//   whitespace characters are those designated as "Pattern White Space" by
	//   Unicode, which are the isspace() characters plus CHAR_NEL (newline), which is
	//   U+0085 in Unicode, plus U+200E, U+200F, U+2028, and U+2029. These are a
	//   subset of space characters that match \h and \v.

	if !(options&DPCRE2_EXTENDED != uint32(0)) {
		goto __56
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*uint32)(unsafe.Pointer(bp + 16))))))&Dctype_space != 0) {
		goto __57
	}
	goto __19
__57:
	;
	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == libc.Uint32FromUint8(libc.Uint8FromInt32(133)) || *(*uint32)(unsafe.Pointer(bp + 16))|uint32(1) == uint32(0x200f) || *(*uint32)(unsafe.Pointer(bp + 16))|uint32(1) == uint32(0x2029)) {
		goto __58
	}
	goto __19
__58:
	;
	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\043')) {
		goto __59
	}

__60:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __61
	}

	if !(func() int32 {
		if (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 8)) < (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern && X_pcre2_is_newline_8(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnltype, (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern, cb+260, utf) != 0)
		}
		return libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 8)) <= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fend_pattern-uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == int32(*(*uint8)(unsafe.Pointer(cb + 272))) && ((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(cb + 272 + 1)))))
	}() != 0) {
		goto __62
	} /* For non-fixed-length newline cases, */
	// IS_NEWLINE sets cb->nllen.
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnllen)
	goto __61
__62:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	if !(utf != 0) {
		goto __63
	}
__64:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0xc0 == 0x80) {
		goto __65
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __64
__65:
	;
__63:
	;
	goto __60
__61:
	;
	goto __19 // Next character in pattern
__59:
	;
__56:
	;

	// Skip over bracketed comments

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\050') && (int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 >= int64(2) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\077' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) == '\043') {
		goto __66
	}

__67:
	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __68
	}
	goto __67
__68:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __69
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR18 // A special error for missing ) in a comment
	goto FAILED                                                // to make it easier to debug.
__69:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __19 // Next character in pattern
__66:
	;

	// If the next item is not a quantifier, fill in length of any previous
	//   callout and create an auto callout if required.

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) != uint32('\052') && *(*uint32)(unsafe.Pointer(bp + 16)) != uint32('\053') && *(*uint32)(unsafe.Pointer(bp + 16)) != uint32('\077') && (*(*uint32)(unsafe.Pointer(bp + 16)) != uint32('\173') || func() bool {
		*(*uintptr)(unsafe.Pointer(bp + 24)) = *(*uintptr)(unsafe.Pointer(bp + 8))
		return !(read_repeat_counts(tls, bp+24, ptrend, uintptr(0), uintptr(0), bp+20) != 0)
	}())) {
		goto __70
	}

	if !(libc.PostDecInt32(&after_manual_callout, 1) <= 0) {
		goto __71
	}
	parsed_pattern = manage_callouts(tls, thisptr, bp, auto_callout,
		parsed_pattern, cb)
__71:
	;
__70:
	;

	// If expect_cond_assert is 2, we have just passed (?( and are expecting an
	//   assertion, possibly preceded by a callout. If the value is 1, we have just
	//   had the callout and expect an assertion. There must be at least 3 more
	//   characters in all cases. When expect_cond_assert is 2, we know that the
	//   current character is an opening parenthesis, as otherwise we wouldn't be
	//   here. However, when it is 1, we need to check, and it's easiest just to check
	//   always. Note that expect_cond_assert may be negative, since all callouts just
	//   decrement it.

	if !(expect_cond_assert > 0) {
		goto __72
	}

	ok = libc.Bool32(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\050') && (int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 >= int64(3) && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\077' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\052'))
	if !(ok != 0) {
		goto __73
	}

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\052') {
		goto __74
	} /* New alpha assertion format, possibly */

	ok = libc.Bool32(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))))))&Dctype_lcletter != 0)
	goto __75
__74:
	switch int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) + 1))) {
	case '\103':
		goto __77

	case '\075':
		goto __78
	case '\041':
		goto __79

	case '\074':
		goto __80

	default:
		goto __81
	}
	goto __76 /* Traditional symbolic format */

__77:
	ok = libc.Bool32(expect_cond_assert == 2)
	goto __76

__78:
__79:
	goto __76

__80:
	ok = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2))) == '\075' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2))) == '\041')
	goto __76

__81:
	ok = DFALSE
__76:
	;
__75:
	;
__73:
	;

	if !!(ok != 0) {
		goto __82
	}

	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))-- // Adjust error offset
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR28
	goto FAILED
__82:
	;
__72:
	;

	// Remember whether we are expecting a conditional assertion, and set the
	//   default for this item.

	prev_expect_cond_assert = expect_cond_assert
	expect_cond_assert = 0

	// Remember quantification status for the previous significant item, then set
	//   default for this item.

	prev_okquantifier = okquantifier
	prev_meta_quantifier = meta_quantifier
	okquantifier = DFALSE
	meta_quantifier = uint32(0)

	// If the previous significant item was a quantifier, adjust the parsed code
	//   if there is a following modifier. The base meta value is always followed by
	//   the PLUS and QUERY values, in that order. We do this here rather than after
	//   reading a quantifier so that intervening comments and /x whitespace can be
	//   ignored without having to replicate code.

	if !(prev_meta_quantifier != uint32(0) && (*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\077') || *(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\053'))) {
		goto __83
	}

	*(*uint32)(unsafe.Pointer(parsed_pattern + uintptr(func() int32 {
		if prev_meta_quantifier == DMETA_MINMAX {
			return -3
		}
		return -1
	}())*4)) = prev_meta_quantifier + func() uint32 {
		if *(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\077') {
			return 0x00020000
		}
		return 0x00010000
	}()
	goto __19 // Next character in pattern
__83:
	;

	// Process the next item in the main part of a pattern.

	switch *(*uint32)(unsafe.Pointer(bp + 16 /* c */)) {
	default:
		goto __85

	// ---- Escape sequence ----

	case uint32('\134'):
		goto __86 // End escape sequence processing

	// ---- Single-character special items ----

	case uint32('\136'):
		goto __87

	case uint32('\044'):
		goto __88

	case uint32('\056'):
		goto __89

	// ---- Single-character quantifiers ----

	case uint32('\052'):
		goto __90

	case uint32('\053'):
		goto __91

	case uint32('\077'):
		goto __92

	// ---- Potential {n,m} quantifier ----

	case uint32('\173'):
		goto __93

	// ---- Character class ----

	case uint32('\133'):
		goto __94 // End of character class

	// ---- Opening parenthesis ----

	case uint32('\050'):
		goto __95 // End of ( handling

	// ---- Branch terminators ----

	// Alternation: reset the capture count if we are in a (?| group.

	case uint32('\174'):
		goto __96

	// End of group; reset the capture count to the maximum if we are in a (?|
	//     group and/or reset the options that are tracked during parsing. Disallow
	//     quantifier for a condition that is an assertion.

	case uint32('\051'):
		goto __97
	}
	goto __84

__85: // Non-special character
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

	goto __84

	// ---- Escape sequence ----

__86:
	*(*uintptr)(unsafe.Pointer(bp + 24 /* tempptr */)) = *(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))
	escape = X_pcre2_check_escape_8(tls, bp+8, ptrend, bp+16, bp+20, options,
		(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options, DFALSE, cb)
	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __98
	}

ESCAPE_FAILED:
	if !(extra_options&DPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL == uint32(0)) {
		goto __99
	}
	goto FAILED
__99:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) = *(*uintptr)(unsafe.Pointer(bp + 24 /* tempptr */))
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __100
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32('\134')
	goto __101
__100:

	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __102
	}
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x20 == uint32(0)) {
		goto __103
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __104
__103:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x10 == uint32(0)) {
		goto __105
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __106
__105:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x08 == uint32(0)) {
		goto __107
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __108
__107:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x04 == uint32(0)) {
		goto __109
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __110
__109:
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__110:
	;
__108:
	;
__106:
	;
__104:
	;
__102:
	;

	// Get character value, increment pointer
__101:
	;
	escape = 0 // Treat as literal character
__98:
	;

	// The escape was a data escape or literal character.

	if !(escape == 0) {
		goto __111
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

	goto __112
__111:
	if !(escape < 0) {
		goto __113
	}

	*(*uint64)(unsafe.Pointer(bp + 56 /* offset */)) = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 8)))-int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern))/1 - int64(1))
	escape = -escape
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_BACKREF | uint32(escape)
	if !(escape < 10) {
		goto __115
	}

	if !(*(*uint64)(unsafe.Pointer(cb + 88 + uintptr(escape)*8)) == libc.CplUint64(uint64(0))) {
		goto __117
	}
	*(*uint64)(unsafe.Pointer(cb + 88 + uintptr(escape)*8)) = *(*uint64)(unsafe.Pointer(bp + 56 /* offset */))
__117:
	;
	goto __116
__115:

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

__116:
	;
	okquantifier = DTRUE
	goto __114
__113:
	switch escape {
	case ESC_C:
		goto __119

	case ESC_X:
		goto __120
	case ESC_H:
		goto __121
	case ESC_h:
		goto __122
	case ESC_N:
		goto __123
	case ESC_R:
		goto __124
	case ESC_V:
		goto __125
	case ESC_v:
		goto __126

	default:
		goto __127

	// Escapes that change in UCP mode. Note that PCRE2_UCP will never be set
	//       without Unicode support because it is checked when pcre2_compile() is
	//       called.

	case ESC_d:
		goto __128
	case ESC_D:
		goto __129
	case ESC_s:
		goto __130
	case ESC_S:
		goto __131
	case ESC_w:
		goto __132
	case ESC_W:
		goto __133

	// Unicode property matching

	case ESC_P:
		goto __134
	case ESC_p:
		goto __135 // End \P and \p

	// When \g is used with quotes or angle brackets as delimiters, it is a
	//       numerical or named subroutine call, and control comes here. When used
	//       with brace delimiters it is a numberical back reference and does not come
	//       here because check_escape() returns it directly as a reference. \k is
	//       always a named back reference.

	case ESC_g:
		goto __136
	case ESC_k:
		goto __137
	}
	goto __118

__119:
	if !(options&DPCRE2_NEVER_BACKSLASH_C != uint32(0)) {
		goto __138
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR83
	goto ESCAPE_FAILED
__138:
	;
	okquantifier = DTRUE
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __118

__120:
__121:
__122:
__123:
__124:
__125:
__126:
	okquantifier = DTRUE
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __118

__127: // \A, \B, \b, \G, \K, \Z, \z cannot be quantified.
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __118

	// Escapes that change in UCP mode. Note that PCRE2_UCP will never be set
	//       without Unicode support because it is checked when pcre2_compile() is
	//       called.

__128:
__129:
__130:
__131:
__132:
__133:
	okquantifier = DTRUE
	if !(options&DPCRE2_UCP == uint32(0)) {
		goto __139
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __140
__139:

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + func() uint32 {
		if escape == ESC_d || escape == ESC_s || escape == ESC_w {
			return ESC_p
		}
		return ESC_P
	}()
	switch escape {
	case ESC_d:
		goto __142
	case ESC_D:
		goto __143

	case ESC_s:
		goto __144
	case ESC_S:
		goto __145

	case ESC_w:
		goto __146
	case ESC_W:
		goto __147
	}
	goto __141

__142:
__143:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(DPT_PC)<<16 | ucp_Nd)
	goto __141

__144:
__145:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(DPT_SPACE) << 16)
	goto __141

__146:
__147:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(DPT_WORD) << 16)
	goto __141
__141:
	;
__140:
	;
	goto __118

	// Unicode property matching

__134:
__135:

	*(*uint16)(unsafe.Pointer(bp + 36 /* ptype */)) = uint16(0)
	*(*uint16)(unsafe.Pointer(bp + 38 /* pdata */)) = uint16(0)
	if !!(get_ucp(tls, bp+8, bp+32, bp+36, bp+38, bp+20, cb) != 0) {
		goto __148
	}
	goto ESCAPE_FAILED
__148:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 32)) != 0) {
		goto __149
	}
	if escape == ESC_P {
		escape = ESC_p
	} else {
		escape = ESC_P
	}
__149:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(*(*uint16)(unsafe.Pointer(bp + 36)))<<16 | int32(*(*uint16)(unsafe.Pointer(bp + 38))))
	okquantifier = DTRUE

	goto __118 // End \P and \p

	// When \g is used with quotes or angle brackets as delimiters, it is a
	//       numerical or named subroutine call, and control comes here. When used
	//       with brace delimiters it is a numberical back reference and does not come
	//       here because check_escape() returns it directly as a reference. \k is
	//       always a named back reference.

__136:
__137:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\173' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\074' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\047') {
		goto __150
	}

	if escape == ESC_g {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR57
	} else {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR69
	}
	goto ESCAPE_FAILED
__150:
	;
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\074' {
		terminator = uint32('\076')
	} else {
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\047' {
			terminator = uint32('\047')
		} else {
			terminator = uint32('\175')
		}
	}

	// For a non-braced \g, check for a numerical recursion.

	if !(escape == ESC_g && terminator != uint32('\175')) {
		goto __151
	}

	*(*uintptr)(unsafe.Pointer(bp + 40 /* p */)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(1)

	if !(read_number(tls, bp+40, ptrend, int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount), DMAX_GROUP_NUMBER, ERR61, bp+48,
		bp+20) != 0) {
		goto __152
	}

	if !(*(*uintptr)(unsafe.Pointer(bp + 40)) >= ptrend || uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40))))) != terminator) {
		goto __153
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR57
	goto ESCAPE_FAILED
__153:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) = *(*uintptr)(unsafe.Pointer(bp + 40 /* p */))
	goto SET_RECURSION
__152:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __154
	}
	goto ESCAPE_FAILED
__154:
	;
__151:
	;

	// Not a numerical recursion

	if !!(read_name(tls, bp+8, ptrend, utf, terminator, bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __155
	}
	goto ESCAPE_FAILED
__155:
	;

	// \k and \g when used with braces are back references, whereas \g used
	//       with quotes or angle brackets is a recursion

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if escape == ESC_k || terminator == uint32('\175') {
			return DMETA_BACKREF_BYNAME
		}
		return DMETA_RECURSE_BYNAME
	}()
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 72 /* namelen */))

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	okquantifier = DTRUE
	goto __118 // End special escape processing
__118:
	;
__114:
	;
__112:
	;
	goto __84 // End escape sequence processing

	// ---- Single-character special items ----

__87:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CIRCUMFLEX
	goto __84

__88:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_DOLLAR
	goto __84

__89:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_DOT
	okquantifier = DTRUE
	goto __84

	// ---- Single-character quantifiers ----

__90:
	meta_quantifier = DMETA_ASTERISK
	goto CHECK_QUANTIFIER

__91:
	meta_quantifier = DMETA_PLUS
	goto CHECK_QUANTIFIER

__92:
	meta_quantifier = DMETA_QUERY
	goto CHECK_QUANTIFIER

	// ---- Potential {n,m} quantifier ----

__93:
	if !!(read_repeat_counts(tls, bp+8, ptrend, bp+76, bp+80,
		bp+20) != 0) {
		goto __156
	}

	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __157
	}
	goto FAILED
__157:
	; // Error in quantifier.
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE
	// Not a quantifier
	goto __84 // No more quantifier processing
__156:
	;
	meta_quantifier = DMETA_MINMAX
	// Fall through

	// ---- Quantifier post-processing ----

	// Check that a quantifier is allowed after the previous item.

CHECK_QUANTIFIER:
	if !!(prev_okquantifier != 0) {
		goto __158
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR9
	goto FAILED_BACK
__158:
	;

	// Most (*VERB)s are not allowed to be quantified, but an ungreedy
	//     quantifier can be useful for (*ACCEPT) - meaning "succeed on backtrack", a
	//     sort of negated (*COMMIT). We therefore allow (*ACCEPT) to be quantified by
	//     wrapping it in non-capturing brackets, but we have to allow for a preceding
	//     (*MARK) for when (*ACCEPT) has an argument.

	if !(*(*uint32)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) == DMETA_ACCEPT) {
		goto __159
	}

	p1 = parsed_pattern - uintptr(1)*4
__160:
	if !(p1 >= verbstartptr) {
		goto __162
	}
	*(*uint32)(unsafe.Pointer(p1 + 1*4)) = *(*uint32)(unsafe.Pointer(p1))
	goto __161
__161:
	p1 -= 4
	goto __160
	goto __162
__162:
	;
	*(*uint32)(unsafe.Pointer(verbstartptr)) = DMETA_NOCAPTURE
	*(*uint32)(unsafe.Pointer(parsed_pattern + 1*4)) = DMETA_KET
	parsed_pattern += 4 * uintptr(2)
__159:
	;

	// Now we can put the quantifier into the parsed pattern vector. At this
	//     stage, we have only the basic quantifier. The check for a following + or ?
	//     modifier happens at the top of the loop, after any intervening comments
	//     have been removed.

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = meta_quantifier
	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\173')) {
		goto __163
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 76 /* min_repeat */))
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 80 /* max_repeat */))
__163:
	;
	goto __84

	// ---- Character class ----

__94:
	okquantifier = DTRUE

	// In another (POSIX) regex library, the ugly syntax [[:<:]] and [[:>:]] is
	//     used for "start of word" and "end of word". As these are otherwise illegal
	//     sequences, we don't break anything by recognizing them. They are replaced
	//     by \b(?=\w) and \b(?<=\w) respectively. Sequences like [a[:<:]] are
	//     erroneous and are handled by the normal code below.

	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 >= int64(6) && (X_pcre2_strncmp_c8_8(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ts+597, uint64(6)) == 0 || X_pcre2_strncmp_c8_8(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ts+604, uint64(6)) == 0)) {
		goto __164
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_b

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2))) == '\074') {
		goto __165
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKAHEAD
	goto __166
__165:

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKBEHIND
	*(*int32)(unsafe.Pointer(has_lookbehind)) = DTRUE

	/* The offset is used only for the "non-fixed length" error; this won't
	   occur here, so just store zero. */

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(uint64(uint64(0)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(uint64(0) & uint64(0xffffffff))

__166:
	;

	if !(options&DPCRE2_UCP == uint32(0)) {
		goto __167
	}
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_w
	goto __168
__167:

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_p
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(DPT_WORD) << 16)
__168:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(6)
	goto __84
__164:
	;

	// PCRE supports POSIX class stuff inside a class. Perl gives an error if
	//     they are encountered at the top level, so we'll do that too.

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\072' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\056' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\075') && check_posix_syntax(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ptrend, bp+24) != 0) {
		goto __169
	}

	if int32(*(*uint8)(unsafe.Pointer(libc.PostDecUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1)))) == '\072' {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR12
	} else {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR13
	}
	goto FAILED
__169:
	;

	// Process a regular character class. If the first character is '^', set
	//     the negation flag. If the first few characters (either before or after ^)
	//     are \Q\E or \E or space or tab in extended-more mode, we skip them too.
	//     This makes for compatibility with Perl.

	negate_class = DFALSE
__170:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend) {
		goto __171
	}

	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __172
	}
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x20 == uint32(0)) {
		goto __173
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __174
__173:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x10 == uint32(0)) {
		goto __175
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __176
__175:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x08 == uint32(0)) {
		goto __177
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __178
__177:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x04 == uint32(0)) {
		goto __179
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __180
__179:
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__180:
	;
__178:
	;
__176:
	;
__174:
	;
__172:
	;

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\134')) {
		goto __181
	}

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\105') {
		goto __183
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __184
__183:
	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 >= int64(3) && X_pcre2_strncmp_c8_8(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ts+611, uint64(3)) == 0) {
		goto __185
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __186
__185:
	goto __171
__186:
	;
__184:
	;
	goto __182
__181:
	if !(options&DPCRE2_EXTENDED_MORE != uint32(0) && (*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\040') || *(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\011'))) {
		goto __187
	} // Note: just these two
	goto __170
	goto __188
__187:
	if !(!(negate_class != 0) && *(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\136')) {
		goto __189
	}
	negate_class = DTRUE
	goto __190
__189:
	goto __171
__190:
	;
__188:
	;
__182:
	;
	goto __170
__171:
	;

	// Now the real contents of the class; c has the first "real" character.
	//     Empty classes are permitted only if the option is set.

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\135') && (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_ALLOW_EMPTY_CLASS != uint32(0)) {
		goto __191
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if negate_class != 0 {
			return DMETA_CLASS_EMPTY_NOT
		}
		return DMETA_CLASS_EMPTY
	}()
	goto __84 // End of class processing
__191:
	;

	// Process a non-empty class.

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if negate_class != 0 {
			return DMETA_CLASS_NOT
		}
		return DMETA_CLASS
	}()
	class_range_state = RANGE_NO

	// In an EBCDIC environment, Perl treats alphabetic ranges specially
	//     because there are holes in the encoding, and simply using the range A-Z
	//     (for example) would include the characters in the holes. This applies only
	//     to ranges where both values are literal; [\xC1-\xE9] is different to [A-Z]
	//     in this respect. In order to accommodate this, we keep track of whether
	//     character values are literal or not, and a state variable for handling
	//     ranges.

	// Loop for the contents of the class

__192:
	char_is_literal = DTRUE

	// Inside \Q...\E everything is literal except \E

	if !(inescq != 0) {
		goto __195
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\134') && *(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\105') {
		goto __196
	}

	inescq = DFALSE                                 // Reset literal state
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++ // Skip the 'E'
	goto CLASS_CONTINUE
__196:
	;
	goto CLASS_LITERAL
__195:
	;

	// Skip over space and tab (only) in extended-more mode.

	if !(options&DPCRE2_EXTENDED_MORE != uint32(0) && (*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\040') || *(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\011'))) {
		goto __197
	}
	goto CLASS_CONTINUE
__197:
	;

	// Handle POSIX class names. Perl allows a negation extension of the
	//       form [:^name:]. A square bracket that doesn't match the syntax is
	//       treated as a literal. We also recognize the POSIX constructions
	//       [.ch.] and [=ch=] ("collating elements") and fault them, as Perl
	//       5.6 and 5.8 do.

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\133') && (int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 >= int64(3) && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\072' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\056' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\075') && check_posix_syntax(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ptrend, bp+24) != 0) {
		goto __198
	}

	posix_negate = DFALSE

	// Perl treats a hyphen before a POSIX class as a literal, not the
	//         start of a range. However, it gives a warning in its warning mode. PCRE
	//         does not have a warning mode, so we give an error, because this is
	//         likely an error on the user's part.

	if !(class_range_state == RANGE_STARTED) {
		goto __200
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR50
	goto FAILED
__200:
	;

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\072') {
		goto __201
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR13
	goto FAILED_BACK
__201:
	;

	if !(int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1)))) == '\136') {
		goto __202
	}

	posix_negate = DTRUE
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
__202:
	;

	posix_class = check_posix_name(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1))
	if !(posix_class < 0) {
		goto __203
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR30
	goto FAILED
__203:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) = *(*uintptr)(unsafe.Pointer(bp + 24)) + uintptr(2)

	// Perl treats a hyphen after a POSIX class as a literal, not the
	//         start of a range. However, it gives a warning in its warning mode
	//         unless the hyphen is the last character in the class. PCRE does not
	//         have a warning mode, so we give an error, because this is likely an
	//         error on the user's part.

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend-uintptr(1) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\055' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) != '\135') {
		goto __204
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR50
	goto FAILED
__204:
	;

	// Set "a hyphen is not the start of a range" for the -] case, and also
	//         in case the POSIX class is followed by \E or \Q\E (possibly repeated -
	//         fuzzers do that kind of thing) and *then* a hyphen. This causes that
	//         hyphen to be treated as a literal. I don't think it's worth setting up
	//         special apparatus to do otherwise.

	class_range_state = RANGE_NO

	// When PCRE2_UCP is set, some of the POSIX classes are converted to
	//         use Unicode properties \p or \P or, in one case, \h or \H. The
	//         substitutes table has two values per class, containing the type and
	//         value of a \p or \P item. The special cases are specified with a
	//         negative type: a non-zero value causes \h or \H to be used, and a zero
	//         value falls through to behave like a non-UCP POSIX class.

	if !(options&DPCRE2_UCP != uint32(0)) {
		goto __205
	}

	ptype1 = posix_substitutes[2*posix_class]
	pvalue = posix_substitutes[2*posix_class+1]
	if !(ptype1 >= 0) {
		goto __206
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + func() uint32 {
		if posix_negate != 0 {
			return ESC_P
		}
		return ESC_p
	}()
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(ptype1<<16 | pvalue)
	goto CLASS_CONTINUE
__206:
	;

	if !(pvalue != 0) {
		goto __207
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + func() uint32 {
		if posix_negate != 0 {
			return ESC_H
		}
		return ESC_h
	}()
	goto CLASS_CONTINUE
__207:
	;

	// Fall through
__205:
	;

	// Non-UCP POSIX class

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if posix_negate != 0 {
			return DMETA_POSIX_NEG
		}
		return DMETA_POSIX
	}()
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(posix_class)
	goto __199
__198:
	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\055') && class_range_state >= RANGE_OK_ESCAPED) {
		goto __208
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if class_range_state == RANGE_OK_LITERAL {
			return DMETA_RANGE_LITERAL
		}
		return DMETA_RANGE_ESCAPED
	}()
	class_range_state = RANGE_STARTED
	goto __209
__208:
	if !(*(*uint32)(unsafe.Pointer(bp + 16)) != uint32('\134')) {
		goto __210
	}

CLASS_LITERAL:
	if !(class_range_state == RANGE_STARTED) {
		goto __212
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == *(*uint32)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-2)*4))) {
		goto __214
	} // Optimize one-char range
	parsed_pattern -= 4
	goto __215
__214:
	if !(*(*uint32)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-2)*4)) > *(*uint32)(unsafe.Pointer(bp + 16))) {
		goto __216
	} /* Check range is in order */

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR8
	goto FAILED_BACK
	goto __217
__216:

	if !(!(char_is_literal != 0) && *(*uint32)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) == DMETA_RANGE_LITERAL) {
		goto __218
	}
	*(*uint32)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) = DMETA_RANGE_ESCAPED
__218:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

__217:
	;
__215:
	;
	class_range_state = RANGE_NO
	goto __213
__212: /* Potential start of range */

	if char_is_literal != 0 {
		class_range_state = RANGE_OK_LITERAL
	} else {
		class_range_state = RANGE_OK_ESCAPED
	}
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 16 /* c */))
	okquantifier = DTRUE

__213:
	;
	goto __211
__210:

	*(*uintptr)(unsafe.Pointer(bp + 24 /* tempptr */)) = *(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))
	escape = X_pcre2_check_escape_8(tls, bp+8, ptrend, bp+16, bp+20, options,
		(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options, DTRUE, cb)

	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __219
	}

	if !(extra_options&DPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL == uint32(0)) {
		goto __220
	}
	goto FAILED
__220:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) = *(*uintptr)(unsafe.Pointer(bp + 24 /* tempptr */))
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __221
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32('\134')
	goto __222
__221:

	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __223
	}
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x20 == uint32(0)) {
		goto __224
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __225
__224:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x10 == uint32(0)) {
		goto __226
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __227
__226:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x08 == uint32(0)) {
		goto __228
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __229
__228:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x04 == uint32(0)) {
		goto __230
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __231
__230:
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__231:
	;
__229:
	;
__227:
	;
__225:
	;
__223:
	;

	// Get character value, increment pointer
__222:
	;
	escape = 0 // Treat as literal character
__219:
	;

	switch escape {
	case 0:
		goto __233

	case ESC_b:
		goto __234

	case ESC_Q:
		goto __235

	case ESC_E:
		goto __236

	case ESC_B:
		goto __237 // Always an error in a class
	case ESC_R:
		goto __238
	case ESC_X:
		goto __239
	}
	goto __232

__233: // Escaped character code point is in c
	char_is_literal = DFALSE
	goto CLASS_LITERAL

__234:
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32('\010') // \b is backspace in a class
	char_is_literal = DFALSE
	goto CLASS_LITERAL

__235:
	inescq = DTRUE // Enter literal mode
	goto CLASS_CONTINUE

__236: // Ignore orphan \E
	goto CLASS_CONTINUE

__237: // Always an error in a class
__238:
__239:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR7
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))--
	goto FAILED
__232:
	;

	// The second part of a range can be a single-character escape
	//         sequence (detected above), but not any of the other escapes. Perl
	//         treats a hyphen as a literal in such circumstances. However, in Perl's
	//         warning mode, a warning is given, so PCRE now faults it, as it is
	//         almost certainly a mistake on the user's part.

	if !(class_range_state == RANGE_STARTED) {
		goto __240
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR50
	goto FAILED // Not CLASS_ESCAPE_FAILED; always an error
__240:
	;

	// Of the remaining escapes, only those that define characters are
	//         allowed in a class. None may start a range.

	class_range_state = RANGE_NO
	switch escape {
	case ESC_N:
		goto __242

	case ESC_H:
		goto __243
	case ESC_h:
		goto __244
	case ESC_V:
		goto __245
	case ESC_v:
		goto __246

	// These escapes are converted to Unicode property tests when
	//           PCRE2_UCP is set.

	case ESC_d:
		goto __247
	case ESC_D:
		goto __248
	case ESC_s:
		goto __249
	case ESC_S:
		goto __250
	case ESC_w:
		goto __251
	case ESC_W:
		goto __252

	// Explicit Unicode property matching

	case ESC_P:
		goto __253
	case ESC_p:
		goto __254 // End \P and \p

	default:
		goto __255
	}
	goto __241

__242:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR71
	goto FAILED

__243:
__244:
__245:
__246:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __241

	// These escapes are converted to Unicode property tests when
	//           PCRE2_UCP is set.

__247:
__248:
__249:
__250:
__251:
__252:
	if !(options&DPCRE2_UCP == uint32(0)) {
		goto __256
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	goto __257
__256:

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + func() uint32 {
		if escape == ESC_d || escape == ESC_s || escape == ESC_w {
			return ESC_p
		}
		return ESC_P
	}()
	switch escape {
	case ESC_d:
		goto __259
	case ESC_D:
		goto __260

	case ESC_s:
		goto __261
	case ESC_S:
		goto __262

	case ESC_w:
		goto __263
	case ESC_W:
		goto __264
	}
	goto __258

__259:
__260:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(DPT_PC)<<16 | ucp_Nd)
	goto __258

__261:
__262:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(DPT_SPACE) << 16)
	goto __258

__263:
__264:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(DPT_WORD) << 16)
	goto __258
__258:
	;
__257:
	;
	goto __241

	// Explicit Unicode property matching

__253:
__254:

	*(*uint16)(unsafe.Pointer(bp + 88 /* ptype2 */)) = uint16(0)
	*(*uint16)(unsafe.Pointer(bp + 90 /* pdata1 */)) = uint16(0)
	if !!(get_ucp(tls, bp+8, bp+84, bp+88, bp+90, bp+20, cb) != 0) {
		goto __265
	}
	goto FAILED
__265:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 84)) != 0) {
		goto __266
	}
	if escape == ESC_P {
		escape = ESC_p
	} else {
		escape = ESC_P
	}
__266:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + uint32(escape)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(int32(*(*uint16)(unsafe.Pointer(bp + 88)))<<16 | int32(*(*uint16)(unsafe.Pointer(bp + 90))))

	goto __241 // End \P and \p

__255: // All others are not allowed in a class
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR7
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))--
	goto FAILED
__241:
	;

	// Perl gives a warning unless a following hyphen is the last character
	//         in the class. PCRE throws an error.

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend-uintptr(1) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\055' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) != '\135') {
		goto __267
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR50
	goto FAILED
__267:
	;
__211:
	;
__209:
	;
__199:
	;

	// Proceed to next thing in the class.

CLASS_CONTINUE:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __268
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR6 // Missing terminating ']'
	goto FAILED
__268:
	;
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(bp + 16)) >= 0xc0) {
		goto __269
	}
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x20 == uint32(0)) {
		goto __270
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1))))&0x3f
	goto __271
__270:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x10 == uint32(0)) {
		goto __272
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	goto __273
__272:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x08 == uint32(0)) {
		goto __274
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(3)
	goto __275
__274:
	if !(*(*uint32)(unsafe.Pointer(bp + 16))&0x04 == uint32(0)) {
		goto __276
	}
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(4)
	goto __277
__276:
	*(*uint32)(unsafe.Pointer(bp + 16 /* c */)) = *(*uint32)(unsafe.Pointer(bp + 16))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(5)
__277:
	;
__275:
	;
__273:
	;
__271:
	;
__269:
	;

	if !(*(*uint32)(unsafe.Pointer(bp + 16)) == uint32('\135') && !(inescq != 0)) {
		goto __278
	}
	goto __194
__278:
	;
	goto __193
__193:
	goto __192
	goto __194
__194:
	; // End of class-processing loop

	// -] at the end of a class is a literal '-'

	if !(class_range_state == RANGE_STARTED) {
		goto __279
	}

	*(*uint32)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) = uint32('\055')
	class_range_state = RANGE_NO
__279:
	;

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CLASS_END
	goto __84 // End of character class

	// ---- Opening parenthesis ----

__95:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __280
	}
	goto UNCLOSED_PARENTHESIS
__280:
	;

	// If ( is not followed by ? it is either a capture or a special verb or an
	//     alpha assertion or a positive non-atomic lookahead.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\077') {
		goto __281
	}

	// Handle capturing brackets (or non-capturing if auto-capture is turned
	//       off).

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\052') {
		goto __282
	}

	nest_depth++
	if !(options&DPCRE2_NO_AUTO_CAPTURE == uint32(0)) {
		goto __284
	}

	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount >= DMAX_GROUP_NUMBER) {
		goto __286
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR97
	goto FAILED
__286:
	;
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount++
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CAPTURE | (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount
	goto __285
__284:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
__285:
	;
	goto __283
__282:
	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 <= int64(1) || libc.AssignPtrUint32(bp+16, uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1)))) == uint32('\051')) {
		goto __287
	}
	goto __84
	goto __288
__287:
	if !(*(*uint32)(unsafe.Pointer(bp + 16)) <= 255 && int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fctypes + uintptr(*(*uint32)(unsafe.Pointer(bp + 16))))))&Dctype_lcletter != 0) {
		goto __289
	}

	vn = uintptr(unsafe.Pointer(&alasnames))
	if !!(read_name(tls, bp+8, ptrend, utf, uint32(0), bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __291
	}
	goto FAILED
__291:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\072') {
		goto __292
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR95 // Malformed
	goto FAILED
__292:
	;

	// Scan the table of alpha assertion names

	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0
__293:
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < alascount) {
		goto __295
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 72)) == alasmeta[*(*int32)(unsafe.Pointer(bp + 48))].Flen && X_pcre2_strncmp_c8_8(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), vn, uint64(*(*uint32)(unsafe.Pointer(bp + 72)))) == 0) {
		goto __296
	}
	goto __295
__296:
	;
	vn += uintptr(alasmeta[*(*int32)(unsafe.Pointer(bp + 48))].Flen + uint32(1))
	goto __294
__294:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	goto __293
	goto __295
__295:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 48)) >= alascount) {
		goto __297
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR95 // Alpha assertion not recognized
	goto FAILED
__297:
	;

	// Check for expecting an assertion condition. If so, only atomic
	//         lookaround assertions are valid.

	meta = alasmeta[*(*int32)(unsafe.Pointer(bp + 48 /* i */))].Fmeta
	if !(prev_expect_cond_assert > 0 && (meta < DMETA_LOOKAHEAD || meta > DMETA_LOOKBEHINDNOT)) {
		goto __298
	}

	if meta == DMETA_LOOKAHEAD_NA || meta == DMETA_LOOKBEHIND_NA {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR98
	} else {
		*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR28
	} // (Atomic) assertion expected
	goto FAILED
__298:
	;

	// The lookaround alphabetic synonyms can mostly be handled by jumping
	//         to the code that handles the traditional symbolic forms.

	switch meta {
	default:
		goto __300 // the meta values come from a table above.

	case DMETA_ATOMIC:
		goto __301

	case DMETA_LOOKAHEAD:
		goto __302

	case DMETA_LOOKAHEAD_NA:
		goto __303

	case DMETA_LOOKAHEADNOT:
		goto __304

	case DMETA_LOOKBEHIND:
		goto __305
	case DMETA_LOOKBEHINDNOT:
		goto __306
	case DMETA_LOOKBEHIND_NA:
		goto __307

	// The script run facilities are handled here. Unicode support is
	//           required (give an error if not, as this is a security issue). Always
	//           record a META_SCRIPT_RUN item. Then, for the atomic version, insert
	//           META_ATOMIC and remember that we need two META_KETs at the end.

	case DMETA_SCRIPT_RUN:
		goto __308
	case DMETA_ATOMIC_SCRIPT_RUN:
		goto __309
	}
	goto __299

__300:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR89 // Unknown code; should never occur because
	goto FAILED                                                // the meta values come from a table above.

__301:
	goto ATOMIC_GROUP

__302:
	goto POSITIVE_LOOK_AHEAD

__303:
	goto POSITIVE_NONATOMIC_LOOK_AHEAD

__304:
	goto NEGATIVE_LOOK_AHEAD

__305:
__306:
__307:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = meta
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))--
	goto POST_LOOKBEHIND

	// The script run facilities are handled here. Unicode support is
	//           required (give an error if not, as this is a security issue). Always
	//           record a META_SCRIPT_RUN item. Then, for the atomic version, insert
	//           META_ATOMIC and remember that we need two META_KETs at the end.

__308:
__309:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_SCRIPT_RUN
	nest_depth++
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	if !(meta == DMETA_ATOMIC_SCRIPT_RUN) {
		goto __310
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ATOMIC
	if !(top_nest == uintptr(0)) {
		goto __311
	}
	top_nest = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace
	goto __312
__311:
	if !(libc.PreIncUintptr(&top_nest, 12) >= end_nests) {
		goto __313
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR84
	goto FAILED
__313:
	;
__312:
	;
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth = nest_depth
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fflags = uint16(DNSF_ATOMICSR)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Foptions = options & (DPCRE2_CASELESS | DPCRE2_DOTALL | DPCRE2_DUPNAMES | DPCRE2_EXTENDED | DPCRE2_EXTENDED_MORE | DPCRE2_MULTILINE | DPCRE2_NO_AUTO_CAPTURE | DPCRE2_UNGREEDY)
__310:
	;
	goto __299
__299:
	;
	goto __290
__289:

	vn = uintptr(unsafe.Pointer(&verbnames))
	if !!(read_name(tls, bp+8, ptrend, utf, uint32(0), bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __314
	}
	goto FAILED
__314:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\072' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __315
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR60 // Malformed
	goto FAILED
__315:
	;

	// Scan the table of verb names

	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0
__316:
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < verbcount) {
		goto __318
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 72)) == verbs[*(*int32)(unsafe.Pointer(bp + 48))].Flen && X_pcre2_strncmp_c8_8(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), vn, uint64(*(*uint32)(unsafe.Pointer(bp + 72)))) == 0) {
		goto __319
	}
	goto __318
__319:
	;
	vn += uintptr(verbs[*(*int32)(unsafe.Pointer(bp + 48))].Flen + uint32(1))
	goto __317
__317:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	goto __316
	goto __318
__318:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 48)) >= verbcount) {
		goto __320
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR60 // Verb not recognized
	goto FAILED
__320:
	;

	// An empty argument is treated as no argument.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\072' && *(*uintptr)(unsafe.Pointer(bp + 8))+uintptr(1) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) == '\051') {
		goto __321
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
__321:
	; // Advance to the closing parens

	// Check for mandatory non-empty argument; this is (*MARK)

	if !(verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fhas_arg > 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\072') {
		goto __322
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR66
	goto FAILED
__322:
	;

	// Remember where this verb, possibly with a preceding (*MARK), starts,
	//         for handling quantified (*ACCEPT).

	verbstartptr = parsed_pattern
	okquantifier = libc.Bool32(verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fmeta == DMETA_ACCEPT)

	// It appears that Perl allows any characters whatsoever, other than a
	//         closing parenthesis, to appear in arguments ("names"), so we no longer
	//         insist on letters, digits, and underscores. Perl does not, however, do
	//         any interpretation within arguments, and has no means of including a
	//         closing parenthesis. PCRE supports escape processing but only when it
	//         is requested by an option. We set inverbname TRUE here, and let the
	//         main loop take care of this so that escape and \x processing is done by
	//         the main code above.

	if !(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1)))) == '\072') {
		goto __323
	} /* Skip past : or ) */

	// Some optional arguments can be treated as a preceding (*MARK)

	if !(verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fhas_arg < 0) {
		goto __325
	}

	add_after_mark = verbs[*(*int32)(unsafe.Pointer(bp + 48 /* i */))].Fmeta
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_MARK
	goto __326
__325:

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fmeta + func() uint32 {
		if verbs[*(*int32)(unsafe.Pointer(bp + 48))].Fmeta != DMETA_MARK {
			return 0x00010000
		}
		return uint32(0)
	}()
__326:
	;

	// Set up for reading the name in the main loop.

	verblengthptr = libc.PostIncUintptr(&parsed_pattern, 4)
	verbnamestart = *(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))
	inverbname = DTRUE
	goto __324
__323: /* No verb "name" argument */

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = verbs[*(*int32)(unsafe.Pointer(bp + 48 /* i */))].Fmeta
__324:
	;
__290:
	;
__288:
	;
__283:
	;         // End of (*VERB) handling
	goto __84 // Done with this parenthesis
__281:
	; // End of groups that don't start with (?

	// ---- Items starting (? ----

	// The type of item is determined by what follows (?. Handle (?| and option
	//     changes under "default" because both need a new block on the nest stack.
	//     Comments starting with (?# are handled above. Note that there is some
	//     ambiguity about the sequence (?- because if a digit follows it's a relative
	//     recursion or subroutine call whereas otherwise it's an option unsetting.

	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __327
	}
	goto UNCLOSED_PARENTHESIS
__327:
	;

	switch int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))))) {
	default:
		goto __329 // End default case after (?

	// ---- Python syntax support ----

	case '\120':
		goto __330 // End of (?P processing

	// ---- Recursion/subroutine calls by number ----

	case '\122':
		goto __331

	// An item starting (?- followed by a digit comes here via the "default"
	//       case because (?- followed by a non-digit is an options setting.

	case '\053':
		goto __332
	// Fall through

	case '\060':
		goto __333
	case '\061':
		goto __334
	case '\062':
		goto __335
	case '\063':
		goto __336
	case '\064':
		goto __337
	case '\065':
		goto __338
	case '\066':
		goto __339
	case '\067':
		goto __340
	case '\070':
		goto __341
	case '\071':
		goto __342 // End of recursive call by number handling

	// ---- Recursion/subroutine calls by name ----

	case '\046':
		goto __343

	// ---- Callout with numerical or string argument ----

	case '\103':
		goto __344 // End callout

	// ---- Conditional group ----

	// A condition can be an assertion, a number (referring to a numbered
	//       group's having been set), a name (referring to a named group), or 'R',
	//       referring to overall recursion. R<digits> and R&name are also permitted
	//       for recursion state tests. Numbers may be preceded by + or - to specify a
	//       relative group number.
	//
	//       There are several syntaxes for testing a named group: (?(name)) is used
	//       by Python; Perl 5.10 onwards uses (?(<name>) or (?('name')).
	//
	//       There are two unfortunate ambiguities. 'R' can be the recursive thing or
	//       the name 'R' (and similarly for 'R' followed by digits). 'DEFINE' can be
	//       the Perl DEFINE feature or the Python named test. We look for a name
	//       first; if not found, we try the other case.
	//
	//       For compatibility with auto-callouts, we allow a callout to be specified
	//       before a condition that is an assertion.

	case '\050':
		goto __345 // End of condition processing

	// ---- Atomic group ----

	case '\076':
		goto __346

	// ---- Lookahead assertions ----

	case '\075':
		goto __347

	case '\052':
		goto __348

	case '\041':
		goto __349

	// ---- Lookbehind assertions ----

	// (?< followed by = or ! or * is a lookbehind assertion. Otherwise (?<
	//       is the start of the name of a capturing group.

	case '\074':
		goto __350

	// ---- Define a named group ----

	// A named group may be defined as (?'name') or (?<name>). In the latter
	//       case we jump to DEFINE_NAME from the disambiguation of (?< above with the
	//       terminator set to '>'.

	case '\047':
		goto __351
	}
	goto __328

__329:
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\055' && (int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 > int64(1) && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) <= '\071')) {
		goto __352
	}
	goto RECURSION_BYNUMBER
__352:
	; // The + case is handled by CHAR_PLUS

	// We now have either (?| or a (possibly empty) option setting,
	//       optionally followed by a non-capturing group.

	nest_depth++
	if !(top_nest == uintptr(0)) {
		goto __353
	}
	top_nest = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace
	goto __354
__353:
	if !(libc.PreIncUintptr(&top_nest, 12) >= end_nests) {
		goto __355
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR84
	goto FAILED
__355:
	;
__354:
	;
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth = nest_depth
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fflags = uint16(0)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Foptions = options & (DPCRE2_CASELESS | DPCRE2_DOTALL | DPCRE2_DUPNAMES | DPCRE2_EXTENDED | DPCRE2_EXTENDED_MORE | DPCRE2_MULTILINE | DPCRE2_NO_AUTO_CAPTURE | DPCRE2_UNGREEDY)

	// Start of non-capturing group that resets the capture count for each
	//       branch.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\174') {
		goto __356
	}

	(*Tnest_save)(unsafe.Pointer(top_nest)).Freset_group = uint16((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group = uint16((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount)
	*(*uint16)(unsafe.Pointer(top_nest + 6)) |= uint16(DNSF_RESET)
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_DUPCAPUSED)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __357
__356:

	hyphenok = DTRUE
	oldoptions = options

	(*Tnest_save)(unsafe.Pointer(top_nest)).Freset_group = uint16(0)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group = uint16(0)
	*(*uint32)(unsafe.Pointer(bp + 92 /* set */)) = libc.AssignPtrUint32(bp+96 /* unset */, uint32(0))
	optset = bp + 92 /* &set */

	// ^ at the start unsets imnsx and disables the subsequent use of -

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\136') {
		goto __358
	}

	options = options & libc.CplUint32(DPCRE2_CASELESS|DPCRE2_MULTILINE|DPCRE2_NO_AUTO_CAPTURE|DPCRE2_DOTALL|DPCRE2_EXTENDED|DPCRE2_EXTENDED_MORE)
	hyphenok = DFALSE
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
__358:
	;

__359:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\072') {
		goto __360
	}

	switch int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), 1)))) {
	case '\055':
		goto __362

	case '\112':
		goto __363

	case '\151':
		goto __364
	case '\155':
		goto __365
	case '\156':
		goto __366
	case '\163':
		goto __367
	case '\125':
		goto __368

	// If x appears twice it sets the extended extended option.

	case '\170':
		goto __369

	default:
		goto __370
	}
	goto __361

__362:
	if !!(hyphenok != 0) {
		goto __371
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR94
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))-- // Correct the offset
	goto FAILED
__371:
	;
	optset = bp + 96 /* &unset */
	hyphenok = DFALSE
	goto __361

__363: // Record that it changed in the external options
	*(*uint32)(unsafe.Pointer(optset)) |= DPCRE2_DUPNAMES
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_JCHANGED)
	goto __361

__364:
	*(*uint32)(unsafe.Pointer(optset)) |= DPCRE2_CASELESS
	goto __361
__365:
	*(*uint32)(unsafe.Pointer(optset)) |= DPCRE2_MULTILINE
	goto __361
__366:
	*(*uint32)(unsafe.Pointer(optset)) |= DPCRE2_NO_AUTO_CAPTURE
	goto __361
__367:
	*(*uint32)(unsafe.Pointer(optset)) |= DPCRE2_DOTALL
	goto __361
__368:
	*(*uint32)(unsafe.Pointer(optset)) |= DPCRE2_UNGREEDY
	goto __361

	// If x appears twice it sets the extended extended option.

__369:
	*(*uint32)(unsafe.Pointer(optset)) |= DPCRE2_EXTENDED
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\170') {
		goto __372
	}

	*(*uint32)(unsafe.Pointer(optset)) |= DPCRE2_EXTENDED_MORE
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
__372:
	;
	goto __361

__370:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR11
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))-- // Correct the offset
	goto FAILED
__361:
	;
	goto __359
__360:
	;

	// If we are setting extended without extended-more, ensure that any
	//         existing extended-more gets unset. Also, unsetting extended must also
	//         unset extended-more.

	if !(*(*uint32)(unsafe.Pointer(bp + 92))&(DPCRE2_EXTENDED|DPCRE2_EXTENDED_MORE) == DPCRE2_EXTENDED || *(*uint32)(unsafe.Pointer(bp + 96))&DPCRE2_EXTENDED != uint32(0)) {
		goto __373
	}
	*(*uint32)(unsafe.Pointer(bp + 96 /* unset */)) |= DPCRE2_EXTENDED_MORE
__373:
	;

	options = (options | *(*uint32)(unsafe.Pointer(bp + 92))) & ^*(*uint32)(unsafe.Pointer(bp + 96))

	// If the options ended with ')' this is not the start of a nested
	//         group with option changes, so the options change at this level.
	//         In this case, if the previous level set up a nest block, discard the
	//         one we have just created. Otherwise adjust it for the previous level.
	//         If the options ended with ':' we are starting a non-capturing group,
	//         possibly with an options setting.

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __374
	}
	goto UNCLOSED_PARENTHESIS
__374:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1)))) == '\051') {
		goto __375
	}

	nest_depth-- // This is not a nested group after all.
	if !(top_nest > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace && int32((*Tnest_save)(unsafe.Pointer(top_nest-uintptr(1)*12)).Fnest_depth) == int32(nest_depth)) {
		goto __377
	}
	top_nest -= 12
	goto __378
__377:
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth = nest_depth
__378:
	;
	goto __376
__375:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_NOCAPTURE
__376:
	;

	// If nothing changed, no need to record.

	if !(options != oldoptions) {
		goto __379
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_OPTIONS
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = options
__379:
	;
__357:
	;          // End options processing
	goto __328 // End default case after (?

	// ---- Python syntax support ----

__330:
	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __380
	}
	goto UNCLOSED_PARENTHESIS
__380:
	;

	// (?P<name> is the same as (?<name>, which defines a named group.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\074') {
		goto __381
	}

	terminator = uint32('\076')
	goto DEFINE_NAME
__381:
	;

	// (?P>name) is the same as (?&name), which is a recursion or subroutine
	//       call.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\076') {
		goto __382
	}
	goto RECURSE_BY_NAME
__382:
	;

	// (?P=name) is the same as \k<name>, a back reference by name. Anything
	//       else after (?P is an error.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\075') {
		goto __383
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR41
	goto FAILED
__383:
	;
	if !!(read_name(tls, bp+8, ptrend, utf, uint32('\051'), bp+56, bp+64,
		bp+72, bp+20, cb) != 0) {
		goto __384
	}
	goto FAILED
__384:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_BACKREF_BYNAME
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 72 /* namelen */))
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	okquantifier = DTRUE
	goto __328 // End of (?P processing

	// ---- Recursion/subroutine calls by number ----

__331:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0 // (?R) == (?R0)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __385
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR58
	goto FAILED
__385:
	;
	goto SET_RECURSION

	// An item starting (?- followed by a digit comes here via the "default"
	//       case because (?- followed by a non-digit is an options setting.

__332:
	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 < int64(2) || !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) <= '\071')) {
		goto __386
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR29 // Missing number
	goto FAILED
__386:
	;
	// Fall through

__333:
__334:
__335:
__336:
__337:
__338:
__339:
__340:
__341:
__342:
RECURSION_BYNUMBER:
	if !!(read_number(tls, bp+8, ptrend,
		func() int32 {
			if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) <= '\071' {
				return -1
			}
			return int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount)
		}(),
		DMAX_GROUP_NUMBER, ERR61,
		bp+48, bp+20) != 0) {
		goto __387
	}
	goto FAILED
__387:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < 0) {
		goto __388
	} /* NB (?0) is permitted */

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR15 // Unknown group
	goto FAILED_BACK
__388:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __389
	}
	goto UNCLOSED_PARENTHESIS
__389:
	;

SET_RECURSION:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_RECURSE | uint32(*(*int32)(unsafe.Pointer(bp + 48)))
	*(*uint64)(unsafe.Pointer(bp + 56 /* offset */)) = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 8))) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	okquantifier = DTRUE
	goto __328 // End of recursive call by number handling

	// ---- Recursion/subroutine calls by name ----

__343:
RECURSE_BY_NAME:
	if !!(read_name(tls, bp+8, ptrend, utf, uint32('\051'), bp+56, bp+64,
		bp+72, bp+20, cb) != 0) {
		goto __390
	}
	goto FAILED
__390:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_RECURSE_BYNAME
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 72 /* namelen */))
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	okquantifier = DTRUE
	goto __328

	// ---- Callout with numerical or string argument ----

__344:
	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __391
	}
	goto UNCLOSED_PARENTHESIS
__391:
	;

	// If the previous item was a condition starting (?(? an assertion,
	//       optionally preceded by a callout, is expected. This is checked later on,
	//       during actual compilation. However we need to identify this kind of
	//       assertion in this pass because it must not be qualified. The value of
	//       expect_cond_assert is set to 2 after (?(? is processed. We decrement it
	//       for a callout - still leaving a positive value that identifies the
	//       assertion. Multiple callouts or any other items will make it zero or
	//       less, which doesn't matter because they will cause an error later.

	expect_cond_assert = prev_expect_cond_assert - 1

	// If previous_callout is not NULL, it means this follows a previous
	//       callout. If it was a manual callout, do nothing; this means its "length
	//       of next pattern item" field will remain zero. If it was an automatic
	//       callout, abolish it.

	if !(*(*uintptr)(unsafe.Pointer(bp)) != uintptr(0) && options&DPCRE2_AUTO_CALLOUT != uint32(0) && *(*uintptr)(unsafe.Pointer(bp)) == parsed_pattern-uintptr(4)*4 && *(*uint32)(unsafe.Pointer(parsed_pattern + libc.UintptrFromInt32(-1)*4)) == uint32(255)) {
		goto __392
	}
	parsed_pattern = *(*uintptr)(unsafe.Pointer(bp /* previous_callout */))
__392:
	;

	// Save for updating next pattern item length, and skip one item before
	//       completing.

	*(*uintptr)(unsafe.Pointer(bp /* previous_callout */)) = parsed_pattern
	after_manual_callout = 1

	// Handle a string argument; specific delimiter is required.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051' && !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) <= '\071')) {
		goto __393
	}

	startptr = *(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))

	delimiter = uint32(0)
	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0
__395:
	if !(X_pcre2_callout_start_delims_8[*(*int32)(unsafe.Pointer(bp + 48))] != uint32(0)) {
		goto __397
	}

	if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == X_pcre2_callout_start_delims_8[*(*int32)(unsafe.Pointer(bp + 48))]) {
		goto __398
	}

	delimiter = X_pcre2_callout_end_delims_8[*(*int32)(unsafe.Pointer(bp + 48 /* i */))]
	goto __397
__398:
	;
	goto __396
__396:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	goto __395
	goto __397
__397:
	;
	if !(delimiter == uint32(0)) {
		goto __399
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR82
	goto FAILED
__399:
	;

	*(*uint32)(unsafe.Pointer(parsed_pattern)) = DMETA_CALLOUT_STRING
	parsed_pattern += 4 * uintptr(3) // Skip pattern info

__400:

	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __403
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR81
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) = startptr // To give a more useful message
	goto FAILED
__403:
	;
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == delimiter && (libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1) >= ptrend || uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != delimiter)) {
		goto __404
	}
	goto __402
__404:
	;
	goto __401
__401:
	goto __400
	goto __402
__402:
	;

	calloutlength = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 8))) - int64(startptr)) / 1)
	if !(calloutlength > uint64(4294967295)) {
		goto __405
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR72
	goto FAILED
__405:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(calloutlength)
	*(*uint64)(unsafe.Pointer(bp + 56 /* offset */)) = uint64((int64(startptr) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	goto __394
__393:

	n = 0
	*(*uint32)(unsafe.Pointer(parsed_pattern)) = DMETA_CALLOUT_NUMBER // Numerical callout
	parsed_pattern += 4 * uintptr(3)                                  // Skip pattern info
__406:
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) < ptrend && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) <= '\071')) {
		goto __407
	}

	n = n*10 + int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1)))) - '\060'
	if !(n > 255) {
		goto __408
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR38
	goto FAILED
__408:
	;
	goto __406
__407:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(n)
__394:
	;

	// Both formats must have a closing parenthesis

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __409
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR39
	goto FAILED
__409:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++

	// Remember the offset to the next item in the pattern, and set a default
	//       length. This should get updated after the next item is read.

	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* previous_callout */)) + 1*4)) = uint32((int64(*(*uintptr)(unsafe.Pointer(bp + 8))) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* previous_callout */)) + 2*4)) = uint32(0)
	goto __328 // End callout

	// ---- Conditional group ----

	// A condition can be an assertion, a number (referring to a numbered
	//       group's having been set), a name (referring to a named group), or 'R',
	//       referring to overall recursion. R<digits> and R&name are also permitted
	//       for recursion state tests. Numbers may be preceded by + or - to specify a
	//       relative group number.
	//
	//       There are several syntaxes for testing a named group: (?(name)) is used
	//       by Python; Perl 5.10 onwards uses (?(<name>) or (?('name')).
	//
	//       There are two unfortunate ambiguities. 'R' can be the recursive thing or
	//       the name 'R' (and similarly for 'R' followed by digits). 'DEFINE' can be
	//       the Perl DEFINE feature or the Python named test. We look for a name
	//       first; if not found, we try the other case.
	//
	//       For compatibility with auto-callouts, we allow a callout to be specified
	//       before a condition that is an assertion.

__345:
	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1) >= ptrend) {
		goto __410
	}
	goto UNCLOSED_PARENTHESIS
__410:
	;
	nest_depth++

	// If the next character is ? or * there must be an assertion next
	//       (optionally preceded by a callout). We do not check this here, but
	//       instead we set expect_cond_assert to 2. If this is still greater than
	//       zero (callouts decrement it) when the next assertion is read, it will be
	//       marked as a condition that must not be repeated. A value greater than
	//       zero also causes checking that an assertion (possibly with callout)
	//       follows.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\077' || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\052') {
		goto __411
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_COND_ASSERT
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))-- // Pull pointer back to the opening parenthesis.
	expect_cond_assert = 2
	goto __328 // End of conditional
__411:
	;

	// Handle (?([+-]number)...

	if !(read_number(tls, bp+8, ptrend, int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount), DMAX_GROUP_NUMBER, ERR61, bp+48,
		bp+20) != 0) {
		goto __412
	}

	if !(*(*int32)(unsafe.Pointer(bp + 48)) <= 0) {
		goto __414
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR15
	goto FAILED
__414:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_COND_NUMBER
	*(*uint64)(unsafe.Pointer(bp + 56 /* offset */)) = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 8)))-int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern))/1 - int64(2))
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*int32)(unsafe.Pointer(bp + 48 /* i */)))
	goto __413
__412:
	if !(*(*int32)(unsafe.Pointer(bp + 20)) != 0) {
		goto __415
	}
	goto FAILED
	goto __416
__415:
	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 >= int64(10) && X_pcre2_strncmp_c8_8(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), ts+615, uint64(7)) == 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 7))) != '\051') {
		goto __417
	}

	ge = uint32(0)
	*(*int32)(unsafe.Pointer(bp + 100 /* major */)) = 0
	minor = 0

	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(7)
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\076') {
		goto __419
	}

	ge = uint32(1)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
__419:
	;

	// NOTE: cannot write IS_DIGIT(*(++ptr)) here because IS_DIGIT
	//         references its argument twice.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\075' || func() bool {
		*(*uintptr)(unsafe.Pointer(bp + 8))++
		return !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) <= '\071')
	}()) {
		goto __420
	}
	goto BAD_VERSION_CONDITION
__420:
	;

	if !!(read_number(tls, bp+8, ptrend, -1, uint32(1000), ERR79, bp+100, bp+20) != 0) {
		goto __421
	}
	goto FAILED
__421:
	;

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __422
	}
	goto BAD_VERSION_CONDITION
__422:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\056') {
		goto __423
	}

	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1) >= ptrend || !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) <= '\071')) {
		goto __424
	}
	goto BAD_VERSION_CONDITION
__424:
	;
	minor = (int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1)))) - '\060') * 10
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __425
	}
	goto BAD_VERSION_CONDITION
__425:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) <= '\071') {
		goto __426
	}
	minor = minor + (int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 8)), 1)))) - '\060')
__426:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __427
	}
	goto BAD_VERSION_CONDITION
__427:
	;
__423:
	;

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_COND_VERSION
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = ge
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*int32)(unsafe.Pointer(bp + 100 /* major */)))
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(minor)
	goto __418
__417:

	was_r_ampersand = DFALSE

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\122' && (int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 > int64(1) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) == '\046') {
		goto __428
	}

	terminator = uint32('\051')
	was_r_ampersand = DTRUE
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __429
__428:
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\074') {
		goto __430
	}
	terminator = uint32('\076')
	goto __431
__430:
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) == '\047') {
		goto __432
	}
	terminator = uint32('\047')
	goto __433
__432:

	terminator = uint32('\051')
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))-- // Point to char before name
__433:
	;
__431:
	;
__429:
	;
	if !!(read_name(tls, bp+8, ptrend, utf, terminator, bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __434
	}
	goto FAILED
__434:
	;

	// Handle (?(R&name)

	if !(was_r_ampersand != 0) {
		goto __435
	}

	*(*uint32)(unsafe.Pointer(parsed_pattern)) = DMETA_COND_RNAME
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))-- // Back to closing parens
	goto __436
__435:
	if !(terminator == uint32('\051')) {
		goto __437
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 72)) == uint32(6) && X_pcre2_strncmp_c8_8(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), ts+623, uint64(6)) == 0) {
		goto __439
	}
	*(*uint32)(unsafe.Pointer(parsed_pattern)) = DMETA_COND_DEFINE
	goto __440
__439:

	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 1
__441:
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < int32(*(*uint32)(unsafe.Pointer(bp + 72)))) {
		goto __443
	}
	if !!(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64)) + uintptr(*(*int32)(unsafe.Pointer(bp + 48)))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64)) + uintptr(*(*int32)(unsafe.Pointer(bp + 48)))))) <= '\071') {
		goto __444
	}
	goto __443
__444:
	;
	goto __442
__442:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	goto __441
	goto __443
__443:
	;
	*(*uint32)(unsafe.Pointer(parsed_pattern)) = func() uint32 {
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64))))) == '\122' && *(*int32)(unsafe.Pointer(bp + 48)) >= int32(*(*uint32)(unsafe.Pointer(bp + 72))) {
			return DMETA_COND_RNUMBER
		}
		return DMETA_COND_NAME
	}()
__440:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))-- // Back to closing parens
	goto __438
__437:
	*(*uint32)(unsafe.Pointer(parsed_pattern)) = DMETA_COND_NAME
__438:
	;
__436:
	;

	// All these cases except DEFINE end with the name length and offset;
	//         DEFINE just has an offset (for the "too many branches" error).

	if !(*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) != DMETA_COND_DEFINE) {
		goto __445
	}
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = *(*uint32)(unsafe.Pointer(bp + 72 /* namelen */))
__445:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

__418:
	;
__416:
	;
__413:
	; // End cases that read a name

	// Check the closing parenthesis of the condition

	if !(*(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))) != '\051') {
		goto __446
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR24
	goto FAILED
__446:
	;
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __328 // End of condition processing

	// ---- Atomic group ----

__346:
ATOMIC_GROUP: // Come from (*atomic:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ATOMIC
	nest_depth++
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto __328

	// ---- Lookahead assertions ----

__347:
POSITIVE_LOOK_AHEAD: // Come from (*pla:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKAHEAD
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto POST_ASSERTION

__348:
POSITIVE_NONATOMIC_LOOK_AHEAD: // Come from (?*
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKAHEAD_NA
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto POST_ASSERTION

__349:
NEGATIVE_LOOK_AHEAD: // Come from (*nla:
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_LOOKAHEADNOT
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))++
	goto POST_ASSERTION

	// ---- Lookbehind assertions ----

	// (?< followed by = or ! or * is a lookbehind assertion. Otherwise (?<
	//       is the start of the name of a capturing group.

__350:
	if !((int64(ptrend)-int64(*(*uintptr)(unsafe.Pointer(bp + 8))))/1 <= int64(1) || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) != '\075' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) != '\041' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) != '\052') {
		goto __447
	}

	terminator = uint32('\076')
	goto DEFINE_NAME
__447:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = func() uint32 {
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) == '\075' {
			return DMETA_LOOKBEHIND
		}
		return func() uint32 {
			if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1))) == '\041' {
				return DMETA_LOOKBEHINDNOT
			}
			return DMETA_LOOKBEHIND_NA
		}()
	}()

POST_LOOKBEHIND: // Come from (*plb: (*naplb: and (*nlb:
	*(*int32)(unsafe.Pointer(has_lookbehind)) = DTRUE
	*(*uint64)(unsafe.Pointer(bp + 56 /* offset */)) = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 8)))-int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern))/1 - int64(2))
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) >> 32)
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = uint32(*(*uint64)(unsafe.Pointer(bp + 56)) & uint64(0xffffffff))

	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)) += uintptr(2)
	// Fall through

	// If the previous item was a condition starting (?(? an assertion,
	//       optionally preceded by a callout, is expected. This is checked later on,
	//       during actual compilation. However we need to identify this kind of
	//       assertion in this pass because it must not be qualified. The value of
	//       expect_cond_assert is set to 2 after (?(? is processed. We decrement it
	//       for a callout - still leaving a positive value that identifies the
	//       assertion. Multiple callouts or any other items will make it zero or
	//       less, which doesn't matter because they will cause an error later.

POST_ASSERTION:
	nest_depth++
	if !(prev_expect_cond_assert > 0) {
		goto __448
	}

	if !(top_nest == uintptr(0)) {
		goto __449
	}
	top_nest = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace
	goto __450
__449:
	if !(libc.PreIncUintptr(&top_nest, 12) >= end_nests) {
		goto __451
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR84
	goto FAILED
__451:
	;
__450:
	;
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth = nest_depth
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fflags = uint16(DNSF_CONDASSERT)
	(*Tnest_save)(unsafe.Pointer(top_nest)).Foptions = options & (DPCRE2_CASELESS | DPCRE2_DOTALL | DPCRE2_DUPNAMES | DPCRE2_EXTENDED | DPCRE2_EXTENDED_MORE | DPCRE2_MULTILINE | DPCRE2_NO_AUTO_CAPTURE | DPCRE2_UNGREEDY)
__448:
	;
	goto __328

	// ---- Define a named group ----

	// A named group may be defined as (?'name') or (?<name>). In the latter
	//       case we jump to DEFINE_NAME from the disambiguation of (?< above with the
	//       terminator set to '>'.

__351:
	terminator = uint32('\047') // Terminator

DEFINE_NAME:
	if !!(read_name(tls, bp+8, ptrend, utf, terminator, bp+56, bp+64, bp+72,
		bp+20, cb) != 0) {
		goto __452
	}
	goto FAILED
__452:
	;

	// We have a name for this capturing group. It is also assigned a number,
	//       which is its primary means of identification.

	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount >= DMAX_GROUP_NUMBER) {
		goto __453
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR97
	goto FAILED
__453:
	;
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount++
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_CAPTURE | (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount
	nest_depth++

	// Check not too many names

	if !(int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found) >= DMAX_NAME_COUNT) {
		goto __454
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR49
	goto FAILED
__454:
	;

	// Adjust the entry size to accommodate the longest name found.

	if !(*(*uint32)(unsafe.Pointer(bp + 72))+uint32(DIMM2_SIZE)+uint32(1) > uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)) {
		goto __455
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size = uint16(*(*uint32)(unsafe.Pointer(bp + 72)) + uint32(DIMM2_SIZE) + uint32(1))
__455:
	;

	// Scan the list to check for duplicates. For duplicate names, if the
	//       number is the same, break the loop, which causes the name to be
	//       discarded; otherwise, if DUPNAMES is not set, give an error.
	//       If it is set, allow the name with a different number, but continue
	//       scanning in case this is a duplicate with the same number. For
	//       non-duplicate names, give an error if the number is duplicated.

	isdupname = DFALSE
	ng = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups
	*(*int32)(unsafe.Pointer(bp + 48 /* i */)) = 0
__456:
	if !(*(*int32)(unsafe.Pointer(bp + 48)) < int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __458
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 72)) == uint32((*Tnamed_group_8)(unsafe.Pointer(ng)).Flength) && X_pcre2_strncmp_8(tls, *(*uintptr)(unsafe.Pointer(bp + 64)), (*Tnamed_group_8)(unsafe.Pointer(ng)).Fname, uint64(*(*uint32)(unsafe.Pointer(bp + 72)))) == 0) {
		goto __459
	}

	if !((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber == (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __461
	}
	goto __458
__461:
	;
	if !(options&DPCRE2_DUPNAMES == uint32(0)) {
		goto __462
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR43
	goto FAILED
__462:
	;
	isdupname = int32(libc.AssignPtrUint16(ng+14, uint16(DTRUE))) // Mark as a duplicate
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fdupnames = DTRUE     // Duplicate names exist
	goto __460
__459:
	if !((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber == (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __463
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR65
	goto FAILED
__463:
	;
__460:
	;
	goto __457
__457:
	*(*int32)(unsafe.Pointer(bp + 48 /* i */))++
	ng += 16
	goto __456
	goto __458
__458:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 48)) < int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __464
	}
	goto __328
__464:
	; // Ignore duplicate with same number

	// Increase the list size if necessary

	if !(uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found) >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size) {
		goto __465
	}

	newsize = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size * uint32(2)
	newspace =
		(*struct {
			f func(*libc.TLS, uint64, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fmemctl.Fmalloc})).f(tls, uint64(newsize)*uint64(unsafe.Sizeof(Tnamed_group_8{})),
			(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fmemctl.Fmemory_data)
	if !(newspace == uintptr(0)) {
		goto __466
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR21
	goto FAILED
__466:
	;

	libc.Xmemcpy(tls, newspace, (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups,
		uint64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size)*uint64(unsafe.Sizeof(Tnamed_group_8{})))
	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size > uint32(DNAMED_GROUP_LIST_SIZE)) {
		goto __467
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fmemctl.Ffree})).f(tls, (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups,
		(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fmemctl.Fmemory_data)
__467:
	;
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups = newspace
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_group_list_size = newsize
__465:
	;

	// Add this name to the list

	(*Tnamed_group_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)*16)).Fname = *(*uintptr)(unsafe.Pointer(bp + 64 /* name */))
	(*Tnamed_group_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)*16)).Flength = uint16(*(*uint32)(unsafe.Pointer(bp + 72 /* namelen */)))
	(*Tnamed_group_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)*16)).Fnumber = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount
	(*Tnamed_group_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups + uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)*16)).Fisdup = uint16(isdupname)
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found++
	goto __328
__328:
	;         // End of (? switch
	goto __84 // End of ( handling

	// ---- Branch terminators ----

	// Alternation: reset the capture count if we are in a (?| group.

__96:
	if !(top_nest != uintptr(0) && int32((*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth) == int32(nest_depth) && uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fflags)&DNSF_RESET != uint32(0)) {
		goto __468
	}

	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount > uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group)) {
		goto __469
	}
	(*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group = uint16((*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount)
__469:
	;
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount = uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Freset_group)
__468:
	;
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ALT
	goto __84

	// End of group; reset the capture count to the maximum if we are in a (?|
	//     group and/or reset the options that are tracked during parsing. Disallow
	//     quantifier for a condition that is an assertion.

__97:
	okquantifier = DTRUE
	if !(top_nest != uintptr(0) && int32((*Tnest_save)(unsafe.Pointer(top_nest)).Fnest_depth) == int32(nest_depth)) {
		goto __470
	}

	options = options&libc.CplUint32(DPCRE2_CASELESS|DPCRE2_DOTALL|DPCRE2_DUPNAMES|DPCRE2_EXTENDED|DPCRE2_EXTENDED_MORE|DPCRE2_MULTILINE|DPCRE2_NO_AUTO_CAPTURE|DPCRE2_UNGREEDY) | (*Tnest_save)(unsafe.Pointer(top_nest)).Foptions
	if !(uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fflags)&DNSF_RESET != uint32(0) && uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group) > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __471
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount = uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fmax_group)
__471:
	;
	if !(uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fflags)&DNSF_CONDASSERT != uint32(0)) {
		goto __472
	}
	okquantifier = DFALSE
__472:
	;

	if !(uint32((*Tnest_save)(unsafe.Pointer(top_nest)).Fflags)&DNSF_ATOMICSR != uint32(0)) {
		goto __473
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
__473:
	;

	if !(top_nest == (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace) {
		goto __474
	}
	top_nest = uintptr(0)
	goto __475
__474:
	top_nest -= 12
__475:
	;
__470:
	;
	if !(int32(nest_depth) == 0) {
		goto __476
	} /* Unmatched closing parenthesis */

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR22
	goto FAILED_BACK
__476:
	;
	nest_depth--
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
	goto __84
__84:
	; // End of switch on pattern character
	goto __19
__20:
	; // End of main character scan loop

	// End of pattern reached. Check for missing ) at the end of a verb name.

	if !(inverbname != 0 && *(*uintptr)(unsafe.Pointer(bp + 8)) >= ptrend) {
		goto __477
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR60
	goto FAILED
__477:
	;

	// Manage callout for the final item

PARSED_END:
	parsed_pattern = manage_callouts(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */)), bp, auto_callout,
		parsed_pattern, cb)

	// Insert trailing items for word and line matching (features provided for the
	// benefit of pcre2grep).

	if !(extra_options&DPCRE2_EXTRA_MATCH_LINE != uint32(0)) {
		goto __478
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_DOLLAR
	goto __479
__478:
	if !(extra_options&DPCRE2_EXTRA_MATCH_WORD != uint32(0)) {
		goto __480
	}

	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_KET
	*(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&parsed_pattern, 4))) = DMETA_ESCAPE + ESC_b
__480:
	;
__479:
	;

	// Terminate the parsed pattern, then return success if all groups are closed.
	// Otherwise we have unclosed parentheses.

	if !(parsed_pattern >= parsed_pattern_end) {
		goto __481
	}

	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR63 // Internal error (parsed pattern overflow)
	goto FAILED
__481:
	;

	*(*uint32)(unsafe.Pointer(parsed_pattern)) = DMETA_END
	if !(int32(nest_depth) == 0) {
		goto __482
	}
	return 0
__482:
	;

UNCLOSED_PARENTHESIS:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR14

	// Come here for all failures.

FAILED:
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 8))) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
	return *(*int32)(unsafe.Pointer(bp + 20 /* errorcode */))

	// Some errors need to indicate the previous character.

FAILED_BACK:
	*(*uintptr)(unsafe.Pointer(bp + 8 /* ptr */))--
	goto FAILED

	// This failure happens several times.

BAD_VERSION_CONDITION:
	*(*int32)(unsafe.Pointer(bp + 20 /* errorcode */)) = ERR79
	goto FAILED
	return int32(0)
}

// ************************************************
//
//       Find first significant opcode            *
//

// This is called by several functions that scan a compiled expression looking
// for a fixed first character, or an anchoring opcode etc. It skips over things
// that do not influence this. For some calls, it makes sense to skip negative
// forward and all backward assertions, and also the \b assertion; for others it
// does not.
//
// Arguments:
//   code         pointer to the start of the group
//   skipassert   TRUE if certain assertions are to be skipped
//
// Returns:       pointer to the first significant opcode

func first_significant_code(tls *libc.TLS, code uintptr, skipassert int32) uintptr { /* pcre2_compile.c:4847:25: */
	for {
		switch int32(*(*uint8)(unsafe.Pointer(code))) {
		case OP_ASSERT_NOT:
			fallthrough
		case OP_ASSERTBACK:
			fallthrough
		case OP_ASSERTBACK_NOT:
			fallthrough
		case OP_ASSERTBACK_NA:
			if !(skipassert != 0) {
				return code
			}
			for __ccgo := true; __ccgo; __ccgo = int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT {
				code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
			}
			code += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(code))])
			break

		case OP_WORD_BOUNDARY:
			fallthrough
		case OP_NOT_WORD_BOUNDARY:
			if !(skipassert != 0) {
				return code
			}
			fallthrough
		// Fall through

		case OP_CALLOUT:
			fallthrough
		case OP_CREF:
			fallthrough
		case OP_DNCREF:
			fallthrough
		case OP_RREF:
			fallthrough
		case OP_DNRREF:
			fallthrough
		case OP_FALSE:
			fallthrough
		case OP_TRUE:
			code += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(code))])
			break

		case OP_CALLOUT_STR:
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 6)))))
			break

		case OP_SKIPZERO:
			code += uintptr(uint32(2) + uint32(int32(*(*uint8)(unsafe.Pointer(code + 2)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 3)))) + uint32(DLINK_SIZE))
			break

		case OP_COND:
			fallthrough
		case OP_SCOND:
			if int32(*(*uint8)(unsafe.Pointer(code + 3))) != OP_FALSE || int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))))) != OP_KET { // More than one branch
				return code
			}
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))) + uint32(1) + uint32(DLINK_SIZE))
			break

		case OP_MARK:
			fallthrough
		case OP_COMMIT_ARG:
			fallthrough
		case OP_PRUNE_ARG:
			fallthrough
		case OP_SKIP_ARG:
			fallthrough
		case OP_THEN_ARG:
			code += uintptr(int32(*(*uint8)(unsafe.Pointer(code + 1))) + int32(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(code))]))
			break

		default:
			return code
		}
	}
	return uintptr(0)
	// Control never reaches here
}

// ************************************************
//
//           Get othercase range                  *
//

// This function is passed the start and end of a class range in UCP mode. It
// searches up the characters, looking for ranges of characters in the "other"
// case. Each call returns the next one, updating the start address. A character
// with multiple other cases is returned on its own with a special return value.
//
// Arguments:
//   cptr        points to starting character value; updated
//   d           end value
//   ocptr       where to put start of othercase range
//   odptr       where to put end of othercase range
//
// Yield:        -1 when no more
//                0 when a range is returned
//               >0 the CASESET offset for char with multiple other cases
//                 in this case, ocptr contains the original

func get_othercase_range(tls *libc.TLS, cptr uintptr, d uint32, ocptr uintptr, odptr uintptr) int32 { /* pcre2_compile.c:4934:1: */
	var c uint32
	var othercase uint32
	var next uint32
	var co uint32

	// Find the first character that has an other case. If it has multiple other
	// cases, return its case offset value.

	for c = *(*uint32)(unsafe.Pointer(cptr)); c <= d; c++ {
		if libc.AssignUint32(&co, uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fcaseset)) != uint32(0) {
			*(*uint32)(unsafe.Pointer(ocptr)) = libc.PostIncUint32(&c, 1) // Character that has the set
			*(*uint32)(unsafe.Pointer(cptr)) = c                          // Rest of input range
			return int32(co)
		}
		if libc.AssignUint32(&othercase, uint32(int32(c)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fother_case)) != c {
			break
		}
	}

	if c > d {
		return -1
	} // Reached end of range

	// Found a character that has a single other case. Search for the end of the
	// range, which is either the end of the input range, or a character that has zero
	// or more than one other cases.

	*(*uint32)(unsafe.Pointer(ocptr)) = othercase
	next = othercase + uint32(1)

	for c++; c <= d; c++ {
		if libc.AssignUint32(&co, uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fcaseset)) != uint32(0) || uint32(int32(c)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fother_case) != next {
			break
		}
		next++
	}

	*(*uint32)(unsafe.Pointer(odptr)) = next - uint32(1) // End of othercase range
	*(*uint32)(unsafe.Pointer(cptr)) = c                 // Rest of input range
	return 0
}

// ************************************************
//
// Add a character or range to a class (internal) *
//

// This function packages up the logic of adding a character or range of
// characters to a class. The character values in the arguments will be within the
// valid values for the current mode (8-bit, 16-bit, UTF, etc). This function is
// called only from within the "add to class" group of functions, some of which
// are recursive and mutually recursive. The external entry point is
// add_to_class().
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            compile data
//   start         start of range character
//   end           end of range character
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_to_class_internal(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options uint32, cb uintptr, start uint32, end uint32) uint32 { /* pcre2_compile.c:5001:1: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var c uint32 at bp, 4

	var classbits_end uint32 = func() uint32 {
		if end <= uint32(0xff) {
			return end
		}
		return uint32(0xff)
	}()
	var n8 uint32 = uint32(0)

	// If caseless matching is required, scan the range and process alternate
	// cases. In Unicode, there are 8-bit characters that have alternate cases that
	// are greater than 255 and vice-versa. Sometimes we can just extend the original
	// range.

	if options&DPCRE2_CASELESS != uint32(0) {
		if options&(DPCRE2_UTF|DPCRE2_UCP) != uint32(0) {
			var rc int32
			// var oc uint32 at bp+4, 4

			// var od uint32 at bp+8, 4

			options = options & libc.CplUint32(DPCRE2_CASELESS) // Remove for recursive calls
			*(*uint32)(unsafe.Pointer(bp /* c */)) = start

			for libc.AssignInt32(&rc, get_othercase_range(tls, bp, end, bp+4, bp+8)) >= 0 {
				// Handle a single character that has more than one other case.

				if rc > 0 {
					n8 = n8 + add_list_to_class_internal(tls, classbits, uchardptr, options, cb,
						uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8))+uintptr(rc)*4, *(*uint32)(unsafe.Pointer(bp + 4)))
				} else if *(*uint32)(unsafe.Pointer(bp + 4)) >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_start && *(*uint32)(unsafe.Pointer(bp + 8)) <= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_end {
					continue
				} else if *(*uint32)(unsafe.Pointer(bp + 4)) < start && *(*uint32)(unsafe.Pointer(bp + 8)) >= start-uint32(1) {
					start = *(*uint32)(unsafe.Pointer(bp + 4 /* oc */))
				} else if *(*uint32)(unsafe.Pointer(bp + 8)) > end && *(*uint32)(unsafe.Pointer(bp + 4)) <= end+uint32(1) {
					end = *(*uint32)(unsafe.Pointer(bp + 8 /* od */)) // Extend upwards
					if end > classbits_end {
						classbits_end = func() uint32 {
							if end <= uint32(0xff) {
								return end
							}
							return uint32(0xff)
						}()
					}
				} else {
					n8 = n8 + add_to_class_internal(tls, classbits, uchardptr, options, cb, *(*uint32)(unsafe.Pointer(bp + 4)), *(*uint32)(unsafe.Pointer(bp + 8)))
				}
			}
		} else {

			// Not UTF mode

			for *(*uint32)(unsafe.Pointer(bp /* c */)) = start; *(*uint32)(unsafe.Pointer(bp /* c */)) <= classbits_end; *(*uint32)(unsafe.Pointer(bp /* c */))++ {
				*(*uint8)(unsafe.Pointer(classbits + uintptr(int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc + uintptr(*(*uint32)(unsafe.Pointer(bp))))))/8))) = uint8(uint32(*(*uint8)(unsafe.Pointer(classbits + uintptr(int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc + uintptr(*(*uint32)(unsafe.Pointer(bp))))))/8)))) | uint32(1)<<(int32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc + uintptr(*(*uint32)(unsafe.Pointer(bp))))))&7))
				n8++
			}
		}
	}

	// Now handle the originally supplied range. Adjust the final value according
	// to the bit length - this means that the same lists of (e.g.) horizontal spaces
	// can be used in all cases.

	if options&DPCRE2_UTF == uint32(0) && end > uint32(0xffffffff)>>(32-DPCRE2_CODE_UNIT_WIDTH) {
		end = uint32(0xffffffff) >> (32 - DPCRE2_CODE_UNIT_WIDTH)
	}

	if start > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_start && end < (*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_end {
		return n8
	}

	// Use the bitmap for characters < 256. Otherwise use extra data.

	for *(*uint32)(unsafe.Pointer(bp /* c */)) = start; *(*uint32)(unsafe.Pointer(bp /* c */)) <= classbits_end; *(*uint32)(unsafe.Pointer(bp /* c */))++ {
		// Regardless of start, c will always be <= 255.
		*(*uint8)(unsafe.Pointer(classbits + uintptr(*(*uint32)(unsafe.Pointer(bp))/uint32(8)))) = uint8(uint32(*(*uint8)(unsafe.Pointer(classbits + uintptr(*(*uint32)(unsafe.Pointer(bp))/uint32(8))))) | uint32(1)<<(*(*uint32)(unsafe.Pointer(bp))&uint32(7)))
		n8++
	}

	if start <= uint32(0xff) {
		start = uint32(0xff + 1)
	}

	if end >= start {
		var uchardata uintptr = *(*uintptr)(unsafe.Pointer(uchardptr))

		if options&DPCRE2_UTF != uint32(0) {
			if start < end {
				*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&uchardata, 1))) = uint8(DXCL_RANGE)
				uchardata += uintptr(X_pcre2_ord2utf_8(tls, start, uchardata))
				uchardata += uintptr(X_pcre2_ord2utf_8(tls, end, uchardata))
			} else if start == end {
				*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&uchardata, 1))) = uint8(DXCL_SINGLE)
				uchardata += uintptr(X_pcre2_ord2utf_8(tls, start, uchardata))
			}
		} else {
		}
		*(*uintptr)(unsafe.Pointer(uchardptr)) = uchardata // Updata extra data pointer
	}

	return n8 // Number of 8-bit characters
}

// ************************************************
//
// Add a list of characters to a class (internal) *
//

// This function is used for adding a list of case-equivalent characters to a
// class when in UTF mode. This function is called only from within
// add_to_class_internal(), with which it is mutually recursive.
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            contains pointers to tables etc.
//   p             points to row of 32-bit values, terminated by NOTACHAR
//   except        character to omit; this is used when adding lists of
//                   case-equivalent characters to avoid including the one we
//                   already know about
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_list_to_class_internal(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options uint32, cb uintptr, p uintptr, except uint32) uint32 { /* pcre2_compile.c:5156:1: */
	var n8 uint32 = uint32(0)
	for *(*uint32)(unsafe.Pointer(p)) < DNOTACHAR {
		var n uint32 = uint32(0)
		if *(*uint32)(unsafe.Pointer(p)) != except {
			for *(*uint32)(unsafe.Pointer(p + uintptr(n+uint32(1))*4)) == *(*uint32)(unsafe.Pointer(p))+n+uint32(1) {
				n++
			}
			n8 = n8 + add_to_class_internal(tls, classbits, uchardptr, options, cb, *(*uint32)(unsafe.Pointer(p)), *(*uint32)(unsafe.Pointer(p + uintptr(n)*4)))
		}
		p += 4 * uintptr(n+uint32(1))
	}
	return n8
}

// ************************************************
//
//   External entry point for add range to class  *
//

// This function sets the overall range so that the internal functions can try
// to avoid duplication when handling case-independence.
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            compile data
//   start         start of range character
//   end           end of range character
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_to_class(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options uint32, cb uintptr, start uint32, end uint32) uint32 { /* pcre2_compile.c:5196:1: */
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_start = start
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_end = end
	return add_to_class_internal(tls, classbits, uchardptr, options, cb, start, end)
}

// ************************************************
//
//   External entry point for add list to class   *
//

// This function is used for adding a list of horizontal or vertical whitespace
// characters to a class. The list must be in order so that ranges of characters
// can be detected and handled appropriately. This function sets the overall range
// so that the internal functions can try to avoid duplication when handling
// case-independence.
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            contains pointers to tables etc.
//   p             points to row of 32-bit values, terminated by NOTACHAR
//   except        character to omit; this is used when adding lists of
//                   case-equivalent characters to avoid including the one we
//                   already know about
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_list_to_class(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options uint32, cb uintptr, p uintptr, except uint32) uint32 { /* pcre2_compile.c:5230:1: */
	var n8 uint32 = uint32(0)
	for *(*uint32)(unsafe.Pointer(p)) < DNOTACHAR {
		var n uint32 = uint32(0)
		if *(*uint32)(unsafe.Pointer(p)) != except {
			for *(*uint32)(unsafe.Pointer(p + uintptr(n+uint32(1))*4)) == *(*uint32)(unsafe.Pointer(p))+n+uint32(1) {
				n++
			}
			(*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_start = *(*uint32)(unsafe.Pointer(p))
			(*Tcompile_block_8)(unsafe.Pointer(cb)).Fclass_range_end = *(*uint32)(unsafe.Pointer(p + uintptr(n)*4))
			n8 = n8 + add_to_class_internal(tls, classbits, uchardptr, options, cb, *(*uint32)(unsafe.Pointer(p)), *(*uint32)(unsafe.Pointer(p + uintptr(n)*4)))
		}
		p += 4 * uintptr(n+uint32(1))
	}
	return n8
}

// ************************************************
//
//    Add characters not in a list to a class     *
//

// This function is used for adding the complement of a list of horizontal or
// vertical whitespace to a class. The list must be in order.
//
// Arguments:
//   classbits     the bit map for characters < 256
//   uchardptr     points to the pointer for extra data
//   options       the options word
//   cb            contains pointers to tables etc.
//   p             points to row of 32-bit values, terminated by NOTACHAR
//
// Returns:        the number of < 256 characters added
//                 the pointer to extra data is updated

func add_not_list_to_class(tls *libc.TLS, classbits uintptr, uchardptr uintptr, options uint32, cb uintptr, p uintptr) uint32 { /* pcre2_compile.c:5270:1: */
	var utf int32 = libc.Bool32(options&DPCRE2_UTF != uint32(0))
	var n8 uint32 = uint32(0)
	if *(*uint32)(unsafe.Pointer(p)) > uint32(0) {
		n8 = n8 + add_to_class(tls, classbits, uchardptr, options, cb, uint32(0), *(*uint32)(unsafe.Pointer(p))-uint32(1))
	}
	for *(*uint32)(unsafe.Pointer(p)) < DNOTACHAR {
		for *(*uint32)(unsafe.Pointer(p + 1*4)) == *(*uint32)(unsafe.Pointer(p))+uint32(1) {
			p += 4
		}
		n8 = n8 + add_to_class(tls, classbits, uchardptr, options, cb, *(*uint32)(unsafe.Pointer(p))+uint32(1),
			func() uint32 {
				if *(*uint32)(unsafe.Pointer(p + 1*4)) == DNOTACHAR {
					return func() uint32 {
						if utf != 0 {
							return 0x10ffff
						}
						return 0xffffffff
					}()
				}
				return *(*uint32)(unsafe.Pointer(p + 1*4)) - uint32(1)
			}())
		p += 4
	}
	return n8
}

// ************************************************
//
//    Find details of duplicate group names       *
//

// This is called from compile_branch() when it needs to know the index and
// count of duplicates in the names table when processing named backreferences,
// either directly, or as conditions.
//
// Arguments:
//   name          points to the name
//   length        the length of the name
//   indexptr      where to put the index
//   countptr      where to put the count of duplicates
//   errorcodeptr  where to put an error code
//   cb            the compile block
//
// Returns:        TRUE if OK, FALSE if not, error code set

func find_dupname_details(tls *libc.TLS, name uintptr, length uint32, indexptr uintptr, countptr uintptr, errorcodeptr uintptr, cb uintptr) int32 { /* pcre2_compile.c:5309:1: */
	var i uint32
	var groupnumber uint32
	var count int32
	var slot uintptr = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_table

	// Find the first entry in the table

	for i = uint32(0); i < uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found); i++ {
		if X_pcre2_strncmp_8(tls, name, slot+uintptr(DIMM2_SIZE), uint64(length)) == 0 && int32(*(*uint8)(unsafe.Pointer(slot + uintptr(uint32(DIMM2_SIZE)+length)))) == 0 {
			break
		}
		slot += uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)
	}

	// This should not occur, because this function is called only when we know we
	// have duplicate names. Give an internal error.

	if i >= uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found) {
		*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR53
		(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = uint64((int64(name) - int64((*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern)) / 1)
		return DFALSE
	}

	// Record the index and then see how many duplicates there are, updating the
	// backref map and maximum back reference as we do.

	*(*int32)(unsafe.Pointer(indexptr)) = int32(i)
	count = 0

	for {
		count++
		groupnumber = uint32(int32(*(*uint8)(unsafe.Pointer(slot)))<<8 | int32(*(*uint8)(unsafe.Pointer(slot + 1))))
		*(*uint32)(unsafe.Pointer(cb + 252)) |= func() uint32 {
			if groupnumber < uint32(32) {
				return uint32(1) << groupnumber
			}
			return uint32(1)
		}()
		if groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref {
			(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = groupnumber
		}
		if libc.PreIncUint32(&i, 1) >= uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found) {
			break
		}
		slot += uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)
		if X_pcre2_strncmp_8(tls, name, slot+uintptr(DIMM2_SIZE), uint64(length)) != 0 || int32(*(*uint8)(unsafe.Pointer(slot + uintptr(DIMM2_SIZE) + uintptr(length)))) != 0 {
			break
		}
	}

	*(*int32)(unsafe.Pointer(countptr)) = count
	return DTRUE
}

// ************************************************
//
//           Compile one branch                   *
//

// Scan the parsed pattern, compiling it into the a vector of PCRE2_UCHAR. If
// the options are changed during the branch, the pointer is used to change the
// external options bits. This function is used during the pre-compile phase when
// we are trying to find out the amount of memory needed, as well as during the
// real compile phase. The value of lengthptr distinguishes the two phases.
//
// Arguments:
//   optionsptr        pointer to the option bits
//   codeptr           points to the pointer to the current code point
//   pptrptr           points to the current parsed pattern pointer
//   errorcodeptr      points to error code variable
//   firstcuptr        place to put the first required code unit
//   firstcuflagsptr   place to put the first code unit flags
//   reqcuptr          place to put the last required code unit
//   reqcuflagsptr     place to put the last required code unit flags
//   bcptr             points to current branch chain
//   cb                contains pointers to tables etc.
//   lengthptr         NULL during the real compile phase
//                     points to length accumulator during pre-compile phase
//
// Returns:            0 There's been an error, *errorcodeptr is non-zero
//                    +1 Success, this branch must match at least one character
//                    -1 Success, this branch may match an empty string

func compile_branch(tls *libc.TLS, optionsptr uintptr, codeptr uintptr, pptrptr uintptr, errorcodeptr uintptr, firstcuptr uintptr, firstcuflagsptr uintptr, reqcuptr uintptr, reqcuflagsptr uintptr, bcptr uintptr, cb uintptr, lengthptr uintptr) int32 { /* pcre2_compile.c:5389:1: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var bravalue int32
	var okreturn int32
	var group_return int32
	var repeat_min uint32
	var repeat_max uint32 // To please picky compilers
	var greedy_default uint32
	var greedy_non_default uint32
	var repeat_type uint32
	var op_type uint32
	var options uint32 // May change dynamically
	var firstcu uint32
	var reqcu uint32
	var zeroreqcu uint32
	var zerofirstcu uint32
	var escape uint32
	// var pptr uintptr at bp+96, 8

	var meta uint32
	var meta_arg uint32
	var firstcuflags uint32
	var reqcuflags uint32
	var zeroreqcuflags uint32
	var zerofirstcuflags uint32
	var req_caseopt uint32
	var reqvary uint32
	var tempreqvary uint32
	var offset uint64
	// var length_prevgroup uint64 at bp+120, 8

	var code uintptr
	var last_code uintptr
	var orig_code uintptr
	// var tempcode uintptr at bp+88, 8

	var previous uintptr
	var op_previous uint8
	var groupsetfirstcu int32
	var had_accept int32
	var matched_char int32
	var previous_matched_char int32
	var reset_caseful int32
	var cbits uintptr
	// var classbits [32]uint8 at bp, 32

	// We can fish out the UTF setting once and for all into a BOOL, but we must
	// not do this for other options (e.g. PCRE2_EXTENDED) because they may change
	// dynamically as we process the pattern.

	var utf int32
	var ucp int32

	// Helper variables for OP_XCLASS opcode (for characters > 255). We define
	// class_uchardata always so that it can be passed to add_to_class() always,
	// though it will not be used in non-UTF 8-bit cases. This avoids having to supply
	// alternative calls for the different cases.

	// var class_uchardata uintptr at bp+64, 8

	var xclass int32
	var class_uchardata_base uintptr
	var d uint32
	var c uint32
	var d1 uint32
	var c1 uint32
	var i int32
	var i1 int32
	var local_negate int32
	var posix_class int32
	var taboffset int32
	var tabopt int32
	// var pbits [32]uint8 at bp+32, 32

	var i2 int32
	var i3 int32
	var ptype uint32
	var pdata uint32
	var i4 int32
	var i5 int32
	var i6 int32
	var i7 int32
	var i8 int32
	var i9 int32
	var c2 uint32
	var d2 uint32
	var i10 int32
	var i11 int32
	// var count int32 at bp+84, 4

	// var index int32 at bp+80, 4

	var i12 uint32
	var name uintptr
	var ng uintptr
	var length uint32
	var tc uintptr
	var condcount int32
	// var count1 int32 at bp+132, 4

	// var index1 int32 at bp+128, 4

	var name1 uintptr
	var is_dupname int32
	var ng1 uintptr
	var length1 uint32
	var i13 uint32
	var pp uintptr
	var delimiter uint32
	var length2 uint32
	var callout_string uintptr
	var lastchar uintptr
	var delta uint64
	var replicate int32
	var i14 int32
	var linkoffset int32
	var delta1 uint64
	var i15 uint32
	var delta2 uint64
	var linkoffset1 int32
	var oldlinkoffset int32
	var linkoffset2 int32
	var bra uintptr
	var i16 uint32
	var nlen int32
	var ketcode uintptr
	var bracode uintptr
	var len int32
	var bralink uintptr
	var brazeroptr uintptr
	var prop_type int32
	var prop_value int32
	var oldcode uintptr
	var repcode uint32
	var len1 int32
	var ptype1 uint32
	var pdata1 uint32
	var caseset uint32
	var i17 int32
	var xclass_has_prop int32
	var negate_class int32
	var should_flip_negation int32
	var match_all_or_no_wide_chars int32
	var possessive_quantifier int32
	var note_group_empty int32
	var class_has_8bitchar int32
	var mclength uint32
	var skipunits uint32
	// var subreqcu uint32 at bp+112, 4

	// var subfirstcu uint32 at bp+104, 4

	var groupnumber uint32
	var verbarglen uint32
	var verbculen uint32
	// var subreqcuflags uint32 at bp+116, 4

	// var subfirstcuflags uint32 at bp+108, 4

	var oc uintptr
	// var mcbuffer [8]uint8 at bp+72, 8
	bravalue = 0
	okreturn = -1
	group_return = 0
	repeat_min = uint32(0)
	repeat_max = uint32(0)
	options = *(*uint32)(unsafe.Pointer(optionsptr))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) = *(*uintptr)(unsafe.Pointer(pptrptr))
	offset = uint64(0)
	*(*uint64)(unsafe.Pointer(bp + 120 /* length_prevgroup */)) = uint64(0)
	code = *(*uintptr)(unsafe.Pointer(codeptr))
	last_code = code
	orig_code = code
	previous = uintptr(0)
	groupsetfirstcu = DFALSE
	had_accept = DFALSE
	matched_char = DFALSE
	previous_matched_char = DFALSE
	reset_caseful = DFALSE
	cbits = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fcbits
	utf = libc.Bool32(options&DPCRE2_UTF != uint32(0))
	ucp = libc.Bool32(options&DPCRE2_UCP != uint32(0))

	// Set up the default and non-default settings for greediness

	greedy_default = uint32(libc.Bool32(options&DPCRE2_UNGREEDY != uint32(0)))
	greedy_non_default = greedy_default ^ uint32(1)

	// Initialize no first unit, no required unit. REQ_UNSET means "no char
	// matching encountered yet". It gets changed to REQ_NONE if we hit something that
	// matches a non-fixed first unit; reqcu just remains unset if we never find one.
	//
	// When we hit a repeat whose minimum is zero, we may have to adjust these values
	// to take the zero repeat into account. This is implemented by setting them to
	// zerofirstcu and zeroreqcu when such a repeat is encountered. The individual
	// item types that can be repeated set these backoff variables appropriately.

	firstcu = libc.AssignUint32(&reqcu, libc.AssignUint32(&zerofirstcu, libc.AssignUint32(&zeroreqcu, uint32(0))))
	firstcuflags = libc.AssignUint32(&reqcuflags, libc.AssignUint32(&zerofirstcuflags, libc.AssignUint32(&zeroreqcuflags, DREQ_UNSET)))

	// The variable req_caseopt contains either the REQ_CASELESS bit or zero,
	// according to the current setting of the caseless flag. The REQ_CASELESS value
	// leaves the lower 28 bit empty. It is added into the firstcu or reqcu variables
	// to record the case status of the value. This is used only for ASCII characters.

	if options&DPCRE2_CASELESS != uint32(0) {
		req_caseopt = DREQ_CASELESS
	} else {
		req_caseopt = uint32(0)
	}

	// Switch on next META item until the end of the branch

__1:
	;

	// Get next META item in the pattern and its potential argument.

	meta = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)))) & 0xffff0000
	meta_arg = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)))) & 0x0000ffff

	// If we are in the pre-compile phase, accumulate the length used for the
	//   previous cycle of this loop, unless the next item is a quantifier.

	if !(lengthptr != uintptr(0)) {
		goto __4
	}

	if !(code > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace+uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fworkspace_size)-uintptr(100)) {
		goto __5
	} /* Check for overrun */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = func() int32 {
		if code >= (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_workspace+uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fworkspace_size) {
			return ERR52
		}
		return ERR86
	}()
	return 0
__5:
	;

	// There is at least one situation where code goes backwards: this is the
	//     case of a zero quantifier after a class (e.g. [ab]{0}). When the quantifier
	//     is processed, the whole class is eliminated. However, it is created first,
	//     so we have to allow memory for it. Therefore, don't ever reduce the length
	//     at this point.

	if !(code < last_code) {
		goto __6
	}
	code = last_code
__6:
	;

	// If the next thing is not a quantifier, we add the length of the previous
	//     item into the total, and reset the code pointer to the start of the
	//     workspace. Otherwise leave the previous item available to be quantified.

	if !(meta < DMETA_ASTERISK || meta > DMETA_MINMAX_QUERY) {
		goto __7
	}

	if !(uint64(0x7fffffff-20)-*(*uint64)(unsafe.Pointer(lengthptr)) < uint64((int64(code)-int64(orig_code))/1)) {
		goto __8
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20 // Integer overflow
	return 0
__8:
	;
	*(*uint64)(unsafe.Pointer(lengthptr)) += uint64((int64(code) - int64(orig_code)) / 1)
	if !(*(*uint64)(unsafe.Pointer(lengthptr)) > uint64(int32(1)<<16)) {
		goto __9
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20 // Pattern is too large
	return 0
__9:
	;
	code = orig_code
__7:
	;

	// Remember where this code item starts so we can catch the "backwards"
	//     case above next time round.

	last_code = code
__4:
	;

	// Process the next parsed pattern item. If it is not a quantifier, remember
	//   where it starts so that it can be quantified when a quantifier follows.
	//   Checking for the legality of quantifiers happens in parse_regex(), except for
	//   a quantifier after an assertion that is a condition.

	if !(meta < DMETA_ASTERISK || meta > DMETA_MINMAX_QUERY) {
		goto __10
	}

	previous = code
	if !(matched_char != 0 && !(had_accept != 0)) {
		goto __11
	}
	okreturn = 1
__11:
	;
__10:
	;

	previous_matched_char = matched_char
	matched_char = DFALSE
	note_group_empty = DFALSE
	skipunits = uint32(0) // Default value for most subgroups

	switch meta {
	// ===================================================================
	// The branch terminates at pattern end or | or )

	case DMETA_END:
		goto __13
	case DMETA_ALT:
		goto __14
	case DMETA_KET:
		goto __15

	// ===================================================================
	// Handle single-character metacharacters. In multiline mode, ^ disables
	//     the setting of any following char as a first character.

	case DMETA_CIRCUMFLEX:
		goto __16

	case DMETA_DOLLAR:
		goto __17

	// There can never be a first char if '.' is first, whatever happens about
	//     repeats. The value of reqcu doesn't change either.

	case DMETA_DOT:
		goto __18

	// ===================================================================
	// Empty character classes are allowed if PCRE2_ALLOW_EMPTY_CLASS is set.
	//     Otherwise, an initial ']' is taken as a data character. When empty classes
	//     are allowed, [] must always fail, so generate OP_FAIL, whereas [^] must
	//     match any character, so generate OP_ALLANY.

	case DMETA_CLASS_EMPTY:
		goto __19
	case DMETA_CLASS_EMPTY_NOT:
		goto __20

	// ===================================================================
	// Non-empty character class. If the included characters are all < 256, we
	//     build a 32-byte bitmap of the permitted characters, except in the special
	//     case where there is only one such character. For negated classes, we build
	//     the map as usual, then invert it at the end. However, we use a different
	//     opcode so that data characters > 255 can be handled correctly.
	//
	//     If the class contains characters outside the 0-255 range, a different
	//     opcode is compiled. It may optionally have a bit map for characters < 256,
	//     but those above are are explicitly listed afterwards. A flag code unit
	//     tells whether the bitmap is present, and whether this is a negated class or
	//     not.

	case DMETA_CLASS_NOT:
		goto __21
	case DMETA_CLASS:
		goto __22 // End of class processing

	// ===================================================================
	// Deal with (*VERB)s.

	// Check for open captures before ACCEPT and close those that are within
	//     the same assertion level, also converting ACCEPT to ASSERT_ACCEPT in an
	//     assertion. In the first pass, just accumulate the length required;
	//     otherwise hitting (*ACCEPT) inside many nested parentheses can cause
	//     workspace overflow. Do not set firstcu after *ACCEPT.

	case DMETA_ACCEPT:
		goto __23

	case DMETA_PRUNE:
		goto __24
	case DMETA_SKIP:
		goto __25
	// Fall through
	case DMETA_COMMIT:
		goto __26
	case DMETA_FAIL:
		goto __27

	case DMETA_THEN:
		goto __28

	// Handle verbs with arguments. Arguments can be very long, especially in
	//     16- and 32-bit modes, and can overflow the workspace in the first pass.
	//     However, the argument length is constrained to be small enough to fit in
	//     one code unit. This check happens in parse_regex(). In the first pass,
	//     instead of putting the argument into memory, we just update the length
	//     counter and set up an empty argument.

	case DMETA_THEN_ARG:
		goto __29

	case DMETA_PRUNE_ARG:
		goto __30
	case DMETA_SKIP_ARG:
		goto __31
	// Fall through
	case DMETA_MARK:
		goto __32
	case DMETA_COMMIT_ARG:
		goto __33

	// ===================================================================
	// Handle options change. The new setting must be passed back for use in
	//     subsequent branches. Reset the greedy defaults and the case value for
	//     firstcu and reqcu.

	case DMETA_OPTIONS:
		goto __34

	// ===================================================================
	// Handle conditional subpatterns. The case of (?(Rdigits) is ambiguous
	//     because it could be a numerical check on recursion, or a name check on a
	//     group's being set. The pre-pass sets up META_COND_RNUMBER as a name so that
	//     we can handle it either way. We first try for a name; if not found, process
	//     the number.

	case DMETA_COND_RNUMBER:
		goto __35 // (?(Rdigits)
	case DMETA_COND_NAME:
		goto __36 // (?(name) or (?'name') or ?(<name>)
	case DMETA_COND_RNAME:
		goto __37

	// The DEFINE condition is always false. Its internal groups may never
	//     be called, so matched_char must remain false, hence the jump to
	//     GROUP_PROCESS rather than GROUP_PROCESS_NOTE_EMPTY.

	case DMETA_COND_DEFINE:
		goto __38

	// Conditional test of a group's being set.

	case DMETA_COND_NUMBER:
		goto __39

	// Test for the PCRE2 version.

	case DMETA_COND_VERSION:
		goto __40

	// The condition is an assertion, possibly preceded by a callout.

	case DMETA_COND_ASSERT:
		goto __41

	// ===================================================================
	// Handle all kinds of nested bracketed groups. The non-capturing,
	//     non-conditional cases are here; others come to GROUP_PROCESS via goto.

	case DMETA_LOOKAHEAD:
		goto __42

	case DMETA_LOOKAHEAD_NA:
		goto __43

	// Optimize (?!) to (*FAIL) unless it is quantified - which is a weird
	//     thing to do, but Perl allows all assertions to be quantified, and when
	//     they contain capturing parentheses there may be a potential use for
	//     this feature. Not that that applies to a quantified (?!) but we allow
	//     it for uniformity.

	case DMETA_LOOKAHEADNOT:
		goto __44

	case DMETA_LOOKBEHIND:
		goto __45

	case DMETA_LOOKBEHINDNOT:
		goto __46

	case DMETA_LOOKBEHIND_NA:
		goto __47

	case DMETA_ATOMIC:
		goto __48

	case DMETA_SCRIPT_RUN:
		goto __49

	case DMETA_NOCAPTURE:
		goto __50 // End of nested group handling

	// ===================================================================
	// Handle named backreferences and recursions.

	case DMETA_BACKREF_BYNAME:
		goto __51
	case DMETA_RECURSE_BYNAME:
		goto __52

	// ===================================================================
	// Handle a numerical callout.

	case DMETA_CALLOUT_NUMBER:
		goto __53

	// ===================================================================
	// Handle a callout with a string argument. In the pre-pass we just compute
	//     the length without generating anything. The length in pptr[3] includes both
	//     delimiters; in the actual compile only the first one is copied, but a
	//     terminating zero is added. Any doubled delimiters within the string make
	//     this an overestimate, but it is not worth bothering about.

	case DMETA_CALLOUT_STRING:
		goto __54

	// ===================================================================
	// Handle repetition. The different types are all sorted out in the parsing
	//     pass.

	case DMETA_MINMAX_PLUS:
		goto __55
	case DMETA_MINMAX_QUERY:
		goto __56
	case DMETA_MINMAX:
		goto __57

	case DMETA_ASTERISK:
		goto __58
	case DMETA_ASTERISK_PLUS:
		goto __59
	case DMETA_ASTERISK_QUERY:
		goto __60

	case DMETA_PLUS:
		goto __61
	case DMETA_PLUS_PLUS:
		goto __62
	case DMETA_PLUS_QUERY:
		goto __63

	case DMETA_QUERY:
		goto __64
	case DMETA_QUERY_PLUS:
		goto __65
	case DMETA_QUERY_QUERY:
		goto __66

	// ===================================================================
	// Handle a 32-bit data character with a value greater than META_END.

	case DMETA_BIGVALUE:
		goto __67

	// ===============================================================
	// Handle a back reference by number, which is the meta argument. The
	//     pattern offsets for back references to group numbers less than 10 are held
	//     in a special vector, to avoid using more than two parsed pattern elements
	//     in 64-bit environments. We only need the offset to the first occurrence,
	//     because if that doesn't fail, subsequent ones will also be OK.

	case DMETA_BACKREF:
		goto __68

	// ===============================================================
	// Handle recursion by inserting the number of the called group (which is
	//     the meta argument) after OP_RECURSE. At the end of compiling the pattern is
	//     scanned and these numbers are replaced by offsets within the pattern. It is
	//     done like this to avoid problems with forward references and adjusting
	//     offsets when groups are duplicated and moved (as discovered in previous
	//     implementations). Note that a recursion does not have a set first
	//     character.

	case DMETA_RECURSE:
		goto __69

	// ===============================================================
	// Handle capturing parentheses; the number is the meta argument.

	case DMETA_CAPTURE:
		goto __70

	// ===============================================================
	// Handle escape sequence items. For ones like \d, the ESC_values are
	//     arranged to be the same as the corresponding OP_values in the default case
	//     when PCRE2_UCP is not set (which is the only case in which they will appear
	//     here).
	//
	//     Note: \Q and \E are never seen here, as they were dealt with in
	//     parse_pattern(). Neither are numerical back references or recursions, which
	//     were turned into META_BACKREF or META_RECURSE items, respectively. \k and
	//     \g, when followed by names, are turned into META_BACKREF_BYNAME or
	//     META_RECURSE_BYNAME.

	case DMETA_ESCAPE:
		goto __71 // End META_ESCAPE

	// ===================================================================
	// Handle an unrecognized meta value. A parsed pattern value less than
	//     META_END is a literal. Otherwise we have a problem.

	default:
		goto __72
	}
	goto __12

	// ===================================================================
	// The branch terminates at pattern end or | or )

__13:
__14:
__15:
	*(*uint32)(unsafe.Pointer(firstcuptr)) = firstcu
	*(*uint32)(unsafe.Pointer(firstcuflagsptr)) = firstcuflags
	*(*uint32)(unsafe.Pointer(reqcuptr)) = reqcu
	*(*uint32)(unsafe.Pointer(reqcuflagsptr)) = reqcuflags
	*(*uintptr)(unsafe.Pointer(codeptr)) = code
	*(*uintptr)(unsafe.Pointer(pptrptr)) = *(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */))
	return okreturn

	// ===================================================================
	// Handle single-character metacharacters. In multiline mode, ^ disables
	//     the setting of any following char as a first character.

__16:
	if !(options&DPCRE2_MULTILINE != uint32(0)) {
		goto __73
	}

	if !(firstcuflags == DREQ_UNSET) {
		goto __75
	}
	zerofirstcuflags = libc.AssignUint32(&firstcuflags, DREQ_NONE)
__75:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_CIRCM
	goto __74
__73:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_CIRC
__74:
	;
	goto __12

__17:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_MULTILINE != uint32(0) {
			return OP_DOLLM
		}
		return OP_DOLL
	}()
	goto __12

	// There can never be a first char if '.' is first, whatever happens about
	//     repeats. The value of reqcu doesn't change either.

__18:
	matched_char = DTRUE
	if !(firstcuflags == DREQ_UNSET) {
		goto __76
	}
	firstcuflags = DREQ_NONE
__76:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_DOTALL != uint32(0) {
			return OP_ALLANY
		}
		return OP_ANY
	}()
	goto __12

	// ===================================================================
	// Empty character classes are allowed if PCRE2_ALLOW_EMPTY_CLASS is set.
	//     Otherwise, an initial ']' is taken as a data character. When empty classes
	//     are allowed, [] must always fail, so generate OP_FAIL, whereas [^] must
	//     match any character, so generate OP_ALLANY.

__19:
__20:
	matched_char = DTRUE
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if meta == DMETA_CLASS_EMPTY_NOT {
			return OP_ALLANY
		}
		return OP_FAIL
	}()
	if !(firstcuflags == DREQ_UNSET) {
		goto __77
	}
	firstcuflags = DREQ_NONE
__77:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	goto __12

	// ===================================================================
	// Non-empty character class. If the included characters are all < 256, we
	//     build a 32-byte bitmap of the permitted characters, except in the special
	//     case where there is only one such character. For negated classes, we build
	//     the map as usual, then invert it at the end. However, we use a different
	//     opcode so that data characters > 255 can be handled correctly.
	//
	//     If the class contains characters outside the 0-255 range, a different
	//     opcode is compiled. It may optionally have a bit map for characters < 256,
	//     but those above are are explicitly listed afterwards. A flag code unit
	//     tells whether the bitmap is present, and whether this is a negated class or
	//     not.

__21:
__22:
	matched_char = DTRUE
	negate_class = libc.Bool32(meta == DMETA_CLASS_NOT)

	// We can optimize the case of a single character in a class by generating
	//     OP_CHAR or OP_CHARI if it's positive, or OP_NOT or OP_NOTI if it's
	//     negative. In the negative case there can be no first char if this item is
	//     first, whatever repeat count may follow. In the case of reqcu, save the
	//     previous value for reinstating.

	// NOTE: at present this optimization is not effective if the only
	//     character in a class in 32-bit, non-UCP mode has its top bit set.

	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) < DMETA_END && *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) == DMETA_CLASS_END) {
		goto __78
	}

	c = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) + 1*4))

	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2) // Move on to class end
	if !(meta == DMETA_CLASS) {
		goto __79
	} /* A positive one-char class can be */
	// handled as a normal literal character.
	meta = c // Set up the character
	goto NORMAL_CHAR_SET
__79:
	;

	// Handle a negative one-character class

	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags
	if !(firstcuflags == DREQ_UNSET) {
		goto __80
	}
	firstcuflags = DREQ_NONE
__80:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags

	// For caseless UTF or UCP mode, check whether this character has more
	//       than one other case. If so, generate a special OP_NOTPROP item instead of
	//       OP_NOTI.

	if !((utf != 0 || ucp != 0) && options&DPCRE2_CASELESS != uint32(0) && libc.AssignUint32(&d, uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fcaseset)) != uint32(0)) {
		goto __81
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_NOTPROP
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(DPT_CLIST)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(d)
	goto __12 // We are finished with this class
__81:
	;
	// Char has only one other case, or UCP not available

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_CASELESS != uint32(0) {
			return OP_NOTI
		}
		return OP_NOT
	}()
	code += func() uintptr {
		if utf != 0 && c > uint32(DMAX_UTF_SINGLE_CU) {
			return uintptr(X_pcre2_ord2utf_8(tls, c, code))
		}
		return uintptr(func() int32 { *(*uint8)(unsafe.Pointer(code)) = uint8(c); return 1 }())
	}()
	goto __12 // We are finished with this class
__78:
	; // End of 1-char optimization

	// Handle character classes that contain more than just one literal
	//     character. If there are exactly two characters in a positive class, see if
	//     they are case partners. This can be optimized to generate a caseless single
	//     character match (which also sets first/required code units if relevant).

	if !(meta == DMETA_CLASS && *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) < DMETA_END && *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) < DMETA_END && *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 3*4)) == DMETA_CLASS_END) {
		goto __82
	}

	c1 = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) + 1*4))

	if !(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c1)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c1)%DUCD_BLOCK_SIZE])*12)).Fcaseset) == 0) {
		goto __83
	}

	if !((utf != 0 || ucp != 0) && c1 > uint32(127)) {
		goto __84
	}
	d1 = uint32(int32(c1) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c1)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c1)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __85
__84:

	d1 = uint32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Ffcc + uintptr(c1))))
__85:
	;

	if !(c1 != d1 && *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) == d1) {
		goto __86
	}

	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3) // Move on to class end
	meta = c1
	if !(options&DPCRE2_CASELESS == uint32(0)) {
		goto __87
	}

	reset_caseful = DTRUE
	options = options | DPCRE2_CASELESS
	req_caseopt = DREQ_CASELESS
__87:
	;
	goto CLASS_CASELESS_CHAR
__86:
	;
__83:
	;
__82:
	;

	// If a non-extended class contains a negative special such as \S, we need
	//     to flip the negation flag at the end, so that support for characters > 255
	//     works correctly (they are all included in the class). An extended class may
	//     need to insert specific matching or non-matching code for wide characters.
	//

	should_flip_negation = libc.AssignInt32(&match_all_or_no_wide_chars, DFALSE)

	// Extended class (xclass) will be used when characters > 255
	//     might match.

	xclass = DFALSE
	*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)) = code + uintptr(DLINK_SIZE) + uintptr(2) // For XCLASS items
	class_uchardata_base = *(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */))                    // Save the start

	// For optimization purposes, we track some properties of the class:
	//     class_has_8bitchar will be non-zero if the class contains at least one
	//     character with a code point less than 256; xclass_has_prop will be TRUE if
	//     Unicode property checks are present in the class.

	class_has_8bitchar = 0
	xclass_has_prop = DFALSE

	// Initialize the 256-bit (32-byte) bit map to all zeros. We build the map
	//     in a temporary bit of memory, in case the class contains fewer than two
	//     8-bit characters because in that case the compiled code doesn't use the bit
	//     map.

	libc.Xmemset(tls, bp, 0, uint64(32)*uint64(unsafe.Sizeof(uint8(0))))

	// Process items until META_CLASS_END is reached.

__88:
	if !(libc.AssignUint32(&meta, *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))) != DMETA_CLASS_END) {
		goto __89
	}

	// Handle POSIX classes such as [:alpha:] etc.

	if !(meta == DMETA_POSIX || meta == DMETA_POSIX_NEG) {
		goto __90
	}

	local_negate = libc.Bool32(meta == DMETA_POSIX_NEG)
	posix_class = int32(*(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4))))

	should_flip_negation = local_negate // Note negative special

	// If matching is caseless, upper and lower are converted to alpha.
	//         This relies on the fact that the class table starts with alpha,
	//         lower, upper as the first 3 entries.

	if !(options&DPCRE2_CASELESS != uint32(0) && posix_class <= 2) {
		goto __91
	}
	posix_class = 0
__91:
	;

	// When PCRE2_UCP is set, some of the POSIX classes are converted to
	//         different escape sequences that use Unicode properties \p or \P.
	//         Others that are not available via \p or \P have to generate
	//         XCL_PROP/XCL_NOTPROP directly, which is done here.

	if !(options&DPCRE2_UCP != uint32(0)) {
		goto __92
	}
	switch posix_class {
	case DPC_GRAPH:
		goto __94
	case DPC_PRINT:
		goto __95
	case DPC_PUNCT:
		goto __96

	// For the other POSIX classes (ascii, xdigit) we are going to
	//           fall through to the non-UCP case and build a bit map for
	//           characters with code points less than 256. However, if we are in
	//           a negated POSIX class, characters with code points greater than
	//           255 must either all match or all not match, depending on whether
	//           the whole class is not or is negated. For example, for
	//           [[:^ascii:]... they must all match, whereas for [^[:^xdigit:]...
	//           they must not.
	//
	//           In the special case where there are no xclass items, this is
	//           automatically handled by the use of OP_CLASS or OP_NCLASS, but an
	//           explicit range is needed for OP_XCLASS. Setting a flag here
	//           causes the range to be generated later when it is known that
	//           OP_XCLASS is required. In the 8-bit library this is relevant only in
	//           utf mode, since no wide characters can exist otherwise.

	default:
		goto __97
	}
	goto __93

__94:
__95:
__96:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = func() uint8 {
		if local_negate != 0 {
			return uint8(DXCL_NOTPROP)
		}
		return uint8(DXCL_PROP)
	}()
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = func() uint8 {
		if posix_class == DPC_GRAPH {
			return uint8(DPT_PXGRAPH)
		}
		return func() uint8 {
			if posix_class == DPC_PRINT {
				return uint8(DPT_PXPRINT)
			}
			return uint8(DPT_PXPUNCT)
		}()
	}()
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = uint8(0)
	xclass_has_prop = DTRUE
	goto CONTINUE_CLASS

	// For the other POSIX classes (ascii, xdigit) we are going to
	//           fall through to the non-UCP case and build a bit map for
	//           characters with code points less than 256. However, if we are in
	//           a negated POSIX class, characters with code points greater than
	//           255 must either all match or all not match, depending on whether
	//           the whole class is not or is negated. For example, for
	//           [[:^ascii:]... they must all match, whereas for [^[:^xdigit:]...
	//           they must not.
	//
	//           In the special case where there are no xclass items, this is
	//           automatically handled by the use of OP_CLASS or OP_NCLASS, but an
	//           explicit range is needed for OP_XCLASS. Setting a flag here
	//           causes the range to be generated later when it is known that
	//           OP_XCLASS is required. In the 8-bit library this is relevant only in
	//           utf mode, since no wide characters can exist otherwise.

__97:
	if !(utf != 0) {
		goto __98
	}
	match_all_or_no_wide_chars = match_all_or_no_wide_chars | local_negate
__98:
	;
	goto __93
__93:
	;
__92:
	;

	// In the non-UCP case, or when UCP makes no difference, we build the
	//         bit map for the POSIX class in a chunk of local store because we may
	//         be adding and subtracting from it, and we don't want to subtract bits
	//         that may be in the main map already. At the end we or the result into
	//         the bit map that is being built.

	posix_class = posix_class * 3

	// Copy in the first table (always present)

	libc.Xmemcpy(tls, bp+32, cbits+uintptr(posix_class_maps[posix_class]),
		uint64(32)*uint64(unsafe.Sizeof(uint8(0))))

	// If there is a second table, add or remove it as required.

	taboffset = posix_class_maps[posix_class+1]
	tabopt = posix_class_maps[posix_class+2]

	if !(taboffset >= 0) {
		goto __99
	}

	if !(tabopt >= 0) {
		goto __100
	}
	{
		i = 0
	__102:
		if !(i < 32) {
			goto __104
		}
		*(*uint8)(unsafe.Pointer(bp + 32 + uintptr(i))) |= uint8(int32(*(*uint8)(unsafe.Pointer(cbits + uintptr(i+taboffset)))))
		goto __103
	__103:
		i++
		goto __102
		goto __104
	__104:
	}
	goto __101
__100:
	{
		i1 = 0
	__105:
		if !(i1 < 32) {
			goto __107
		}
		*(*uint8)(unsafe.Pointer(bp + 32 + uintptr(i1))) &= uint8(^int32(*(*uint8)(unsafe.Pointer(cbits + uintptr(i1+taboffset)))))
		goto __106
	__106:
		i1++
		goto __105
		goto __107
	__107:
	}
__101:
	;
__99:
	;

	// Now see if we need to remove any special characters. An option
	//         value of 1 removes vertical space and 2 removes underscore.

	if !(tabopt < 0) {
		goto __108
	}
	tabopt = -tabopt
__108:
	;
	if !(tabopt == 1) {
		goto __109
	}
	*(*uint8)(unsafe.Pointer(bp + 32 + 1)) &= libc.Uint8FromInt32(libc.CplInt32(0x3c))
	goto __110
__109:
	if !(tabopt == 2) {
		goto __111
	}
	*(*uint8)(unsafe.Pointer(bp + 32 + 11)) &= uint8(0x7f)
__111:
	;
__110:
	;

	// Add the POSIX table or its complement into the main table that is
	//         being built and we are done.

	if !(local_negate != 0) {
		goto __112
	}
	{
		i2 = 0
	__114:
		if !(i2 < 32) {
			goto __116
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i2))) |= uint8(int32(uint8(^int32(*(*uint8)(unsafe.Pointer(bp + 32 + uintptr(i2)))))))
		goto __115
	__115:
		i2++
		goto __114
		goto __116
	__116:
	}
	goto __113
__112:
	{
		i3 = 0
	__117:
		if !(i3 < 32) {
			goto __119
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i3))) |= uint8(int32(*(*uint8)(unsafe.Pointer(bp + 32 + uintptr(i3)))))
		goto __118
	__118:
		i3++
		goto __117
		goto __119
	__119:
	}
__113:
	;

	// Every class contains at least one < 256 character.

	class_has_8bitchar = 1
	goto CONTINUE_CLASS // End of POSIX handling
__90:
	;

	// Other than POSIX classes, the only items we should encounter are
	//       \d-type escapes and literal characters (possibly as ranges).

	if !(meta == DMETA_BIGVALUE) {
		goto __120
	}

	meta = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	goto CLASS_LITERAL
__120:
	;

	// Any other non-literal must be an escape

	if !(meta >= DMETA_END) {
		goto __121
	}

	if !(meta&0xffff0000 != DMETA_ESCAPE) {
		goto __123
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR89 // Internal error - unrecognized.
	return 0
__123:
	;
	escape = meta & 0x0000ffff

	// Every class contains at least one < 256 character.

	class_has_8bitchar++

	switch escape {
	case ESC_d:
		goto __125

	case ESC_D:
		goto __126

	case ESC_w:
		goto __127

	case ESC_W:
		goto __128

	// Perl 5.004 onwards omitted VT from \s, but restored it at Perl
	//           5.18. Before PCRE 8.34, we had to preserve the VT bit if it was
	//           previously set by something earlier in the character class.
	//           Luckily, the value of CHAR_VT is 0x0b in both ASCII and EBCDIC, so
	//           we could just adjust the appropriate bit. From PCRE 8.34 we no
	//           longer treat \s and \S specially.

	case ESC_s:
		goto __129

	case ESC_S:
		goto __130

	// When adding the horizontal or vertical space lists to a class, or
	//           their complements, disable PCRE2_CASELESS, because it justs wastes
	//           time, and in the "not-x" UTF cases can create unwanted duplicates in
	//           the XCLASS list (provoked by characters that have more than one other
	//           case and by both cases being in the same "not-x" sublist).

	case ESC_h:
		goto __131

	case ESC_H:
		goto __132

	case ESC_v:
		goto __133

	case ESC_V:
		goto __134

	// If Unicode is not supported, \P and \p are not allowed and are
	//           faulted at parse time, so will never appear here.

	case ESC_p:
		goto __135
	case ESC_P:
		goto __136
	}
	goto __124

__125:
	{
		i4 = 0
	__137:
		if !(i4 < 32) {
			goto __139
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i4))) |= uint8(int32(*(*uint8)(unsafe.Pointer(cbits + uintptr(i4+Dcbit_digit)))))
		goto __138
	__138:
		i4++
		goto __137
		goto __139
	__139:
	}
	goto __124

__126:
	should_flip_negation = DTRUE
	{
		i5 = 0
	__140:
		if !(i5 < 32) {
			goto __142
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i5))) |= uint8(int32(uint8(^int32(*(*uint8)(unsafe.Pointer(cbits + uintptr(i5+Dcbit_digit)))))))
		goto __141
	__141:
		i5++
		goto __140
		goto __142
	__142:
	}
	goto __124

__127:
	{
		i6 = 0
	__143:
		if !(i6 < 32) {
			goto __145
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i6))) |= uint8(int32(*(*uint8)(unsafe.Pointer(cbits + uintptr(i6+Dcbit_word)))))
		goto __144
	__144:
		i6++
		goto __143
		goto __145
	__145:
	}
	goto __124

__128:
	should_flip_negation = DTRUE
	{
		i7 = 0
	__146:
		if !(i7 < 32) {
			goto __148
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i7))) |= uint8(int32(uint8(^int32(*(*uint8)(unsafe.Pointer(cbits + uintptr(i7+Dcbit_word)))))))
		goto __147
	__147:
		i7++
		goto __146
		goto __148
	__148:
	}
	goto __124

	// Perl 5.004 onwards omitted VT from \s, but restored it at Perl
	//           5.18. Before PCRE 8.34, we had to preserve the VT bit if it was
	//           previously set by something earlier in the character class.
	//           Luckily, the value of CHAR_VT is 0x0b in both ASCII and EBCDIC, so
	//           we could just adjust the appropriate bit. From PCRE 8.34 we no
	//           longer treat \s and \S specially.

__129:
	{
		i8 = 0
	__149:
		if !(i8 < 32) {
			goto __151
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i8))) |= uint8(int32(*(*uint8)(unsafe.Pointer(cbits + uintptr(i8+Dcbit_space)))))
		goto __150
	__150:
		i8++
		goto __149
		goto __151
	__151:
	}
	goto __124

__130:
	should_flip_negation = DTRUE
	{
		i9 = 0
	__152:
		if !(i9 < 32) {
			goto __154
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i9))) |= uint8(int32(uint8(^int32(*(*uint8)(unsafe.Pointer(cbits + uintptr(i9+Dcbit_space)))))))
		goto __153
	__153:
		i9++
		goto __152
		goto __154
	__154:
	}
	goto __124

	// When adding the horizontal or vertical space lists to a class, or
	//           their complements, disable PCRE2_CASELESS, because it justs wastes
	//           time, and in the "not-x" UTF cases can create unwanted duplicates in
	//           the XCLASS list (provoked by characters that have more than one other
	//           case and by both cases being in the same "not-x" sublist).

__131:
	add_list_to_class(tls, bp, bp+64,
		options&libc.CplUint32(DPCRE2_CASELESS), cb, uintptr(unsafe.Pointer(&X_pcre2_hspace_list_8)), DNOTACHAR)
	goto __124

__132:
	add_not_list_to_class(tls, bp, bp+64,
		options&libc.CplUint32(DPCRE2_CASELESS), cb, uintptr(unsafe.Pointer(&X_pcre2_hspace_list_8)))
	goto __124

__133:
	add_list_to_class(tls, bp, bp+64,
		options&libc.CplUint32(DPCRE2_CASELESS), cb, uintptr(unsafe.Pointer(&X_pcre2_vspace_list_8)), DNOTACHAR)
	goto __124

__134:
	add_not_list_to_class(tls, bp, bp+64,
		options&libc.CplUint32(DPCRE2_CASELESS), cb, uintptr(unsafe.Pointer(&X_pcre2_vspace_list_8)))
	goto __124

	// If Unicode is not supported, \P and \p are not allowed and are
	//           faulted at parse time, so will never appear here.

__135:
__136:

	ptype = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4))) >> 16
	pdata = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)))) & uint32(0xffff)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = func() uint8 {
		if escape == ESC_p {
			return uint8(DXCL_PROP)
		}
		return uint8(DXCL_NOTPROP)
	}()
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = uint8(ptype)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = uint8(pdata)
	xclass_has_prop = DTRUE
	class_has_8bitchar-- // Undo!

	goto __124
__124:
	;

	goto CONTINUE_CLASS
	goto __122
__121:

CLASS_LITERAL:
	c2 = libc.AssignUint32(&d2, meta)

	// Remember if \r or \n were explicitly used

	if !(c2 == uint32('\015') || c2 == uint32('\012')) {
		goto __155
	}
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_HASCRORLF)
__155:
	;

	// Process a character range

	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) == DMETA_RANGE_LITERAL || *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) == DMETA_RANGE_ESCAPED) {
		goto __156
	}

	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)
	d2 = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */))))
	if !(d2 == DMETA_BIGVALUE) {
		goto __157
	}
	d2 = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
__157:
	;

	// Remember an explicit \r or \n, and add the range to the class.

	if !(d2 == uint32('\015') || d2 == uint32('\012')) {
		goto __158
	}
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_HASCRORLF)
__158:
	;

	// In an EBCDIC environment, Perl treats alphabetic ranges specially
	//           because there are holes in the encoding, and simply using the range
	//           A-Z (for example) would include the characters in the holes. This
	//           applies only to literal ranges; [\xC1-\xE9] is different to [A-Z].

	// Not an EBCDIC special range

	class_has_8bitchar = int32(uint32(class_has_8bitchar) + add_to_class(tls, bp, bp+64, options, cb, c2, d2))
	goto CONTINUE_CLASS // Go get the next char in the class
__156:
	; // End of range handling

	// Handle a single character.

	class_has_8bitchar = int32(uint32(class_has_8bitchar) + add_to_class(tls, bp, bp+64, options, cb, meta, meta))
__122:
	;

	// Continue to the next item in the class.

CONTINUE_CLASS:

	// If any wide characters or Unicode properties have been encountered,
	//       set xclass = TRUE. Then, in the pre-compile phase, accumulate the length
	//       of the extra data and reset the pointer. This is so that very large
	//       classes that contain a zillion wide characters or Unicode property tests
	//       do not overwrite the workspace (which is on the stack).

	if !(*(*uintptr)(unsafe.Pointer(bp + 64)) > class_uchardata_base) {
		goto __159
	}

	xclass = DTRUE
	if !(lengthptr != uintptr(0)) {
		goto __160
	}

	*(*uint64)(unsafe.Pointer(lengthptr)) += uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 64))) - int64(class_uchardata_base)) / 1)
	*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)) = class_uchardata_base
__160:
	;
__159:
	;

	goto __88 // Needed to avoid error when not supporting wide chars
	goto __88
__89:
	; // End of main class-processing loop

	// If this class is the first thing in the branch, there can be no first
	//     char setting, whatever the repeat count. Any reqcu setting must remain
	//     unchanged after any kind of repeat.

	if !(firstcuflags == DREQ_UNSET) {
		goto __161
	}
	firstcuflags = DREQ_NONE
__161:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags

	// If there are characters with values > 255, or Unicode property settings
	//     (\p or \P), we have to compile an extended class, with its own opcode,
	//     unless there were no property settings and there was a negated special such
	//     as \S in the class, and PCRE2_UCP is not set, because in that case all
	//     characters > 255 are in or not in the class, so any that were explicitly
	//     given as well can be ignored.
	//
	//     In the UCP case, if certain negated POSIX classes ([:^ascii:] or
	//     [^:xdigit:]) were present in a class, we either have to match or not match
	//     all wide characters (depending on whether the whole class is or is not
	//     negated). This requirement is indicated by match_all_or_no_wide_chars being
	//     true. We do this by including an explicit range, which works in both cases.
	//     This applies only in UTF and 16-bit and 32-bit non-UTF modes, since there
	//     cannot be any wide characters in 8-bit non-UTF mode.
	//
	//     When there *are* properties in a positive UTF-8 or any 16-bit or 32_bit
	//     class where \S etc is present without PCRE2_UCP, causing an extended class
	//     to be compiled, we make sure that all characters > 255 are included by
	//     forcing match_all_or_no_wide_chars to be true.
	//
	//     If, when generating an xclass, there are no characters < 256, we can omit
	//     the bitmap in the actual compiled code.

	if !(xclass != 0 && (options&DPCRE2_UCP != uint32(0) || xclass_has_prop != 0 || !(should_flip_negation != 0))) {
		goto __162
	}

	if !(match_all_or_no_wide_chars != 0 || utf != 0 && should_flip_negation != 0 && !(negate_class != 0) && options&DPCRE2_UCP == uint32(0)) {
		goto __163
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = uint8(DXCL_RANGE)
	if !(utf != 0) {
		goto __164
	} /* Will always be utf in the 8-bit library */

	*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)) += uintptr(X_pcre2_ord2utf_8(tls, uint32(0x100), *(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */))))
	*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)) += uintptr(X_pcre2_ord2utf_8(tls, uint32(DMAX_UTF_CODE_POINT), *(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */))))
	goto __165
__164: /* Can only happen for the 16-bit & 32-bit libraries */

	;
__165:
	;
__163:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */)), 1))) = uint8(DXCL_END) // Marks the end of extra data
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_XCLASS
	code += uintptr(DLINK_SIZE)
	*(*uint8)(unsafe.Pointer(code)) = func() uint8 {
		if negate_class != 0 {
			return uint8(DXCL_NOT)
		}
		return uint8(0)
	}()
	if !(xclass_has_prop != 0) {
		goto __166
	}
	*(*uint8)(unsafe.Pointer(code)) |= uint8(DXCL_HASPROP)
__166:
	;

	// If the map is required, move up the extra data to make room for it;
	//       otherwise just move the code pointer to the end of the extra data.

	if !(class_has_8bitchar > 0) {
		goto __167
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) |= uint8(DXCL_MAP)
	libc.Xmemmove(tls, code+uintptr(uint64(32)/uint64(unsafe.Sizeof(uint8(0)))), code,
		uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 64)))-int64(code))/1*int64(DPCRE2_CODE_UNIT_WIDTH/8)))
	if !(negate_class != 0 && !(xclass_has_prop != 0)) {
		goto __169
	}

	// Using 255 ^ instead of ~ avoids clang sanitize warning.
	{
		i10 = 0
	__170:
		if !(i10 < 32) {
			goto __172
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i10))) = uint8(255 ^ int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i10)))))
		goto __171
	__171:
		i10++
		goto __170
		goto __172
	__172:
	}
__169:
	;
	libc.Xmemcpy(tls, code, bp, uint64(32))
	code = *(*uintptr)(unsafe.Pointer(bp + 64)) + uintptr(uint64(32)/uint64(unsafe.Sizeof(uint8(0))))
	goto __168
__167:
	code = *(*uintptr)(unsafe.Pointer(bp + 64 /* class_uchardata */))
__168:
	;

	// Now fill in the complete length of the item

	*(*uint8)(unsafe.Pointer(previous + 1)) = uint8(int32((int64(code)-int64(previous))/1) >> 8)
	*(*uint8)(unsafe.Pointer(previous + 2)) = uint8(int32((int64(code)-int64(previous))/1) & 255)
	goto __12 // End of class handling
__162:
	;

	// If there are no characters > 255, or they are all to be included or
	//     excluded, set the opcode to OP_CLASS or OP_NCLASS, depending on whether the
	//     whole class was negated and whether there were negative specials such as \S
	//     (non-UCP) in the class. Then copy the 32-byte map into the code vector,
	//     negating it if necessary.

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if negate_class == should_flip_negation {
			return OP_CLASS
		}
		return OP_NCLASS
	}()
	if !(lengthptr == uintptr(0)) {
		goto __173
	} /* Save time in the pre-compile phase */

	if !(negate_class != 0) {
		goto __174
	}

	// Using 255 ^ instead of ~ avoids clang sanitize warning.
	{
		i11 = 0
	__175:
		if !(i11 < 32) {
			goto __177
		}
		*(*uint8)(unsafe.Pointer(bp + uintptr(i11))) = uint8(255 ^ int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i11)))))
		goto __176
	__176:
		i11++
		goto __175
		goto __177
	__177:
	}
__174:
	;
	libc.Xmemcpy(tls, code, bp, uint64(32))
__173:
	;
	code += uintptr(uint64(32) / uint64(unsafe.Sizeof(uint8(0))))
	goto __12 // End of class processing

	// ===================================================================
	// Deal with (*VERB)s.

	// Check for open captures before ACCEPT and close those that are within
	//     the same assertion level, also converting ACCEPT to ASSERT_ACCEPT in an
	//     assertion. In the first pass, just accumulate the length required;
	//     otherwise hitting (*ACCEPT) inside many nested parentheses can cause
	//     workspace overflow. Do not set firstcu after *ACCEPT.

__23:
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_accept = libc.AssignInt32(&had_accept, DTRUE)
	oc = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps
__178:
	if !(oc != uintptr(0) && int32((*Topen_capitem)(unsafe.Pointer(oc)).Fassert_depth) >= int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fassert_depth)) {
		goto __180
	}

	if !(lengthptr != uintptr(0)) {
		goto __181
	}

	*(*uint64)(unsafe.Pointer(lengthptr)) += uint64(1*(DPCRE2_CODE_UNIT_WIDTH/8) + DIMM2_SIZE)
	goto __182
__181:

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_CLOSE
	*(*uint8)(unsafe.Pointer(code)) = uint8(int32((*Topen_capitem)(unsafe.Pointer(oc)).Fnumber) >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(int32((*Topen_capitem)(unsafe.Pointer(oc)).Fnumber) & 255)
	code += uintptr(DIMM2_SIZE)
__182:
	;
	goto __179
__179:
	oc = (*Topen_capitem)(unsafe.Pointer(oc)).Fnext
	goto __178
	goto __180
__180:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fassert_depth) > 0 {
			return OP_ASSERT_ACCEPT
		}
		return OP_ACCEPT
	}()
	if !(firstcuflags == DREQ_UNSET) {
		goto __183
	}
	firstcuflags = DREQ_NONE
__183:
	;
	goto __12

__24:
__25:
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_pruneorskip = DTRUE
	// Fall through
__26:
__27:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(verbops[(meta-DMETA_MARK)>>16])
	goto __12

__28:
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_HASTHEN)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_THEN
	goto __12

	// Handle verbs with arguments. Arguments can be very long, especially in
	//     16- and 32-bit modes, and can overflow the workspace in the first pass.
	//     However, the argument length is constrained to be small enough to fit in
	//     one code unit. This check happens in parse_regex(). In the first pass,
	//     instead of putting the argument into memory, we just update the length
	//     counter and set up an empty argument.

__29:
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_HASTHEN)
	goto VERB_ARG

__30:
__31:
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_pruneorskip = DTRUE
	// Fall through
__32:
__33:
VERB_ARG:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(verbops[(meta-DMETA_MARK)>>16])
	// The length is in characters.
	verbarglen = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	verbculen = uint32(0)
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) = libc.PostIncUintptr(&code, 1)
	{
		i17 = 0
	__184:
		if !(i17 < int32(verbarglen)) {
			goto __186
		}

		meta = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
		if !(utf != 0) {
			goto __187
		}
		mclength = X_pcre2_ord2utf_8(tls, meta, bp+72)
		goto __188
	__187:

		mclength = uint32(1)
		*(*uint8)(unsafe.Pointer(bp + 72)) = uint8(meta)
	__188:
		;
		if !(lengthptr != uintptr(0)) {
			goto __189
		}
		*(*uint64)(unsafe.Pointer(lengthptr)) += uint64(mclength)
		goto __190
	__189:

		libc.Xmemcpy(tls, code, bp+72, uint64(mclength*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
		code += uintptr(mclength)
		verbculen = verbculen + mclength
	__190:
		;
		goto __185
	__185:
		i17++
		goto __184
		goto __186
	__186:
	}

	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)))) = uint8(verbculen) // Fill in the code unit length
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(0)                               // Terminating zero
	goto __12

	// ===================================================================
	// Handle options change. The new setting must be passed back for use in
	//     subsequent branches. Reset the greedy defaults and the case value for
	//     firstcu and reqcu.

__34:
	*(*uint32)(unsafe.Pointer(optionsptr)) = libc.AssignUint32(&options, *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4))))
	greedy_default = uint32(libc.Bool32(options&DPCRE2_UNGREEDY != uint32(0)))
	greedy_non_default = greedy_default ^ uint32(1)
	if options&DPCRE2_CASELESS != uint32(0) {
		req_caseopt = DREQ_CASELESS
	} else {
		req_caseopt = uint32(0)
	}
	goto __12

	// ===================================================================
	// Handle conditional subpatterns. The case of (?(Rdigits) is ambiguous
	//     because it could be a numerical check on recursion, or a name check on a
	//     group's being set. The pre-pass sets up META_COND_RNUMBER as a name so that
	//     we can handle it either way. We first try for a name; if not found, process
	//     the number.

__35: // (?(Rdigits)
__36: // (?(name) or (?'name') or ?(<name>)
__37: // (?(R&name) - test for recursion
	bravalue = OP_COND

	ng = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups
	length = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))

	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	name = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern + uintptr(offset)

	// In the first pass, the names generated in the pre-pass are available,
	//       but the main name table has not yet been created. Scan the list of names
	//       generated in the pre-pass in order to get a number and whether or not
	//       this name is duplicated. If it is not duplicated, we can handle it as a
	//       numerical group.

	i12 = uint32(0)
__191:
	if !(i12 < uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __193
	}

	if !(length == uint32((*Tnamed_group_8)(unsafe.Pointer(ng)).Flength) && X_pcre2_strncmp_8(tls, name, (*Tnamed_group_8)(unsafe.Pointer(ng)).Fname, uint64(length)) == 0) {
		goto __194
	}

	if !!(int32((*Tnamed_group_8)(unsafe.Pointer(ng)).Fisdup) != 0) {
		goto __195
	}

	*(*uint8)(unsafe.Pointer(code + 3)) = func() uint8 {
		if meta == DMETA_COND_RNAME {
			return OP_RREF
		}
		return OP_CREF
	}()
	*(*uint8)(unsafe.Pointer(code + 4)) = uint8((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber >> 8)
	*(*uint8)(unsafe.Pointer(code + 5)) = uint8((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber & uint32(255))
	if !((*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref) {
		goto __196
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = (*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber
__196:
	;
	skipunits = uint32(1 + DIMM2_SIZE)
	goto GROUP_PROCESS_NOTE_EMPTY
__195:
	;
	goto __193 // Found a duplicated name
__194:
	;
	goto __192
__192:
	i12++
	ng += 16
	goto __191
	goto __193
__193:
	;

	// If the name was not found we have a bad reference, unless we are
	//       dealing with R<digits>, which is treated as a recursion test by number.
	//

	if !(i12 >= uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __197
	}

	groupnumber = uint32(0)
	if !(meta == DMETA_COND_RNUMBER) {
		goto __198
	}

	i12 = uint32(1)
__199:
	if !(i12 < length) {
		goto __201
	}

	groupnumber = groupnumber*uint32(10) + uint32(*(*uint8)(unsafe.Pointer(name + uintptr(i12)))) - uint32('\060')
	if !(groupnumber > DMAX_GROUP_NUMBER) {
		goto __202
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR61
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset + uint64(i12)
	return 0
__202:
	;
	goto __200
__200:
	i12++
	goto __199
	goto __201
__201:
	;
__198:
	;

	if !(meta != DMETA_COND_RNUMBER || groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __203
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	return 0
__203:
	;

	// (?Rdigits) treated as a recursion reference by number. A value of
	//         zero (which is the result of both (?R) and (?R0)) means "any", and is
	//         translated into RREF_ANY (which is 0xffff).

	if !(groupnumber == uint32(0)) {
		goto __204
	}
	groupnumber = uint32(DRREF_ANY)
__204:
	;
	*(*uint8)(unsafe.Pointer(code + 3)) = OP_RREF
	*(*uint8)(unsafe.Pointer(code + 4)) = uint8(groupnumber >> 8)
	*(*uint8)(unsafe.Pointer(code + 5)) = uint8(groupnumber & uint32(255))
	skipunits = uint32(1 + DIMM2_SIZE)
	goto GROUP_PROCESS_NOTE_EMPTY
__197:
	;

	// A duplicated name was found. Note that if an R<digits> name is found
	//       (META_COND_RNUMBER), it is a reference test, not a recursion test.

	*(*uint8)(unsafe.Pointer(code + 3)) = func() uint8 {
		if meta == DMETA_COND_RNAME {
			return OP_RREF
		}
		return OP_CREF
	}()

	// We have a duplicated name. In the compile pass we have to search the
	//       main table in order to get the index and count values.

	*(*int32)(unsafe.Pointer(bp + 84 /* count */)) = 0 // Values for first pass (avoids compiler warning)
	*(*int32)(unsafe.Pointer(bp + 80 /* index */)) = 0
	if !(lengthptr == uintptr(0) && !(find_dupname_details(tls, name, length, bp+80,
		bp+84, errorcodeptr, cb) != 0)) {
		goto __205
	}
	return 0
__205:
	;

	// Add one to the opcode to change CREF/RREF into DNCREF/DNRREF and
	//       insert appropriate data values.

	*(*uint8)(unsafe.Pointer(code + 3))++
	skipunits = uint32(1 + 2*DIMM2_SIZE)
	*(*uint8)(unsafe.Pointer(code + 4)) = uint8(*(*int32)(unsafe.Pointer(bp + 80)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 5)) = uint8(*(*int32)(unsafe.Pointer(bp + 80)) & 255)
	*(*uint8)(unsafe.Pointer(code + 6)) = uint8(*(*int32)(unsafe.Pointer(bp + 84)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 7)) = uint8(*(*int32)(unsafe.Pointer(bp + 84)) & 255)

	goto GROUP_PROCESS_NOTE_EMPTY

	// The DEFINE condition is always false. Its internal groups may never
	//     be called, so matched_char must remain false, hence the jump to
	//     GROUP_PROCESS rather than GROUP_PROCESS_NOTE_EMPTY.

__38:
	bravalue = OP_COND
	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	*(*uint8)(unsafe.Pointer(code + 3)) = OP_DEFINE
	skipunits = uint32(1)
	goto GROUP_PROCESS

	// Conditional test of a group's being set.

__39:
	bravalue = OP_COND
	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	groupnumber = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	if !(groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __206
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	return 0
__206:
	;
	if !(groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref) {
		goto __207
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = groupnumber
__207:
	;
	offset = offset - uint64(2) // Point at initial ( for too many branches error
	*(*uint8)(unsafe.Pointer(code + 3)) = OP_CREF
	skipunits = uint32(1 + DIMM2_SIZE)
	*(*uint8)(unsafe.Pointer(code + 4)) = uint8(groupnumber >> 8)
	*(*uint8)(unsafe.Pointer(code + 5)) = uint8(groupnumber & uint32(255))
	goto GROUP_PROCESS_NOTE_EMPTY

	// Test for the PCRE2 version.

__40:
	bravalue = OP_COND
	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) > uint32(0)) {
		goto __208
	}
	*(*uint8)(unsafe.Pointer(code + 3)) = func() uint8 {
		if uint32(DPCRE2_MAJOR) > *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) || uint32(DPCRE2_MAJOR) == *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) && uint32(DPCRE2_MINOR) >= *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 3*4)) {
			return OP_TRUE
		}
		return OP_FALSE
	}()
	goto __209
__208:
	*(*uint8)(unsafe.Pointer(code + 3)) = func() uint8 {
		if uint32(DPCRE2_MAJOR) == *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) && uint32(DPCRE2_MINOR) == *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 3*4)) {
			return OP_TRUE
		}
		return OP_FALSE
	}()
__209:
	;
	skipunits = uint32(1)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3)
	goto GROUP_PROCESS_NOTE_EMPTY

	// The condition is an assertion, possibly preceded by a callout.

__41:
	bravalue = OP_COND
	goto GROUP_PROCESS_NOTE_EMPTY

	// ===================================================================
	// Handle all kinds of nested bracketed groups. The non-capturing,
	//     non-conditional cases are here; others come to GROUP_PROCESS via goto.

__42:
	bravalue = OP_ASSERT
	*(*uint16)(unsafe.Pointer(cb + 182)) += uint16(1)
	goto GROUP_PROCESS

__43:
	bravalue = OP_ASSERT_NA
	*(*uint16)(unsafe.Pointer(cb + 182)) += uint16(1)
	goto GROUP_PROCESS

	// Optimize (?!) to (*FAIL) unless it is quantified - which is a weird
	//     thing to do, but Perl allows all assertions to be quantified, and when
	//     they contain capturing parentheses there may be a potential use for
	//     this feature. Not that that applies to a quantified (?!) but we allow
	//     it for uniformity.

__44:
	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) == DMETA_KET && (*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) < DMETA_ASTERISK || *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) > DMETA_MINMAX_QUERY)) {
		goto __210
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_FAIL
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4
	goto __211
__210:

	bravalue = OP_ASSERT_NOT
	*(*uint16)(unsafe.Pointer(cb + 182)) += uint16(1)
	goto GROUP_PROCESS
__211:
	;
	goto __12

__45:
	bravalue = OP_ASSERTBACK
	*(*uint16)(unsafe.Pointer(cb + 182)) += uint16(1)
	goto GROUP_PROCESS

__46:
	bravalue = OP_ASSERTBACK_NOT
	*(*uint16)(unsafe.Pointer(cb + 182)) += uint16(1)
	goto GROUP_PROCESS

__47:
	bravalue = OP_ASSERTBACK_NA
	*(*uint16)(unsafe.Pointer(cb + 182)) += uint16(1)
	goto GROUP_PROCESS

__48:
	bravalue = OP_ONCE
	goto GROUP_PROCESS_NOTE_EMPTY

__49:
	bravalue = OP_SCRIPT_RUN
	goto GROUP_PROCESS_NOTE_EMPTY

__50:
	bravalue = OP_BRA
	// Fall through

	// Process nested bracketed regex. The nesting depth is maintained for the
	//     benefit of the stackguard function. The test for too deep nesting is now
	//     done in parse_regex(). Assertion and DEFINE groups come to GROUP_PROCESS;
	//     others come to GROUP_PROCESS_NOTE_EMPTY, to indicate that we need to take
	//     note of whether or not they may match an empty string.

GROUP_PROCESS_NOTE_EMPTY:
	note_group_empty = DTRUE

GROUP_PROCESS:
	*(*uint16)(unsafe.Pointer(cb + 180)) += uint16(1)
	*(*uint8)(unsafe.Pointer(code)) = uint8(bravalue)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) = code
	tempreqvary = (*Tcompile_block_8)(unsafe.Pointer(cb)).Freq_varyopt      // Save value before group
	*(*uint64)(unsafe.Pointer(bp + 120 /* length_prevgroup */)) = uint64(0) // Initialize for pre-compile phase

	if !(libc.AssignInt32(&group_return, compile_regex(tls,
		options,
		bp+88,
		bp+96,
		errorcodeptr,
		skipunits,
		bp+104,
		bp+108,
		bp+112,
		bp+116,
		bcptr,
		cb,
		func() uintptr {
			if lengthptr == uintptr(0) {
				return uintptr(0)
			}
			return bp + 120
		}())) == 0) {
		goto __212
	}
	return 0
__212:
	; // Error

	*(*uint16)(unsafe.Pointer(cb + 180)) -= uint16(1)

	// If that was a non-conditional significant group (not an assertion, not a
	//     DEFINE) that matches at least one character, then the current item matches
	//     a character. Conditionals are handled below.

	if !(note_group_empty != 0 && bravalue != OP_COND && group_return > 0) {
		goto __213
	}
	matched_char = DTRUE
__213:
	;

	// If we've just compiled an assertion, pop the assert depth.

	if !(bravalue >= OP_ASSERT && bravalue <= OP_ASSERTBACK_NA) {
		goto __214
	}
	*(*uint16)(unsafe.Pointer(cb + 182)) -= uint16(1)
__214:
	;

	// At the end of compiling, code is still pointing to the start of the
	//     group, while tempcode has been updated to point past the end of the group.
	//     The parsed pattern pointer (pptr) is on the closing META_KET.
	//
	//     If this is a conditional bracket, check that there are no more than
	//     two branches in the group, or just one if it's a DEFINE group. We do this
	//     in the real compile phase, not in the pre-pass, where the whole group may
	//     not be available.

	if !(bravalue == OP_COND && lengthptr == uintptr(0)) {
		goto __215
	}

	tc = code
	condcount = 0

__216:
	condcount++
	tc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(tc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(tc + 2)))))
	goto __217
__217:
	if int32(*(*uint8)(unsafe.Pointer(tc))) != OP_KET {
		goto __216
	}
	goto __218
__218:
	;

	// A DEFINE group is never obeyed inline (the "condition" is always
	//       false). It must have only one branch. Having checked this, change the
	//       opcode to OP_FALSE.

	if !(int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_DEFINE) {
		goto __219
	}

	if !(condcount > 1) {
		goto __221
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR54
	return 0
__221:
	;
	*(*uint8)(unsafe.Pointer(code + 3)) = OP_FALSE
	bravalue = OP_DEFINE // A flag to suppress char handling below
	goto __220
__219:

	if !(condcount > 2) {
		goto __222
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR27
	return 0
__222:
	;
	if !(condcount == 1) {
		goto __223
	}
	*(*uint32)(unsafe.Pointer(bp + 108 /* subfirstcuflags */)) = libc.AssignPtrUint32(bp+116 /* subreqcuflags */, DREQ_NONE)
	goto __224
__223:
	if !(group_return > 0) {
		goto __225
	}
	matched_char = DTRUE
__225:
	;
__224:
	;
__220:
	;
__215:
	;

	// In the pre-compile phase, update the length by the length of the group,
	//     less the brackets at either end. Then reduce the compiled code to just a
	//     set of non-capturing brackets so that it doesn't use much memory if it is
	//     duplicated by a quantifier.

	if !(lengthptr != uintptr(0)) {
		goto __226
	}

	if !(uint64(0x7fffffff-20)-*(*uint64)(unsafe.Pointer(lengthptr)) < *(*uint64)(unsafe.Pointer(bp + 120))-uint64(2)-uint64(2*DLINK_SIZE)) {
		goto __227
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
	return 0
__227:
	;
	*(*uint64)(unsafe.Pointer(lengthptr)) += *(*uint64)(unsafe.Pointer(bp + 120)) - uint64(2) - uint64(2*DLINK_SIZE)
	code++ // This already contains bravalue
	*(*uint8)(unsafe.Pointer(code)) = uint8(int32(1+DLINK_SIZE) >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8((1 + DLINK_SIZE) & 255)
	code += uintptr(DLINK_SIZE)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_KET
	*(*uint8)(unsafe.Pointer(code)) = uint8(int32(1+DLINK_SIZE) >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8((1 + DLINK_SIZE) & 255)
	code += uintptr(DLINK_SIZE)
	goto __12 // No need to waste time with special character handling
__226:
	;

	// Otherwise update the main code pointer to the end of the group.

	code = *(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */))

	// For a DEFINE group, required and first character settings are not
	//     relevant.

	if !(bravalue == OP_DEFINE) {
		goto __228
	}
	goto __12
__228:
	;

	// Handle updating of the required and first code units for other types of
	//     group. Update for normal brackets of all kinds, and conditions with two
	//     branches (see code above). If the bracket is followed by a quantifier with
	//     zero repeat, we have to back off. Hence the definition of zeroreqcu and
	//     zerofirstcu outside the main loop so that they can be accessed for the back
	//     off.

	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	groupsetfirstcu = DFALSE

	if !(bravalue >= OP_ONCE) {
		goto __229
	} /* Not an assertion */

	// If we have not yet set a firstcu in this branch, take it from the
	//       subpattern, remembering that it was set here so that a repeat of more
	//       than one can replicate it as reqcu if necessary. If the subpattern has
	//       no firstcu, set "none" for the whole branch. In both cases, a zero
	//       repeat forces firstcu to "none".

	if !(firstcuflags == DREQ_UNSET && *(*uint32)(unsafe.Pointer(bp + 108)) != DREQ_UNSET) {
		goto __231
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 108)) < DREQ_NONE) {
		goto __233
	}

	firstcu = *(*uint32)(unsafe.Pointer(bp + 104 /* subfirstcu */))
	firstcuflags = *(*uint32)(unsafe.Pointer(bp + 108 /* subfirstcuflags */))
	groupsetfirstcu = DTRUE
	goto __234
__233:
	firstcuflags = DREQ_NONE
__234:
	;
	zerofirstcuflags = DREQ_NONE
	goto __232
__231:
	if !(*(*uint32)(unsafe.Pointer(bp + 108)) < DREQ_NONE && *(*uint32)(unsafe.Pointer(bp + 116)) >= DREQ_NONE) {
		goto __235
	}

	*(*uint32)(unsafe.Pointer(bp + 112 /* subreqcu */)) = *(*uint32)(unsafe.Pointer(bp + 104 /* subfirstcu */))
	*(*uint32)(unsafe.Pointer(bp + 116 /* subreqcuflags */)) = *(*uint32)(unsafe.Pointer(bp + 108)) | tempreqvary
__235:
	;
__232:
	;

	// If the subpattern set a required code unit (or set a first code unit
	//       that isn't really the first code unit - see above), set it.

	if !(*(*uint32)(unsafe.Pointer(bp + 116)) < DREQ_NONE) {
		goto __236
	}

	reqcu = *(*uint32)(unsafe.Pointer(bp + 112 /* subreqcu */))
	reqcuflags = *(*uint32)(unsafe.Pointer(bp + 116 /* subreqcuflags */))
__236:
	;
	goto __230
__229:
	if !((bravalue == OP_ASSERT || bravalue == OP_ASSERT_NA) && *(*uint32)(unsafe.Pointer(bp + 116)) < DREQ_NONE && *(*uint32)(unsafe.Pointer(bp + 108)) < DREQ_NONE) {
		goto __237
	}

	reqcu = *(*uint32)(unsafe.Pointer(bp + 112 /* subreqcu */))
	reqcuflags = *(*uint32)(unsafe.Pointer(bp + 116 /* subreqcuflags */))
__237:
	;
__230:
	;

	goto __12 // End of nested group handling

	// ===================================================================
	// Handle named backreferences and recursions.

__51:
__52:

	is_dupname = DFALSE
	ng1 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups
	length1 = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))

	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	name1 = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern + uintptr(offset)

	// In the first pass, the names generated in the pre-pass are available,
	//       but the main name table has not yet been created. Scan the list of names
	//       generated in the pre-pass in order to get a number and whether or not
	//       this name is duplicated.

	groupnumber = uint32(0)
	{
		i13 = uint32(0)
	__238:
		if !(i13 < uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
			goto __240
		}

		if !(length1 == uint32((*Tnamed_group_8)(unsafe.Pointer(ng1)).Flength) && X_pcre2_strncmp_8(tls, name1, (*Tnamed_group_8)(unsafe.Pointer(ng1)).Fname, uint64(length1)) == 0) {
			goto __241
		}

		is_dupname = int32((*Tnamed_group_8)(unsafe.Pointer(ng1)).Fisdup)
		groupnumber = (*Tnamed_group_8)(unsafe.Pointer(ng1)).Fnumber

		// For a recursion, that's all that is needed. We can now go to
		//           the code that handles numerical recursion, applying it to the first
		//           group with the given name.

		if !(meta == DMETA_RECURSE_BYNAME) {
			goto __242
		}

		meta_arg = groupnumber
		goto HANDLE_NUMERICAL_RECURSION
	__242:
		;

		// For a back reference, update the back reference map and the
		//           maximum back reference.

		*(*uint32)(unsafe.Pointer(cb + 252)) |= func() uint32 {
			if groupnumber < uint32(32) {
				return uint32(1) << groupnumber
			}
			return uint32(1)
		}()
		if !(groupnumber > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref) {
			goto __243
		}
		(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = groupnumber
	__243:
		;
	__241:
		;
		goto __239
	__239:
		i13++
		ng1 += 16
		goto __238
		goto __240
	__240:
	}

	// If the name was not found we have a bad reference.

	if !(groupnumber == uint32(0)) {
		goto __244
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	return 0
__244:
	;

	// If a back reference name is not duplicated, we can handle it as
	//       a numerical reference.

	if !!(is_dupname != 0) {
		goto __245
	}

	meta_arg = groupnumber
	goto HANDLE_SINGLE_REFERENCE
__245:
	;

	// If a back reference name is duplicated, we generate a different
	//       opcode to a numerical back reference. In the second pass we must
	//       search for the index and count in the final name table.

	*(*int32)(unsafe.Pointer(bp + 132 /* count1 */)) = 0 // Values for first pass (avoids compiler warning)
	*(*int32)(unsafe.Pointer(bp + 128 /* index1 */)) = 0
	if !(lengthptr == uintptr(0) && !(find_dupname_details(tls, name1, length1, bp+128,
		bp+132, errorcodeptr, cb) != 0)) {
		goto __246
	}
	return 0
__246:
	;

	if !(firstcuflags == DREQ_UNSET) {
		goto __247
	}
	firstcuflags = DREQ_NONE
__247:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_CASELESS != uint32(0) {
			return OP_DNREFI
		}
		return OP_DNREF
	}()
	*(*uint8)(unsafe.Pointer(code)) = uint8(*(*int32)(unsafe.Pointer(bp + 128)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(*(*int32)(unsafe.Pointer(bp + 128)) & 255)
	code += uintptr(DIMM2_SIZE)
	*(*uint8)(unsafe.Pointer(code)) = uint8(*(*int32)(unsafe.Pointer(bp + 132)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(*(*int32)(unsafe.Pointer(bp + 132)) & 255)
	code += uintptr(DIMM2_SIZE)

	goto __12

	// ===================================================================
	// Handle a numerical callout.

__53:
	*(*uint8)(unsafe.Pointer(code)) = OP_CALLOUT
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 2)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) & uint32(255)) // Offset to next pattern item
	*(*uint8)(unsafe.Pointer(code + 3)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 4)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) & uint32(255)) // Length of next pattern item
	*(*uint8)(unsafe.Pointer(code + 5)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) + 3*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3)
	code += uintptr(X_pcre2_OP_lengths_8[OP_CALLOUT])
	goto __12

	// ===================================================================
	// Handle a callout with a string argument. In the pre-pass we just compute
	//     the length without generating anything. The length in pptr[3] includes both
	//     delimiters; in the actual compile only the first one is copied, but a
	//     terminating zero is added. Any doubled delimiters within the string make
	//     this an overestimate, but it is not worth bothering about.

__54:
	if !(lengthptr != uintptr(0)) {
		goto __248
	}

	*(*uint64)(unsafe.Pointer(lengthptr)) += uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 3*4)) + uint32(1+4*DLINK_SIZE))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)
	goto __249
__248:

	length2 = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) + 3*4))
	callout_string = code + uintptr(1+4*DLINK_SIZE)

	*(*uint8)(unsafe.Pointer(code)) = OP_CALLOUT_STR
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 2)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)) & uint32(255)) // Offset to next pattern item
	*(*uint8)(unsafe.Pointer(code + 3)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 4)) = uint8(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)) & uint32(255)) // Length of next pattern item

	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(3)
	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)
	// Offset to string in pattern
	pp = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern + uintptr(offset)
	delimiter = uint32(libc.AssignPtrUint8(libc.PostIncUintptr(&callout_string, 1), *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pp, 1)))))
	if !(delimiter == uint32('\173')) {
		goto __250
	}
	delimiter = uint32('\175')
__250:
	;
	*(*uint8)(unsafe.Pointer(code + 7)) = uint8(int32(offset+uint64(1)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 8)) = uint8(int32(offset+uint64(1)) & 255) // One after delimiter

	// The syntax of the pattern was checked in the parsing scan. The length
	//       includes both delimiters, but we have passed the opening one just above,
	//       so we reduce length before testing it. The test is for > 1 because we do
	//       not want to copy the final delimiter. This also ensures that pp[1] is
	//       accessible.

__251:
	if !(libc.PreDecUint32(&length2, 1) > uint32(1)) {
		goto __252
	}

	if !(uint32(*(*uint8)(unsafe.Pointer(pp))) == delimiter && uint32(*(*uint8)(unsafe.Pointer(pp + 1))) == delimiter) {
		goto __253
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&callout_string, 1))) = uint8(delimiter)
	pp += uintptr(2)
	length2--
	goto __254
__253:
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&callout_string, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pp, 1)))
__254:
	;
	goto __251
__252:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&callout_string, 1))) = uint8(0)

	// Set the length of the entire item, the advance to its end.

	*(*uint8)(unsafe.Pointer(code + 5)) = uint8(int32((int64(callout_string)-int64(code))/1) >> 8)
	*(*uint8)(unsafe.Pointer(code + 6)) = uint8(int32((int64(callout_string)-int64(code))/1) & 255)
	code = callout_string
__249:
	;
	goto __12

	// ===================================================================
	// Handle repetition. The different types are all sorted out in the parsing
	//     pass.

__55:
__56:
__57:
	repeat_min = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	repeat_max = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4)))
	goto REPEAT

__58:
__59:
__60:
	repeat_min = uint32(0)
	repeat_max = DMAX_REPEAT_COUNT + uint32(1)
	goto REPEAT

__61:
__62:
__63:
	repeat_min = uint32(1)
	repeat_max = DMAX_REPEAT_COUNT + uint32(1)
	goto REPEAT

__64:
__65:
__66:
	repeat_min = uint32(0)
	repeat_max = uint32(1)

REPEAT:
	if !(previous_matched_char != 0 && repeat_min > uint32(0)) {
		goto __255
	}
	matched_char = DTRUE
__255:
	;

	// Remember whether this is a variable length repeat, and default to
	//     single-char opcodes.

	if repeat_min == repeat_max {
		reqvary = uint32(0)
	} else {
		reqvary = DREQ_VARY
	}
	op_type = uint32(0)

	// Adjust first and required code units for a zero repeat.

	if !(repeat_min == uint32(0)) {
		goto __256
	}

	firstcu = zerofirstcu
	firstcuflags = zerofirstcuflags
	reqcu = zeroreqcu
	reqcuflags = zeroreqcuflags
__256:
	;

	// Note the greediness and possessiveness.

	switch meta {
	case DMETA_MINMAX_PLUS:
		goto __258
	case DMETA_ASTERISK_PLUS:
		goto __259
	case DMETA_PLUS_PLUS:
		goto __260
	case DMETA_QUERY_PLUS:
		goto __261

	case DMETA_MINMAX_QUERY:
		goto __262
	case DMETA_ASTERISK_QUERY:
		goto __263
	case DMETA_PLUS_QUERY:
		goto __264
	case DMETA_QUERY_QUERY:
		goto __265

	default:
		goto __266
	}
	goto __257

__258:
__259:
__260:
__261:
	repeat_type = uint32(0) // Force greedy
	possessive_quantifier = DTRUE
	goto __257

__262:
__263:
__264:
__265:
	repeat_type = greedy_non_default
	possessive_quantifier = DFALSE
	goto __257

__266:
	repeat_type = greedy_default
	possessive_quantifier = DFALSE
	goto __257
__257:
	;

	// Save start of previous item, in case we have to move it up in order to
	//     insert something before it, and remember what it was.

	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) = previous
	op_previous = *(*uint8)(unsafe.Pointer(previous))

	// Now handle repetition for the different types of item. If the repeat
	//     minimum and the repeat maximum are both 1, we can ignore the quantifier for
	//     non-parenthesized items, as they have only one alternative. For anything in
	//     parentheses, we must not ignore if {1} is possessive.

	switch int32(op_previous) {
	// If previous was a character or negated character match, abolish the
	//       item and generate a repeat item instead. If a char item has a minimum of
	//       more than one, ensure that it is set in reqcu - it might not be if a
	//       sequence such as x{3} is the first thing in a branch because the x will
	//       have gone into firstcu instead.

	case OP_CHAR:
		goto __268
	case OP_CHARI:
		goto __269
	case OP_NOT:
		goto __270
	case OP_NOTI:
		goto __271 // Code shared with single character types

	// If previous was a character class or a back reference, we put the
	//       repeat stuff after it, but just skip the item if the repeat was {0,0}.

	case OP_XCLASS:
		goto __272
	case OP_CLASS:
		goto __273
	case OP_NCLASS:
		goto __274
	case OP_REF:
		goto __275
	case OP_REFI:
		goto __276
	case OP_DNREF:
		goto __277
	case OP_DNREFI:
		goto __278

	// If previous is OP_FAIL, it was generated by an empty class []
	//       (PCRE2_ALLOW_EMPTY_CLASS is set). The other ways in which OP_FAIL can be
	//       generated, that is by (*FAIL) or (?!), disallow a quantifier at parse
	//       time. We can just ignore this repeat.

	case OP_FAIL:
		goto __279

	// Prior to 10.30, repeated recursions were wrapped in OP_ONCE brackets
	//       because pcre2_match() could not handle backtracking into recursively
	//       called groups. Now that this backtracking is available, we no longer need
	//       to do this. However, we still need to replicate recursions as we do for
	//       groups so as to have independent backtracking points. We can replicate
	//       for the minimum number of repeats directly. For optional repeats we now
	//       wrap the recursion in OP_BRA brackets and make use of the bracket
	//       repetition.

	case OP_RECURSE:
		goto __280 // Set "may match empty string"

	// Now treat as a repeated OP_BRA.
	// Fall through

	// If previous was a bracket group, we may have to replicate it in
	//       certain cases. Note that at this point we can encounter only the "basic"
	//       bracket opcodes such as BRA and CBRA, as this is the place where they get
	//       converted into the more special varieties such as BRAPOS and SBRA.
	//       Originally, PCRE did not allow repetition of assertions, but now it does,
	//       for Perl compatibility.

	case OP_ASSERT:
		goto __281
	case OP_ASSERT_NOT:
		goto __282
	case OP_ASSERT_NA:
		goto __283
	case OP_ASSERTBACK:
		goto __284
	case OP_ASSERTBACK_NOT:
		goto __285
	case OP_ASSERTBACK_NA:
		goto __286
	case OP_ONCE:
		goto __287
	case OP_SCRIPT_RUN:
		goto __288
	case OP_BRA:
		goto __289
	case OP_CBRA:
		goto __290
	case OP_COND:
		goto __291

	// If previous was a character type match (\d or similar), abolish it and
	//       create a suitable repeat item. The code is shared with single-character
	//       repeats by setting op_type to add a suitable offset into repeat_type.
	//       Note the the Unicode property types will be present only when
	//       SUPPORT_UNICODE is defined, but we don't wrap the little bits of code
	//       here because it just makes it horribly messy.

	default:
		goto __292
	}
	goto __267

	// If previous was a character or negated character match, abolish the
	//       item and generate a repeat item instead. If a char item has a minimum of
	//       more than one, ensure that it is set in reqcu - it might not be if a
	//       sequence such as x{3} is the first thing in a branch because the x will
	//       have gone into firstcu instead.

__268:
__269:
__270:
__271:
	if !(repeat_max == uint32(1) && repeat_min == uint32(1)) {
		goto __293
	}
	goto END_REPEAT
__293:
	;
	op_type = chartypeoffset[int32(op_previous)-OP_CHAR]

	// Deal with UTF characters that take up more than one code unit.

	if !(utf != 0 && uint32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))&0xc0 == 0x80) {
		goto __294
	}

	lastchar = code - uintptr(1)
__296:
	if !(uint32(*(*uint8)(unsafe.Pointer(lastchar)))&0xc0 == 0x80) {
		goto __297
	}
	lastchar--
	goto __296
__297:
	;
	mclength = uint32((int64(code) - int64(lastchar)) / 1)                                // Length of UTF character
	libc.Xmemcpy(tls, bp+72, lastchar, uint64(mclength*uint32(DPCRE2_CODE_UNIT_WIDTH/8))) // Save the char
	goto __295
__294:

	/* Handle the case of a single code unit - either with no UTF support, or
	   with UTF disabled, or for a single-code-unit UTF character. In the latter
	   case, for a repeated positive match, get the caseless flag for the
	   required code unit from the previous character, because a class like [Aa]
	   sets a caseless A but by now the req_caseopt flag has been reset. */

	*(*uint8)(unsafe.Pointer(bp + 72)) = *(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1)))
	mclength = uint32(1)
	if !(int32(op_previous) <= OP_CHARI && repeat_min > uint32(1)) {
		goto __298
	}

	reqcu = uint32(*(*uint8)(unsafe.Pointer(bp + 72)))
	reqcuflags = (*Tcompile_block_8)(unsafe.Pointer(cb)).Freq_varyopt
	if !(int32(op_previous) == OP_CHARI) {
		goto __299
	}
	reqcuflags = reqcuflags | DREQ_CASELESS
__299:
	;
__298:
	;
__295:
	;
	goto OUTPUT_SINGLE_REPEAT // Code shared with single character types

	// If previous was a character class or a back reference, we put the
	//       repeat stuff after it, but just skip the item if the repeat was {0,0}.

__272:
__273:
__274:
__275:
__276:
__277:
__278:

	if !(repeat_max == uint32(0)) {
		goto __300
	}

	code = previous
	goto END_REPEAT
__300:
	;
	if !(repeat_max == uint32(1) && repeat_min == uint32(1)) {
		goto __301
	}
	goto END_REPEAT
__301:
	;

	if !(repeat_min == uint32(0) && repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __302
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_CRSTAR + repeat_type)
	goto __303
__302:
	if !(repeat_min == uint32(1) && repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __304
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_CRPLUS + repeat_type)
	goto __305
__304:
	if !(repeat_min == uint32(0) && repeat_max == uint32(1)) {
		goto __306
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_CRQUERY + repeat_type)
	goto __307
__306:

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_CRRANGE + repeat_type)
	*(*uint8)(unsafe.Pointer(code)) = uint8(repeat_min >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(repeat_min & uint32(255))
	code += uintptr(DIMM2_SIZE)
	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __308
	}
	repeat_max = uint32(0)
__308:
	; // 2-byte encoding for max
	*(*uint8)(unsafe.Pointer(code)) = uint8(repeat_max >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(repeat_max & uint32(255))
	code += uintptr(DIMM2_SIZE)
__307:
	;
__305:
	;
__303:
	;
	goto __267

	// If previous is OP_FAIL, it was generated by an empty class []
	//       (PCRE2_ALLOW_EMPTY_CLASS is set). The other ways in which OP_FAIL can be
	//       generated, that is by (*FAIL) or (?!), disallow a quantifier at parse
	//       time. We can just ignore this repeat.

__279:
	goto END_REPEAT

	// Prior to 10.30, repeated recursions were wrapped in OP_ONCE brackets
	//       because pcre2_match() could not handle backtracking into recursively
	//       called groups. Now that this backtracking is available, we no longer need
	//       to do this. However, we still need to replicate recursions as we do for
	//       groups so as to have independent backtracking points. We can replicate
	//       for the minimum number of repeats directly. For optional repeats we now
	//       wrap the recursion in OP_BRA brackets and make use of the bracket
	//       repetition.

__280:
	if !(repeat_max == uint32(1) && repeat_min == uint32(1) && !(possessive_quantifier != 0)) {
		goto __309
	}
	goto END_REPEAT
__309:
	;

	// Generate unwrapped repeats for a non-zero minimum, except when the
	//       minimum is 1 and the maximum unlimited, because that can be handled with
	//       OP_BRA terminated by OP_KETRMAX/MIN. When the maximum is equal to the
	//       minimum, we just need to generate the appropriate additional copies.
	//       Otherwise we need to generate one more, to simulate the situation when
	//       the minimum is zero.

	if !(repeat_min > uint32(0) && (repeat_min != uint32(1) || repeat_max != DMAX_REPEAT_COUNT+uint32(1))) {
		goto __310
	}

	replicate = int32(repeat_min)
	if !(repeat_min == repeat_max) {
		goto __311
	}
	replicate--
__311:
	;

	// In the pre-compile phase, we don't actually do the replication. We
	//         just adjust the length as if we had. Do some paranoid checks for
	//         potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
	//         integer type when available, otherwise double.

	if !(lengthptr != uintptr(0)) {
		goto __312
	}

	delta = uint64(replicate * (1 + DLINK_SIZE))
	if !(int64(replicate)*int64(1+DLINK_SIZE) > int64(0x7fffffff) || uint64(0x7fffffff-20)-*(*uint64)(unsafe.Pointer(lengthptr)) < delta) {
		goto __314
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
	return 0
__314:
	;
	*(*uint64)(unsafe.Pointer(lengthptr)) += delta
	goto __313
__312:
	{
		i14 = 0
	__315:
		if !(i14 < replicate) {
			goto __317
		}

		libc.Xmemcpy(tls, code, previous, uint64((1+DLINK_SIZE)*(DPCRE2_CODE_UNIT_WIDTH/8)))
		previous = code
		code += uintptr(1 + DLINK_SIZE)
		goto __316
	__316:
		i14++
		goto __315
		goto __317
	__317:
	}
__313:
	;

	// If the number of repeats is fixed, we are done. Otherwise, adjust
	//         the counts and fall through.

	if !(repeat_min == repeat_max) {
		goto __318
	}
	goto __267
__318:
	;
	if !(repeat_max != DMAX_REPEAT_COUNT+uint32(1)) {
		goto __319
	}
	repeat_max = repeat_max - repeat_min
__319:
	;
	repeat_min = uint32(0)
__310:
	;

	// Wrap the recursion call in OP_BRA brackets.

	libc.Xmemmove(tls, previous+uintptr(1)+uintptr(DLINK_SIZE), previous, uint64((1+DLINK_SIZE)*(DPCRE2_CODE_UNIT_WIDTH/8)))
	op_previous = libc.AssignPtrUint8(previous, OP_BRA)
	*(*uint8)(unsafe.Pointer(previous + 1)) = uint8(int32(2+2*DLINK_SIZE) >> 8)
	*(*uint8)(unsafe.Pointer(previous + 2)) = uint8((2 + 2*DLINK_SIZE) & 255)
	*(*uint8)(unsafe.Pointer(previous + 6)) = OP_KET
	*(*uint8)(unsafe.Pointer(previous + 7)) = uint8(int32(2+2*DLINK_SIZE) >> 8)
	*(*uint8)(unsafe.Pointer(previous + 8)) = uint8((2 + 2*DLINK_SIZE) & 255)
	code += uintptr(2 + 2*DLINK_SIZE)
	*(*uint64)(unsafe.Pointer(bp + 120 /* length_prevgroup */)) = uint64(3 + 3*DLINK_SIZE)
	group_return = -1 // Set "may match empty string"

	// Now treat as a repeated OP_BRA.
	// Fall through

	// If previous was a bracket group, we may have to replicate it in
	//       certain cases. Note that at this point we can encounter only the "basic"
	//       bracket opcodes such as BRA and CBRA, as this is the place where they get
	//       converted into the more special varieties such as BRAPOS and SBRA.
	//       Originally, PCRE did not allow repetition of assertions, but now it does,
	//       for Perl compatibility.

__281:
__282:
__283:
__284:
__285:
__286:
__287:
__288:
__289:
__290:
__291:

	len = int32((int64(code) - int64(previous)) / 1)
	bralink = uintptr(0)
	brazeroptr = uintptr(0)

	if !(repeat_max == uint32(1) && repeat_min == uint32(1) && !(possessive_quantifier != 0)) {
		goto __320
	}
	goto END_REPEAT
__320:
	;

	// Repeating a DEFINE group (or any group where the condition is always
	//         FALSE and there is only one branch) is pointless, but Perl allows the
	//         syntax, so we just ignore the repeat.

	if !(int32(op_previous) == OP_COND && int32(*(*uint8)(unsafe.Pointer(previous + 3))) == OP_FALSE && int32(*(*uint8)(unsafe.Pointer(previous + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(previous + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(previous + 2)))))))) != OP_ALT) {
		goto __321
	}
	goto END_REPEAT
__321:
	;

	// Perl allows all assertions to be quantified, and when they contain
	//         capturing parentheses and/or are optional there are potential uses for
	//         this feature. PCRE2 used to force the maximum quantifier to 1 on the
	//         invalid grounds that further repetition was never useful. This was
	//         always a bit pointless, since an assertion could be wrapped with a
	//         repeated group to achieve the effect. General repetition is now
	//         permitted, but if the maximum is unlimited it is set to one more than
	//         the minimum.

	if !(int32(op_previous) < OP_ONCE) {
		goto __322
	} /* Assertion */

	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __323
	}
	repeat_max = repeat_min + uint32(1)
__323:
	;
__322:
	;

	// The case of a zero minimum is special because of the need to stick
	//         OP_BRAZERO in front of it, and because the group appears once in the
	//         data, whereas in other cases it appears the minimum number of times. For
	//         this reason, it is simplest to treat this case separately, as otherwise
	//         the code gets far too messy. There are several special subcases when the
	//         minimum is zero.

	if !(repeat_min == uint32(0)) {
		goto __324
	}

	// If the maximum is also zero, we used to just omit the group from
	//           the output altogether, like this:
	//
	//           ** if (repeat_max == 0)
	//           **   {
	//           **   code = previous;
	//           **   goto END_REPEAT;
	//           **   }
	//
	//           However, that fails when a group or a subgroup within it is
	//           referenced as a subroutine from elsewhere in the pattern, so now we
	//           stick in OP_SKIPZERO in front of it so that it is skipped on
	//           execution. As we don't have a list of which groups are referenced, we
	//           cannot do this selectively.
	//
	//           If the maximum is 1 or unlimited, we just have to stick in the
	//           BRAZERO and do no more at this point.

	if !(repeat_max <= uint32(1) || repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __326
	}

	libc.Xmemmove(tls, previous+uintptr(1), previous, uint64(len*(DPCRE2_CODE_UNIT_WIDTH/8)))
	code++
	if !(repeat_max == uint32(0)) {
		goto __328
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&previous, 1))) = OP_SKIPZERO
	goto END_REPEAT
__328:
	;
	brazeroptr = previous // Save for possessive optimizing
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&previous, 1))) = uint8(OP_BRAZERO + repeat_type)
	goto __327
__326:

	libc.Xmemmove(tls, previous+uintptr(2)+uintptr(DLINK_SIZE), previous, uint64(len*(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(2 + DLINK_SIZE)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&previous, 1))) = uint8(OP_BRAZERO + repeat_type)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&previous, 1))) = OP_BRA

	// We chain together the bracket link offset fields that have to be
	//             filled in later when the ends of the brackets are reached.

	if bralink == uintptr(0) {
		linkoffset = 0
	} else {
		linkoffset = int32((int64(previous) - int64(bralink)) / 1)
	}
	bralink = previous
	*(*uint8)(unsafe.Pointer(previous)) = uint8(linkoffset >> 8)
	*(*uint8)(unsafe.Pointer(previous + 1)) = uint8(linkoffset & 255)
	previous += uintptr(DLINK_SIZE)
__327:
	;

	if !(repeat_max != DMAX_REPEAT_COUNT+uint32(1)) {
		goto __329
	}
	repeat_max--
__329:
	;
	goto __325
__324:

	if !(repeat_min > uint32(1)) {
		goto __330
	}

	// In the pre-compile phase, we don't actually do the replication.
	//             We just adjust the length as if we had. Do some paranoid checks for
	//             potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
	//             integer type when available, otherwise double.

	if !(lengthptr != uintptr(0)) {
		goto __331
	}

	delta1 = uint64(repeat_min-uint32(1)) * *(*uint64)(unsafe.Pointer(bp + 120))
	if !(int64(repeat_min-uint32(1))*int64(*(*uint64)(unsafe.Pointer(bp + 120))) > int64(0x7fffffff) || uint64(0x7fffffff-20)-*(*uint64)(unsafe.Pointer(lengthptr)) < delta1) {
		goto __333
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
	return 0
__333:
	;
	*(*uint64)(unsafe.Pointer(lengthptr)) += delta1
	goto __332
__331:

	if !(groupsetfirstcu != 0 && reqcuflags >= DREQ_NONE) {
		goto __334
	}

	reqcu = firstcu
	reqcuflags = firstcuflags
__334:
	;
	{
		i15 = uint32(1)
	__335:
		if !(i15 < repeat_min) {
			goto __337
		}

		libc.Xmemcpy(tls, code, previous, uint64(len*(DPCRE2_CODE_UNIT_WIDTH/8)))
		code += uintptr(len)
		goto __336
	__336:
		i15++
		goto __335
		goto __337
	__337:
	}
__332:
	;
__330:
	;

	if !(repeat_max != DMAX_REPEAT_COUNT+uint32(1)) {
		goto __338
	}
	repeat_max = repeat_max - repeat_min
__338:
	;
__325:
	;

	// This code is common to both the zero and non-zero minimum cases. If
	//         the maximum is limited, it replicates the group in a nested fashion,
	//         remembering the bracket starts on a stack. In the case of a zero
	//         minimum, the first one was set up above. In all cases the repeat_max
	//         now specifies the number of additional copies needed. Again, we must
	//         remember to replicate entries on the forward reference list.

	if !(repeat_max != DMAX_REPEAT_COUNT+uint32(1)) {
		goto __339
	}

	// In the pre-compile phase, we don't actually do the replication. We
	//           just adjust the length as if we had. For each repetition we must add
	//           1 to the length for BRAZERO and for all but the last repetition we
	//           must add 2 + 2*LINKSIZE to allow for the nesting that occurs. Do some
	//           paranoid checks to avoid integer overflow. The INT64_OR_DOUBLE type
	//           is a 64-bit integer type when available, otherwise double.

	if !(lengthptr != uintptr(0) && repeat_max > uint32(0)) {
		goto __341
	}

	delta2 = uint64(repeat_max)*(*(*uint64)(unsafe.Pointer(bp + 120))+uint64(1)+uint64(2)+uint64(2*DLINK_SIZE)) - uint64(2) - uint64(2*DLINK_SIZE) // Last one doesn't nest
	if !(int64(repeat_max)*int64(*(*uint64)(unsafe.Pointer(bp + 120))+uint64(1)+uint64(2)+uint64(2*DLINK_SIZE)) >
		int64(0x7fffffff) || uint64(0x7fffffff-20)-*(*uint64)(unsafe.Pointer(lengthptr)) < delta2) {
		goto __343
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
	return 0
__343:
	;
	*(*uint64)(unsafe.Pointer(lengthptr)) += delta2
	goto __342
__341:
	{
		i16 = repeat_max
	__344:
		if !(i16 >= uint32(1)) {
			goto __346
		}

		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_BRAZERO + repeat_type)

		// All but the final copy start a new nesting, maintaining the
		//             chain of brackets outstanding.

		if !(i16 != uint32(1)) {
			goto __347
		}

		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_BRA
		if bralink == uintptr(0) {
			linkoffset1 = 0
		} else {
			linkoffset1 = int32((int64(code) - int64(bralink)) / 1)
		}
		bralink = code
		*(*uint8)(unsafe.Pointer(code)) = uint8(linkoffset1 >> 8)
		*(*uint8)(unsafe.Pointer(code + 1)) = uint8(linkoffset1 & 255)
		code += uintptr(DLINK_SIZE)
	__347:
		;

		libc.Xmemcpy(tls, code, previous, uint64(len*(DPCRE2_CODE_UNIT_WIDTH/8)))
		code += uintptr(len)
		goto __345
	__345:
		i16--
		goto __344
		goto __346
	__346:
	}
__342:
	;

	// Now chain through the pending brackets, and fill in their length
	//           fields (which are holding the chain links pro tem).

__348:
	if !(bralink != uintptr(0)) {
		goto __349
	}

	linkoffset2 = int32((int64(code)-int64(bralink))/1 + int64(1))
	bra = code - uintptr(linkoffset2)
	oldlinkoffset = int32(uint32(int32(*(*uint8)(unsafe.Pointer(bra + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(bra + 2)))))
	if oldlinkoffset == 0 {
		bralink = uintptr(0)
	} else {
		bralink = bralink - uintptr(oldlinkoffset)
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_KET
	*(*uint8)(unsafe.Pointer(code)) = uint8(linkoffset2 >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(linkoffset2 & 255)
	code += uintptr(DLINK_SIZE)
	*(*uint8)(unsafe.Pointer(bra + 1)) = uint8(linkoffset2 >> 8)
	*(*uint8)(unsafe.Pointer(bra + 2)) = uint8(linkoffset2 & 255)
	goto __348
__349:
	;
	goto __340
__339:

	ketcode = code - uintptr(1) - uintptr(DLINK_SIZE)
	bracode = ketcode - uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(ketcode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(ketcode + 2)))))

	// Convert possessive ONCE brackets to non-capturing

	if !(int32(*(*uint8)(unsafe.Pointer(bracode))) == OP_ONCE && possessive_quantifier != 0) {
		goto __350
	}
	*(*uint8)(unsafe.Pointer(bracode)) = OP_BRA
__350:
	;

	// For non-possessive ONCE and for SCRIPT_RUN brackets, all we need
	//           to do is to set the KET.

	if !(int32(*(*uint8)(unsafe.Pointer(bracode))) == OP_ONCE || int32(*(*uint8)(unsafe.Pointer(bracode))) == OP_SCRIPT_RUN) {
		goto __351
	}
	*(*uint8)(unsafe.Pointer(ketcode)) = uint8(OP_KETRMAX + repeat_type)
	goto __352
__351:

	// In the compile phase, adjust the opcode if the group can match
	//             an empty string. For a conditional group with only one branch, the
	//             value of group_return will not show "could be empty", so we must
	//             check that separately.

	if !(lengthptr == uintptr(0)) {
		goto __353
	}

	if !(group_return < 0) {
		goto __354
	}
	*(*uint8)(unsafe.Pointer(bracode)) += uint8(OP_SBRA - OP_BRA)
__354:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(bracode))) == OP_COND && int32(*(*uint8)(unsafe.Pointer(bracode + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(bracode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(bracode + 2)))))))) != OP_ALT) {
		goto __355
	}
	*(*uint8)(unsafe.Pointer(bracode)) = OP_SCOND
__355:
	;
__353:
	;

	// Handle possessive quantifiers.

	if !(possessive_quantifier != 0) {
		goto __356
	}

	// For COND brackets, we wrap the whole thing in a possessively
	//               repeated non-capturing bracket, because we have not invented POS
	//               versions of the COND opcodes.

	if !(int32(*(*uint8)(unsafe.Pointer(bracode))) == OP_COND || int32(*(*uint8)(unsafe.Pointer(bracode))) == OP_SCOND) {
		goto __358
	}

	nlen = int32((int64(code) - int64(bracode)) / 1)
	libc.Xmemmove(tls, bracode+uintptr(1)+uintptr(DLINK_SIZE), bracode, uint64(nlen*(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(1 + DLINK_SIZE)
	nlen = nlen + (1 + DLINK_SIZE)
	*(*uint8)(unsafe.Pointer(bracode)) = func() uint8 {
		if int32(*(*uint8)(unsafe.Pointer(bracode))) == OP_COND {
			return OP_BRAPOS
		}
		return OP_SBRAPOS
	}()
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_KETRPOS
	*(*uint8)(unsafe.Pointer(code)) = uint8(nlen >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(nlen & 255)
	code += uintptr(DLINK_SIZE)
	*(*uint8)(unsafe.Pointer(bracode + 1)) = uint8(nlen >> 8)
	*(*uint8)(unsafe.Pointer(bracode + 2)) = uint8(nlen & 255)
	goto __359
__358:

	*(*uint8)(unsafe.Pointer(bracode)) += uint8(1) // Switch to xxxPOS opcodes
	*(*uint8)(unsafe.Pointer(ketcode)) = OP_KETRPOS
__359:
	;

	// If the minimum is zero, mark it as possessive, then unset the
	//               possessive flag when the minimum is 0 or 1.

	if !(brazeroptr != uintptr(0)) {
		goto __360
	}
	*(*uint8)(unsafe.Pointer(brazeroptr)) = OP_BRAPOSZERO
__360:
	;
	if !(repeat_min < uint32(2)) {
		goto __361
	}
	possessive_quantifier = DFALSE
__361:
	;
	goto __357
__356:
	*(*uint8)(unsafe.Pointer(ketcode)) = uint8(OP_KETRMAX + repeat_type)
__357:
	;
__352:
	;
__340:
	;

	goto __267

	// If previous was a character type match (\d or similar), abolish it and
	//       create a suitable repeat item. The code is shared with single-character
	//       repeats by setting op_type to add a suitable offset into repeat_type.
	//       Note the the Unicode property types will be present only when
	//       SUPPORT_UNICODE is defined, but we don't wrap the little bits of code
	//       here because it just makes it horribly messy.

__292:
	if !(int32(op_previous) >= OP_EODN) {
		goto __362
	} /* Not a character type - internal error */

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR10
	return 0
	goto __363
__362:

	if !(repeat_max == uint32(1) && repeat_min == uint32(1)) {
		goto __364
	}
	goto END_REPEAT
__364:
	;

	op_type = uint32(OP_TYPESTAR - OP_STAR) // Use type opcodes
	mclength = uint32(0)                    // Not a character

	if !(int32(op_previous) == OP_PROP || int32(op_previous) == OP_NOTPROP) {
		goto __365
	}

	prop_type = int32(*(*uint8)(unsafe.Pointer(previous + 1)))
	prop_value = int32(*(*uint8)(unsafe.Pointer(previous + 2)))
	goto __366
__365:

	// Come here from just above with a character in mcbuffer/mclength.
OUTPUT_SINGLE_REPEAT:
	prop_type = libc.AssignInt32(&prop_value, -1)
__366:
	;

	// At this point, if prop_type == prop_value == -1 we either have a
	//         character in mcbuffer when mclength is greater than zero, or we have
	//         mclength zero, in which case there is a non-property character type in
	//         op_previous. If prop_type/value are not negative, we have a property
	//         character type in op_previous.

	oldcode = code  // Save where we were
	code = previous // Usually overwrite previous item

	// If the maximum is zero then the minimum must also be zero; Perl allows
	//         this case, so we do too - by simply omitting the item altogether.

	if !(repeat_max == uint32(0)) {
		goto __367
	}
	goto END_REPEAT
__367:
	;

	// Combine the op_type with the repeat_type

	repeat_type = repeat_type + op_type

	// A minimum of zero is handled either as the special case * or ?, or as
	//         an UPTO, with the maximum given.

	if !(repeat_min == uint32(0)) {
		goto __368
	}

	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __370
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_STAR + repeat_type)
	goto __371
__370:
	if !(repeat_max == uint32(1)) {
		goto __372
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_QUERY + repeat_type)
	goto __373
__372:

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_UPTO + repeat_type)
	*(*uint8)(unsafe.Pointer(code)) = uint8(repeat_max >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(repeat_max & uint32(255))
	code += uintptr(DIMM2_SIZE)
__373:
	;
__371:
	;
	goto __369
__368:
	if !(repeat_min == uint32(1)) {
		goto __374
	}

	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __376
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_PLUS + repeat_type)
	goto __377
__376:

	code = oldcode // Leave previous item in place
	if !(repeat_max == uint32(1)) {
		goto __378
	}
	goto END_REPEAT
__378:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_UPTO + repeat_type)
	*(*uint8)(unsafe.Pointer(code)) = uint8((repeat_max - uint32(1)) >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8((repeat_max - uint32(1)) & uint32(255))
	code += uintptr(DIMM2_SIZE)
__377:
	;
	goto __375
__374:

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_EXACT + op_type) // NB EXACT doesn't have repeat_type
	*(*uint8)(unsafe.Pointer(code)) = uint8(repeat_min >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(repeat_min & uint32(255))
	code += uintptr(DIMM2_SIZE)

	// Unless repeat_max equals repeat_min, fill in the data for EXACT,
	//           and then generate the second opcode. For a repeated Unicode property
	//           match, there are two extra values that define the required property,
	//           and mclength is set zero to indicate this.

	if !(repeat_max != repeat_min) {
		goto __379
	}

	if !(mclength > uint32(0)) {
		goto __380
	}

	libc.Xmemcpy(tls, code, bp+72, uint64(mclength*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(mclength)
	goto __381
__380:

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = op_previous
	if !(prop_type >= 0) {
		goto __382
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(prop_type)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(prop_value)
__382:
	;
__381:
	;

	// Now set up the following opcode

	if !(repeat_max == DMAX_REPEAT_COUNT+uint32(1)) {
		goto __383
	}
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_STAR + repeat_type)
	goto __384
__383:

	repeat_max = repeat_max - repeat_min
	if !(repeat_max == uint32(1)) {
		goto __385
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_QUERY + repeat_type)
	goto __386
__385:

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(OP_UPTO + repeat_type)
	*(*uint8)(unsafe.Pointer(code)) = uint8(repeat_max >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(repeat_max & uint32(255))
	code += uintptr(DIMM2_SIZE)
__386:
	;
__384:
	;
__379:
	;
__375:
	;
__369:
	;

	// Fill in the character or character type for the final opcode.

	if !(mclength > uint32(0)) {
		goto __387
	}

	libc.Xmemcpy(tls, code, bp+72, uint64(mclength*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(mclength)
	goto __388
__387:

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = op_previous
	if !(prop_type >= 0) {
		goto __389
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(prop_type)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(prop_value)
__389:
	;
__388:
	;
__363:
	;
	goto __267
__267:
	; // End of switch on different op_previous values

	// If the character following a repeat is '+', possessive_quantifier is
	//     TRUE. For some opcodes, there are special alternative opcodes for this
	//     case. For anything else, we wrap the entire repeated item inside OP_ONCE
	//     brackets. Logically, the '+' notation is just syntactic sugar, taken from
	//     Sun's Java package, but the special opcodes can optimize it.
	//
	//     Some (but not all) possessively repeated subpatterns have already been
	//     completely handled in the code just above. For them, possessive_quantifier
	//     is always FALSE at this stage. Note that the repeated item starts at
	//     tempcode, not at previous, which might be the first part of a string whose
	//     (former) last char we repeated.

	if !(possessive_quantifier != 0) {
		goto __390
	}

	// Possessifying an EXACT quantifier has no effect, so we can ignore it.
	//       However, QUERY, STAR, or UPTO may follow (for quantifiers such as {5,6},
	//       {5,}, or {5,10}). We skip over an EXACT item; if the length of what
	//       remains is greater than zero, there's a further opcode that can be
	//       handled. If not, do nothing, leaving the EXACT alone.

	switch int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */))))) {
	case OP_TYPEEXACT:
		goto __392

	// CHAR opcodes are used for exacts whose count is 1.

	case OP_CHAR:
		goto __393
	case OP_CHARI:
		goto __394
	case OP_NOT:
		goto __395
	case OP_NOTI:
		goto __396
	case OP_EXACT:
		goto __397
	case OP_EXACTI:
		goto __398
	case OP_NOTEXACT:
		goto __399
	case OP_NOTEXACTI:
		goto __400

	// For the class opcodes, the repeat operator appears at the end;
	//         adjust tempcode to point to it.

	case OP_CLASS:
		goto __401
	case OP_NCLASS:
		goto __402

	case OP_XCLASS:
		goto __403
	}
	goto __391

__392:
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(int32(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88))))]) + func() int32 {
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + 3))) == OP_PROP ||
			int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + 3))) == OP_NOTPROP {
			return 2
		}
		return 0
	}())
	goto __391

	// CHAR opcodes are used for exacts whose count is 1.

__393:
__394:
__395:
__396:
__397:
__398:
__399:
__400:
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */))))])
	if !(utf != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + libc.UintptrFromInt32(-1)))) >= 0xc0) {
		goto __404
	}
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(X_pcre2_utf8_table4[uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + libc.UintptrFromInt32(-1))))&0x3f])
__404:
	;
	goto __391

	// For the class opcodes, the repeat operator appears at the end;
	//         adjust tempcode to point to it.

__401:
__402:
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(uint64(1) + uint64(32)/uint64(unsafe.Sizeof(uint8(0))))
	goto __391

__403:
	*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)) + 2)))))
	goto __391
__391:
	;

	// If tempcode is equal to code (which points to the end of the repeated
	//       item), it means we have skipped an EXACT item but there is no following
	//       QUERY, STAR, or UPTO; the value of len will be 0, and we do nothing. In
	//       all other cases, tempcode will be pointing to the repeat opcode, and will
	//       be less than code, so the value of len will be greater than 0.

	len1 = int32((int64(code) - int64(*(*uintptr)(unsafe.Pointer(bp + 88)))) / 1)
	if !(len1 > 0) {
		goto __405
	}

	repcode = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)))))

	// There is a table for possessifying opcodes, all of which are less
	//         than OP_CALLOUT. A zero entry means there is no possessified version.
	//

	if !(repcode < OP_CALLOUT && int32(opcode_possessify[repcode]) > 0) {
		goto __406
	}
	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)))) = opcode_possessify[repcode]
	goto __407
__406:

	libc.Xmemmove(tls, *(*uintptr)(unsafe.Pointer(bp + 88))+uintptr(1)+uintptr(DLINK_SIZE), *(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)), uint64(len1*(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(1 + DLINK_SIZE)
	len1 = len1 + (1 + DLINK_SIZE)
	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)))) = OP_ONCE
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_KET
	*(*uint8)(unsafe.Pointer(code)) = uint8(len1 >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(len1 & 255)
	code += uintptr(DLINK_SIZE)
	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) + 1)) = uint8(len1 >> 8)
	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* tempcode */)) + 2)) = uint8(len1 & 255)
__407:
	;
__405:
	;
__390:
	;

	// We set the "follows varying string" flag for subsequently encountered
	//     reqcus if it isn't already set and we have just passed a varying length
	//     item.

END_REPEAT:
	*(*uint32)(unsafe.Pointer(cb + 276)) |= reqvary
	goto __12

	// ===================================================================
	// Handle a 32-bit data character with a value greater than META_END.

__67:
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4
	goto NORMAL_CHAR

	// ===============================================================
	// Handle a back reference by number, which is the meta argument. The
	//     pattern offsets for back references to group numbers less than 10 are held
	//     in a special vector, to avoid using more than two parsed pattern elements
	//     in 64-bit environments. We only need the offset to the first occurrence,
	//     because if that doesn't fail, subsequent ones will also be OK.

__68:
	if !(meta_arg < uint32(10)) {
		goto __408
	}
	offset = *(*uint64)(unsafe.Pointer(cb + 88 + uintptr(meta_arg)*8))
	goto __409
__408:
	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)
__409:
	;

	if !(meta_arg > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __410
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15 // Non-existent subpattern
	return 0
__410:
	;

	// Come here from named backref handling when the reference is to a
	//     single group (that is, not to a duplicated name). The back reference
	//     data will have already been updated. We must disable firstcu if not
	//     set, to cope with cases like (?=(\w+))\1: which would otherwise set ':'
	//     later.

HANDLE_SINGLE_REFERENCE:
	if !(firstcuflags == DREQ_UNSET) {
		goto __411
	}
	zerofirstcuflags = libc.AssignUint32(&firstcuflags, DREQ_NONE)
__411:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_CASELESS != uint32(0) {
			return OP_REFI
		}
		return OP_REF
	}()
	*(*uint8)(unsafe.Pointer(code)) = uint8(meta_arg >> 8)
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(meta_arg & uint32(255))
	code += uintptr(DIMM2_SIZE)

	// Update the map of back references, and keep the highest one. We
	//     could do this in parse_regex() for numerical back references, but not
	//     for named back references, because we don't know the numbers to which
	//     named back references refer. So we do it all in this function.

	*(*uint32)(unsafe.Pointer(cb + 252)) |= func() uint32 {
		if meta_arg < uint32(32) {
			return uint32(1) << meta_arg
		}
		return uint32(1)
	}()
	if !(meta_arg > (*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref) {
		goto __412
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ftop_backref = meta_arg
__412:
	;
	goto __12

	// ===============================================================
	// Handle recursion by inserting the number of the called group (which is
	//     the meta argument) after OP_RECURSE. At the end of compiling the pattern is
	//     scanned and these numbers are replaced by offsets within the pattern. It is
	//     done like this to avoid problems with forward references and adjusting
	//     offsets when groups are duplicated and moved (as discovered in previous
	//     implementations). Note that a recursion does not have a set first
	//     character.

__69:
	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4 * uintptr(2)

	if !(meta_arg > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __413
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR15 // Non-existent subpattern
	return 0
__413:
	;
HANDLE_NUMERICAL_RECURSION:
	*(*uint8)(unsafe.Pointer(code)) = OP_RECURSE
	*(*uint8)(unsafe.Pointer(code + 1)) = uint8(meta_arg >> 8)
	*(*uint8)(unsafe.Pointer(code + 2)) = uint8(meta_arg & uint32(255))
	code += uintptr(1 + DLINK_SIZE)
	groupsetfirstcu = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_recurse = DTRUE
	if !(firstcuflags == DREQ_UNSET) {
		goto __414
	}
	firstcuflags = DREQ_NONE
__414:
	;
	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	goto __12

	// ===============================================================
	// Handle capturing parentheses; the number is the meta argument.

__70:
	bravalue = OP_CBRA
	skipunits = uint32(DIMM2_SIZE)
	*(*uint8)(unsafe.Pointer(code + 3)) = uint8(meta_arg >> 8)
	*(*uint8)(unsafe.Pointer(code + 4)) = uint8(meta_arg & uint32(255))
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Flastcapture = meta_arg
	goto GROUP_PROCESS_NOTE_EMPTY

	// ===============================================================
	// Handle escape sequence items. For ones like \d, the ESC_values are
	//     arranged to be the same as the corresponding OP_values in the default case
	//     when PCRE2_UCP is not set (which is the only case in which they will appear
	//     here).
	//
	//     Note: \Q and \E are never seen here, as they were dealt with in
	//     parse_pattern(). Neither are numerical back references or recursions, which
	//     were turned into META_BACKREF or META_RECURSE items, respectively. \k and
	//     \g, when followed by names, are turned into META_BACKREF_BYNAME or
	//     META_RECURSE_BYNAME.

__71:

	// We can test for escape sequences that consume a character because their
	//     values lie between ESC_b and ESC_Z; this may have to change if any new ones
	//     are ever created. For these sequences, we disable the setting of a first
	//     character if it hasn't already been set.

	if !(meta_arg > ESC_b && meta_arg < ESC_Z) {
		goto __415
	}

	matched_char = DTRUE
	if !(firstcuflags == DREQ_UNSET) {
		goto __416
	}
	firstcuflags = DREQ_NONE
__416:
	;
__415:
	;

	// Set values to reset to if this is followed by a zero repeat.

	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags

	// If Unicode is not supported, \P and \p are not allowed and are
	//     faulted at parse time, so will never appear here.

	if !(meta_arg == ESC_P || meta_arg == ESC_p) {
		goto __417
	}

	ptype1 = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 96)), 4))) >> 16
	pdata1 = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96)))) & uint32(0xffff)

	// The special case of \p{Any} is compiled to OP_ALLANY so as to benefit
	//       from the auto-anchoring code.

	if !(meta_arg == ESC_p && ptype1 == uint32(DPT_ANY)) {
		goto __418
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_ALLANY
	goto __419
__418:

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if meta_arg == ESC_p {
			return OP_PROP
		}
		return OP_NOTPROP
	}()
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(ptype1)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(pdata1)
__419:
	;
	goto __12 // End META_ESCAPE
__417:
	;

	// \K is forbidden in lookarounds since 10.38 because that's what Perl has
	//     done. However, there's an option, in case anyone was relying on it.

	if !(int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fassert_depth) > 0 && meta_arg == ESC_K && (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fextra_options&DPCRE2_EXTRA_ALLOW_LOOKAROUND_BSK == uint32(0)) {
		goto __420
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR99
	return 0
__420:
	;

	// For the rest (including \X when Unicode is supported - if not it's
	//     faulted at parse time), the OP value is the escape value when PCRE2_UCP is
	//     not set; if it is set, these escapes do not show up here because they are
	//     converted into Unicode property tests in parse_regex(). Note that \b and \B
	//     do a one-character lookbehind, and \A also behaves as if it does.

	if !(meta_arg == ESC_C) {
		goto __421
	}
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_HASBKC)
__421:
	; // Record
	if !((meta_arg == ESC_b || meta_arg == ESC_B || meta_arg == ESC_A) && (*Tcompile_block_8)(unsafe.Pointer(cb)).Fmax_lookbehind == 0) {
		goto __422
	}
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Fmax_lookbehind = 1
__422:
	;

	// In non-UTF mode, and for both 32-bit modes, we turn \C into OP_ALLANY
	//     instead of OP_ANYBYTE so that it works in DFA mode and in lookbehinds.

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if !(utf != 0) && meta_arg == ESC_C {
			return OP_ALLANY
		}
		return uint8(meta_arg)
	}()
	goto __12 // End META_ESCAPE

	// ===================================================================
	// Handle an unrecognized meta value. A parsed pattern value less than
	//     META_END is a literal. Otherwise we have a problem.

__72:
	if !(meta >= DMETA_END) {
		goto __423
	}

	*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR89 // Internal error - unrecognized.
	return 0
__423:
	;

	// Handle a literal character. We come here by goto in the case of a
	//     32-bit, non-UTF character whose value is greater than META_END.

NORMAL_CHAR:
	meta = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)))) // Get the full 32 bits
NORMAL_CHAR_SET: // Character is already in meta
	matched_char = DTRUE

	// For caseless UTF or UCP mode, check whether this character has more than
	//     one other case. If so, generate a special OP_PROP item instead of OP_CHARI.
	//

	if !((utf != 0 || ucp != 0) && options&DPCRE2_CASELESS != uint32(0)) {
		goto __424
	}

	caseset = uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(meta)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(meta)%DUCD_BLOCK_SIZE])*12)).Fcaseset)
	if !(caseset != uint32(0)) {
		goto __425
	}

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = OP_PROP
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(DPT_CLIST)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = uint8(caseset)
	if !(firstcuflags == DREQ_UNSET) {
		goto __426
	}
	firstcuflags = libc.AssignUint32(&zerofirstcuflags, DREQ_NONE)
__426:
	;
	goto __12 // End handling this meta item
__425:
	;
__424:
	;

	// Caseful matches, or caseless and not one of the multicase characters. We
	//     come here by goto in the case of a positive class that contains only
	//     case-partners of a character with just two cases; matched_char has already
	//     been set TRUE and options fudged if necessary.

CLASS_CASELESS_CHAR:

	// Get the character's code units into mcbuffer, with the length in
	//     mclength. When not in UTF mode, the length is always 1.

	if !(utf != 0) {
		goto __427
	}
	mclength = X_pcre2_ord2utf_8(tls, meta, bp+72)
	goto __428
__427:

	mclength = uint32(1)
	*(*uint8)(unsafe.Pointer(bp + 72)) = uint8(meta)
__428:
	;

	// Generate the appropriate code

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&code, 1))) = func() uint8 {
		if options&DPCRE2_CASELESS != uint32(0) {
			return OP_CHARI
		}
		return OP_CHAR
	}()
	libc.Xmemcpy(tls, code, bp+72, uint64(mclength*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
	code += uintptr(mclength)

	// Remember if \r or \n were seen

	if !(int32(*(*uint8)(unsafe.Pointer(bp + 72))) == '\015' || int32(*(*uint8)(unsafe.Pointer(bp + 72))) == '\012') {
		goto __429
	}
	*(*uint32)(unsafe.Pointer(cb + 208)) |= uint32(DPCRE2_HASCRORLF)
__429:
	;

	// Set the first and required code units appropriately. If no previous
	//     first code unit, set it from this character, but revert to none on a zero
	//     repeat. Otherwise, leave the firstcu value alone, and don't change it on
	//     a zero repeat.

	if !(firstcuflags == DREQ_UNSET) {
		goto __430
	}

	zerofirstcuflags = DREQ_NONE
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags

	// If the character is more than one code unit long, we can set a single
	//       firstcu only if it is not to be matched caselessly. Multiple possible
	//       starting code units may be picked up later in the studying code.

	if !(mclength == uint32(1) || req_caseopt == uint32(0)) {
		goto __432
	}

	firstcu = uint32(*(*uint8)(unsafe.Pointer(bp + 72)))
	firstcuflags = req_caseopt
	if !(mclength != uint32(1)) {
		goto __434
	}

	reqcu = uint32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))
	reqcuflags = (*Tcompile_block_8)(unsafe.Pointer(cb)).Freq_varyopt
__434:
	;
	goto __433
__432:
	firstcuflags = libc.AssignUint32(&reqcuflags, DREQ_NONE)
__433:
	;
	goto __431
__430:

	zerofirstcu = firstcu
	zerofirstcuflags = firstcuflags
	zeroreqcu = reqcu
	zeroreqcuflags = reqcuflags
	if !(mclength == uint32(1) || req_caseopt == uint32(0)) {
		goto __435
	}

	reqcu = uint32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))
	reqcuflags = req_caseopt | (*Tcompile_block_8)(unsafe.Pointer(cb)).Freq_varyopt
__435:
	;
__431:
	;

	// If caselessness was temporarily instated, reset it.

	if !(reset_caseful != 0) {
		goto __436
	}

	options = options & libc.CplUint32(DPCRE2_CASELESS)
	req_caseopt = uint32(0)
	reset_caseful = DFALSE
__436:
	;

	goto __12 // End literal character handling
__12:
	; // End of big switch
	goto __2
__2:
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pptr */)) += 4
	goto __1
	goto __3
__3:
	;
	return int32(0) // End of big loop

	// Control never reaches here.
}

// ************************************************
//
//   Compile regex: a sequence of alternatives    *
//

// On entry, pptr is pointing past the bracket meta, but on return it points to
// the closing bracket or META_END. The code variable is pointing at the code unit
// into which the BRA operator has been stored. This function is used during the
// pre-compile phase when we are trying to find out the amount of memory needed,
// as well as during the real compile phase. The value of lengthptr distinguishes
// the two phases.
//
// Arguments:
//   options           option bits, including any changes for this subpattern
//   codeptr           -> the address of the current code pointer
//   pptrptr           -> the address of the current parsed pattern pointer
//   errorcodeptr      -> pointer to error code variable
//   skipunits         skip this many code units at start (for brackets and OP_COND)
//   firstcuptr        place to put the first required code unit
//   firstcuflagsptr   place to put the first code unit flags
//   reqcuptr          place to put the last required code unit
//   reqcuflagsptr     place to put the last required code unit flags
//   bcptr             pointer to the chain of currently open branches
//   cb                points to the data block with tables pointers etc.
//   lengthptr         NULL during the real compile phase
//                     points to length accumulator during pre-compile phase
//
// Returns:            0 There has been an error
//                    +1 Success, this group must match at least one character
//                    -1 Success, this group may match an empty string

func compile_regex(tls *libc.TLS, options uint32, codeptr uintptr, pptrptr uintptr, errorcodeptr uintptr, skipunits uint32, firstcuptr uintptr, firstcuflagsptr uintptr, reqcuptr uintptr, reqcuflagsptr uintptr, bcptr uintptr, cb uintptr, lengthptr uintptr) int32 { /* pcre2_compile.c:8097:1: */
	bp := tls.Alloc(80)
	defer tls.Free(80)
	*(*uint32)(unsafe.Pointer(bp + 16)) = options

	*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) = *(*uintptr)(unsafe.Pointer(codeptr))
	var last_branch uintptr = *(*uintptr)(unsafe.Pointer(bp + 24 /* code */))
	var start_bracket uintptr = *(*uintptr)(unsafe.Pointer(bp + 24 /* code */))
	var lookbehind int32
	// var capitem Topen_capitem at bp, 16

	var capnumber int32 = 0
	var okreturn int32 = 1
	*(*uintptr)(unsafe.Pointer(bp + 32 /* pptr */)) = *(*uintptr)(unsafe.Pointer(pptrptr))
	var firstcu uint32
	var reqcu uint32
	var lookbehindlength uint32
	var firstcuflags uint32
	var reqcuflags uint32
	// var branchfirstcu uint32 at bp+40, 4

	// var branchreqcu uint32 at bp+48, 4

	// var branchfirstcuflags uint32 at bp+44, 4

	// var branchreqcuflags uint32 at bp+52, 4

	// var length uint64 at bp+72, 8

	// var bc Tbranch_chain_8 at bp+56, 16

	// If set, call the external function that checks for stack availability.

	if (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fstack_guard != uintptr(0) && (*struct {
		f func(*libc.TLS, uint32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fstack_guard})).f(tls, uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fparens_depth), (*Tpcre2_real_compile_context_8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fcx)).Fstack_guard_data) != 0 {
		*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR33
		return 0
	}

	// Miscellaneous initialization

	(*Tbranch_chain_8)(unsafe.Pointer(bp + 56 /* &bc */)).Fouter = bcptr
	(*Tbranch_chain_8)(unsafe.Pointer(bp + 56 /* &bc */)).Fcurrent_branch = *(*uintptr)(unsafe.Pointer(bp + 24 /* code */))

	firstcu = libc.AssignUint32(&reqcu, uint32(0))
	firstcuflags = libc.AssignUint32(&reqcuflags, DREQ_UNSET)

	// Accumulate the length for use in the pre-compile phase. Start with the
	// length of the BRA and KET and any extra code units that are required at the
	// beginning. We accumulate in a local variable to save frequent testing of
	// lengthptr for NULL. We cannot do this by looking at the value of 'code' at the
	// start and end of each alternative, because compiled items are discarded during
	// the pre-compile phase so that the workspace is not exceeded.

	*(*uint64)(unsafe.Pointer(bp + 72 /* length */)) = uint64(uint32(2+2*DLINK_SIZE) + skipunits)

	// Remember if this is a lookbehind assertion, and if it is, save its length
	// and skip over the pattern offset.

	lookbehind = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == OP_ASSERTBACK || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == OP_ASSERTBACK_NOT || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == OP_ASSERTBACK_NA)

	if lookbehind != 0 {
		lookbehindlength = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + libc.UintptrFromInt32(-1)*4)) & 0x0000ffff
		*(*uintptr)(unsafe.Pointer(bp + 32 /* pptr */)) += 4 * uintptr(DSIZEOFFSET)
	} else {
		lookbehindlength = uint32(0)
	}

	// If this is a capturing subpattern, add to the chain of open capturing items
	// so that we can detect them if (*ACCEPT) is encountered. Note that only OP_CBRA
	// need be tested here; changing this opcode to one of its variants, e.g.
	// OP_SCBRAPOS, happens later, after the group has been compiled.

	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) == OP_CBRA {
		capnumber = int32(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 4)))))
		(*Topen_capitem)(unsafe.Pointer(bp /* &capitem */)).Fnumber = uint16(capnumber)
		(*Topen_capitem)(unsafe.Pointer(bp /* &capitem */)).Fnext = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps
		(*Topen_capitem)(unsafe.Pointer(bp /* &capitem */)).Fassert_depth = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fassert_depth
		(*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps = bp /* &capitem */
	}

	// Offset is set zero to mark that this bracket is still open

	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 1)) = uint8(int32(0) >> 8)
	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 2)) = uint8(0 & 255)
	*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) += uintptr(uint32(1+DLINK_SIZE) + skipunits)

	// Loop for each alternative branch

	for {
		var branch_return int32

		// Insert OP_REVERSE if this is as lookbehind assertion.

		if lookbehind != 0 && lookbehindlength > uint32(0) {
			*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)), 1))) = OP_REVERSE
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)))) = uint8(lookbehindlength >> 8)
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 1)) = uint8(lookbehindlength & uint32(255))
			*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) += uintptr(DLINK_SIZE)
			*(*uint64)(unsafe.Pointer(bp + 72 /* length */)) += uint64(1 + DLINK_SIZE)
		}

		// Now compile the branch; in the pre-compile phase its length gets added
		//   into the length.

		if libc.AssignInt32(&branch_return, compile_branch(tls, bp+16, bp+24, bp+32, errorcodeptr, bp+40,
			bp+44, bp+48, bp+52, bp+56,
			cb, func() uintptr {
				if lengthptr == uintptr(0) {
					return uintptr(0)
				}
				return bp + 72
			}())) == 0 {
			return 0
		}

		// If a branch can match an empty string, so can the whole group.

		if branch_return < 0 {
			okreturn = -1
		}

		// In the real compile phase, there is some post-processing to be done.

		if lengthptr == uintptr(0) {
			// If this is the first branch, the firstcu and reqcu values for the
			//     branch become the values for the regex.

			if int32(*(*uint8)(unsafe.Pointer(last_branch))) != OP_ALT {
				firstcu = *(*uint32)(unsafe.Pointer(bp + 40 /* branchfirstcu */))
				firstcuflags = *(*uint32)(unsafe.Pointer(bp + 44 /* branchfirstcuflags */))
				reqcu = *(*uint32)(unsafe.Pointer(bp + 48 /* branchreqcu */))
				reqcuflags = *(*uint32)(unsafe.Pointer(bp + 52 /* branchreqcuflags */))
			} else {
				// If we previously had a firstcu, but it doesn't match the new branch,
				//       we have to abandon the firstcu for the regex, but if there was
				//       previously no reqcu, it takes on the value of the old firstcu.

				if firstcuflags != *(*uint32)(unsafe.Pointer(bp + 44)) || firstcu != *(*uint32)(unsafe.Pointer(bp + 40)) {
					if firstcuflags < DREQ_NONE {
						if reqcuflags >= DREQ_NONE {
							reqcu = firstcu
							reqcuflags = firstcuflags
						}
					}
					firstcuflags = DREQ_NONE
				}

				// If we (now or from before) have no firstcu, a firstcu from the
				//       branch becomes a reqcu if there isn't a branch reqcu.

				if firstcuflags >= DREQ_NONE && *(*uint32)(unsafe.Pointer(bp + 44)) < DREQ_NONE && *(*uint32)(unsafe.Pointer(bp + 52)) >= DREQ_NONE {
					*(*uint32)(unsafe.Pointer(bp + 48 /* branchreqcu */)) = *(*uint32)(unsafe.Pointer(bp + 40 /* branchfirstcu */))
					*(*uint32)(unsafe.Pointer(bp + 52 /* branchreqcuflags */)) = *(*uint32)(unsafe.Pointer(bp + 44 /* branchfirstcuflags */))
				}

				// Now ensure that the reqcus match

				if reqcuflags&libc.CplUint32(DREQ_VARY) != *(*uint32)(unsafe.Pointer(bp + 52))&libc.CplUint32(DREQ_VARY) || reqcu != *(*uint32)(unsafe.Pointer(bp + 48)) {
					reqcuflags = DREQ_NONE
				} else {
					reqcu = *(*uint32)(unsafe.Pointer(bp + 48 /* branchreqcu */))
					reqcuflags = reqcuflags | *(*uint32)(unsafe.Pointer(bp + 52)) // To "or" REQ_VARY if present
				}
			}
		}

		// Handle reaching the end of the expression, either ')' or end of pattern.
		//   In the real compile phase, go back through the alternative branches and
		//   reverse the chain of offsets, with the field in the BRA item now becoming an
		//   offset to the first alternative. If there are no alternatives, it points to
		//   the end of the group. The length in the terminating ket is always the length
		//   of the whole bracketed item. Return leaving the pointer at the terminating
		//   char.

		if *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))&0xffff0000 != DMETA_ALT {
			if lengthptr == uintptr(0) {
				var branch_length uint64 = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 24))) - int64(last_branch)) / 1)
				for __ccgo := true; __ccgo; __ccgo = branch_length > uint64(0) {
					var prev_length uint64 = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(last_branch + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(last_branch + 2)))))
					*(*uint8)(unsafe.Pointer(last_branch + 1)) = uint8(branch_length >> 8)
					*(*uint8)(unsafe.Pointer(last_branch + 2)) = uint8(branch_length & uint64(255))
					branch_length = prev_length
					last_branch -= uintptr(branch_length)
				}
			}

			// Fill in the ket

			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)))) = OP_KET
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 1)) = uint8(int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(start_bracket))/1) >> 8)
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 2)) = uint8(int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(start_bracket))/1) & 255)
			*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) += uintptr(1 + DLINK_SIZE)

			// If it was a capturing subpattern, remove the block from the chain.

			if capnumber > 0 {
				(*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps = (*Topen_capitem)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fopen_caps)).Fnext
			}

			// Set values to pass back

			*(*uintptr)(unsafe.Pointer(codeptr)) = *(*uintptr)(unsafe.Pointer(bp + 24 /* code */))
			*(*uintptr)(unsafe.Pointer(pptrptr)) = *(*uintptr)(unsafe.Pointer(bp + 32 /* pptr */))
			*(*uint32)(unsafe.Pointer(firstcuptr)) = firstcu
			*(*uint32)(unsafe.Pointer(firstcuflagsptr)) = firstcuflags
			*(*uint32)(unsafe.Pointer(reqcuptr)) = reqcu
			*(*uint32)(unsafe.Pointer(reqcuflagsptr)) = reqcuflags
			if lengthptr != uintptr(0) {
				if uint64(0x7fffffff-20)-*(*uint64)(unsafe.Pointer(lengthptr)) < *(*uint64)(unsafe.Pointer(bp + 72)) {
					*(*int32)(unsafe.Pointer(errorcodeptr)) = ERR20
					return 0
				}
				*(*uint64)(unsafe.Pointer(lengthptr)) += *(*uint64)(unsafe.Pointer(bp + 72))
			}
			return okreturn
		}

		// Another branch follows. In the pre-compile phase, we can move the code
		//   pointer back to where it was for the start of the first branch. (That is,
		//   pretend that each branch is the only one.)
		//
		//   In the real compile phase, insert an ALT node. Its length field points back
		//   to the previous branch while the bracket remains open. At the end the chain
		//   is reversed. It's done like this so that the start of the bracket has a
		//   zero offset until it is closed, making it possible to detect recursion.

		if lengthptr != uintptr(0) {
			*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) = *(*uintptr)(unsafe.Pointer(codeptr)) + uintptr(1) + uintptr(DLINK_SIZE) + uintptr(skipunits)
			*(*uint64)(unsafe.Pointer(bp + 72 /* length */)) += uint64(1 + DLINK_SIZE)
		} else {
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)))) = OP_ALT
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 1)) = uint8(int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(last_branch))/1) >> 8)
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) + 2)) = uint8(int32((int64(*(*uintptr)(unsafe.Pointer(bp + 24)))-int64(last_branch))/1) & 255)
			(*Tbranch_chain_8)(unsafe.Pointer(bp + 56 /* &bc */)).Fcurrent_branch = libc.AssignUintptr(&last_branch, *(*uintptr)(unsafe.Pointer(bp + 24 /* code */)))
			*(*uintptr)(unsafe.Pointer(bp + 24 /* code */)) += uintptr(1 + DLINK_SIZE)
		}

		// Set the lookbehind length (if not in a lookbehind the value will be zero)
		//   and then advance past the vertical bar.

		lookbehindlength = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))) & 0x0000ffff
		*(*uintptr)(unsafe.Pointer(bp + 32 /* pptr */)) += 4
	}
	return int32(0)
	// Control never reaches here
}

// ************************************************
//
//          Check for anchored pattern            *
//

// Try to find out if this is an anchored regular expression. Consider each
// alternative branch. If they all start with OP_SOD or OP_CIRC, or with a bracket
// all of whose alternatives start with OP_SOD or OP_CIRC (recurse ad lib), then
// it's anchored. However, if this is a multiline pattern, then only OP_SOD will
// be found, because ^ generates OP_CIRCM in that mode.
//
// We can also consider a regex to be anchored if OP_SOM starts all its branches.
// This is the code for \G, which means "match at start of match position, taking
// into account the match offset".
//
// A branch is also implicitly anchored if it starts with .* and DOTALL is set,
// because that will try the rest of the pattern at all possible matching points,
// so there is no point trying again.... er ....
//
// .... except when the .* appears inside capturing parentheses, and there is a
// subsequent back reference to those parentheses. We haven't enough information
// to catch that case precisely.
//
// At first, the best we could do was to detect when .* was in capturing brackets
// and the highest back reference was greater than or equal to that level.
// However, by keeping a bitmap of the first 31 back references, we can catch some
// of the more common cases more precisely.
//
// ... A second exception is when the .* appears inside an atomic group, because
// this prevents the number of characters it matches from being adjusted.
//
// Arguments:
//   code           points to start of the compiled pattern
//   bracket_map    a bitmap of which brackets we are inside while testing; this
//                    handles up to substring 31; after that we just have to take
//                    the less precise approach
//   cb             points to the compile data block
//   atomcount      atomic group level
//   inassert       TRUE if in an assertion
//
// Returns:     TRUE or FALSE

func is_anchored(tls *libc.TLS, code uintptr, bracket_map uint32, cb uintptr, atomcount int32, inassert int32) int32 { /* pcre2_compile.c:8396:1: */
	for __ccgo := true; __ccgo; __ccgo = int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT {
		var scode uintptr = first_significant_code(tls,
			code+uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(code))]), DFALSE)
		var op int32 = int32(*(*uint8)(unsafe.Pointer(scode)))

		// Non-capturing brackets

		if op == OP_BRA || op == OP_BRAPOS || op == OP_SBRA || op == OP_SBRAPOS {
			if !(is_anchored(tls, scode, bracket_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_CBRA || op == OP_CBRAPOS || op == OP_SCBRA || op == OP_SCBRAPOS {
			var n int32 = int32(uint32(int32(*(*uint8)(unsafe.Pointer(scode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(scode + 4)))))
			var new_map uint32 = bracket_map | func() uint32 {
				if n < 32 {
					return uint32(1) << n
				}
				return uint32(1)
			}()
			if !(is_anchored(tls, scode, new_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_ASSERT || op == OP_ASSERT_NA {
			if !(is_anchored(tls, scode, bracket_map, cb, atomcount, DTRUE) != 0) {
				return DFALSE
			}
		} else if op == OP_COND || op == OP_SCOND {
			if int32(*(*uint8)(unsafe.Pointer(scode + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(scode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(scode + 2)))))))) != OP_ALT {
				return DFALSE
			}
			if !(is_anchored(tls, scode, bracket_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_ONCE {
			if !(is_anchored(tls, scode, bracket_map, cb, atomcount+1, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_TYPESTAR || op == OP_TYPEMINSTAR || op == OP_TYPEPOSSTAR {
			if int32(*(*uint8)(unsafe.Pointer(scode + 1))) != OP_ALLANY || bracket_map&(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbackref_map != uint32(0) || atomcount > 0 || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_pruneorskip != 0 || inassert != 0 || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_NO_DOTSTAR_ANCHOR != uint32(0) {
				return DFALSE
			}
		} else if op != OP_SOD && op != OP_SOM && op != OP_CIRC {
			return DFALSE
		}

		code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	} // Loop for each alternative
	return DTRUE
}

// ************************************************
//
//         Check for starting with ^ or .*        *
//

// This is called to find out if every branch starts with ^ or .* so that
// "first char" processing can be done to speed things up in multiline
// matching and for non-DOTALL patterns that start with .* (which must start at
// the beginning or after \n). As in the case of is_anchored() (see above), we
// have to take account of back references to capturing brackets that contain .*
// because in that case we can't make the assumption. Also, the appearance of .*
// inside atomic brackets or in an assertion, or in a pattern that contains *PRUNE
// or *SKIP does not count, because once again the assumption no longer holds.
//
// Arguments:
//   code           points to start of the compiled pattern or a group
//   bracket_map    a bitmap of which brackets we are inside while testing; this
//                    handles up to substring 31; after that we just have to take
//                    the less precise approach
//   cb             points to the compile data
//   atomcount      atomic group level
//   inassert       TRUE if in an assertion
//
// Returns:         TRUE or FALSE

func is_startline(tls *libc.TLS, code uintptr, bracket_map uint32, cb uintptr, atomcount int32, inassert int32) int32 { /* pcre2_compile.c:8501:1: */
	for __ccgo := true; __ccgo; __ccgo = int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT {
		var scode uintptr = first_significant_code(tls,
			code+uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(code))]), DFALSE)
		var op int32 = int32(*(*uint8)(unsafe.Pointer(scode)))

		// If we are at the start of a conditional assertion group, *both* the
		//    conditional assertion *and* what follows the condition must satisfy the test
		//    for start of line. Other kinds of condition fail. Note that there may be an
		//    auto-callout at the start of a condition.

		if op == OP_COND {
			scode += uintptr(1 + DLINK_SIZE)

			if int32(*(*uint8)(unsafe.Pointer(scode))) == OP_CALLOUT {
				scode += uintptr(X_pcre2_OP_lengths_8[OP_CALLOUT])
			} else if int32(*(*uint8)(unsafe.Pointer(scode))) == OP_CALLOUT_STR {
				scode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(scode + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(scode + 6)))))
			}

			switch int32(*(*uint8)(unsafe.Pointer(scode))) {
			case OP_CREF:
				fallthrough
			case OP_DNCREF:
				fallthrough
			case OP_RREF:
				fallthrough
			case OP_DNRREF:
				fallthrough
			case OP_FAIL:
				fallthrough
			case OP_FALSE:
				fallthrough
			case OP_TRUE:
				return DFALSE
				fallthrough

			default: // Assertion
				if !(is_startline(tls, scode, bracket_map, cb, atomcount, DTRUE) != 0) {
					return DFALSE
				}
				for __ccgo1 := true; __ccgo1; __ccgo1 = int32(*(*uint8)(unsafe.Pointer(scode))) == OP_ALT {
					scode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(scode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(scode + 2)))))
				}
				scode += uintptr(1 + DLINK_SIZE)
				break
			}
			scode = first_significant_code(tls, scode, DFALSE)
			op = int32(*(*uint8)(unsafe.Pointer(scode)))
		}

		// Non-capturing brackets

		if op == OP_BRA || op == OP_BRAPOS || op == OP_SBRA || op == OP_SBRAPOS {
			if !(is_startline(tls, scode, bracket_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_CBRA || op == OP_CBRAPOS || op == OP_SCBRA || op == OP_SCBRAPOS {
			var n int32 = int32(uint32(int32(*(*uint8)(unsafe.Pointer(scode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(scode + 4)))))
			var new_map uint32 = bracket_map | func() uint32 {
				if n < 32 {
					return uint32(1) << n
				}
				return uint32(1)
			}()
			if !(is_startline(tls, scode, new_map, cb, atomcount, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_ASSERT || op == OP_ASSERT_NA {
			if !(is_startline(tls, scode, bracket_map, cb, atomcount, DTRUE) != 0) {
				return DFALSE
			}
		} else if op == OP_ONCE {
			if !(is_startline(tls, scode, bracket_map, cb, atomcount+1, inassert) != 0) {
				return DFALSE
			}
		} else if op == OP_TYPESTAR || op == OP_TYPEMINSTAR || op == OP_TYPEPOSSTAR {
			if int32(*(*uint8)(unsafe.Pointer(scode + 1))) != OP_ANY || bracket_map&(*Tcompile_block_8)(unsafe.Pointer(cb)).Fbackref_map != uint32(0) || atomcount > 0 || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fhad_pruneorskip != 0 || inassert != 0 || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_NO_DOTSTAR_ANCHOR != uint32(0) {
				return DFALSE
			}
		} else if op != OP_CIRC && op != OP_CIRCM {
			return DFALSE
		}

		// Move on to the next alternative

		code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	} // Loop for each alternative
	return DTRUE
}

// ************************************************
//
//   Scan compiled regex for recursion reference  *
//

// This function scans through a compiled pattern until it finds an instance of
// OP_RECURSE.
//
// Arguments:
//   code        points to start of expression
//   utf         TRUE in UTF mode
//
// Returns:      pointer to the opcode for OP_RECURSE, or NULL if not found

func find_recurse(tls *libc.TLS, code uintptr, utf int32) uintptr { /* pcre2_compile.c:8623:1: */
	for {
		var c uint8 = *(*uint8)(unsafe.Pointer(code))
		if int32(c) == OP_END {
			return uintptr(0)
		}
		if int32(c) == OP_RECURSE {
			return code
		}

		// XCLASS is used for classes that cannot be represented just by a bit map.
		//   This includes negated single high-valued characters. CALLOUT_STR is used for
		//   callouts with string arguments. In both cases the length in the table is
		//   zero; the actual length is stored in the compiled code.

		if int32(c) == OP_XCLASS {
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
		} else if int32(c) == OP_CALLOUT_STR {
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 6)))))
		} else {
			switch int32(c) {
			case OP_TYPESTAR:
				fallthrough
			case OP_TYPEMINSTAR:
				fallthrough
			case OP_TYPEPLUS:
				fallthrough
			case OP_TYPEMINPLUS:
				fallthrough
			case OP_TYPEQUERY:
				fallthrough
			case OP_TYPEMINQUERY:
				fallthrough
			case OP_TYPEPOSSTAR:
				fallthrough
			case OP_TYPEPOSPLUS:
				fallthrough
			case OP_TYPEPOSQUERY:
				if int32(*(*uint8)(unsafe.Pointer(code + 1))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(code + 1))) == OP_NOTPROP {
					code += uintptr(2)
				}
				break
				fallthrough

			case OP_TYPEPOSUPTO:
				fallthrough
			case OP_TYPEUPTO:
				fallthrough
			case OP_TYPEMINUPTO:
				fallthrough
			case OP_TYPEEXACT:
				if int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_NOTPROP {
					code += uintptr(2)
				}
				break
				fallthrough

			case OP_MARK:
				fallthrough
			case OP_COMMIT_ARG:
				fallthrough
			case OP_PRUNE_ARG:
				fallthrough
			case OP_SKIP_ARG:
				fallthrough
			case OP_THEN_ARG:
				code += uintptr(*(*uint8)(unsafe.Pointer(code + 1)))
				break
			}

			// Add in the fixed length from the table

			code += uintptr(X_pcre2_OP_lengths_8[c])

			// In UTF-8 and UTF-16 modes, opcodes that are followed by a character may
			//     be followed by a multi-unit character. The length in the table is a
			//     minimum, so we have to arrange to skip the extra units.

			if utf != 0 {
				switch int32(c) {
				case OP_CHAR:
					fallthrough
				case OP_CHARI:
					fallthrough
				case OP_NOT:
					fallthrough
				case OP_NOTI:
					fallthrough
				case OP_EXACT:
					fallthrough
				case OP_EXACTI:
					fallthrough
				case OP_NOTEXACT:
					fallthrough
				case OP_NOTEXACTI:
					fallthrough
				case OP_UPTO:
					fallthrough
				case OP_UPTOI:
					fallthrough
				case OP_NOTUPTO:
					fallthrough
				case OP_NOTUPTOI:
					fallthrough
				case OP_MINUPTO:
					fallthrough
				case OP_MINUPTOI:
					fallthrough
				case OP_NOTMINUPTO:
					fallthrough
				case OP_NOTMINUPTOI:
					fallthrough
				case OP_POSUPTO:
					fallthrough
				case OP_POSUPTOI:
					fallthrough
				case OP_NOTPOSUPTO:
					fallthrough
				case OP_NOTPOSUPTOI:
					fallthrough
				case OP_STAR:
					fallthrough
				case OP_STARI:
					fallthrough
				case OP_NOTSTAR:
					fallthrough
				case OP_NOTSTARI:
					fallthrough
				case OP_MINSTAR:
					fallthrough
				case OP_MINSTARI:
					fallthrough
				case OP_NOTMINSTAR:
					fallthrough
				case OP_NOTMINSTARI:
					fallthrough
				case OP_POSSTAR:
					fallthrough
				case OP_POSSTARI:
					fallthrough
				case OP_NOTPOSSTAR:
					fallthrough
				case OP_NOTPOSSTARI:
					fallthrough
				case OP_PLUS:
					fallthrough
				case OP_PLUSI:
					fallthrough
				case OP_NOTPLUS:
					fallthrough
				case OP_NOTPLUSI:
					fallthrough
				case OP_MINPLUS:
					fallthrough
				case OP_MINPLUSI:
					fallthrough
				case OP_NOTMINPLUS:
					fallthrough
				case OP_NOTMINPLUSI:
					fallthrough
				case OP_POSPLUS:
					fallthrough
				case OP_POSPLUSI:
					fallthrough
				case OP_NOTPOSPLUS:
					fallthrough
				case OP_NOTPOSPLUSI:
					fallthrough
				case OP_QUERY:
					fallthrough
				case OP_QUERYI:
					fallthrough
				case OP_NOTQUERY:
					fallthrough
				case OP_NOTQUERYI:
					fallthrough
				case OP_MINQUERY:
					fallthrough
				case OP_MINQUERYI:
					fallthrough
				case OP_NOTMINQUERY:
					fallthrough
				case OP_NOTMINQUERYI:
					fallthrough
				case OP_POSQUERY:
					fallthrough
				case OP_POSQUERYI:
					fallthrough
				case OP_NOTPOSQUERY:
					fallthrough
				case OP_NOTPOSQUERYI:
					if int32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1)))) >= 0xc0 {
						code += uintptr(X_pcre2_utf8_table4[uint32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))&0x3f])
					}
					break
				}
			}
		}
	}
	return uintptr(0)
}

// ************************************************
//
//    Check for asserted fixed first code unit    *
//

// During compilation, the "first code unit" settings from forward assertions
// are discarded, because they can cause conflicts with actual literals that
// follow. However, if we end up without a first code unit setting for an
// unanchored pattern, it is worth scanning the regex to see if there is an
// initial asserted first code unit. If all branches start with the same asserted
// code unit, or with a non-conditional bracket all of whose alternatives start
// with the same asserted code unit (recurse ad lib), then we return that code
// unit, with the flags set to zero or REQ_CASELESS; otherwise return zero with
// REQ_NONE in the flags.
//
// Arguments:
//   code       points to start of compiled pattern
//   flags      points to the first code unit flags
//   inassert   non-zero if in an assertion
//
// Returns:     the fixed first code unit, or 0 with REQ_NONE in flags

func find_firstassertedcu(tls *libc.TLS, code uintptr, flags uintptr, inassert uint32) uint32 { /* pcre2_compile.c:8779:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var c uint32 = uint32(0)
	var cflags uint32 = DREQ_NONE

	*(*uint32)(unsafe.Pointer(flags)) = DREQ_NONE
	for __ccgo := true; __ccgo; __ccgo = int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT {
		var d uint32
		// var dflags uint32 at bp, 4

		var xl int32
		if int32(*(*uint8)(unsafe.Pointer(code))) == OP_CBRA || int32(*(*uint8)(unsafe.Pointer(code))) == OP_SCBRA || int32(*(*uint8)(unsafe.Pointer(code))) == OP_CBRAPOS || int32(*(*uint8)(unsafe.Pointer(code))) == OP_SCBRAPOS {
			xl = DIMM2_SIZE
		} else {
			xl = 0
		}
		var scode uintptr = first_significant_code(tls, code+uintptr(1)+uintptr(DLINK_SIZE)+uintptr(xl), DTRUE)
		var op uint8 = *(*uint8)(unsafe.Pointer(scode))

		switch int32(op) {
		default:
			return uint32(0)

		case OP_BRA:
			fallthrough
		case OP_BRAPOS:
			fallthrough
		case OP_CBRA:
			fallthrough
		case OP_SCBRA:
			fallthrough
		case OP_CBRAPOS:
			fallthrough
		case OP_SCBRAPOS:
			fallthrough
		case OP_ASSERT:
			fallthrough
		case OP_ASSERT_NA:
			fallthrough
		case OP_ONCE:
			fallthrough
		case OP_SCRIPT_RUN:
			d = find_firstassertedcu(tls, scode, bp, inassert+func() uint32 {
				if int32(op) == OP_ASSERT || int32(op) == OP_ASSERT_NA {
					return uint32(1)
				}
				return uint32(0)
			}())
			if *(*uint32)(unsafe.Pointer(bp)) >= DREQ_NONE {
				return uint32(0)
			}
			if cflags >= DREQ_NONE {
				c = d
				cflags = *(*uint32)(unsafe.Pointer(bp /* dflags */))
			} else if c != d || cflags != *(*uint32)(unsafe.Pointer(bp)) {
				return uint32(0)
			}
			break

		case OP_EXACT:
			scode += uintptr(DIMM2_SIZE)
			fallthrough
		// Fall through

		case OP_CHAR:
			fallthrough
		case OP_PLUS:
			fallthrough
		case OP_MINPLUS:
			fallthrough
		case OP_POSPLUS:
			if inassert == uint32(0) {
				return uint32(0)
			}
			if cflags >= DREQ_NONE {
				c = uint32(*(*uint8)(unsafe.Pointer(scode + 1)))
				cflags = uint32(0)
			} else if c != uint32(*(*uint8)(unsafe.Pointer(scode + 1))) {
				return uint32(0)
			}
			break

		case OP_EXACTI:
			scode += uintptr(DIMM2_SIZE)
			fallthrough
		// Fall through

		case OP_CHARI:
			fallthrough
		case OP_PLUSI:
			fallthrough
		case OP_MINPLUSI:
			fallthrough
		case OP_POSPLUSI:
			if inassert == uint32(0) {
				return uint32(0)
			}

			// If the character is more than one code unit long, we cannot set its
			//      first code unit when matching caselessly. Later scanning may pick up
			//      multiple code units.

			if int32(*(*uint8)(unsafe.Pointer(scode + 1))) >= 0x80 {
				return uint32(0)
			}

			if cflags >= DREQ_NONE {
				c = uint32(*(*uint8)(unsafe.Pointer(scode + 1)))
				cflags = DREQ_CASELESS
			} else if c != uint32(*(*uint8)(unsafe.Pointer(scode + 1))) {
				return uint32(0)
			}
			break
		}

		code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	}

	*(*uint32)(unsafe.Pointer(flags)) = cflags
	return c
}

// ************************************************
//
//     Add an entry to the name/number table      *
//

// This function is called between compiling passes to add an entry to the
// name/number table, maintaining alphabetical order. Checking for permitted
// and forbidden duplicates has already been done.
//
// Arguments:
//   cb           the compile data block
//   name         the name to add
//   length       the length of the name
//   groupno      the group number
//   tablecount   the count of names in the table so far
//
// Returns:       nothing

func add_name_to_table(tls *libc.TLS, cb uintptr, name uintptr, length int32, groupno uint32, tablecount uint32) { /* pcre2_compile.c:8884:1: */
	var i uint32
	var slot uintptr = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_table

	for i = uint32(0); i < tablecount; i++ {
		var crc int32 = libc.Xmemcmp(tls, name, slot+uintptr(DIMM2_SIZE), uint64(length*(DPCRE2_CODE_UNIT_WIDTH/8)))
		if crc == 0 && int32(*(*uint8)(unsafe.Pointer(slot + uintptr(DIMM2_SIZE+length)))) != 0 {
			crc = -1
		} // Current name is a substring

		// Make space in the table and break the loop for an earlier name. For a
		//   duplicate or later name, carry on. We do this for duplicates so that in the
		//   simple case (when ?(| is not used) they are in order of their numbers. In all
		//   cases they are in the order in which they appear in the pattern.

		if crc < 0 {
			libc.Xmemmove(tls, slot+uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size), slot,
				uint64((tablecount-i)*uint32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
			break
		}

		// Continue the loop for a later or duplicate name

		slot += uintptr((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)
	}

	*(*uint8)(unsafe.Pointer(slot)) = uint8(groupno >> 8)
	*(*uint8)(unsafe.Pointer(slot + 1)) = uint8(groupno & uint32(255))
	libc.Xmemcpy(tls, slot+uintptr(DIMM2_SIZE), name, uint64(length*(DPCRE2_CODE_UNIT_WIDTH/8)))

	// Add a terminating zero and fill the rest of the slot with zeroes so that
	// the memory is all initialized. Otherwise valgrind moans about uninitialized
	// memory when saving serialized compiled patterns.

	libc.Xmemset(tls, slot+uintptr(DIMM2_SIZE)+uintptr(length), 0,
		uint64((int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fname_entry_size)-length-DIMM2_SIZE)*(DPCRE2_CODE_UNIT_WIDTH/8)))
}

// ************************************************
//
//             Skip in parsed pattern             *
//

// This function is called to skip parts of the parsed pattern when finding the
// length of a lookbehind branch. It is called after (*ACCEPT) and (*FAIL) to find
// the end of the branch, it is called to skip over an internal lookaround or
// (DEFINE) group, and it is also called to skip to the end of a class, during
// which it will never encounter nested groups (but there's no need to have
// special code for that).
//
// When called to find the end of a branch or group, pptr must point to the first
// meta code inside the branch, not the branch-starting code. In other cases it
// can point to the item that causes the function to be called.
//
// Arguments:
//   pptr       current pointer to skip from
//   skiptype   PSKIP_CLASS when skipping to end of class
//              PSKIP_ALT when META_ALT ends the skip
//              PSKIP_KET when only META_KET ends the skip
//
// Returns:     new value of pptr
//              NULL if META_END is reached - should never occur
//                or for an unknown meta value - likewise

func parsed_skip(tls *libc.TLS, pptr uintptr, skiptype uint32) uintptr { /* pcre2_compile.c:8952:17: */
	var nestlevel uint32 = uint32(0)

	for ; ; pptr += 4 {
		var meta uint32 = *(*uint32)(unsafe.Pointer(pptr)) & 0xffff0000

		switch meta {
		default: // Just skip over most items
			if meta < DMETA_END {
				continue
			} // Literal
			break

		// This should never occur.

		case DMETA_END:
			return uintptr(0)

		// The data for these items is variable in length.

		case DMETA_BACKREF: // Offset is present only if group >= 10
			if *(*uint32)(unsafe.Pointer(pptr))&0x0000ffff >= uint32(10) {
				pptr += 4 * uintptr(DSIZEOFFSET)
			}
			break

		case DMETA_ESCAPE: // A few escapes are followed by data items.
			switch *(*uint32)(unsafe.Pointer(pptr)) & 0x0000ffff {
			case ESC_P:
				fallthrough
			case ESC_p:
				pptr += 4 * uintptr(1)
				break

			case ESC_g:
				fallthrough
			case ESC_k:
				pptr += 4 * uintptr(1+DSIZEOFFSET)
				break
			}
			break

		case DMETA_MARK:
			fallthrough // Add the length of the name.
		case DMETA_COMMIT_ARG:
			fallthrough
		case DMETA_PRUNE_ARG:
			fallthrough
		case DMETA_SKIP_ARG:
			fallthrough
		case DMETA_THEN_ARG:
			pptr += 4 * uintptr(*(*uint32)(unsafe.Pointer(pptr + 1*4)))
			break

		// These are the "active" items in this loop.

		case DMETA_CLASS_END:
			if skiptype == PSKIP_CLASS {
				return pptr
			}
			break

		case DMETA_ATOMIC:
			fallthrough
		case DMETA_CAPTURE:
			fallthrough
		case DMETA_COND_ASSERT:
			fallthrough
		case DMETA_COND_DEFINE:
			fallthrough
		case DMETA_COND_NAME:
			fallthrough
		case DMETA_COND_NUMBER:
			fallthrough
		case DMETA_COND_RNAME:
			fallthrough
		case DMETA_COND_RNUMBER:
			fallthrough
		case DMETA_COND_VERSION:
			fallthrough
		case DMETA_LOOKAHEAD:
			fallthrough
		case DMETA_LOOKAHEADNOT:
			fallthrough
		case DMETA_LOOKAHEAD_NA:
			fallthrough
		case DMETA_LOOKBEHIND:
			fallthrough
		case DMETA_LOOKBEHINDNOT:
			fallthrough
		case DMETA_LOOKBEHIND_NA:
			fallthrough
		case DMETA_NOCAPTURE:
			fallthrough
		case DMETA_SCRIPT_RUN:
			nestlevel++
			break

		case DMETA_ALT:
			if nestlevel == uint32(0) && skiptype == PSKIP_ALT {
				return pptr
			}
			break

		case DMETA_KET:
			if nestlevel == uint32(0) {
				return pptr
			}
			nestlevel--
			break
		}

		// The extra data item length for each meta is in a table.

		meta = meta >> 16 & uint32(0x7fff)
		if uint64(meta) >= uint64(unsafe.Sizeof(meta_extra_lengths)) {
			return uintptr(0)
		}
		pptr += 4 * uintptr(meta_extra_lengths[meta])
	}
	// Control never reaches here
	return pptr
}

// ************************************************
//
//       Find length of a parsed group            *
//

// This is called for nested groups within a branch of a lookbehind whose
// length is being computed. If all the branches in the nested group have the same
// length, that is OK. On entry, the pointer must be at the first element after
// the group initializing code. On exit it points to OP_KET. Caching is used to
// improve processing speed when the same capturing group occurs many times.
//
// Arguments:
//   pptrptr     pointer to pointer in the parsed pattern
//   isinline    FALSE if a reference or recursion; TRUE for inline group
//   errcodeptr  pointer to the errorcode
//   lcptr       pointer to the loop counter
//   group       number of captured group or -1 for a non-capturing group
//   recurses    chain of recurse_check to catch mutual recursion
//   cb          pointer to the compile data
//
// Returns:      the group length or a negative number

func get_grouplength(tls *libc.TLS, pptrptr uintptr, isinline int32, errcodeptr uintptr, lcptr uintptr, group int32, recurses uintptr, cb uintptr) int32 { /* pcre2_compile.c:9072:1: */
	var branchlength int32
	var grouplength int32
	var groupinfo uint32
	grouplength = -1

	// The cache can be used only if there is no possibility of there being two
	// groups with the same number. We do not need to set the end pointer for a group
	// that is being processed as a back reference or recursion, but we must do so for
	// an inline group.

	if !(group > 0 && (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_flags&uint32(DPCRE2_DUPCAPUSED) == uint32(0)) {
		goto __1
	}

	groupinfo = *(*uint32)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fgroupinfo + uintptr(group)*4))
	if !(groupinfo&DGI_NOT_FIXED_LENGTH != uint32(0)) {
		goto __2
	}
	return -1
__2:
	;
	if !(groupinfo&DGI_SET_FIXED_LENGTH != uint32(0)) {
		goto __3
	}

	if !(isinline != 0) {
		goto __4
	}
	*(*uintptr)(unsafe.Pointer(pptrptr)) = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(pptrptr)), PSKIP_KET)
__4:
	;
	return int32(groupinfo & DGI_FIXED_LENGTH_MASK)
__3:
	;
__1:
	;

	// Scan the group. In this case we find the end pointer of necessity.

__5:

	branchlength = get_branchlength(tls, pptrptr, errcodeptr, lcptr, recurses, cb)
	if !(branchlength < 0) {
		goto __8
	}
	goto ISNOTFIXED
__8:
	;
	if !(grouplength == -1) {
		goto __9
	}
	grouplength = branchlength
	goto __10
__9:
	if !(grouplength != branchlength) {
		goto __11
	}
	goto ISNOTFIXED
__11:
	;
__10:
	;
	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pptrptr)))) == DMETA_KET) {
		goto __12
	}
	goto __7
__12:
	;
	*(*uintptr)(unsafe.Pointer(pptrptr)) += uintptr(1) * 4 // Skip META_ALT
	goto __6
__6:
	goto __5
	goto __7
__7:
	;

	if !(group > 0) {
		goto __13
	}
	*(*uint32)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fgroupinfo + uintptr(group)*4)) |= DGI_SET_FIXED_LENGTH | uint32(grouplength)
__13:
	;
	return grouplength

ISNOTFIXED:
	if !(group > 0) {
		goto __14
	}
	*(*uint32)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(cb)).Fgroupinfo + uintptr(group)*4)) |= DGI_NOT_FIXED_LENGTH
__14:
	;
	return -1
}

// ************************************************
//
//        Find length of a parsed branch          *
//

// Return a fixed length for a branch in a lookbehind, giving an error if the
// length is not fixed. On entry, *pptrptr points to the first element inside the
// branch. On exit it is set to point to the ALT or KET.
//
// Arguments:
//   pptrptr     pointer to pointer in the parsed pattern
//   errcodeptr  pointer to error code
//   lcptr       pointer to loop counter
//   recurses    chain of recurse_check to catch mutual recursion
//   cb          pointer to compile block
//
// Returns:      the length, or a negative value on error

func get_branchlength(tls *libc.TLS, pptrptr uintptr, errcodeptr uintptr, lcptr uintptr, recurses uintptr, cb uintptr) int32 { /* pcre2_compile.c:9136:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var branchlength int32
	var grouplength int32
	var lastitemlength uint32
	// var pptr uintptr at bp, 8

	var offset uint64
	// var this_recurse Tparsed_recurse_check at bp+16, 16

	var i int32
	var name uintptr
	var is_dupname int32
	var ng uintptr
	var meta_code uint32
	var length uint32
	var r uintptr
	// var gptr uintptr at bp+8, 8

	var gptrend uintptr
	var escape uint32
	var group uint32
	var itemlength uint32
	branchlength = 0
	lastitemlength = uint32(0)
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) = *(*uintptr)(unsafe.Pointer(pptrptr))

	// A large and/or complex regex can take too long to process. This can happen
	// more often when (?| groups are present in the pattern because their length
	// cannot be cached.

	if !(libc.PostIncInt32(&*(*int32)(unsafe.Pointer(lcptr)), 1) > 2000) {
		goto __1
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR35 // Lookbehind is too complicated
	return -1
__1:
	;

	// Scan the branch, accumulating the length.

__2:
	;
	group = uint32(0)
	itemlength = uint32(0)

	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) < DMETA_END) {
		goto __5
	}

	itemlength = uint32(1)
	goto __6
__5:
	switch *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0xffff0000 {
	case DMETA_KET:
		goto __8
	case DMETA_ALT:
		goto __9

	// (*ACCEPT) and (*FAIL) terminate the branch, but we must skip to the
	//     actual termination.

	case DMETA_ACCEPT:
		goto __10
	case DMETA_FAIL:
		goto __11

	case DMETA_MARK:
		goto __12
	case DMETA_COMMIT_ARG:
		goto __13
	case DMETA_PRUNE_ARG:
		goto __14
	case DMETA_SKIP_ARG:
		goto __15
	case DMETA_THEN_ARG:
		goto __16

	case DMETA_CIRCUMFLEX:
		goto __17
	case DMETA_COMMIT:
		goto __18
	case DMETA_DOLLAR:
		goto __19
	case DMETA_PRUNE:
		goto __20
	case DMETA_SKIP:
		goto __21
	case DMETA_THEN:
		goto __22

	case DMETA_OPTIONS:
		goto __23

	case DMETA_BIGVALUE:
		goto __24

	case DMETA_CLASS:
		goto __25
	case DMETA_CLASS_NOT:
		goto __26

	case DMETA_CLASS_EMPTY_NOT:
		goto __27
	case DMETA_DOT:
		goto __28

	case DMETA_CALLOUT_NUMBER:
		goto __29

	case DMETA_CALLOUT_STRING:
		goto __30

	// Only some escapes consume a character. Of those, \R and \X are never
	//     allowed because they might match more than character. \C is allowed only in
	//     32-bit and non-UTF 8/16-bit modes.

	case DMETA_ESCAPE:
		goto __31

	// Lookaheads do not contribute to the length of this branch, but they may
	//     contain lookbehinds within them whose lengths need to be set.

	case DMETA_LOOKAHEAD:
		goto __32
	case DMETA_LOOKAHEADNOT:
		goto __33
	case DMETA_LOOKAHEAD_NA:
		goto __34

	// A nested lookbehind does not contribute any length to this lookbehind,
	//     but must itself be checked and have its lengths set.

	case DMETA_LOOKBEHIND:
		goto __35
	case DMETA_LOOKBEHINDNOT:
		goto __36
	case DMETA_LOOKBEHIND_NA:
		goto __37

	// Back references and recursions are handled by very similar code. At this
	//     stage, the names generated in the parsing pass are available, but the main
	//     name table has not yet been created. So for the named varieties, scan the
	//     list of names in order to get the number of the first one in the pattern,
	//     and whether or not this name is duplicated.

	case DMETA_BACKREF_BYNAME:
		goto __38
	// Fall through

	case DMETA_RECURSE_BYNAME:
		goto __39 // Duplicate name or number

	// The offset values for back references < 10 are in a separate vector
	//     because otherwise they would use more than two parsed pattern elements on
	//     64-bit systems.

	case DMETA_BACKREF:
		goto __40

	// Fall through
	// For groups >= 10 - picking up group twice does no harm.

	// A true recursion implies not fixed length, but a subroutine call may
	//     be OK. Back reference "recursions" are also failed.

	case DMETA_RECURSE:
		goto __41

	// A (DEFINE) group is never obeyed inline and so it does not contribute to
	//     the length of this branch. Skip from the following item to the next
	//     unpaired ket.

	case DMETA_COND_DEFINE:
		goto __42

	// Check other nested groups - advance past the initial data for each type
	//     and then seek a fixed length with get_grouplength().

	case DMETA_COND_NAME:
		goto __43
	case DMETA_COND_NUMBER:
		goto __44
	case DMETA_COND_RNAME:
		goto __45
	case DMETA_COND_RNUMBER:
		goto __46

	case DMETA_COND_ASSERT:
		goto __47

	case DMETA_COND_VERSION:
		goto __48

	case DMETA_CAPTURE:
		goto __49
	// Fall through

	case DMETA_ATOMIC:
		goto __50
	case DMETA_NOCAPTURE:
		goto __51
	case DMETA_SCRIPT_RUN:
		goto __52

	// Exact repetition is OK; variable repetition is not. A repetition of zero
	//     must subtract the length that has already been added.

	case DMETA_MINMAX:
		goto __53
	case DMETA_MINMAX_PLUS:
		goto __54
	case DMETA_MINMAX_QUERY:
		goto __55
	// Fall through

	// Any other item means this branch does not have a fixed length.

	default:
		goto __56
	}
	goto __7

__8:
__9:
	goto EXIT

	// (*ACCEPT) and (*FAIL) terminate the branch, but we must skip to the
	//     actual termination.

__10:
__11:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(bp /* pptr */)), PSKIP_ALT)
	if !(*(*uintptr)(unsafe.Pointer(bp)) == uintptr(0)) {
		goto __57
	}
	goto PARSED_SKIP_FAILED
__57:
	;
	goto EXIT

__12:
__13:
__14:
__15:
__16:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4))+uint32(1))
	goto __7

__17:
__18:
__19:
__20:
__21:
__22:
	goto __7

__23:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
	goto __7

__24:
	itemlength = uint32(1)
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
	goto __7

__25:
__26:
	itemlength = uint32(1)
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(bp /* pptr */)), PSKIP_CLASS)
	if !(*(*uintptr)(unsafe.Pointer(bp)) == uintptr(0)) {
		goto __58
	}
	goto PARSED_SKIP_FAILED
__58:
	;
	goto __7

__27:
__28:
	itemlength = uint32(1)
	goto __7

__29:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3)
	goto __7

__30:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3+DSIZEOFFSET)
	goto __7

	// Only some escapes consume a character. Of those, \R and \X are never
	//     allowed because they might match more than character. \C is allowed only in
	//     32-bit and non-UTF 8/16-bit modes.

__31:
	escape = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0x0000ffff
	if !(escape == ESC_R || escape == ESC_X) {
		goto __59
	}
	return -1
__59:
	;
	if !(escape > ESC_b && escape < ESC_Z) {
		goto __60
	}

	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_UTF != uint32(0) && escape == ESC_C) {
		goto __61
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR36
	return -1
__61:
	;
	itemlength = uint32(1)
	if !(escape == ESC_p || escape == ESC_P) {
		goto __62
	}
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4
__62:
	; // Skip prop data
__60:
	;
	goto __7

	// Lookaheads do not contribute to the length of this branch, but they may
	//     contain lookbehinds within them whose lengths need to be set.

__32:
__33:
__34:
	*(*int32)(unsafe.Pointer(errcodeptr)) = check_lookbehinds(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)*4, bp, recurses, cb, lcptr)
	if !(*(*int32)(unsafe.Pointer(errcodeptr)) != 0) {
		goto __63
	}
	return -1
__63:
	;

	// Ignore any qualifiers that follow a lookahead assertion.

	switch *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* pptr */)) + 1*4)) {
	case DMETA_ASTERISK:
		goto __65
	case DMETA_ASTERISK_PLUS:
		goto __66
	case DMETA_ASTERISK_QUERY:
		goto __67
	case DMETA_PLUS:
		goto __68
	case DMETA_PLUS_PLUS:
		goto __69
	case DMETA_PLUS_QUERY:
		goto __70
	case DMETA_QUERY:
		goto __71
	case DMETA_QUERY_PLUS:
		goto __72
	case DMETA_QUERY_QUERY:
		goto __73

	case DMETA_MINMAX:
		goto __74
	case DMETA_MINMAX_PLUS:
		goto __75
	case DMETA_MINMAX_QUERY:
		goto __76

	default:
		goto __77
	}
	goto __64

__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4
	goto __64

__74:
__75:
__76:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3)
	goto __64

__77:
	goto __64
__64:
	;
	goto __7

	// A nested lookbehind does not contribute any length to this lookbehind,
	//     but must itself be checked and have its lengths set.

__35:
__36:
__37:
	if !!(set_lookbehind_lengths(tls, bp, errcodeptr, lcptr, recurses, cb) != 0) {
		goto __78
	}
	return -1
__78:
	;
	goto __7

	// Back references and recursions are handled by very similar code. At this
	//     stage, the names generated in the parsing pass are available, but the main
	//     name table has not yet been created. So for the named varieties, scan the
	//     list of names in order to get the number of the first one in the pattern,
	//     and whether or not this name is duplicated.

__38:
	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_MATCH_UNSET_BACKREF != uint32(0)) {
		goto __79
	}
	goto ISNOTFIXED
__79:
	;
	// Fall through

__39:

	is_dupname = DFALSE
	ng = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fnamed_groups
	meta_code = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0xffff0000
	length = *(*uint32)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 4)))

	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2)

	name = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fstart_pattern + uintptr(offset)
	i = 0
__80:
	if !(i < int32((*Tcompile_block_8)(unsafe.Pointer(cb)).Fnames_found)) {
		goto __82
	}

	if !(length == uint32((*Tnamed_group_8)(unsafe.Pointer(ng)).Flength) && X_pcre2_strncmp_8(tls, name, (*Tnamed_group_8)(unsafe.Pointer(ng)).Fname, uint64(length)) == 0) {
		goto __83
	}

	group = (*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber
	is_dupname = int32((*Tnamed_group_8)(unsafe.Pointer(ng)).Fisdup)
	goto __82
__83:
	;
	goto __81
__81:
	i++
	ng += 16
	goto __80
	goto __82
__82:
	;

	if !(group == uint32(0)) {
		goto __84
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR15 // Non-existent subpattern
	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	return -1
__84:
	;

	// A numerical back reference can be fixed length if duplicate capturing
	//       groups are not being used. A non-duplicate named back reference can also
	//       be handled.

	if !(meta_code == DMETA_RECURSE_BYNAME || !(is_dupname != 0) && (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_flags&uint32(DPCRE2_DUPCAPUSED) == uint32(0)) {
		goto __85
	}
	goto RECURSE_OR_BACKREF_LENGTH
__85:
	; // Handle as a numbered version.

	goto ISNOTFIXED // Duplicate name or number

	// The offset values for back references < 10 are in a separate vector
	//     because otherwise they would use more than two parsed pattern elements on
	//     64-bit systems.

__40:
	if !((*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_options&DPCRE2_MATCH_UNSET_BACKREF != uint32(0) || (*Tcompile_block_8)(unsafe.Pointer(cb)).Fexternal_flags&uint32(DPCRE2_DUPCAPUSED) != uint32(0)) {
		goto __86
	}
	goto ISNOTFIXED
__86:
	;
	group = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0x0000ffff
	if !(group < uint32(10)) {
		goto __87
	}

	offset = *(*uint64)(unsafe.Pointer(cb + 88 + uintptr(group)*8))
	goto RECURSE_OR_BACKREF_LENGTH
__87:
	;

	// Fall through
	// For groups >= 10 - picking up group twice does no harm.

	// A true recursion implies not fixed length, but a subroutine call may
	//     be OK. Back reference "recursions" are also failed.

__41:
	group = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0x0000ffff
	offset = uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2*4)))
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2)

RECURSE_OR_BACKREF_LENGTH:
	if !(group > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fbracount) {
		goto __88
	}

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR15 // Non-existent subpattern
	return -1
__88:
	;
	if !(group == uint32(0)) {
		goto __89
	}
	goto ISNOTFIXED
__89:
	; // Local recursion
	*(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */)) = (*Tcompile_block_8)(unsafe.Pointer(cb)).Fparsed_pattern
__90:
	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != DMETA_END) {
		goto __92
	}

	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))&0xffff0000 == DMETA_BIGVALUE) {
		goto __93
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */)) += 4
	goto __94
__93:
	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == DMETA_CAPTURE|group) {
		goto __95
	}
	goto __92
__95:
	;
__94:
	;
	goto __91
__91:
	*(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */)) += 4
	goto __90
	goto __92
__92:
	;

	// We must start the search for the end of the group at the first meta code
	//     inside the group. Otherwise it will be treated as an enclosed group.

	gptrend = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(bp + 8))+uintptr(1)*4, PSKIP_KET)
	if !(gptrend == uintptr(0)) {
		goto __96
	}
	goto PARSED_SKIP_FAILED
__96:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp)) > *(*uintptr)(unsafe.Pointer(bp + 8)) && *(*uintptr)(unsafe.Pointer(bp)) < gptrend) {
		goto __97
	}
	goto ISNOTFIXED
__97:
	; // Local recursion
	r = recurses
__98:
	if !(r != uintptr(0)) {
		goto __100
	}
	if !((*Tparsed_recurse_check)(unsafe.Pointer(r)).Fgroupptr == *(*uintptr)(unsafe.Pointer(bp + 8))) {
		goto __101
	}
	goto __100
__101:
	;
	goto __99
__99:
	r = (*Tparsed_recurse_check)(unsafe.Pointer(r)).Fprev
	goto __98
	goto __100
__100:
	;
	if !(r != uintptr(0)) {
		goto __102
	}
	goto ISNOTFIXED
__102:
	; // Mutual recursion
	(*Tparsed_recurse_check)(unsafe.Pointer(bp + 16 /* &this_recurse */)).Fprev = recurses
	(*Tparsed_recurse_check)(unsafe.Pointer(bp + 16 /* &this_recurse */)).Fgroupptr = *(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */))

	// We do not need to know the position of the end of the group, that is,
	//     gptr is not used after the call to get_grouplength(). Setting the second
	//     argument FALSE stops it scanning for the end when the length can be found
	//     in the cache.

	*(*uintptr)(unsafe.Pointer(bp + 8 /* gptr */)) += 4
	grouplength = get_grouplength(tls, bp+8, DFALSE, errcodeptr, lcptr, int32(group),
		bp+16, cb)
	if !(grouplength < 0) {
		goto __103
	}

	if !(*(*int32)(unsafe.Pointer(errcodeptr)) == 0) {
		goto __104
	}
	goto ISNOTFIXED
__104:
	;
	return -1 // Error already set
__103:
	;
	itemlength = uint32(grouplength)
	goto __7

	// A (DEFINE) group is never obeyed inline and so it does not contribute to
	//     the length of this branch. Skip from the following item to the next
	//     unpaired ket.

__42:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) = parsed_skip(tls, *(*uintptr)(unsafe.Pointer(bp))+uintptr(1)*4, PSKIP_KET)
	goto __7

	// Check other nested groups - advance past the initial data for each type
	//     and then seek a fixed length with get_grouplength().

__43:
__44:
__45:
__46:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2+DSIZEOFFSET)
	goto CHECK_GROUP

__47:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
	goto CHECK_GROUP

__48:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(4)
	goto CHECK_GROUP

__49:
	group = *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0x0000ffff
	// Fall through

__50:
__51:
__52:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4
CHECK_GROUP:
	grouplength = get_grouplength(tls, bp, DTRUE, errcodeptr, lcptr, int32(group),
		recurses, cb)
	if !(grouplength < 0) {
		goto __105
	}
	return -1
__105:
	;
	itemlength = uint32(grouplength)
	goto __7

	// Exact repetition is OK; variable repetition is not. A repetition of zero
	//     must subtract the length that has already been added.

__53:
__54:
__55:
	if !(*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)) == *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2*4))) {
		goto __106
	}

	switch *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* pptr */)) + 1*4)) {
	case uint32(0):
		goto __108

	case uint32(1):
		goto __109

	default:
		goto __110
	}
	goto __107

__108:
	branchlength = int32(uint32(branchlength) - lastitemlength)
	goto __107

__109:
	itemlength = uint32(0)
	goto __107

__110: // Check for integer overflow
	if !(lastitemlength != uint32(0) && uint32(0x7fffffff)/lastitemlength < *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4))-uint32(1)) {
		goto __111
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR87 // Integer overflow; lookbehind too big
	return -1
__111:
	;
	itemlength = (*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)) - uint32(1)) * lastitemlength
	goto __107
__107:
	;
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2)
	goto __7
__106:
	;
	// Fall through

	// Any other item means this branch does not have a fixed length.

__56:
ISNOTFIXED:
	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR25 // Not fixed length
	return -1
__7:
	;
__6:
	;

	// Add the item length to the branchlength, checking for integer overflow and
	//   for the branch length exceeding the limit.

	if !(0x7fffffff-branchlength < int32(itemlength) || libc.AssignAddInt32(&branchlength, int32(itemlength)) > 65535) {
		goto __112
	}

	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR87
	return -1
__112:
	;

	// Save this item length for use if the next item is a quantifier.

	lastitemlength = itemlength
	goto __3
__3:
	*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4
	goto __2
	goto __4
__4:
	;

EXIT:
	*(*uintptr)(unsafe.Pointer(pptrptr)) = *(*uintptr)(unsafe.Pointer(bp /* pptr */))
	return branchlength

PARSED_SKIP_FAILED:
	*(*int32)(unsafe.Pointer(errcodeptr)) = ERR90
	return -1
}

// ************************************************
//
//        Set lengths in a lookbehind             *
//

// This function is called for each lookbehind, to set the lengths in its
// branches. An error occurs if any branch does not have a fixed length that is
// less than the maximum (65535). On exit, the pointer must be left on the final
// ket.
//
// The function also maintains the max_lookbehind value. Any lookbehind branch
// that contains a nested lookbehind may actually look further back than the
// length of the branch. The additional amount is passed back from
// get_branchlength() as an "extra" value.
//
// Arguments:
//   pptrptr     pointer to pointer in the parsed pattern
//   errcodeptr  pointer to error code
//   lcptr       pointer to loop counter
//   recurses    chain of recurse_check to catch mutual recursion
//   cb          pointer to compile block
//
// Returns:      TRUE if all is well
//               FALSE otherwise, with error code and offset set

func set_lookbehind_lengths(tls *libc.TLS, pptrptr uintptr, errcodeptr uintptr, lcptr uintptr, recurses uintptr, cb uintptr) int32 { /* pcre2_compile.c:9547:1: */
	var offset uint64
	var branchlength int32
	var bptr uintptr = *(*uintptr)(unsafe.Pointer(pptrptr))

	{
		offset = uint64(*(*uint32)(unsafe.Pointer(bptr + 1*4)))<<32 | uint64(*(*uint32)(unsafe.Pointer(bptr + 2*4)))
	}
	// Offset for error messages
	*(*uintptr)(unsafe.Pointer(pptrptr)) += uintptr(DSIZEOFFSET) * 4

	for __ccgo := true; __ccgo; __ccgo = *(*uint32)(unsafe.Pointer(bptr)) == DMETA_ALT {
		*(*uintptr)(unsafe.Pointer(pptrptr)) += uintptr(1) * 4
		branchlength = get_branchlength(tls, pptrptr, errcodeptr, lcptr, recurses, cb)
		if branchlength < 0 {
			// The errorcode and offset may already be set from a nested lookbehind.
			if *(*int32)(unsafe.Pointer(errcodeptr)) == 0 {
				*(*int32)(unsafe.Pointer(errcodeptr)) = ERR25
			}
			if (*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset == libc.CplUint64(uint64(0)) {
				(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = offset
			}
			return DFALSE
		}
		if branchlength > (*Tcompile_block_8)(unsafe.Pointer(cb)).Fmax_lookbehind {
			(*Tcompile_block_8)(unsafe.Pointer(cb)).Fmax_lookbehind = branchlength
		}
		*(*uint32)(unsafe.Pointer(bptr)) |= uint32(branchlength) // branchlength never more than 65535
		bptr = *(*uintptr)(unsafe.Pointer(pptrptr))
	}

	return DTRUE
}

// ************************************************
//
//         Check parsed pattern lookbehinds       *
//

// This function is called at the end of parsing a pattern if any lookbehinds
// were encountered. It scans the parsed pattern for them, calling
// set_lookbehind_lengths() for each one. At the start, the errorcode is zero and
// the error offset is marked unset. The enables the functions above not to
// override settings from deeper nestings.
//
// This function is called recursively from get_branchlength() for lookaheads in
// order to process any lookbehinds that they may contain. It stops when it hits a
// non-nested closing parenthesis in this case, returning a pointer to it.
//
// Arguments
//   pptr      points to where to start (start of pattern or start of lookahead)
//   retptr    if not NULL, return the ket pointer here
//   recurses  chain of recurse_check to catch mutual recursion
//   cb        points to the compile block
//   lcptr     points to loop counter
//
// Returns:    0 on success, or an errorcode (cb->erroroffset will be set)

func check_lookbehinds(tls *libc.TLS, pptr uintptr, retptr uintptr, recurses uintptr, cb uintptr, lcptr uintptr) int32 { /* pcre2_compile.c:9604:1: */
	bp := tls.Alloc(12)
	defer tls.Free(12)
	*(*uintptr)(unsafe.Pointer(bp)) = pptr

	*(*int32)(unsafe.Pointer(bp + 8 /* errorcode */)) = 0
	var nestlevel int32 = 0

	(*Tcompile_block_8)(unsafe.Pointer(cb)).Ferroroffset = libc.CplUint64(uint64(0))

	for ; *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != DMETA_END; *(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 {
		if *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) < DMETA_END {
			continue
		} // Literal

		switch *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) & 0xffff0000 {
		default:
			return ERR70 // Unrecognized meta code

		case DMETA_ESCAPE:
			if *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))-DMETA_ESCAPE == ESC_P || *(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))-DMETA_ESCAPE == ESC_p {
				*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
			}
			break

		case DMETA_KET:
			if libc.PreDecInt32(&nestlevel, 1) < 0 {
				if retptr != uintptr(0) {
					*(*uintptr)(unsafe.Pointer(retptr)) = *(*uintptr)(unsafe.Pointer(bp /* pptr */))
				}
				return 0
			}
			break

		case DMETA_ATOMIC:
			fallthrough
		case DMETA_CAPTURE:
			fallthrough
		case DMETA_COND_ASSERT:
			fallthrough
		case DMETA_LOOKAHEAD:
			fallthrough
		case DMETA_LOOKAHEADNOT:
			fallthrough
		case DMETA_LOOKAHEAD_NA:
			fallthrough
		case DMETA_NOCAPTURE:
			fallthrough
		case DMETA_SCRIPT_RUN:
			nestlevel++
			break

		case DMETA_ACCEPT:
			fallthrough
		case DMETA_ALT:
			fallthrough
		case DMETA_ASTERISK:
			fallthrough
		case DMETA_ASTERISK_PLUS:
			fallthrough
		case DMETA_ASTERISK_QUERY:
			fallthrough
		case DMETA_BACKREF:
			fallthrough
		case DMETA_CIRCUMFLEX:
			fallthrough
		case DMETA_CLASS:
			fallthrough
		case DMETA_CLASS_EMPTY:
			fallthrough
		case DMETA_CLASS_EMPTY_NOT:
			fallthrough
		case DMETA_CLASS_END:
			fallthrough
		case DMETA_CLASS_NOT:
			fallthrough
		case DMETA_COMMIT:
			fallthrough
		case DMETA_DOLLAR:
			fallthrough
		case DMETA_DOT:
			fallthrough
		case DMETA_FAIL:
			fallthrough
		case DMETA_PLUS:
			fallthrough
		case DMETA_PLUS_PLUS:
			fallthrough
		case DMETA_PLUS_QUERY:
			fallthrough
		case DMETA_PRUNE:
			fallthrough
		case DMETA_QUERY:
			fallthrough
		case DMETA_QUERY_PLUS:
			fallthrough
		case DMETA_QUERY_QUERY:
			fallthrough
		case DMETA_RANGE_ESCAPED:
			fallthrough
		case DMETA_RANGE_LITERAL:
			fallthrough
		case DMETA_SKIP:
			fallthrough
		case DMETA_THEN:
			break

		case DMETA_RECURSE:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(DSIZEOFFSET)
			break

		case DMETA_BACKREF_BYNAME:
			fallthrough
		case DMETA_RECURSE_BYNAME:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1+DSIZEOFFSET)
			break

		case DMETA_COND_DEFINE:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(DSIZEOFFSET)
			nestlevel++
			break

		case DMETA_COND_NAME:
			fallthrough
		case DMETA_COND_NUMBER:
			fallthrough
		case DMETA_COND_RNAME:
			fallthrough
		case DMETA_COND_RNUMBER:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1+DSIZEOFFSET)
			nestlevel++
			break

		case DMETA_COND_VERSION:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3)
			nestlevel++
			break

		case DMETA_CALLOUT_STRING:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3+DSIZEOFFSET)
			break

		case DMETA_BIGVALUE:
			fallthrough
		case DMETA_OPTIONS:
			fallthrough
		case DMETA_POSIX:
			fallthrough
		case DMETA_POSIX_NEG:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(1)
			break

		case DMETA_MINMAX:
			fallthrough
		case DMETA_MINMAX_QUERY:
			fallthrough
		case DMETA_MINMAX_PLUS:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(2)
			break

		case DMETA_CALLOUT_NUMBER:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(3)
			break

		case DMETA_MARK:
			fallthrough
		case DMETA_COMMIT_ARG:
			fallthrough
		case DMETA_PRUNE_ARG:
			fallthrough
		case DMETA_SKIP_ARG:
			fallthrough
		case DMETA_THEN_ARG:
			*(*uintptr)(unsafe.Pointer(bp /* pptr */)) += 4 * uintptr(uint32(1)+*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1*4)))
			break

		case DMETA_LOOKBEHIND:
			fallthrough
		case DMETA_LOOKBEHINDNOT:
			fallthrough
		case DMETA_LOOKBEHIND_NA:
			if !(set_lookbehind_lengths(tls, bp, bp+8, lcptr, recurses, cb) != 0) {
				return *(*int32)(unsafe.Pointer(bp + 8 /* errorcode */))
			}
			break
		}
	}

	return 0
}

// ************************************************
//
//     External function to compile a pattern     *
//

// This function reads a regular expression in the form of a string and returns
// a pointer to a block of store holding a compiled version of the expression.
//
// Arguments:
//   pattern       the regular expression
//   patlen        the length of the pattern, or PCRE2_ZERO_TERMINATED
//   options       option bits
//   errorptr      pointer to errorcode
//   erroroffset   pointer to error offset
//   ccontext      points to a compile context or is NULL
//
// Returns:        pointer to compiled data block, or NULL on error,
//                 with errorcode and erroroffset set

func Xpcre2_compile_8(tls *libc.TLS, pattern uintptr, patlen uint64, options uint32, errorptr uintptr, erroroffset uintptr, ccontext uintptr) uintptr { /* pcre2_compile.c:9763:27: */
	bp := tls.Alloc(17928)
	defer tls.Free(17928)

	var utf int32 // Set TRUE for UTF mode
	var ucp int32 // Set TRUE for UCP mode
	// var has_lookbehind int32 at bp+17744, 4
	// Set TRUE if a lookbehind is found
	var zero_terminated int32
	_ = zero_terminated // Set TRUE for zero-terminated pattern
	var re uintptr      // What we will return
	// var cb Tcompile_block_8 at bp+17440, 304
	// "Static" compile-time data
	var tables uintptr // Char tables base pointer

	// var code uintptr at bp+17752, 8
	// Current pointer in compiled code
	var codestart uintptr // Start of compiled code
	var ptr uintptr       // Current pointer in pattern
	// var pptr uintptr at bp+17760, 8
	// Current pointer in parsed pattern

	// var length uint64 at bp+17792, 8
	// Allow for final END opcode
	var usedlength uint64         // Actual length used
	var re_blocksize uint64       // Size of memory block
	var big32count uint64         // 32-bit literals >= 0x80000000
	var parsed_size_needed uint64 // Needed for parsed pattern

	// var firstcuflags uint32 at bp+17776, 4

	// var reqcuflags uint32 at bp+17784, 4
	// Type of first/req code unit
	// var firstcu uint32 at bp+17772, 4

	// var reqcu uint32 at bp+17780, 4
	// Value of first/req code unit
	var setflags uint32 // NL and BSR set flags

	var skipatstart uint32 // When checking (*UTF) etc
	var limit_heap uint32
	var limit_match uint32 // Unset match limits
	var limit_depth uint32
	var newline int32 // Unset; can be set by the pattern
	var bsr int32     // Unset; can be set by the pattern
	// var errorcode int32 at bp+17768, 4
	// Initialize to avoid compiler warn
	var regexrc int32 // Return from compile

	var i uint32 // Local loop counter

	// Comments at the head of this file explain about these variables.

	// var stack_groupinfo [256]uint32 at bp+12000, 1024

	// var stack_parsed_pattern [1024]uint32 at bp+13344, 4096

	// var named_groups [20]Tnamed_group_8 at bp+13024, 320

	// The workspace is used in different ways in the different compiling phases.
	// It needs to be 16-bit aligned for the preliminary parsing scan.

	// var c16workspace [3000]uint32 at bp, 12000

	var cworkspace uintptr
	var c uint32
	var pp uint32
	var p uintptr
	var heap_parsed_pattern uintptr
	// var loopcount int32 at bp+17748, 4

	var ng uintptr
	var search_from uintptr
	var p1 int32
	var groupnumber int32
	var rcode uintptr
	var rgroup uintptr
	var ccount uint32
	var start int32
	// var rc [8]Trecurse_cache at bp+17800, 128

	var temp uintptr
	var minminlength int32
	*(*int32)(unsafe.Pointer(bp + 17744 /* has_lookbehind */)) = DFALSE
	re = uintptr(0)
	*(*uint64)(unsafe.Pointer(bp + 17792 /* length */)) = uint64(1)
	big32count = uint64(0)
	setflags = uint32(0)
	limit_heap = 4294967295
	limit_match = 4294967295
	limit_depth = 4294967295
	newline = 0
	bsr = 0
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = 0
	cworkspace = bp /* c16workspace */

	// -------------- Check arguments and set up the pattern -----------------

	// There must be error code and offset pointers.

	if !(errorptr == uintptr(0) || erroroffset == uintptr(0)) {
		goto __1
	}
	return uintptr(0)
__1:
	;
	*(*int32)(unsafe.Pointer(errorptr)) = ERR0
	*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(0)

	// There must be a pattern!

	if !(pattern == uintptr(0)) {
		goto __2
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR16
	return uintptr(0)
__2:
	;

	// A NULL compile context means "use a default context"

	if !(ccontext == uintptr(0)) {
		goto __3
	}
	ccontext = uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8))
__3:
	;

	// PCRE2_MATCH_INVALID_UTF implies UTF

	if !(options&DPCRE2_MATCH_INVALID_UTF != uint32(0)) {
		goto __4
	}
	options = options | DPCRE2_UTF
__4:
	;

	// Check that all undefined public option bits are zero.

	if !(options&libc.CplUint32(DPCRE2_ANCHORED|DPCRE2_AUTO_CALLOUT|DPCRE2_CASELESS|DPCRE2_ENDANCHORED|DPCRE2_FIRSTLINE|DPCRE2_LITERAL|DPCRE2_MATCH_INVALID_UTF|DPCRE2_NO_START_OPTIMIZE|DPCRE2_NO_UTF_CHECK|DPCRE2_USE_OFFSET_LIMIT|DPCRE2_UTF|DPCRE2_ALLOW_EMPTY_CLASS|DPCRE2_ALT_BSUX|DPCRE2_ALT_CIRCUMFLEX|DPCRE2_ALT_VERBNAMES|DPCRE2_DOLLAR_ENDONLY|DPCRE2_DOTALL|DPCRE2_DUPNAMES|DPCRE2_EXTENDED|DPCRE2_EXTENDED_MORE|DPCRE2_MATCH_UNSET_BACKREF|DPCRE2_MULTILINE|DPCRE2_NEVER_BACKSLASH_C|DPCRE2_NEVER_UCP|DPCRE2_NEVER_UTF|DPCRE2_NO_AUTO_CAPTURE|DPCRE2_NO_AUTO_POSSESS|DPCRE2_NO_DOTSTAR_ANCHOR|DPCRE2_UCP|DPCRE2_UNGREEDY) != uint32(0) || (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options&libc.CplUint32(DPCRE2_EXTRA_MATCH_LINE|DPCRE2_EXTRA_MATCH_WORD|DPCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES|DPCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL|DPCRE2_EXTRA_ESCAPED_CR_IS_LF|DPCRE2_EXTRA_ALT_BSUX|DPCRE2_EXTRA_ALLOW_LOOKAROUND_BSK) != uint32(0)) {
		goto __5
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR17
	return uintptr(0)
__5:
	;

	if !(options&DPCRE2_LITERAL != uint32(0) && (options&libc.CplUint32(DPCRE2_ANCHORED|DPCRE2_AUTO_CALLOUT|DPCRE2_CASELESS|DPCRE2_ENDANCHORED|DPCRE2_FIRSTLINE|DPCRE2_LITERAL|DPCRE2_MATCH_INVALID_UTF|DPCRE2_NO_START_OPTIMIZE|DPCRE2_NO_UTF_CHECK|DPCRE2_USE_OFFSET_LIMIT|DPCRE2_UTF) != uint32(0) || (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options&libc.CplUint32(DPCRE2_EXTRA_MATCH_LINE|DPCRE2_EXTRA_MATCH_WORD) != uint32(0))) {
		goto __6
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR92
	return uintptr(0)
__6:
	;

	// A zero-terminated pattern is indicated by the special length value
	// PCRE2_ZERO_TERMINATED. Check for an overlong pattern.

	if !(libc.AssignInt32(&zero_terminated, libc.Bool32(patlen == libc.CplUint64(uint64(0)))) != 0) {
		goto __7
	}
	patlen = X_pcre2_strlen_8(tls, pattern)
__7:
	;

	if !(patlen > (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmax_pattern_length) {
		goto __8
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR88
	return uintptr(0)
__8:
	;

	// From here on, all returns from this function should end up going via the
	// EXIT label.

	// ------------ Initialize the "static" compile data --------------

	if (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Ftables != uintptr(0) {
		tables = (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Ftables
	} else {
		tables = uintptr(unsafe.Pointer(&X_pcre2_default_tables_8))
	}

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Flcc = tables + uintptr(Dlcc_offset)     // Individual
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ffcc = tables + uintptr(Dfcc_offset)     //   character
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fcbits = tables + uintptr(Dcbits_offset) //      tables
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fctypes = tables + uintptr(Dcbits_offset+Dcbit_length)

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fassert_depth = uint16(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fbracount = uint32(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fcx = ccontext
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fdupnames = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fend_pattern = pattern + uintptr(patlen)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ferroroffset = uint64(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fexternal_flags = uint32(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fexternal_options = options
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fgroupinfo = bp + 12000 /* &stack_groupinfo[0] */
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fhad_recurse = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Flastcapture = uint32(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fmax_lookbehind = 0
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fname_entry_size = uint16(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fname_table = uintptr(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnamed_groups = bp + 13024 /* &named_groups[0] */
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnamed_group_list_size = uint32(DNAMED_GROUP_LIST_SIZE)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnames_found = uint16(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fopen_caps = uintptr(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparens_depth = uint16(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern = bp + 13344 /* &stack_parsed_pattern[0] */
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Freq_varyopt = uint32(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fstart_code = cworkspace
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fstart_pattern = pattern
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fstart_workspace = cworkspace
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fworkspace_size = uint64(3000 * DLINK_SIZE)

	// Maximum back reference and backref bitmap. The bitmap records up to 31 back
	// references to help in deciding whether (.*) can be treated as anchored or not.

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ftop_backref = uint32(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fbackref_map = uint32(0)

	// Escape sequences \1 to \9 are always back references, but as they are only
	// two characters long, only two elements can be used in the parsed_pattern
	// vector. The first contains the reference, and we'd like to use the second to
	// record the offset in the pattern, so that forward references to non-existent
	// groups can be diagnosed later with an offset. However, on 64-bit systems,
	// PCRE2_SIZE won't fit. Instead, we have a vector of offsets for the first
	// occurrence of \1 to \9, indexed by the second parsed_pattern value. All other
	// references have enough space for the offset to be put into the parsed pattern.

	i = uint32(0)
__9:
	if !(i < uint32(10)) {
		goto __11
	}
	*(*uint64)(unsafe.Pointer(bp + 17440 + 88 + uintptr(i)*8)) = libc.CplUint64(uint64(0))
	goto __10
__10:
	i++
	goto __9
	goto __11
__11:
	;

	// --------------- Start looking at the pattern ---------------

	// Unless PCRE2_LITERAL is set, check for global one-time option settings at
	// the start of the pattern, and remember the offset to the actual regex. With
	// valgrind support, make the terminator of a zero-terminated pattern
	// inaccessible. This catches bugs that would otherwise only show up for
	// non-zero-terminated patterns.

	ptr = pattern
	skipatstart = uint32(0)

	if !(options&DPCRE2_LITERAL == uint32(0)) {
		goto __12
	}

__13:
	if !(patlen-uint64(skipatstart) >= uint64(2) && int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(skipatstart)))) == '\050' && int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(skipatstart+uint32(1))))) == '\052') {
		goto __14
	}

	i = uint32(0)
__15:
	if !(uint64(i) < uint64(unsafe.Sizeof(pso_list))/uint64(unsafe.Sizeof(Tpso{}))) {
		goto __17
	}

	p = uintptr(unsafe.Pointer(&pso_list)) + uintptr(i)*16

	if !(patlen-uint64(skipatstart)-uint64(2) >= uint64((*Tpso)(unsafe.Pointer(p)).Flength) && X_pcre2_strncmp_c8_8(tls, ptr+uintptr(skipatstart)+uintptr(2), (*Tpso)(unsafe.Pointer(p)).Fname,
		uint64((*Tpso)(unsafe.Pointer(p)).Flength)) == 0) {
		goto __18
	}

	skipatstart = skipatstart + uint32(int32((*Tpso)(unsafe.Pointer(p)).Flength)+2)
	switch int32((*Tpso)(unsafe.Pointer(p)).Ftype) {
	case PSO_OPT:
		goto __20

	case PSO_FLG:
		goto __21

	case PSO_NL:
		goto __22

	case PSO_BSR:
		goto __23

	case PSO_LIMM:
		goto __24
	case PSO_LIMD:
		goto __25
	case PSO_LIMH:
		goto __26
	}
	goto __19

__20:
	*(*uint32)(unsafe.Pointer(bp + 17440 + 204)) |= (*Tpso)(unsafe.Pointer(p)).Fvalue
	goto __19

__21:
	setflags = setflags | (*Tpso)(unsafe.Pointer(p)).Fvalue
	goto __19

__22:
	newline = int32((*Tpso)(unsafe.Pointer(p)).Fvalue)
	setflags = setflags | uint32(DPCRE2_NL_SET)
	goto __19

__23:
	bsr = int32((*Tpso)(unsafe.Pointer(p)).Fvalue)
	setflags = setflags | uint32(DPCRE2_BSR_SET)
	goto __19

__24:
__25:
__26:
	c = uint32(0)
	pp = skipatstart
	if !!(int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(pp)))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(pp)))) <= '\071') {
		goto __27
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR60
	ptr += uintptr(pp)
	goto HAD_EARLY_ERROR
__27:
	;
__28:
	if !(int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(pp)))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(pp)))) <= '\071') {
		goto __29
	}

	if !(c > 4294967295/uint32(10)-uint32(1)) {
		goto __30
	}
	goto __29
__30:
	; // Integer overflow
	c = c*uint32(10) + uint32(int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(libc.PostIncUint32(&pp, 1)))))-'\060')
	goto __28
__29:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(libc.PostIncUint32(&pp, 1))))) != '\051') {
		goto __31
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR60
	ptr += uintptr(pp)
	goto HAD_EARLY_ERROR
__31:
	;
	if !(int32((*Tpso)(unsafe.Pointer(p)).Ftype) == PSO_LIMH) {
		goto __32
	}
	limit_heap = c
	goto __33
__32:
	if !(int32((*Tpso)(unsafe.Pointer(p)).Ftype) == PSO_LIMM) {
		goto __34
	}
	limit_match = c
	goto __35
__34:
	limit_depth = c
__35:
	;
__33:
	;
	skipatstart = skipatstart + (pp - skipatstart)
	goto __19
__19:
	;
	goto __17 // Out of the table scan loop
__18:
	;
	goto __16
__16:
	i++
	goto __15
	goto __17
__17:
	;
	if !(uint64(i) >= uint64(unsafe.Sizeof(pso_list))/uint64(unsafe.Sizeof(Tpso{}))) {
		goto __36
	}
	goto __14
__36:
	; // Out of pso loop
	goto __13
__14:
	;
__12:
	;

	// End of pattern-start options; advance to start of real regex.

	ptr += uintptr(skipatstart)

	// Can't support UTF or UCP if PCRE2 was built without Unicode support.

	// Check UTF. We have the original options in 'options', with that value as
	// modified by (*UTF) etc in cb->external_options. The extra option
	// PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not permitted in UTF-16 mode because the
	// surrogate code points cannot be represented in UTF-16.

	utf = libc.Bool32((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fexternal_options&DPCRE2_UTF != uint32(0))
	if !(utf != 0) {
		goto __37
	}

	if !(options&DPCRE2_NEVER_UTF != uint32(0)) {
		goto __38
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR74
	goto HAD_EARLY_ERROR
__38:
	;
	if !(options&DPCRE2_NO_UTF_CHECK == uint32(0) && libc.AssignPtrInt32(bp+17768, X_pcre2_valid_utf_8(tls, pattern, patlen, erroroffset)) != 0) {
		goto __39
	}
	goto HAD_ERROR
__39:
	; // Offset was set by valid_utf()

__37:
	;

	// Check UCP lockout.

	ucp = libc.Bool32((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fexternal_options&DPCRE2_UCP != uint32(0))
	if !(ucp != 0 && (*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fexternal_options&DPCRE2_NEVER_UCP != uint32(0)) {
		goto __40
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR75
	goto HAD_EARLY_ERROR
__40:
	;

	// Process the BSR setting.

	if !(bsr == 0) {
		goto __41
	}
	bsr = int32((*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fbsr_convention)
__41:
	;

	// Process the newline setting.

	if !(newline == 0) {
		goto __42
	}
	newline = int32((*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fnewline_convention)
__42:
	;
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnltype = uint32(DNLTYPE_FIXED)
	switch newline {
	case DPCRE2_NEWLINE_CR:
		goto __44

	case DPCRE2_NEWLINE_LF:
		goto __45

	case DPCRE2_NEWLINE_NUL:
		goto __46

	case DPCRE2_NEWLINE_CRLF:
		goto __47

	case DPCRE2_NEWLINE_ANY:
		goto __48

	case DPCRE2_NEWLINE_ANYCRLF:
		goto __49

	default:
		goto __50
	}
	goto __43

__44:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(bp + 17440 + 272)) = uint8('\015')
	goto __43

__45:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(bp + 17440 + 272)) = uint8('\012')
	goto __43

__46:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(bp + 17440 + 272)) = uint8(0)
	goto __43

__47:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnllen = uint32(2)
	*(*uint8)(unsafe.Pointer(bp + 17440 + 272)) = uint8('\015')
	*(*uint8)(unsafe.Pointer(bp + 17440 + 272 + 1)) = uint8('\012')
	goto __43

__48:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnltype = uint32(DNLTYPE_ANY)
	goto __43

__49:
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnltype = uint32(DNLTYPE_ANYCRLF)
	goto __43

__50:
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR56
	goto HAD_EARLY_ERROR
__43:
	;

	// Pre-scan the pattern to do two things: (1) Discover the named groups and
	// their numerical equivalents, so that this information is always available for
	// the remaining processing. (2) At the same time, parse the pattern and put a
	// processed version into the parsed_pattern vector. This has escapes interpreted
	// and comments removed (amongst other things).
	//
	// In all but one case, when PCRE2_AUTO_CALLOUT is not set, the number of unsigned
	// 32-bit ints in the parsed pattern is bounded by the length of the pattern plus
	// one (for the terminator) plus four if PCRE2_EXTRA_WORD or PCRE2_EXTRA_LINE is
	// set. The exceptional case is when running in 32-bit, non-UTF mode, when literal
	// characters greater than META_END (0x80000000) have to be coded as two units. In
	// this case, therefore, we scan the pattern to check for such values.

	// Ensure that the parsed pattern buffer is big enough. When PCRE2_AUTO_CALLOUT
	// is set we have to assume a numerical callout (4 elements) for each character
	// plus one at the end. This is overkill, but memory is plentiful these days. For
	// many smaller patterns the vector on the stack (which was set up above) can be
	// used.

	parsed_size_needed = patlen - uint64(skipatstart) + big32count

	if !((*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options&(DPCRE2_EXTRA_MATCH_WORD|DPCRE2_EXTRA_MATCH_LINE) != uint32(0)) {
		goto __51
	}
	parsed_size_needed = parsed_size_needed + uint64(4)
__51:
	;

	if !(options&DPCRE2_AUTO_CALLOUT != uint32(0)) {
		goto __52
	}
	parsed_size_needed = (parsed_size_needed + uint64(1)) * uint64(5)
__52:
	;

	if !(parsed_size_needed >= uint64(DPARSED_PATTERN_DEFAULT_SIZE)) {
		goto __53
	}

	heap_parsed_pattern = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls,
		(parsed_size_needed+uint64(1))*uint64(unsafe.Sizeof(uint32(0))), (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if !(heap_parsed_pattern == uintptr(0)) {
		goto __54
	}

	*(*int32)(unsafe.Pointer(errorptr)) = ERR21
	goto EXIT
__54:
	;
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern = heap_parsed_pattern
__53:
	;
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern_end = (*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fparsed_pattern + uintptr(parsed_size_needed)*4 + uintptr(1)*4

	// Do the parsing scan.

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = parse_regex(tls, ptr, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fexternal_options, bp+17744, bp+17440)
	if !(*(*int32)(unsafe.Pointer(bp + 17768)) != 0) {
		goto __55
	}
	goto HAD_CB_ERROR
__55:
	;

	// Workspace is needed to remember information about numbered groups: whether a
	// group can match an empty string and what its fixed length is. This is done to
	// avoid the possibility of recursive references causing very long compile times
	// when checking these features. Unnumbered groups do not have this exposure since
	// they cannot be referenced. We use an indexed vector for this purpose. If there
	// are sufficiently few groups, the default vector on the stack, as set up above,
	// can be used. Otherwise we have to get/free a special vector. The vector must be
	// initialized to zero.

	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fbracount >= uint32(DGROUPINFO_DEFAULT_SIZE)) {
		goto __56
	}

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fgroupinfo = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls,
		uint64((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fbracount+uint32(1))*uint64(unsafe.Sizeof(uint32(0))), (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fgroupinfo == uintptr(0)) {
		goto __57
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR21
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ferroroffset = uint64(0)
	goto HAD_CB_ERROR
__57:
	;
__56:
	;
	libc.Xmemset(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fgroupinfo, 0, uint64((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fbracount+uint32(1))*uint64(unsafe.Sizeof(uint32(0))))

	// If there were any lookbehinds, scan the parsed pattern to figure out their
	// lengths.

	if !(*(*int32)(unsafe.Pointer(bp + 17744)) != 0) {
		goto __58
	}

	*(*int32)(unsafe.Pointer(bp + 17748 /* loopcount */)) = 0
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = check_lookbehinds(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fparsed_pattern, uintptr(0), uintptr(0), bp+17440, bp+17748)
	if !(*(*int32)(unsafe.Pointer(bp + 17768)) != 0) {
		goto __59
	}
	goto HAD_CB_ERROR
__59:
	;
__58:
	;

	// For debugging, there is a function that shows the parsed data vector.

	// For debugging capturing information this code can be enabled.

	// Pretend to compile the pattern while actually just accumulating the amount
	// of memory required in the 'length' variable. This behaviour is triggered by
	// passing a non-NULL final argument to compile_regex(). We pass a block of
	// workspace (cworkspace) for it to compile parts of the pattern into; the
	// compiled code is discarded when it is no longer needed, so hopefully this
	// workspace will never overflow, though there is a test for its doing so.
	//
	// On error, errorcode will be set non-zero, so we don't need to look at the
	// result of the function. The initial options have been put into the cb block,
	// but we still have to pass a separate options variable (the first argument)
	// because the options may change as the pattern is processed.

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ferroroffset = patlen // For any subsequent errors that do not set it
	*(*uintptr)(unsafe.Pointer(bp + 17760 /* pptr */)) = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern
	*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)) = cworkspace
	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)))) = OP_BRA

	compile_regex(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fexternal_options, bp+17752, bp+17760, bp+17768, uint32(0), bp+17772,
		bp+17776, bp+17780, bp+17784, uintptr(0), bp+17440, bp+17792)

	if !(*(*int32)(unsafe.Pointer(bp + 17768)) != 0) {
		goto __60
	}
	goto HAD_CB_ERROR
__60:
	; // Offset is in cb.erroroffset

	// This should be caught in compile_regex(), but just in case...

	if !(*(*uint64)(unsafe.Pointer(bp + 17792)) > uint64(int32(1)<<16)) {
		goto __61
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR20
	goto HAD_CB_ERROR
__61:
	;

	// Compute the size of, and then get and initialize, the data block for storing
	// the compiled pattern and names table. Integer overflow should no longer be
	// possible because nowadays we limit the maximum value of cb.names_found and
	// cb.name_entry_size.

	re_blocksize = uint64(unsafe.Sizeof(Tpcre2_real_code_8{})) + (*(*uint64)(unsafe.Pointer(bp + 17792))+uint64((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fnames_found)*uint64((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fname_entry_size))*uint64(DPCRE2_CODE_UNIT_WIDTH/8)
	re = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls, re_blocksize, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if !(re == uintptr(0)) {
		goto __62
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR21
	goto HAD_CB_ERROR
__62:
	;

	// The compiler may put padding at the end of the pcre2_real_code structure in
	// order to round it up to a multiple of 4 or 8 bytes. This means that when a
	// compiled pattern is copied (for example, when serialized) undefined bytes are
	// read, and this annoys debuggers such as valgrind. To avoid this, we explicitly
	// write to the last 8 bytes of the structure before setting the fields.

	libc.Xmemset(tls, re+uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))-uintptr(8), 0, uint64(8))
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmemctl = (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables = tables
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fexecutable_jit = uintptr(0)
	libc.Xmemset(tls, re+40, 0, uint64(32)*uint64(unsafe.Sizeof(uint8(0))))
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize = re_blocksize
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number = uint32(DMAGIC_NUMBER)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fcompile_options = options
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fexternal_options
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fextra_options = (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags = uint32(DPCRE2_CODE_UNIT_WIDTH/8) | (*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fexternal_flags | setflags
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap = limit_heap
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match = limit_match
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth = limit_depth
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit = uint32(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit = uint32(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fbsr_convention = uint16(bsr)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fnewline_convention = uint16(newline)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind = uint16(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength = uint16(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket = uint16(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_backref = uint16(0)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fname_entry_size
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnames_found

	// The basic block is immediately followed by the name table, and the compiled
	// code follows after that.

	codestart = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) + uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count))

	// Update the compile data block for the actual compile. The starting points of
	// the name/number translation table and of the code are passed around in the
	// compile data block. The start/end pattern and initial options are already set
	// from the pre-compile phase, as is the name_entry_size field.

	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparens_depth = uint16(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fassert_depth = uint16(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Flastcapture = uint32(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fname_table = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fstart_code = codestart
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Freq_varyopt = uint32(0)
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fhad_accept = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fhad_pruneorskip = DFALSE
	(*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fopen_caps = uintptr(0)

	// If any named groups were found, create the name/number table from the list
	// created in the pre-pass.

	if !(int32((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fnames_found) > 0) {
		goto __63
	}

	ng = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fnamed_groups
	i = uint32(0)
__64:
	if !(i < uint32((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fnames_found)) {
		goto __66
	}
	add_name_to_table(tls, bp+17440, (*Tnamed_group_8)(unsafe.Pointer(ng)).Fname, int32((*Tnamed_group_8)(unsafe.Pointer(ng)).Flength), (*Tnamed_group_8)(unsafe.Pointer(ng)).Fnumber, i)
	goto __65
__65:
	i++
	ng += 16
	goto __64
	goto __66
__66:
	;
__63:
	;

	// Set up a starting, non-extracting bracket, then compile the expression. On
	// error, errorcode will be set non-zero, so we don't need to look at the result
	// of the function here.

	*(*uintptr)(unsafe.Pointer(bp + 17760 /* pptr */)) = (*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fparsed_pattern
	*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)) = codestart
	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)))) = OP_BRA
	regexrc = compile_regex(tls, (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options, bp+17752, bp+17760, bp+17768, uint32(0),
		bp+17772, bp+17776, bp+17780, bp+17784, uintptr(0), bp+17440, uintptr(0))
	if !(regexrc < 0) {
		goto __67
	}
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_MATCH_EMPTY)
__67:
	;
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket = uint16((*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fbracount)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_backref = uint16((*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Ftop_backref)
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind = uint16((*Tcompile_block_8)(unsafe.Pointer(bp + 17440 /* &cb */)).Fmax_lookbehind)

	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fhad_accept != 0) {
		goto __68
	}

	*(*uint32)(unsafe.Pointer(bp + 17780 /* reqcu */)) = uint32(0) // Must disable after (*ACCEPT)
	*(*uint32)(unsafe.Pointer(bp + 17784 /* reqcuflags */)) = DREQ_NONE
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_HASACCEPT) // Disables minimum length
__68:
	;

	// Fill in the final opcode and check for disastrous overflow. If no overflow,
	// but the estimated length exceeds the really used length, adjust the value of
	// re->blocksize, and if valgrind support is configured, mark the extra allocated
	// memory as unaddressable, so that any out-of-bound reads can be detected.

	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 17752 /* code */)), 1))) = OP_END
	usedlength = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 17752))) - int64(codestart)) / 1)
	if !(usedlength > *(*uint64)(unsafe.Pointer(bp + 17792))) {
		goto __69
	}
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR23
	goto __70
__69:

	*(*uint64)(unsafe.Pointer(re + 72)) -= (*(*uint64)(unsafe.Pointer(bp + 17792)) - usedlength) * uint64(DPCRE2_CODE_UNIT_WIDTH/8)
__70:
	;

	// Scan the pattern for recursion/subroutine calls and convert the group
	// numbers into offsets. Maintain a small cache so that repeated groups containing
	// recursions are efficiently handled.

	if !(*(*int32)(unsafe.Pointer(bp + 17768)) == 0 && (*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fhad_recurse != 0) {
		goto __71
	}

	ccount = uint32(0)
	start = DRSCAN_CACHE_SIZE

	rcode = find_recurse(tls, codestart, utf)
__72:
	if !(rcode != uintptr(0)) {
		goto __74
	}

	groupnumber = int32(uint32(int32(*(*uint8)(unsafe.Pointer(rcode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(rcode + 2)))))
	if !(groupnumber == 0) {
		goto __75
	}
	rgroup = codestart
	goto __76
__75:

	search_from = codestart
	rgroup = uintptr(0)
	i = uint32(0)
	p1 = start
__77:
	if !(i < ccount) {
		goto __79
	}

	if !(groupnumber == (*Trecurse_cache)(unsafe.Pointer(bp+17800+uintptr(p1)*16)).Fgroupnumber) {
		goto __80
	}

	rgroup = (*Trecurse_cache)(unsafe.Pointer(bp + 17800 + uintptr(p1)*16)).Fgroup
	goto __79
__80:
	;

	// Group n+1 must always start to the right of group n, so we can save
	//         search time below when the new group number is greater than any of the
	//         previously found groups.

	if !(groupnumber > (*Trecurse_cache)(unsafe.Pointer(bp+17800+uintptr(p1)*16)).Fgroupnumber) {
		goto __81
	}
	search_from = (*Trecurse_cache)(unsafe.Pointer(bp + 17800 + uintptr(p1)*16)).Fgroup
__81:
	;
	goto __78
__78:
	i++
	p1 = (p1 + 1) & 7
	goto __77
	goto __79
__79:
	;

	if !(rgroup == uintptr(0)) {
		goto __82
	}

	rgroup = X_pcre2_find_bracket_8(tls, search_from, utf, groupnumber)
	if !(rgroup == uintptr(0)) {
		goto __83
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR53
	goto __74
__83:
	;
	if !(libc.PreDecInt32(&start, 1) < 0) {
		goto __84
	}
	start = DRSCAN_CACHE_SIZE - 1
__84:
	;
	(*Trecurse_cache)(unsafe.Pointer(bp + 17800 + uintptr(start)*16)).Fgroupnumber = groupnumber
	(*Trecurse_cache)(unsafe.Pointer(bp + 17800 + uintptr(start)*16)).Fgroup = rgroup
	if !(ccount < uint32(DRSCAN_CACHE_SIZE)) {
		goto __85
	}
	ccount++
__85:
	;
__82:
	;
__76:
	;

	*(*uint8)(unsafe.Pointer(rcode + 1)) = uint8((int64(rgroup) - int64(codestart)) / 1 >> 8)
	*(*uint8)(unsafe.Pointer(rcode + 2)) = uint8((int64(rgroup) - int64(codestart)) / 1 & int64(255))
	goto __73
__73:
	rcode = find_recurse(tls, rcode+uintptr(1)+uintptr(DLINK_SIZE), utf)
	goto __72
	goto __74
__74:
	;
__71:
	;

	// In rare debugging situations we sometimes need to look at the compiled code
	// at this stage.

	// Unless disabled, check whether any single character iterators can be
	// auto-possessified. The function overwrites the appropriate opcode values, so
	// the type of the pointer must be cast. NOTE: the intermediate variable "temp" is
	// used in this code because at least one compiler gives a warning about loss of
	// "const" attribute if the cast (PCRE2_UCHAR *)codestart is used directly in the
	// function call.

	if !(*(*int32)(unsafe.Pointer(bp + 17768)) == 0 && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_NO_AUTO_POSSESS == uint32(0)) {
		goto __86
	}

	temp = codestart
	if !(X_pcre2_auto_possessify_8(tls, temp, bp+17440) != 0) {
		goto __87
	}
	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR80
__87:
	;
__86:
	;

	// Failed to compile, or error while post-processing.

	if !(*(*int32)(unsafe.Pointer(bp + 17768)) != 0) {
		goto __88
	}
	goto HAD_CB_ERROR
__88:
	;

	// Successful compile. If the anchored option was not passed, set it if
	// we can determine that the pattern is anchored by virtue of ^ characters or \A
	// or anything else, such as starting with non-atomic .* when DOTALL is set and
	// there are no occurrences of *PRUNE or *SKIP (though there is an option to
	// disable this case).

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_ANCHORED == uint32(0) && is_anchored(tls, codestart, uint32(0), bp+17440, 0, DFALSE) != 0) {
		goto __89
	}
	*(*uint32)(unsafe.Pointer(re + 88)) |= DPCRE2_ANCHORED
__89:
	;

	// Set up the first code unit or startline flag, the required code unit, and
	// then study the pattern. This code need not be obeyed if PCRE2_NO_START_OPTIMIZE
	// is set, as the data it would create will not be used. Note that a first code
	// unit (but not the startline flag) is useful for anchored patterns because it
	// can still give a quick "no match" and also avoid searching for a last code
	// unit.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_NO_START_OPTIMIZE == uint32(0)) {
		goto __90
	}

	minminlength = 0 // For minimal minlength from first/required CU

	// If we do not have a first code unit, see if there is one that is asserted
	//   (these are not saved during the compile because they can cause conflicts with
	//   actual literals that follow).

	if !(*(*uint32)(unsafe.Pointer(bp + 17776)) >= DREQ_NONE) {
		goto __91
	}
	*(*uint32)(unsafe.Pointer(bp + 17772 /* firstcu */)) = find_firstassertedcu(tls, codestart, bp+17776, uint32(0))
__91:
	;

	// Save the data for a first code unit. The existence of one means the
	//   minimum length must be at least 1.

	if !(*(*uint32)(unsafe.Pointer(bp + 17776)) < DREQ_NONE) {
		goto __92
	}

	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit = *(*uint32)(unsafe.Pointer(bp + 17772 /* firstcu */))
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_FIRSTSET)
	minminlength++

	// Handle caseless first code units.

	if !(*(*uint32)(unsafe.Pointer(bp + 17776))&DREQ_CASELESS != uint32(0)) {
		goto __94
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 17772)) < uint32(128) || !(utf != 0) && !(ucp != 0) && *(*uint32)(unsafe.Pointer(bp + 17772)) < uint32(255)) {
		goto __95
	}

	if !(uint32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Ffcc + uintptr(*(*uint32)(unsafe.Pointer(bp + 17772)))))) != *(*uint32)(unsafe.Pointer(bp + 17772))) {
		goto __97
	}
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_FIRSTCASELESS)
__97:
	;
	goto __96
__95:
	if !(ucp != 0 && !(utf != 0) && uint32(int32(*(*uint32)(unsafe.Pointer(bp + 17772)))+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*uint32)(unsafe.Pointer(bp + 17772)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*uint32)(unsafe.Pointer(bp + 17772)))%DUCD_BLOCK_SIZE])*12)).Fother_case) != *(*uint32)(unsafe.Pointer(bp + 17772))) {
		goto __98
	}
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_FIRSTCASELESS)
__98:
	;
__96:
	;
__94:
	;
	goto __93
__92:
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_ANCHORED == uint32(0) && is_startline(tls, codestart, uint32(0), bp+17440, 0, DFALSE) != 0) {
		goto __99
	}
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_STARTLINE)
__99:
	;
__93:
	;

	// Handle the "required code unit", if one is set. In the UTF case we can
	//   increment the minimum minimum length only if we are sure this really is a
	//   different character and not a non-starting code unit of the first character,
	//   because the minimum length count is in characters, not code units.

	if !(*(*uint32)(unsafe.Pointer(bp + 17784)) < DREQ_NONE) {
		goto __100
	}

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF == uint32(0) || *(*uint32)(unsafe.Pointer(bp + 17776)) >= DREQ_NONE || *(*uint32)(unsafe.Pointer(bp + 17772))&uint32(0x80) == uint32(0) || *(*uint32)(unsafe.Pointer(bp + 17780))&uint32(0x80) == uint32(0)) {
		goto __101
	} /* Req is ASCII */

	minminlength++
__101:
	;

	// In the case of an anchored pattern, set up the value only if it follows
	//     a variable length item in the pattern.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_ANCHORED == uint32(0) || *(*uint32)(unsafe.Pointer(bp + 17784))&DREQ_VARY != uint32(0)) {
		goto __102
	}

	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit = *(*uint32)(unsafe.Pointer(bp + 17780 /* reqcu */))
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_LASTSET)

	// Handle caseless required code units as for first code units (above).

	if !(*(*uint32)(unsafe.Pointer(bp + 17784))&DREQ_CASELESS != uint32(0)) {
		goto __103
	}

	if !(*(*uint32)(unsafe.Pointer(bp + 17780)) < uint32(128) || !(utf != 0) && !(ucp != 0) && *(*uint32)(unsafe.Pointer(bp + 17780)) < uint32(255)) {
		goto __104
	}

	if !(uint32(*(*uint8)(unsafe.Pointer((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Ffcc + uintptr(*(*uint32)(unsafe.Pointer(bp + 17780)))))) != *(*uint32)(unsafe.Pointer(bp + 17780))) {
		goto __106
	}
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_LASTCASELESS)
__106:
	;
	goto __105
__104:
	if !(ucp != 0 && !(utf != 0) && uint32(int32(*(*uint32)(unsafe.Pointer(bp + 17780)))+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*uint32)(unsafe.Pointer(bp + 17780)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*uint32)(unsafe.Pointer(bp + 17780)))%DUCD_BLOCK_SIZE])*12)).Fother_case) != *(*uint32)(unsafe.Pointer(bp + 17780))) {
		goto __107
	}
	*(*uint32)(unsafe.Pointer(re + 96)) |= uint32(DPCRE2_LASTCASELESS)
__107:
	;
__105:
	;
__103:
	;
__102:
	;
__100:
	;

	// Study the compiled pattern to set up information such as a bitmap of
	//   starting code units and a minimum matching length.

	if !(X_pcre2_study_8(tls, re) != 0) {
		goto __108
	}

	*(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */)) = ERR31
	goto HAD_CB_ERROR
__108:
	;

	// If study() set a bitmap of starting code units, it implies a minimum
	//   length of at least one.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTMAPSET) != uint32(0) && minminlength == 0) {
		goto __109
	}
	minminlength = 1
__109:
	;

	// If the minimum length set (or not set) by study() is less than the minimum
	//   implied by required code units, override it.

	if !(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength) < minminlength) {
		goto __110
	}
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength = uint16(minminlength)
__110:
	;
__90:
	; // End of start-of-match optimizations.

	// Control ends up here in all cases. When running under valgrind, make a
	// pattern's terminating zero defined again. If memory was obtained for the parsed
	// version of the pattern, free it before returning. Also free the list of named
	// groups if a larger one had to be obtained, and likewise the group information
	// vector.

EXIT:
	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fparsed_pattern != bp+13344) {
		goto __111
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fparsed_pattern, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
__111:
	;
	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fnamed_group_list_size > uint32(DNAMED_GROUP_LIST_SIZE)) {
		goto __112
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fnamed_groups, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
__112:
	;
	if !((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Fgroupinfo != bp+12000) {
		goto __113
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, (*Tcompile_block_8)(unsafe.Pointer(bp+17440 /* &cb */)).Fgroupinfo, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
__113:
	;
	return re // Will be NULL after an error

	// Errors discovered in parse_regex() set the offset value in the compile
	// block. Errors discovered before it is called must compute it from the ptr
	// value. After parse_regex() is called, the offset in the compile block is set to
	// the end of the pattern, but certain errors in compile_regex() may reset it if
	// an offset is available in the parsed pattern.

HAD_CB_ERROR:
	ptr = pattern + uintptr((*Tcompile_block_8)(unsafe.Pointer(bp+17440)).Ferroroffset)

HAD_EARLY_ERROR:
	*(*uint64)(unsafe.Pointer(erroroffset)) = uint64((int64(ptr) - int64(pattern)) / 1)

HAD_ERROR:
	*(*int32)(unsafe.Pointer(errorptr)) = *(*int32)(unsafe.Pointer(bp + 17768 /* errorcode */))
	Xpcre2_code_free_8(tls, re)
	re = uintptr(0)
	goto EXIT
	return uintptr(0)
}

// These #undefs are here to enable unity builds with CMake.

// End of pcre2_compile.c

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2020 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// src/config.h.  Generated from config.h.in by configure.
// src/config.h.in.  Generated from configure.ac by autoheader.

// PCRE2 is written in Standard C, but there are a few non-standard things it
// can cope with, allowing it to run on SunOS4 and other "close to standard"
// systems.
//
// In environments that support the GNU autotools, config.h.in is converted into
// config.h by the "configure" script. In environments that use CMake,
// config-cmake.in is converted into config.h. If you are going to build PCRE2 "by
// hand" without using "configure" or CMake, you should copy the distributed
// config.h.generic to config.h, and edit the macro definitions to be the way you
// need them. You must then add -DHAVE_CONFIG_H to all of your compile commands,
// so that config.h is included at the start of every source.
//
// Alternatively, you can avoid editing by using -D on the compiler command line
// to set the macro values. In this case, you do not have to set -DHAVE_CONFIG_H,
// but if you do, default values will be taken from config.h for non-boolean
// macros that are not defined on the command line.
//
// Boolean macros such as HAVE_STDLIB_H and SUPPORT_PCRE2_8 should either be
// defined (conventionally to 1) for TRUE, and not defined at all for FALSE. All
// such macros are listed as a commented #undef in config.h.generic. Macros such
// as MATCH_LIMIT, whose actual value is relevant, have defaults defined, but are
// surrounded by #ifndef/#endif lines so that the value can be overridden by -D.
//
// PCRE2 uses memmove() if HAVE_MEMMOVE is defined; otherwise it uses bcopy() if
// HAVE_BCOPY is defined. If your system has neither bcopy() nor memmove(), make
// sure both macros are undefined; an emulation function will then be used.

// By default, the \R escape sequence matches any Unicode line ending
//    character or sequence of characters. If BSR_ANYCRLF is defined (to any
//    value), this is changed so that backslash-R matches only CR, LF, or CRLF.
//    The build-time default can be overridden by the user of PCRE2 at runtime.
//
// #undef BSR_ANYCRLF

// Define to any value to disable the use of the z and t modifiers in
//    formatting settings such as %zu or %td (this is rarely needed).
// #undef DISABLE_PERCENT_ZT

// If you are compiling for a system that uses EBCDIC instead of ASCII
//    character codes, define this macro to any value. When EBCDIC is set, PCRE2
//    assumes that all input strings are in EBCDIC. If you do not define this
//    macro, PCRE2 will assume input strings are ASCII or UTF-8/16/32 Unicode. It
//    is not possible to build a version of PCRE2 that supports both EBCDIC and
//    UTF-8/16/32.
// #undef EBCDIC

// In an EBCDIC environment, define this macro to any value to arrange for the
//    NL character to be 0x25 instead of the default 0x15. NL plays the role that
//    LF does in an ASCII/Unicode environment.
// #undef EBCDIC_NL25

// Define this if your compiler supports __attribute__((uninitialized))

// Define to 1 if you have the `bcopy' function.

// Define to 1 if you have the <bzlib.h> header file.

// Define to 1 if you have the <dirent.h> header file.

// Define to 1 if you have the <dlfcn.h> header file.

// Define to 1 if you have the <editline/readline.h> header file.
// #undef HAVE_EDITLINE_READLINE_H

// Define to 1 if you have the <edit/readline/readline.h> header file.
// #undef HAVE_EDIT_READLINE_READLINE_H

// Define to 1 if you have the <inttypes.h> header file.

// Define to 1 if you have the <limits.h> header file.

// Define to 1 if you have the `memfd_create' function.

// Define to 1 if you have the `memmove' function.

// Define to 1 if you have the <minix/config.h> header file.
// #undef HAVE_MINIX_CONFIG_H

// Define to 1 if you have the `mkostemp' function.

// Define if you have POSIX threads libraries and header files.
// #undef HAVE_PTHREAD

// Have PTHREAD_PRIO_INHERIT.
// #undef HAVE_PTHREAD_PRIO_INHERIT

// Define to 1 if you have the <readline.h> header file.
// #undef HAVE_READLINE_H

// Define to 1 if you have the <readline/history.h> header file.
// #undef HAVE_READLINE_HISTORY_H

// Define to 1 if you have the <readline/readline.h> header file.
// #undef HAVE_READLINE_READLINE_H

// Define to 1 if you have the `realpath' function.

// Define to 1 if you have the `secure_getenv' function.

// Define to 1 if you have the <stdint.h> header file.

// Define to 1 if you have the <stdio.h> header file.

// Define to 1 if you have the <stdlib.h> header file.

// Define to 1 if you have the `strerror' function.

// Define to 1 if you have the <strings.h> header file.

// Define to 1 if you have the <string.h> header file.

// Define to 1 if you have the <sys/stat.h> header file.

// Define to 1 if you have the <sys/types.h> header file.

// Define to 1 if you have the <sys/wait.h> header file.

// Define to 1 if you have the <unistd.h> header file.

// Define to 1 if the compiler supports simple visibility declarations.

// Define to 1 if you have the <wchar.h> header file.

// Define to 1 if you have the <windows.h> header file.
// #undef HAVE_WINDOWS_H

// Define to 1 if you have the <zlib.h> header file.

// This limits the amount of memory that may be used while matching a pattern.
//    It applies to both pcre2_match() and pcre2_dfa_match(). It does not apply
//    to JIT matching. The value is in kibibytes (units of 1024 bytes).

// The value of LINK_SIZE determines the number of bytes used to store links
//    as offsets within the compiled regex. The default is 2, which allows for
//    compiled patterns up to 65535 code units long. This covers the vast
//    majority of cases. However, PCRE2 can also be compiled to use 3 or 4 bytes
//    instead. This allows for longer patterns in extreme cases.

// Define to the sub-directory where libtool stores uninstalled libraries.

// The value of MATCH_LIMIT determines the default number of times the
//    pcre2_match() function can record a backtrack position during a single
//    matching attempt. The value is also used to limit a loop counter in
//    pcre2_dfa_match(). There is a runtime interface for setting a different
//    limit. The limit exists in order to catch runaway regular expressions that
//    take for ever to determine that they do not match. The default is set very
//    large so that it does not accidentally catch legitimate cases.

// The above limit applies to all backtracks, whether or not they are nested.
//    In some environments it is desirable to limit the nesting of backtracking
//    (that is, the depth of tree that is searched) more strictly, in order to
//    restrict the maximum amount of heap memory that is used. The value of
//    MATCH_LIMIT_DEPTH provides this facility. To have any useful effect, it
//    must be less than the value of MATCH_LIMIT. The default is to use the same
//    value as MATCH_LIMIT. There is a runtime method for setting a different
//    limit. In the case of pcre2_dfa_match(), this limit controls the depth of
//    the internal nested function calls that are used for pattern recursions,
//    lookarounds, and atomic groups.

// This limit is parameterized just in case anybody ever wants to change it.
//    Care must be taken if it is increased, because it guards against integer
//    overflow caused by enormously large patterns.

// This limit is parameterized just in case anybody ever wants to change it.
//    Care must be taken if it is increased, because it guards against integer
//    overflow caused by enormously large patterns.

// Defining NEVER_BACKSLASH_C locks out the use of \C in all patterns.
// #undef NEVER_BACKSLASH_C

// The value of NEWLINE_DEFAULT determines the default newline character
//    sequence. PCRE2 client programs can override this by selecting other values
//    at run time. The valid values are 1 (CR), 2 (LF), 3 (CRLF), 4 (ANY), 5
//    (ANYCRLF), and 6 (NUL).

// Name of package

// Define to the address where bug reports for this package should be sent.

// Define to the full name of this package.

// Define to the full name and version of this package.

// Define to the one symbol short name of this package.

// Define to the home page for this package.

// Define to the version of this package.

// The value of PARENS_NEST_LIMIT specifies the maximum depth of nested
//    parentheses (of any kind) in a pattern. This limits the amount of system
//    stack that is used while compiling a pattern.

// The value of PCRE2GREP_BUFSIZE is the starting size of the buffer used by
//    pcre2grep to hold parts of the file it is searching. The buffer will be
//    expanded up to PCRE2GREP_MAX_BUFSIZE if necessary, for files containing
//    very long lines. The actual amount of memory used by pcre2grep is three
//    times this number, because it allows for the buffering of "before" and
//    "after" lines.

// The value of PCRE2GREP_MAX_BUFSIZE specifies the maximum size of the buffer
//    used by pcre2grep to hold parts of the file it is searching. The actual
//    amount of memory used by pcre2grep is three times this number, because it
//    allows for the buffering of "before" and "after" lines.

// to make a symbol visible

// to make a symbol visible

// Define to any value to include debugging code.
// #undef PCRE2_DEBUG

// to make a symbol visible

// If you are compiling for a system other than a Unix-like system or
//    Win32, and it needs some magic to be inserted before the definition
//    of a function that is exported by the library, define this macro to
//    contain the relevant magic. If you do not define this macro, a suitable
//     __declspec value is used for Windows systems; in other environments
//    "extern" is used for a C compiler and "extern C" for a C++ compiler.
//    This macro apears at the start of every exported function that is part
//    of the external API. It does not appear on functions that are "external"
//    in the C sense, but which are internal to the library.

// Define to any value if linking statically (TODO: make nice with Libtool)

// Define to necessary symbol if this constant uses a non-standard name on
//    your system.
// #undef PTHREAD_CREATE_JOINABLE

// Define to any non-zero number to enable support for SELinux compatible
//    executable memory allocator in JIT. Note that this will have no effect
//    unless SUPPORT_JIT is also defined.
// #undef SLJIT_PROT_EXECUTABLE_ALLOCATOR

// Define to 1 if all of the C90 standard headers exist (not just the ones
//    required in a freestanding environment). This macro is provided for
//    backward compatibility; new code need not use it.

// Define to any value to enable support for Just-In-Time compiling.
// #undef SUPPORT_JIT

// Define to any value to allow pcre2grep to be linked with libbz2, so that it
//    is able to handle .bz2 files.
// #undef SUPPORT_LIBBZ2

// Define to any value to allow pcre2test to be linked with libedit.
// #undef SUPPORT_LIBEDIT

// Define to any value to allow pcre2test to be linked with libreadline.
// #undef SUPPORT_LIBREADLINE

// Define to any value to allow pcre2grep to be linked with libz, so that it
//    is able to handle .gz files.
// #undef SUPPORT_LIBZ

// Define to any value to enable callout script support in pcre2grep.

// Define to any value to enable fork support in pcre2grep callout scripts.
//    This will have no effect unless SUPPORT_PCRE2GREP_CALLOUT is also defined.
//

// Define to any value to enable JIT support in pcre2grep. Note that this will
//    have no effect unless SUPPORT_JIT is also defined.
// #undef SUPPORT_PCRE2GREP_JIT

// Define to any value to enable the 16 bit PCRE2 library.
// #undef SUPPORT_PCRE2_16

// Define to any value to enable the 32 bit PCRE2 library.
// #undef SUPPORT_PCRE2_32

// Define to any value to enable the 8 bit PCRE2 library.

// Define to any value to enable support for Unicode and UTF encoding. This
//    will work even in an EBCDIC environment, but it is incompatible with the
//    EBCDIC macro. That is, PCRE2 can support *either* EBCDIC code *or*
//    ASCII/Unicode, but not both at once.

// Define to any value for valgrind support to find invalid memory reads.
// #undef SUPPORT_VALGRIND

// Enable extensions on AIX 3, Interix.
// Enable general extensions on macOS.
// Enable general extensions on Solaris.
// Enable GNU extensions on systems that have them.
// Enable X/Open compliant socket functions that do not require linking
//    with -lxnet on HP-UX 11.11.
// Identify the host operating system as Minix.
//    This macro does not affect the system headers' behavior.
//    A future release of Autoconf may stop defining this macro.
// # undef _MINIX
// Enable general extensions on NetBSD.
//    Enable NetBSD compatibility extensions on Minix.
// Enable OpenBSD compatibility extensions on NetBSD.
//    Oddly enough, this does nothing on OpenBSD.
// Define to 1 if needed for POSIX-compatible behavior.
// # undef _POSIX_SOURCE
// Define to 2 if needed for POSIX-compatible behavior.
// # undef _POSIX_1_SOURCE
// Enable POSIX-compatible threading on Solaris.
// Enable extensions specified by ISO/IEC TS 18661-5:2014.
// Enable extensions specified by ISO/IEC TS 18661-1:2014.
// Enable extensions specified by ISO/IEC TS 18661-2:2015.
// Enable extensions specified by ISO/IEC TS 18661-4:2015.
// Enable extensions specified by ISO/IEC TS 18661-3:2015.
// Enable extensions specified by ISO/IEC TR 24731-2:2010.
// Enable extensions specified by ISO/IEC 24747:2009.
// Enable extensions on HP NonStop.
// Enable X/Open extensions.  Define to 500 only if necessary
//    to make mbstate_t available.
// # undef _XOPEN_SOURCE

// Version number of package

// Number of bits in a file offset, on hosts where this is settable.
// #undef _FILE_OFFSET_BITS

// Define for large files, on AIX-style hosts.
// #undef _LARGE_FILES

// Define to empty if `const' does not conform to ANSI C.
// #undef const

// Define to the type of a signed integer type of width exactly 64 bits if
//    such a type exists and the standard includes do not define it.
// #undef int64_t

// Define to `unsigned int' if <sys/types.h> does not define.
// #undef size_t

// Save the configured link size, which is in bytes. In 16-bit and 32-bit modes
// its value gets changed by pcre2_intmodedep.h (included by pcre2_internal.h) to
// be in code units.

var configured_link_size int32 = DLINK_SIZE /* pcre2_config.c:49:12 */

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// These macros are the standard way of turning unquoted text into C strings.
// They allow macros like PCRE2_MAJOR to be defined without quotes, which is
// convenient for user programs that want to test their values.

// ************************************************
//
// Return info about what features are configured *
//

// If where is NULL, the length of memory required is returned.
//
// Arguments:
//   what             what information is required
//   where            where to put the information
//
// Returns:           0 if a numerical value is returned
//                    >= 0 if a string value
//                    PCRE2_ERROR_BADOPTION if "where" not recognized
//                      or JIT target requested when JIT not enabled

func Xpcre2_config_8(tls *libc.TLS, what uint32, where uintptr) int32 { /* pcre2_config.c:78:1: */
	if where == uintptr(0) {
		switch what {
		default:
			return -34
			fallthrough

		case uint32(DPCRE2_CONFIG_BSR):
			fallthrough
		case uint32(DPCRE2_CONFIG_COMPILED_WIDTHS):
			fallthrough
		case uint32(DPCRE2_CONFIG_DEPTHLIMIT):
			fallthrough
		case uint32(DPCRE2_CONFIG_HEAPLIMIT):
			fallthrough
		case uint32(DPCRE2_CONFIG_JIT):
			fallthrough
		case uint32(DPCRE2_CONFIG_LINKSIZE):
			fallthrough
		case uint32(DPCRE2_CONFIG_MATCHLIMIT):
			fallthrough
		case uint32(DPCRE2_CONFIG_NEVER_BACKSLASH_C):
			fallthrough
		case uint32(DPCRE2_CONFIG_NEWLINE):
			fallthrough
		case uint32(DPCRE2_CONFIG_PARENSLIMIT):
			fallthrough
		case uint32(DPCRE2_CONFIG_STACKRECURSE):
			fallthrough // Obsolete
		case uint32(DPCRE2_CONFIG_TABLES_LENGTH):
			fallthrough
		case uint32(DPCRE2_CONFIG_UNICODE):
			return int32(unsafe.Sizeof(uint32(0)))
			fallthrough

		// These are handled below

		case uint32(DPCRE2_CONFIG_JITTARGET):
			fallthrough
		case uint32(DPCRE2_CONFIG_UNICODE_VERSION):
			fallthrough
		case uint32(DPCRE2_CONFIG_VERSION):
			break
		}
	}

	switch what {
	default:
		return -34

	case uint32(DPCRE2_CONFIG_BSR):
		*(*uint32)(unsafe.Pointer(where)) = uint32(DPCRE2_BSR_UNICODE)
		break

	case uint32(DPCRE2_CONFIG_COMPILED_WIDTHS):
		*(*uint32)(unsafe.Pointer(where)) = uint32(0 +
			1)
		break

	case uint32(DPCRE2_CONFIG_DEPTHLIMIT):
		*(*uint32)(unsafe.Pointer(where)) = uint32(DMATCH_LIMIT)
		break

	case uint32(DPCRE2_CONFIG_HEAPLIMIT):
		*(*uint32)(unsafe.Pointer(where)) = uint32(DHEAP_LIMIT)
		break

	case uint32(DPCRE2_CONFIG_JIT):
		*(*uint32)(unsafe.Pointer(where)) = uint32(0)
		break

	case uint32(DPCRE2_CONFIG_JITTARGET):
		return -34

	case uint32(DPCRE2_CONFIG_LINKSIZE):
		*(*uint32)(unsafe.Pointer(where)) = uint32(configured_link_size)
		break

	case uint32(DPCRE2_CONFIG_MATCHLIMIT):
		*(*uint32)(unsafe.Pointer(where)) = uint32(DMATCH_LIMIT)
		break

	case uint32(DPCRE2_CONFIG_NEWLINE):
		*(*uint32)(unsafe.Pointer(where)) = uint32(DNEWLINE_DEFAULT)
		break

	case uint32(DPCRE2_CONFIG_NEVER_BACKSLASH_C):
		*(*uint32)(unsafe.Pointer(where)) = uint32(0)
		break

	case uint32(DPCRE2_CONFIG_PARENSLIMIT):
		*(*uint32)(unsafe.Pointer(where)) = uint32(DPARENS_NEST_LIMIT)
		break

	// This is now obsolete. The stack is no longer used via recursion for
	//   handling backtracking in pcre2_match().

	case uint32(DPCRE2_CONFIG_STACKRECURSE):
		*(*uint32)(unsafe.Pointer(where)) = uint32(0)
		break

	case uint32(DPCRE2_CONFIG_TABLES_LENGTH):
		*(*uint32)(unsafe.Pointer(where)) = uint32(Dcbits_offset + Dcbit_length + 256)
		break

	case uint32(DPCRE2_CONFIG_UNICODE_VERSION):
		{
			var v uintptr = X_pcre2_unicode_version_8
			return int32(uint64(1) + func() uint64 {
				if where == uintptr(0) {
					return libc.Xstrlen(tls, v)
				}
				return X_pcre2_strcpy_c8_8(tls, where, v)
			}())

		}
		break

	case uint32(DPCRE2_CONFIG_UNICODE):
		*(*uint32)(unsafe.Pointer(where)) = uint32(1)
		break

	// The hackery in setting "v" below is to cope with the case when
	//   PCRE2_PRERELEASE is set to an empty string (which it is for real releases).
	//   If the second alternative is used in this case, it does not leave a space
	//   before the date. On the other hand, if all four macros are put into a single
	//   XSTRING when PCRE2_PRERELEASE is not empty, an unwanted space is inserted.
	//   There are problems using an "obvious" approach like this:
	//
	//      XSTRING(PCRE2_MAJOR) "." XSTRING(PCRE_MINOR)
	//      XSTRING(PCRE2_PRERELEASE) " " XSTRING(PCRE_DATE)
	//
	//   because, when PCRE2_PRERELEASE is empty, this leads to an attempted expansion
	//   of STRING(). The C standard states: "If (before argument substitution) any
	//   argument consists of no preprocessing tokens, the behavior is undefined." It
	//   turns out the gcc treats this case as a single empty string - which is what
	//   we really want - but Visual C grumbles about the lack of an argument for the
	//   macro. Unfortunately, both are within their rights. As there seems to be no
	//   way to test for a macro's value being empty at compile time, we have to
	//   resort to a runtime test.

	case uint32(DPCRE2_CONFIG_VERSION):
		{
			var v uintptr
			if int32(*(*int8)(unsafe.Pointer(ts + 630 + 1))) == 0 {
				v = ts + 632 /* "10.42 2022-12-11" */
			} else {
				v = ts + 649 /* "10.422022-12-11" */
			}
			return int32(uint64(1) + func() uint64 {
				if where == uintptr(0) {
					return libc.Xstrlen(tls, v)
				}
				return X_pcre2_strcpy_c8_8(tls, where, v)
			}())

		}
	}

	return 0
}

// End of pcre2_config.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//          Default malloc/free functions         *
//

// Ignore the "user data" argument in each case.

func default_malloc(tls *libc.TLS, size uint64, data uintptr) uintptr { /* pcre2_context.c:56:13: */
	_ = data
	return libc.Xmalloc(tls, size)
}

func default_free(tls *libc.TLS, block uintptr, data uintptr) { /* pcre2_context.c:63:13: */
	_ = data
	libc.Xfree(tls, block)
}

// ************************************************
//
//        Get a block and save memory control     *
//

// This internal function is called to get a block of memory in which the
// memory control data is to be stored at the start for future use.
//
// Arguments:
//   size        amount of memory required
//   memctl      pointer to a memctl block or NULL
//
// Returns:      pointer to memory or NULL on failure

func X_pcre2_memctl_malloc_8(tls *libc.TLS, size uint64, memctl uintptr) uintptr { /* pcre2_context.c:85:13: */
	var newmemctl uintptr
	var yield uintptr
	if memctl == uintptr(0) {
		yield = libc.Xmalloc(tls, size)
	} else {
		yield = (*struct {
			f func(*libc.TLS, uint64, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmalloc})).f(tls, size, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
	if yield == uintptr(0) {
		return uintptr(0)
	}
	newmemctl = yield
	if memctl == uintptr(0) {
		(*Tpcre2_memctl)(unsafe.Pointer(newmemctl)).Fmalloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uint64, uintptr) uintptr
		}{default_malloc}))
		(*Tpcre2_memctl)(unsafe.Pointer(newmemctl)).Ffree = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{default_free}))
		(*Tpcre2_memctl)(unsafe.Pointer(newmemctl)).Fmemory_data = uintptr(0)
	} else {
		*(*Tpcre2_memctl)(unsafe.Pointer(newmemctl)) = *(*Tpcre2_memctl)(unsafe.Pointer(memctl))
	}
	return yield
}

// ************************************************
//
//          Create and initialize contexts        *
//

// Initializing for compile and match contexts is done in separate, private
// functions so that these can be called from functions such as pcre2_compile()
// when an external context is not supplied. The initializing functions have an
// option to set up default memory management.

func Xpcre2_general_context_create_8(tls *libc.TLS, private_malloc uintptr, private_free uintptr, memory_data uintptr) uintptr { /* pcre2_context.c:114:38: */
	var gcontext uintptr
	if private_malloc == uintptr(0) {
		private_malloc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uint64, uintptr) uintptr
		}{default_malloc}))
	}
	if private_free == uintptr(0) {
		private_free = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{default_free}))
	}
	gcontext = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{private_malloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_general_context_8{})), memory_data)
	if gcontext == uintptr(0) {
		return uintptr(0)
	}
	(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmalloc = private_malloc
	(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Ffree = private_free
	(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data = memory_data
	return gcontext
}

// A default compile context is set up to save having to initialize at run time
// when no context is supplied to the compile function.

var X_pcre2_default_compile_context_8 = Tpcre2_compile_context_8{
	Fmemctl:             Tpcre2_memctl{Fmalloc: 0, Ffree: 0}, // Stack guard data
	Ftables:             0,                                   // Character tables
	Fmax_pattern_length: libc.CplUint64(uint64(0)),
	Fbsr_convention:     uint16(DPCRE2_BSR_UNICODE), // Backslash R default
	Fnewline_convention: uint16(DNEWLINE_DEFAULT),   // Newline convention
	Fparens_nest_limit:  uint32(DPARENS_NEST_LIMIT)} /* pcre2_context.c:133:29 */

// Extra options

// The create function copies the default into the new memory, but must
// override the default memory handling functions if a gcontext was provided.

func Xpcre2_compile_context_create_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_context.c:147:38: */
	var ccontext uintptr = X_pcre2_memctl_malloc_8(tls,
		uint64(unsafe.Sizeof(Tpcre2_real_compile_context_8{})), gcontext)
	if ccontext == uintptr(0) {
		return uintptr(0)
	}
	*(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)) = X_pcre2_default_compile_context_8
	if gcontext != uintptr(0) {
		*(*Tpcre2_memctl)(unsafe.Pointer(ccontext)) = *(*Tpcre2_memctl)(unsafe.Pointer(gcontext))
	}
	return ccontext
}

// A default match context is set up to save having to initialize at run time
// when no context is supplied to a match function.

var X_pcre2_default_match_context_8 = Tpcre2_match_context_8{
	Fmemctl:       Tpcre2_memctl{Fmalloc: 0, Ffree: 0}, // Substitute callout data
	Foffset_limit: libc.CplUint64(uint64(0)),
	Fheap_limit:   uint32(DHEAP_LIMIT),
	Fmatch_limit:  uint32(DMATCH_LIMIT),
	Fdepth_limit:  uint32(DMATCH_LIMIT)} /* pcre2_context.c:163:27 */

// The create function copies the default into the new memory, but must
// override the default memory handling functions if a gcontext was provided.

func Xpcre2_match_context_create_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_context.c:181:36: */
	var mcontext uintptr = X_pcre2_memctl_malloc_8(tls,
		uint64(unsafe.Sizeof(Tpcre2_real_match_context_8{})), gcontext)
	if mcontext == uintptr(0) {
		return uintptr(0)
	}
	*(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)) = X_pcre2_default_match_context_8
	if gcontext != uintptr(0) {
		*(*Tpcre2_memctl)(unsafe.Pointer(mcontext)) = *(*Tpcre2_memctl)(unsafe.Pointer(gcontext))
	}
	return mcontext
}

// A default convert context is set up to save having to initialize at run time
// when no context is supplied to the convert function.

var X_pcre2_default_convert_context_8 = Tpcre2_convert_context_8{
	Fmemctl:         Tpcre2_memctl{Fmalloc: 0, Ffree: 0}, // Default memory handling
	Fglob_separator: uint32('\057'),                      // Default path separator
	Fglob_escape:    uint32('\134'),                      // Default escape character
} /* pcre2_context.c:197:29 */

// The create function copies the default into the new memory, but must
// override the default memory handling functions if a gcontext was provided.

func Xpcre2_convert_context_create_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_context.c:211:38: */
	var ccontext uintptr = X_pcre2_memctl_malloc_8(tls,
		uint64(unsafe.Sizeof(Tpcre2_real_convert_context_8{})), gcontext)
	if ccontext == uintptr(0) {
		return uintptr(0)
	}
	*(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)) = X_pcre2_default_convert_context_8
	if gcontext != uintptr(0) {
		*(*Tpcre2_memctl)(unsafe.Pointer(ccontext)) = *(*Tpcre2_memctl)(unsafe.Pointer(gcontext))
	}
	return ccontext
}

// ************************************************
//
//              Context copy functions            *
//

func Xpcre2_general_context_copy_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_context.c:228:38: */
	var new uintptr = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmalloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_general_context_8{})),
		(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data)
	if new == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, new, gcontext, uint64(unsafe.Sizeof(Tpcre2_real_general_context_8{})))
	return new
}

func Xpcre2_compile_context_copy_8(tls *libc.TLS, ccontext uintptr) uintptr { /* pcre2_context.c:240:38: */
	var new uintptr = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_compile_context_8{})),
		(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if new == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, new, ccontext, uint64(unsafe.Sizeof(Tpcre2_real_compile_context_8{})))
	return new
}

func Xpcre2_match_context_copy_8(tls *libc.TLS, mcontext uintptr) uintptr { /* pcre2_context.c:252:36: */
	var new uintptr = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl.Fmalloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_match_context_8{})),
		(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl.Fmemory_data)
	if new == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, new, mcontext, uint64(unsafe.Sizeof(Tpcre2_real_match_context_8{})))
	return new
}

func Xpcre2_convert_context_copy_8(tls *libc.TLS, ccontext uintptr) uintptr { /* pcre2_context.c:265:38: */
	var new uintptr = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmalloc})).f(tls, uint64(unsafe.Sizeof(Tpcre2_real_convert_context_8{})),
		(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	if new == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemcpy(tls, new, ccontext, uint64(unsafe.Sizeof(Tpcre2_real_convert_context_8{})))
	return new
}

// ************************************************
//
//              Context free functions            *
//

func Xpcre2_general_context_free_8(tls *libc.TLS, gcontext uintptr) { /* pcre2_context.c:282:1: */
	if gcontext != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Ffree})).f(tls, gcontext, (*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data)
	}
}

func Xpcre2_compile_context_free_8(tls *libc.TLS, ccontext uintptr) { /* pcre2_context.c:290:1: */
	if ccontext != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, ccontext, (*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	}
}

func Xpcre2_match_context_free_8(tls *libc.TLS, mcontext uintptr) { /* pcre2_context.c:298:1: */
	if mcontext != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl.Ffree})).f(tls, mcontext, (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl.Fmemory_data)
	}
}

func Xpcre2_convert_context_free_8(tls *libc.TLS, ccontext uintptr) { /* pcre2_context.c:306:1: */
	if ccontext != uintptr(0) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Ffree})).f(tls, ccontext, (*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fmemctl.Fmemory_data)
	}
}

// ************************************************
//
//             Set values in contexts             *
//

// All these functions return 0 for success or PCRE2_ERROR_BADDATA if invalid
// data is given. Only some of the functions are able to test the validity of the
// data.

// ------------ Compile context ------------

func Xpcre2_set_character_tables_8(tls *libc.TLS, ccontext uintptr, tables uintptr) int32 { /* pcre2_context.c:325:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Ftables = tables
	return 0
}

func Xpcre2_set_bsr_8(tls *libc.TLS, ccontext uintptr, value uint32) int32 { /* pcre2_context.c:333:1: */
	switch value {
	case uint32(DPCRE2_BSR_ANYCRLF):
		fallthrough
	case uint32(DPCRE2_BSR_UNICODE):
		(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fbsr_convention = uint16(value)
		return 0

	default:
		return -29
	}
	return int32(0)
}

func Xpcre2_set_max_pattern_length_8(tls *libc.TLS, ccontext uintptr, length uint64) int32 { /* pcre2_context.c:348:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fmax_pattern_length = length
	return 0
}

func Xpcre2_set_newline_8(tls *libc.TLS, ccontext uintptr, newline uint32) int32 { /* pcre2_context.c:355:1: */
	switch newline {
	case uint32(DPCRE2_NEWLINE_CR):
		fallthrough
	case uint32(DPCRE2_NEWLINE_LF):
		fallthrough
	case uint32(DPCRE2_NEWLINE_CRLF):
		fallthrough
	case uint32(DPCRE2_NEWLINE_ANY):
		fallthrough
	case uint32(DPCRE2_NEWLINE_ANYCRLF):
		fallthrough
	case uint32(DPCRE2_NEWLINE_NUL):
		(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fnewline_convention = uint16(newline)
		return 0

	default:
		return -29
	}
	return int32(0)
}

func Xpcre2_set_parens_nest_limit_8(tls *libc.TLS, ccontext uintptr, limit uint32) int32 { /* pcre2_context.c:374:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fparens_nest_limit = limit
	return 0
}

func Xpcre2_set_compile_extra_options_8(tls *libc.TLS, ccontext uintptr, options uint32) int32 { /* pcre2_context.c:381:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fextra_options = options
	return 0
}

func Xpcre2_set_compile_recursion_guard_8(tls *libc.TLS, ccontext uintptr, guard uintptr, user_data uintptr) int32 { /* pcre2_context.c:388:1: */
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fstack_guard = guard
	(*Tpcre2_compile_context_8)(unsafe.Pointer(ccontext)).Fstack_guard_data = user_data
	return 0
}

// ------------ Match context ------------

func Xpcre2_set_callout_8(tls *libc.TLS, mcontext uintptr, callout uintptr, callout_data uintptr) int32 { /* pcre2_context.c:400:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout = callout
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout_data = callout_data
	return 0
}

func Xpcre2_set_substitute_callout_8(tls *libc.TLS, mcontext uintptr, substitute_callout uintptr, substitute_callout_data uintptr) int32 { /* pcre2_context.c:409:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout = substitute_callout
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout_data = substitute_callout_data
	return 0
}

func Xpcre2_set_heap_limit_8(tls *libc.TLS, mcontext uintptr, limit uint32) int32 { /* pcre2_context.c:419:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fheap_limit = limit
	return 0
}

func Xpcre2_set_match_limit_8(tls *libc.TLS, mcontext uintptr, limit uint32) int32 { /* pcre2_context.c:426:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmatch_limit = limit
	return 0
}

func Xpcre2_set_depth_limit_8(tls *libc.TLS, mcontext uintptr, limit uint32) int32 { /* pcre2_context.c:433:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fdepth_limit = limit
	return 0
}

func Xpcre2_set_offset_limit_8(tls *libc.TLS, mcontext uintptr, limit uint64) int32 { /* pcre2_context.c:440:1: */
	(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit = limit
	return 0
}

// These functions became obsolete at release 10.30. The first is kept as a
// synonym for backwards compatibility. The second now does nothing. Exclude both
// from coverage reports.

// LCOV_EXCL_START

func Xpcre2_set_recursion_limit_8(tls *libc.TLS, mcontext uintptr, limit uint32) int32 { /* pcre2_context.c:453:1: */
	return Xpcre2_set_depth_limit_8(tls, mcontext, limit)
}

func Xpcre2_set_recursion_memory_management_8(tls *libc.TLS, mcontext uintptr, mymalloc uintptr, myfree uintptr, mydata uintptr) int32 { /* pcre2_context.c:459:1: */
	_ = mcontext
	_ = mymalloc
	_ = myfree
	_ = mydata
	return 0
}

// LCOV_EXCL_STOP

// ------------ Convert context ------------

func Xpcre2_set_glob_separator_8(tls *libc.TLS, ccontext uintptr, separator uint32) int32 { /* pcre2_context.c:476:1: */
	if separator != uint32('\057') && separator != uint32('\134') && separator != uint32('\056') {
		return -29
	}
	(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fglob_separator = separator
	return 0
}

func Xpcre2_set_glob_escape_8(tls *libc.TLS, ccontext uintptr, escape uint32) int32 { /* pcre2_context.c:485:1: */
	if escape > uint32(255) || escape != uint32(0) && !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(escape))*2)))&int32(_ISpunct) != 0) {
		return -29
	}
	(*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fglob_escape = escape
	return 0
}

// End of pcre2_context.c

// Macro to add a character string to the output buffer, checking for overflow.

// Literals that must be escaped: \ ? * + | . ^ $ { } [ ] ( )

var pcre2_escaped_literals uintptr = ts + 665 /* "\\?*+|.^${}[]()" */ /* pcre2_convert.c:86:19 */

// Recognized escaped metacharacters in POSIX basic patterns.

var posix_meta_escapes uintptr = ts + 680 /* "(){}123456789" */ /* pcre2_convert.c:95:19 */

// ************************************************
//
//           Convert a POSIX pattern              *
//

// This function handles both basic and extended POSIX patterns.
//
// Arguments:
//   pattype        the pattern type
//   pattern        the pattern
//   plength        length in code units
//   utf            TRUE if UTF
//   use_buffer     where to put the output
//   use_length     length of use_buffer
//   bufflenptr     where to put the used length
//   dummyrun       TRUE if a dummy run
//   ccontext       the convert context
//
// Returns:         0 => success
//                 !0 => error code

func convert_posix(tls *libc.TLS, pattype uint32, pattern uintptr, plength uint64, utf int32, use_buffer uintptr, use_length uint64, bufflenptr uintptr, dummyrun int32, ccontext uintptr) int32 { /* pcre2_convert.c:124:1: */
	var s uintptr
	var posix uintptr
	var p uintptr
	var pp uintptr
	var endp uintptr // Allow for trailing zero
	var convlength uint64
	var bracount uint32
	var posix_state uint32
	var lastspecial uint32
	var extended int32
	var nextisliteral int32
	var c uint32
	var sc uint32
	var clength int32
	posix = pattern
	p = use_buffer
	pp = p
	endp = p + uintptr(use_length) - uintptr(1)
	convlength = uint64(0)
	bracount = uint32(0)
	posix_state = POSIX_START_REGEX
	lastspecial = uint32(0)
	extended = libc.Bool32(pattype&DPCRE2_CONVERT_POSIX_EXTENDED != uint32(0))
	nextisliteral = DFALSE

	_ = utf      // Not used when Unicode not supported
	_ = ccontext // Not currently used

	// Initialize default for error offset as end of input.

	*(*uint64)(unsafe.Pointer(bufflenptr)) = plength
	s = ts + 694
__1:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __3
	}
	if !(p >= endp) {
		goto __4
	}
	return -48
__4:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __2
__2:
	s++
	goto __1
	goto __3
__3:
	;

	// Now scan the input.

__5:
	if !(plength > uint64(0)) {
		goto __6
	}
	clength = 1

	// Add in the length of the last item, then, if in the dummy run, pull the
	//   pointer back to the start of the (temporary) buffer and then remember the
	//   start of the next item.

	convlength = convlength + uint64((int64(p)-int64(pp))/1)
	if !(dummyrun != 0) {
		goto __7
	}
	p = use_buffer
__7:
	;
	pp = p

	// Pick up the next character

	c = uint32(*(*uint8)(unsafe.Pointer(posix)))
	if !(utf != 0 && c >= 0xc0) {
		goto __8
	}
	if !(c&0x20 == uint32(0)) {
		goto __9
	}
	c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(posix + 1)))&0x3f
	clength++
	goto __10
__9:
	if !(c&0x10 == uint32(0)) {
		goto __11
	}
	c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(posix + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(posix + 2)))&0x3f
	clength = clength + 2
	goto __12
__11:
	if !(c&0x08 == uint32(0)) {
		goto __13
	}
	c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(posix + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(posix + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(posix + 3)))&0x3f
	clength = clength + 3
	goto __14
__13:
	if !(c&0x04 == uint32(0)) {
		goto __15
	}
	c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(posix + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(posix + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(posix + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(posix + 4)))&0x3f
	clength = clength + 4
	goto __16
__15:
	c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(posix + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(posix + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(posix + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(posix + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(posix + 5)))&0x3f
	clength = clength + 5
__16:
	;
__14:
	;
__12:
	;
__10:
	;
__8:
	;

	posix += uintptr(clength)
	plength = plength - uint64(clength)

	if nextisliteral != 0 {
		sc = uint32(0)
	} else {
		sc = c
	}
	nextisliteral = DFALSE

	// Handle a character within a class.

	if !(posix_state >= POSIX_CLASS_NOT_STARTED) {
		goto __17
	}

	if !(c == uint32('\135')) {
		goto __19
	}

	s = ts + 701
__21:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __23
	}
	if !(p >= endp) {
		goto __24
	}
	return -48
__24:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __22
__22:
	s++
	goto __21
	goto __23
__23:
	;

	posix_state = POSIX_NOT_BRACKET
	goto __20
__19:

	switch posix_state {
	case POSIX_CLASS_STARTED:
		goto __26
	// Fall through

	case POSIX_CLASS_NOT_STARTED:
		goto __27

	case POSIX_CLASS_STARTING:
		goto __28
	}
	goto __25

__26:
	if !(c <= uint32(127) && int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2)))&int32(_ISlower) != 0) {
		goto __29
	}
	goto __25
__29:
	; // Remain in started state
	posix_state = POSIX_CLASS_NOT_STARTED
	if !(c == uint32('\072') && plength > uint64(0) && int32(*(*uint8)(unsafe.Pointer(posix))) == '\135') {
		goto __30
	}

	s = ts + 703
__31:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __33
	}
	if !(p >= endp) {
		goto __34
	}
	return -48
__34:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __32
__32:
	s++
	goto __31
	goto __33
__33:
	;

	plength--
	posix++
	goto __5 // With next character after :]
__30:
	;
	// Fall through

__27:
	if !(c == uint32('\133')) {
		goto __35
	}
	posix_state = POSIX_CLASS_STARTING
__35:
	;
	goto __25

__28:
	if !(c == uint32('\072')) {
		goto __36
	}
	posix_state = POSIX_CLASS_STARTED
__36:
	;
	goto __25
__25:
	;

	if !(c == uint32('\134')) {
		goto __37
	}
	s = ts + 706
__38:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __40
	}
	if !(p >= endp) {
		goto __41
	}
	return -48
__41:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __39
__39:
	s++
	goto __38
	goto __40
__40:
	;
__37:
	;

	if !(p+uintptr(clength) > endp) {
		goto __42
	}
	return -48
__42:
	;
	libc.Xmemcpy(tls, p, posix-uintptr(clength), uint64(clength*(DPCRE2_CODE_UNIT_WIDTH/8)))
	p += uintptr(clength)
__20:
	;
	goto __18
__17:
	switch sc {
	case uint32('\133'):
		goto __44

	case uint32('\134'):
		goto __45

	case uint32('\051'):
		goto __46

	case uint32('\050'):
		goto __47
	// Fall through

	case uint32('\077'):
		goto __48
	case uint32('\053'):
		goto __49
	case uint32('\173'):
		goto __50
	case uint32('\175'):
		goto __51
	case uint32('\174'):
		goto __52
	// Fall through

	case uint32('\056'):
		goto __53
	case uint32('\044'):
		goto __54

	case uint32('\052'):
		goto __55 // Ignore second and subsequent asterisks

	case uint32('\136'):
		goto __56
	// Fall through

	default:
		goto __57
	}
	goto __43

__44:
	s = ts + 708
__58:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __60
	}
	if !(p >= endp) {
		goto __61
	}
	return -48
__61:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __59
__59:
	s++
	goto __58
	goto __60
__60:
	;

	// Handle start of "normal" character classes

	posix_state = POSIX_CLASS_NOT_STARTED

	// Handle ^ and ] as first characters

	if !(plength > uint64(0)) {
		goto __62
	}

	if !(int32(*(*uint8)(unsafe.Pointer(posix))) == '\136') {
		goto __63
	}

	posix++
	plength--
	s = ts + 710
__64:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __66
	}
	if !(p >= endp) {
		goto __67
	}
	return -48
__67:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __65
__65:
	s++
	goto __64
	goto __66
__66:
	;

__63:
	;
	if !(plength > uint64(0) && int32(*(*uint8)(unsafe.Pointer(posix))) == '\135') {
		goto __68
	}

	posix++
	plength--
	s = ts + 701
__69:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __71
	}
	if !(p >= endp) {
		goto __72
	}
	return -48
__72:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __70
__70:
	s++
	goto __69
	goto __71
__71:
	;

__68:
	;
__62:
	;
	goto __43

__45:
	if !(plength == uint64(0)) {
		goto __73
	}
	return DPCRE2_ERROR_END_BACKSLASH
__73:
	;
	if !(extended != 0) {
		goto __74
	}
	nextisliteral = DTRUE
	goto __75
__74:

	if !(int32(*(*uint8)(unsafe.Pointer(posix))) < 127 && libc.Xstrchr(tls, posix_meta_escapes, int32(*(*uint8)(unsafe.Pointer(posix)))) != uintptr(0)) {
		goto __76
	}

	if !(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(*(*uint8)(unsafe.Pointer(posix))))*2)))&int32(_ISdigit) != 0) {
		goto __78
	}
	s = ts + 706
__79:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __81
	}
	if !(p >= endp) {
		goto __82
	}
	return -48
__82:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __80
__80:
	s++
	goto __79
	goto __81
__81:
	;
__78:
	;

	if !(p+uintptr(1) > endp) {
		goto __83
	}
	return -48
__83:
	;
	lastspecial = uint32(libc.AssignPtrUint8(libc.PostIncUintptr(&p, 1), *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&posix, 1)))))
	plength--
	goto __77
__76:
	nextisliteral = DTRUE
__77:
	;
__75:
	;
	goto __43

__46:
	if !(!(extended != 0) || bracount == uint32(0)) {
		goto __84
	}
	goto ESCAPE_LITERAL
__84:
	;
	bracount--
	goto COPY_SPECIAL

__47:
	bracount++
	// Fall through

__48:
__49:
__50:
__51:
__52:
	if !!(extended != 0) {
		goto __85
	}
	goto ESCAPE_LITERAL
__85:
	;
	// Fall through

__53:
__54:
	posix_state = POSIX_NOT_BRACKET
COPY_SPECIAL:
	lastspecial = c
	if !(p+uintptr(1) > endp) {
		goto __86
	}
	return -48
__86:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(c)
	goto __43

__55:
	if !(lastspecial != uint32('\052')) {
		goto __87
	}

	if !(!(extended != 0) && (posix_state < POSIX_NOT_BRACKET || lastspecial == uint32('\050'))) {
		goto __88
	}
	goto ESCAPE_LITERAL
__88:
	;
	goto COPY_SPECIAL
__87:
	;
	goto __43 // Ignore second and subsequent asterisks

__56:
	if !(extended != 0) {
		goto __89
	}
	goto COPY_SPECIAL
__89:
	;
	if !(posix_state == POSIX_START_REGEX || lastspecial == uint32('\050')) {
		goto __90
	}

	posix_state = POSIX_ANCHORED
	goto COPY_SPECIAL
__90:
	;
	// Fall through

__57:
	if !(c < uint32(128) && libc.Xstrchr(tls, pcre2_escaped_literals, int32(c)) != uintptr(0)) {
		goto __91
	}

ESCAPE_LITERAL:
	s = ts + 706
__92:
	if !(int32(*(*int8)(unsafe.Pointer(s))) != 0) {
		goto __94
	}
	if !(p >= endp) {
		goto __95
	}
	return -48
__95:
	;
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(*(*int8)(unsafe.Pointer(s)))
	goto __93
__93:
	s++
	goto __92
	goto __94
__94:
	;

__91:
	;
	lastspecial = uint32(0xff) // Indicates nothing special
	if !(p+uintptr(clength) > endp) {
		goto __96
	}
	return -48
__96:
	;
	libc.Xmemcpy(tls, p, posix-uintptr(clength), uint64(clength*(DPCRE2_CODE_UNIT_WIDTH/8)))
	p += uintptr(clength)
	posix_state = POSIX_NOT_BRACKET
	goto __43
__43:
	;
__18:
	;
	goto __5
__6:
	;

	if !(posix_state >= POSIX_CLASS_NOT_STARTED) {
		goto __97
	}
	return DPCRE2_ERROR_MISSING_SQUARE_BRACKET
__97:
	;
	convlength = convlength + uint64((int64(p)-int64(pp))/1) // Final segment
	*(*uint64)(unsafe.Pointer(bufflenptr)) = convlength
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(0)
	return 0
}

// ************************************************
//
//           Convert a glob pattern               *
//

// Context for writing the output into a buffer.

type Spcre2_output_context = struct {
	Foutput      uintptr
	Foutput_end  uintptr
	Foutput_size uint64
	Fout_str     [8]uint8
} /* pcre2_convert.c:368:9 */

// ************************************************
//
//           Convert a glob pattern               *
//

// Context for writing the output into a buffer.

type Tpcre2_output_context = Spcre2_output_context /* pcre2_convert.c:373:3 */

// Write a character into the output.
//
// Arguments:
//   out            output context
//   chr            the next character

func convert_glob_write(tls *libc.TLS, out uintptr, chr uint8) { /* pcre2_convert.c:384:1: */
	(*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_size++

	if (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput < (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_end {
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput, 1))) = chr
	}
}

// Write a string into the output.
//
// Arguments:
//   out            output context
//   length         length of out->out_str

func convert_glob_write_str(tls *libc.TLS, out uintptr, length uint64) { /* pcre2_convert.c:401:1: */
	var out_str uintptr = out + 24 /* &.out_str */
	var output uintptr = (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput
	var output_end uintptr = (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_end
	var output_size uint64 = (*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_size

	for __ccgo := true; __ccgo; __ccgo = libc.PreDecUint64(&length, 1) != uint64(0) {
		output_size++

		if output < output_end {
			*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&output, 1))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&out_str, 1)))
		}
	}

	(*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput = output
	(*Tpcre2_output_context)(unsafe.Pointer(out)).Foutput_size = output_size
}

// Prints the separator into the output.
//
// Arguments:
//   out            output context
//   separator      glob separator
//   with_escape    backslash is needed before separator

func convert_glob_print_separator(tls *libc.TLS, out uintptr, separator uint8, with_escape int32) { /* pcre2_convert.c:431:1: */
	if with_escape != 0 {
		convert_glob_write(tls, out, uint8('\134'))
	}

	convert_glob_write(tls, out, separator)
}

// Prints a wildcard into the output.
//
// Arguments:
//   out            output context
//   separator      glob separator
//   with_escape    backslash is needed before separator

func convert_glob_print_wildcard(tls *libc.TLS, out uintptr, separator uint8, with_escape int32) { /* pcre2_convert.c:450:1: */
	*(*uint8)(unsafe.Pointer(out + 24)) = uint8('\133')
	*(*uint8)(unsafe.Pointer(out + 24 + 1)) = uint8('\136')
	convert_glob_write_str(tls, out, uint64(2))

	convert_glob_print_separator(tls, out, separator, with_escape)

	convert_glob_write(tls, out, uint8('\135'))
}

// Parse a posix class.
//
// Arguments:
//   from           starting point of scanning the range
//   pattern_end    end of pattern
//   out            output context
//
// Returns:  >0 => class index
//           0  => malformed class

func convert_glob_parse_class(tls *libc.TLS, from uintptr, pattern_end uintptr, out uintptr) int32 { /* pcre2_convert.c:475:1: */
	var start uintptr = *(*uintptr)(unsafe.Pointer(from)) + uintptr(1)
	var pattern uintptr = start
	var class_ptr uintptr
	var c uint8
	var class_index int32

	for 1 != 0 {
		if pattern >= pattern_end {
			return 0
		}

		c = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1)))

		if int32(c) < '\141' || int32(c) > '\172' {
			break
		}
	}

	if int32(c) != '\072' || pattern >= pattern_end || int32(*(*uint8)(unsafe.Pointer(pattern))) != '\135' {
		return 0
	}

	class_ptr = posix_classes
	class_index = 1

	for 1 != 0 {
		if int32(*(*int8)(unsafe.Pointer(class_ptr))) == 0 {
			return 0
		}

		pattern = start

		for int32(*(*uint8)(unsafe.Pointer(pattern))) == int32(uint8(*(*int8)(unsafe.Pointer(class_ptr)))) {
			if int32(*(*uint8)(unsafe.Pointer(pattern))) == '\072' {
				pattern += uintptr(2)
				start -= uintptr(2)

				for __ccgo := true; __ccgo; __ccgo = start < pattern {
					convert_glob_write(tls, out, *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&start, 1))))
				}

				*(*uintptr)(unsafe.Pointer(from)) = pattern
				return class_index
			}
			pattern++
			class_ptr++
		}

		for int32(*(*int8)(unsafe.Pointer(class_ptr))) != '\072' {
			class_ptr++
		}
		class_ptr++
		class_index++
	}
	return int32(0)
}

var posix_classes uintptr = ts + 712 /* "alnum:alpha:asci..." */ /* pcre2_convert.c:478:19 */

// Checks whether the character is in the class.
//
// Arguments:
//   class_index    class index
//   c              character
//
// Returns:   !0 => character is found in the class
//             0 => otherwise

func convert_glob_char_in_class(tls *libc.TLS, class_index int32, c uint8) int32 { /* pcre2_convert.c:541:1: */
	switch class_index {
	case 1:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISalnum)
	case 2:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISalpha)
	case 3:
		return 1
	case 4:
		return libc.Bool32(int32(c) == '\011' || int32(c) == '\040')
	case 5:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_IScntrl)
	case 6:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISdigit)
	case 7:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISgraph)
	case 8:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISlower)
	case 9:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISprint)
	case 10:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISpunct)
	case 11:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISspace)
	case 12:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISupper)
	case 13:
		return libc.Bool32(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2)))&int32(_ISalnum) != 0 || int32(c) == '\137')
	default:
		return int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(int32(c))*2))) & int32(_ISxdigit)
	}
	return int32(0)
}

// Parse a range of characters.
//
// Arguments:
//   from           starting point of scanning the range
//   pattern_end    end of pattern
//   out            output context
//   separator      glob separator
//   with_escape    backslash is needed before separator
//
// Returns:         0 => success
//                 !0 => error code

func convert_glob_parse_range(tls *libc.TLS, from uintptr, pattern_end uintptr, out uintptr, utf int32, separator uint8, with_escape int32, escape uint8, no_wildsep int32) int32 { /* pcre2_convert.c:576:1: */
	var is_negative int32 = DFALSE
	var separator_seen int32 = DFALSE
	var has_prev_c int32
	var pattern uintptr = *(*uintptr)(unsafe.Pointer(from))
	var char_start uintptr = uintptr(0)
	var c uint32
	var prev_c uint32
	var len int32
	var class_index int32

	_ = utf // Avoid compiler warning.

	if pattern >= pattern_end {
		*(*uintptr)(unsafe.Pointer(from)) = pattern
		return DPCRE2_ERROR_MISSING_SQUARE_BRACKET
	}

	if int32(*(*uint8)(unsafe.Pointer(pattern))) == '\041' ||
		int32(*(*uint8)(unsafe.Pointer(pattern))) == '\136' {
		pattern++

		if pattern >= pattern_end {
			*(*uintptr)(unsafe.Pointer(from)) = pattern
			return DPCRE2_ERROR_MISSING_SQUARE_BRACKET
		}

		is_negative = DTRUE

		*(*uint8)(unsafe.Pointer(out + 24)) = uint8('\133')
		*(*uint8)(unsafe.Pointer(out + 24 + 1)) = uint8('\136')
		len = 2

		if !(no_wildsep != 0) {
			if with_escape != 0 {
				*(*uint8)(unsafe.Pointer(out + 24 + uintptr(len))) = uint8('\134')
				len++
			}
			*(*uint8)(unsafe.Pointer(out + 24 + uintptr(len))) = separator
		}

		convert_glob_write_str(tls, out, uint64(len+1))
	} else {
		convert_glob_write(tls, out, uint8('\133'))
	}

	has_prev_c = DFALSE
	prev_c = uint32(0)

	if int32(*(*uint8)(unsafe.Pointer(pattern))) == '\135' {
		*(*uint8)(unsafe.Pointer(out + 24)) = uint8('\134')
		*(*uint8)(unsafe.Pointer(out + 24 + 1)) = uint8('\135')
		convert_glob_write_str(tls, out, uint64(2))
		has_prev_c = DTRUE
		prev_c = uint32('\135')
		pattern++
	}

	for pattern < pattern_end {
		char_start = pattern
		c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))
		if utf != 0 && c >= 0xc0 {
			if c&0x20 == uint32(0) {
				c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))&0x3f
			} else if c&0x10 == uint32(0) {
				c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f
				pattern += uintptr(2)
			} else if c&0x08 == uint32(0) {
				c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f
				pattern += uintptr(3)
			} else if c&0x04 == uint32(0) {
				c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 3)))&0x3f
				pattern += uintptr(4)
			} else {
				c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 4)))&0x3f
				pattern += uintptr(5)
			}
		}

		if c == uint32('\135') {
			convert_glob_write(tls, out, uint8(c))

			if !(is_negative != 0) && !(no_wildsep != 0) && separator_seen != 0 {
				*(*uint8)(unsafe.Pointer(out + 24)) = uint8('\050')
				*(*uint8)(unsafe.Pointer(out + 24 + 1)) = uint8('\077')
				*(*uint8)(unsafe.Pointer(out + 24 + 2)) = uint8('\074')
				*(*uint8)(unsafe.Pointer(out + 24 + 3)) = uint8('\041')
				convert_glob_write_str(tls, out, uint64(4))

				convert_glob_print_separator(tls, out, separator, with_escape)
				convert_glob_write(tls, out, uint8('\051'))
			}

			*(*uintptr)(unsafe.Pointer(from)) = pattern
			return 0
		}

		if pattern >= pattern_end {
			break
		}

		if c == uint32('\133') && int32(*(*uint8)(unsafe.Pointer(pattern))) == '\072' {
			*(*uintptr)(unsafe.Pointer(from)) = pattern
			class_index = convert_glob_parse_class(tls, from, pattern_end, out)

			if class_index != 0 {
				pattern = *(*uintptr)(unsafe.Pointer(from))

				has_prev_c = DFALSE
				prev_c = uint32(0)

				if !(is_negative != 0) && convert_glob_char_in_class(tls, class_index, separator) != 0 {
					separator_seen = DTRUE
				}
				continue
			}
		} else if c == uint32('\055') && has_prev_c != 0 && int32(*(*uint8)(unsafe.Pointer(pattern))) != '\135' {
			convert_glob_write(tls, out, uint8('\055'))

			char_start = pattern
			c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))
			if utf != 0 && c >= 0xc0 {
				if c&0x20 == uint32(0) {
					c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))&0x3f
				} else if c&0x10 == uint32(0) {
					c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f
					pattern += uintptr(2)
				} else if c&0x08 == uint32(0) {
					c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f
					pattern += uintptr(3)
				} else if c&0x04 == uint32(0) {
					c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 3)))&0x3f
					pattern += uintptr(4)
				} else {
					c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 4)))&0x3f
					pattern += uintptr(5)
				}
			}

			if pattern >= pattern_end {
				break
			}

			if int32(escape) != 0 && c == uint32(escape) {
				char_start = pattern
				c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))
				if utf != 0 && c >= 0xc0 {
					if c&0x20 == uint32(0) {
						c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))&0x3f
					} else if c&0x10 == uint32(0) {
						c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f
						pattern += uintptr(2)
					} else if c&0x08 == uint32(0) {
						c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f
						pattern += uintptr(3)
					} else if c&0x04 == uint32(0) {
						c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 3)))&0x3f
						pattern += uintptr(4)
					} else {
						c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 4)))&0x3f
						pattern += uintptr(5)
					}
				}

			} else if c == uint32('\133') && int32(*(*uint8)(unsafe.Pointer(pattern))) == '\072' {
				*(*uintptr)(unsafe.Pointer(from)) = pattern
				return -64
			}

			if prev_c > c {
				*(*uintptr)(unsafe.Pointer(from)) = pattern
				return -64
			}

			if prev_c < uint32(separator) && uint32(separator) < c {
				separator_seen = DTRUE
			}

			has_prev_c = DFALSE
			prev_c = uint32(0)
		} else {
			if int32(escape) != 0 && c == uint32(escape) {
				char_start = pattern
				c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))
				if utf != 0 && c >= 0xc0 {
					if c&0x20 == uint32(0) {
						c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&pattern, 1))))&0x3f
					} else if c&0x10 == uint32(0) {
						c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f
						pattern += uintptr(2)
					} else if c&0x08 == uint32(0) {
						c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f
						pattern += uintptr(3)
					} else if c&0x04 == uint32(0) {
						c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 3)))&0x3f
						pattern += uintptr(4)
					} else {
						c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(pattern)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(pattern + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(pattern + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(pattern + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(pattern + 4)))&0x3f
						pattern += uintptr(5)
					}
				}

				if pattern >= pattern_end {
					break
				}
			}

			has_prev_c = DTRUE
			prev_c = c
		}

		if c == uint32('\133') || c == uint32('\135') || c == uint32('\134') || c == uint32('\055') {
			convert_glob_write(tls, out, uint8('\134'))
		}

		if c == uint32(separator) {
			separator_seen = DTRUE
		}

		for __ccgo := true; __ccgo; __ccgo = char_start < pattern {
			convert_glob_write(tls, out, *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&char_start, 1))))
		}
	}

	*(*uintptr)(unsafe.Pointer(from)) = pattern
	return DPCRE2_ERROR_MISSING_SQUARE_BRACKET
}

// Prints a (*COMMIT) into the output.
//
// Arguments:
//   out            output context

func convert_glob_print_commit(tls *libc.TLS, out uintptr) { /* pcre2_convert.c:753:1: */
	*(*uint8)(unsafe.Pointer(out + 24)) = uint8('\050')
	*(*uint8)(unsafe.Pointer(out + 24 + 1)) = uint8('\052')
	*(*uint8)(unsafe.Pointer(out + 24 + 2)) = uint8('\103')
	*(*uint8)(unsafe.Pointer(out + 24 + 3)) = uint8('\117')
	*(*uint8)(unsafe.Pointer(out + 24 + 4)) = uint8('\115')
	*(*uint8)(unsafe.Pointer(out + 24 + 5)) = uint8('\115')
	*(*uint8)(unsafe.Pointer(out + 24 + 6)) = uint8('\111')
	*(*uint8)(unsafe.Pointer(out + 24 + 7)) = uint8('\124')
	convert_glob_write_str(tls, out, uint64(8))
	convert_glob_write(tls, out, uint8('\051'))
}

// Bash glob converter.
//
// Arguments:
//   pattype        the pattern type
//   pattern        the pattern
//   plength        length in code units
//   utf            TRUE if UTF
//   use_buffer     where to put the output
//   use_length     length of use_buffer
//   bufflenptr     where to put the used length
//   dummyrun       TRUE if a dummy run
//   ccontext       the convert context
//
// Returns:         0 => success
//                 !0 => error code

func convert_glob(tls *libc.TLS, options uint32, pattern uintptr, plength uint64, utf int32, use_buffer uintptr, use_length uint64, bufflenptr uintptr, dummyrun int32, ccontext uintptr) int32 { /* pcre2_convert.c:786:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)
	*(*uintptr)(unsafe.Pointer(bp + 32)) = pattern

	// var out Tpcre2_output_context at bp, 32

	var pattern_start uintptr = *(*uintptr)(unsafe.Pointer(bp + 32 /* pattern */))
	var pattern_end uintptr = *(*uintptr)(unsafe.Pointer(bp + 32)) + uintptr(plength)
	var separator uint8 = uint8((*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fglob_separator)
	var escape uint8 = uint8((*Tpcre2_convert_context_8)(unsafe.Pointer(ccontext)).Fglob_escape)
	var c uint8
	var no_wildsep int32 = libc.Bool32(options&DPCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR != uint32(0))
	var no_starstar int32 = libc.Bool32(options&DPCRE2_CONVERT_GLOB_NO_STARSTAR != uint32(0))
	var in_atomic int32 = DFALSE
	var after_starstar int32 = DFALSE
	var no_slash_z int32 = DFALSE
	var with_escape int32
	var is_start int32
	var after_separator int32
	var result int32 = 0

	_ = utf // Avoid compiler warning.

	if utf != 0 && (int32(separator) >= 128 || int32(escape) >= 128) {
		// Currently only ASCII characters are supported.
		*(*uint64)(unsafe.Pointer(bufflenptr)) = uint64(0)
		return -64
	}

	with_escape = libc.Bool32(libc.Xstrchr(tls, pcre2_escaped_literals, int32(separator)) != uintptr(0))

	// Initialize default for error offset as end of input.
	(*Tpcre2_output_context)(unsafe.Pointer(bp /* &out */)).Foutput = use_buffer
	(*Tpcre2_output_context)(unsafe.Pointer(bp /* &out */)).Foutput_end = use_buffer + uintptr(use_length)
	(*Tpcre2_output_context)(unsafe.Pointer(bp /* &out */)).Foutput_size = uint64(0)

	*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\050')
	*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\077')
	*(*uint8)(unsafe.Pointer(bp + 24 + 2)) = uint8('\163')
	*(*uint8)(unsafe.Pointer(bp + 24 + 3)) = uint8('\051')
	convert_glob_write_str(tls, bp, uint64(4))

	is_start = DTRUE

	if *(*uintptr)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) == '\052' {
		if no_wildsep != 0 {
			is_start = DFALSE
		} else if !(no_starstar != 0) && *(*uintptr)(unsafe.Pointer(bp + 32))+uintptr(1) < pattern_end && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + 1))) == '\052' {
			is_start = DFALSE
		}
	}

	if is_start != 0 {
		*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\134')
		*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\101')
		convert_glob_write_str(tls, bp, uint64(2))
	}

	for *(*uintptr)(unsafe.Pointer(bp + 32)) < pattern_end {
		c = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 32 /* pattern */)), 1)))

		if int32(c) == '\052' {
			is_start = libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 32)) == pattern_start+uintptr(1))

			if in_atomic != 0 {
				convert_glob_write(tls, bp, uint8('\051'))
				in_atomic = DFALSE
			}

			if !(no_starstar != 0) && *(*uintptr)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) == '\052' {
				after_separator = libc.Bool32(is_start != 0 || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + libc.UintptrFromInt32(-2)))) == int32(separator))

				for __ccgo := true; __ccgo; __ccgo = *(*uintptr)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) == '\052' {
					*(*uintptr)(unsafe.Pointer(bp + 32 /* pattern */))++
				}

				if *(*uintptr)(unsafe.Pointer(bp + 32)) >= pattern_end {
					no_slash_z = DTRUE
					break
				}

				after_starstar = DTRUE

				if after_separator != 0 && int32(escape) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) == int32(escape) && *(*uintptr)(unsafe.Pointer(bp + 32))+uintptr(1) < pattern_end && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + 1))) == int32(separator) {
					*(*uintptr)(unsafe.Pointer(bp + 32 /* pattern */))++
				}

				if is_start != 0 {
					if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) != int32(separator) {
						continue
					}

					*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\050')
					*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\077')
					*(*uint8)(unsafe.Pointer(bp + 24 + 2)) = uint8('\072')
					*(*uint8)(unsafe.Pointer(bp + 24 + 3)) = uint8('\134')
					*(*uint8)(unsafe.Pointer(bp + 24 + 4)) = uint8('\101')
					*(*uint8)(unsafe.Pointer(bp + 24 + 5)) = uint8('\174')
					convert_glob_write_str(tls, bp, uint64(6))

					convert_glob_print_separator(tls, bp, separator, with_escape)
					convert_glob_write(tls, bp, uint8('\051'))

					*(*uintptr)(unsafe.Pointer(bp + 32 /* pattern */))++
					continue
				}

				convert_glob_print_commit(tls, bp)

				if !(after_separator != 0) || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) != int32(separator) {
					*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\056')
					*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\052')
					*(*uint8)(unsafe.Pointer(bp + 24 + 2)) = uint8('\077')
					convert_glob_write_str(tls, bp, uint64(3))
					continue
				}

				*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\050')
				*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\077')
				*(*uint8)(unsafe.Pointer(bp + 24 + 2)) = uint8('\072')
				*(*uint8)(unsafe.Pointer(bp + 24 + 3)) = uint8('\056')
				*(*uint8)(unsafe.Pointer(bp + 24 + 4)) = uint8('\052')
				*(*uint8)(unsafe.Pointer(bp + 24 + 5)) = uint8('\077')

				convert_glob_write_str(tls, bp, uint64(6))

				convert_glob_print_separator(tls, bp, separator, with_escape)

				*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\051')
				*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\077')
				*(*uint8)(unsafe.Pointer(bp + 24 + 2)) = uint8('\077')
				convert_glob_write_str(tls, bp, uint64(3))

				*(*uintptr)(unsafe.Pointer(bp + 32 /* pattern */))++
				continue
			}

			if *(*uintptr)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) == '\052' {
				for __ccgo1 := true; __ccgo1; __ccgo1 = *(*uintptr)(unsafe.Pointer(bp + 32)) < pattern_end && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) == '\052' {
					*(*uintptr)(unsafe.Pointer(bp + 32 /* pattern */))++
				}
			}

			if no_wildsep != 0 {
				if *(*uintptr)(unsafe.Pointer(bp + 32)) >= pattern_end {
					no_slash_z = DTRUE
					break
				}

				// Start check must be after the end check.
				if is_start != 0 {
					continue
				}
			}

			if !(is_start != 0) {
				if after_starstar != 0 {
					*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\050')
					*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\077')
					*(*uint8)(unsafe.Pointer(bp + 24 + 2)) = uint8('\076')
					convert_glob_write_str(tls, bp, uint64(3))
					in_atomic = DTRUE
				} else {
					convert_glob_print_commit(tls, bp)
				}
			}

			if no_wildsep != 0 {
				convert_glob_write(tls, bp, uint8('\056'))
			} else {
				convert_glob_print_wildcard(tls, bp, separator, with_escape)
			}

			*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\052')
			*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\077')
			if *(*uintptr)(unsafe.Pointer(bp + 32)) >= pattern_end {
				*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\053')
			}
			convert_glob_write_str(tls, bp, uint64(2))
			continue
		}

		if int32(c) == '\077' {
			if no_wildsep != 0 {
				convert_glob_write(tls, bp, uint8('\056'))
			} else {
				convert_glob_print_wildcard(tls, bp, separator, with_escape)
			}
			continue
		}

		if int32(c) == '\133' {
			result = convert_glob_parse_range(tls, bp+32, pattern_end,
				bp, utf, separator, with_escape, escape, no_wildsep)
			if result != 0 {
				break
			}
			continue
		}

		if int32(escape) != 0 && int32(c) == int32(escape) {
			if *(*uintptr)(unsafe.Pointer(bp + 32)) >= pattern_end {
				result = -64
				break
			}
			c = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 32 /* pattern */)), 1)))
		}

		if int32(c) < 128 && libc.Xstrchr(tls, pcre2_escaped_literals, int32(c)) != uintptr(0) {
			convert_glob_write(tls, bp, uint8('\134'))
		}

		convert_glob_write(tls, bp, c)
	}

	if result == 0 {
		if !(no_slash_z != 0) {
			*(*uint8)(unsafe.Pointer(bp + 24)) = uint8('\134')
			*(*uint8)(unsafe.Pointer(bp + 24 + 1)) = uint8('\172')
			convert_glob_write_str(tls, bp, uint64(2))
		}

		if in_atomic != 0 {
			convert_glob_write(tls, bp, uint8('\051'))
		}

		convert_glob_write(tls, bp, uint8(0))

		if !(dummyrun != 0) && (*Tpcre2_output_context)(unsafe.Pointer(bp)).Foutput_size != uint64((int64((*Tpcre2_output_context)(unsafe.Pointer(bp)).Foutput)-int64(use_buffer))/1) {
			result = -48
		}
	}

	if result != 0 {
		*(*uint64)(unsafe.Pointer(bufflenptr)) = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 32))) - int64(pattern_start)) / 1)
		return result
	}

	*(*uint64)(unsafe.Pointer(bufflenptr)) = (*Tpcre2_output_context)(unsafe.Pointer(bp)).Foutput_size - uint64(1)
	return 0
}

// ************************************************
//
//                Convert pattern                 *
//

// This is the external-facing function for converting other forms of pattern
// into PCRE2 regular expression patterns. On error, the bufflenptr argument is
// used to return an offset in the original pattern.
//
// Arguments:
//   pattern     the input pattern
//   plength     length of input, or PCRE2_ZERO_TERMINATED
//   options     options bits
//   buffptr     pointer to pointer to output buffer
//   bufflenptr  pointer to length of output buffer
//   ccontext    convert context or NULL
//
// Returns:      0 for success, else an error code (+ve or -ve)

func Xpcre2_pattern_convert_8(tls *libc.TLS, pattern uintptr, plength uint64, options uint32, buffptr uintptr, bufflenptr uintptr, ccontext uintptr) int32 { /* pcre2_convert.c:1056:1: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var i int32
	var rc int32
	// var dummy_buffer [100]uint8 at bp, 100

	var use_buffer uintptr = bp /* dummy_buffer */
	var use_length uint64 = uint64(DDUMMY_BUFFER_SIZE)
	var utf int32 = libc.Bool32(options&DPCRE2_CONVERT_UTF != uint32(0))
	var pattype uint32 = options & (DPCRE2_CONVERT_GLOB | DPCRE2_CONVERT_POSIX_BASIC | DPCRE2_CONVERT_POSIX_EXTENDED)

	if pattern == uintptr(0) || bufflenptr == uintptr(0) {
		return -51
	}

	if options&libc.CplUint32(DPCRE2_CONVERT_UTF|DPCRE2_CONVERT_NO_UTF_CHECK|DPCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR|DPCRE2_CONVERT_GLOB_NO_STARSTAR|(DPCRE2_CONVERT_GLOB|DPCRE2_CONVERT_POSIX_BASIC|DPCRE2_CONVERT_POSIX_EXTENDED)) != uint32(0) || pattype&(^pattype+uint32(1)) != pattype || pattype == uint32(0) {
		*(*uint64)(unsafe.Pointer(bufflenptr)) = uint64(0) // Error offset
		return -34
	}

	if plength == libc.CplUint64(uint64(0)) {
		plength = X_pcre2_strlen_8(tls, pattern)
	}
	if ccontext == uintptr(0) {
		ccontext = uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8))
	}

	// Check UTF if required.

	if utf != 0 && options&DPCRE2_CONVERT_NO_UTF_CHECK == uint32(0) {
		// var erroroffset uint64 at bp+104, 8

		rc = X_pcre2_valid_utf_8(tls, pattern, plength, bp+104)
		if rc != 0 {
			*(*uint64)(unsafe.Pointer(bufflenptr)) = *(*uint64)(unsafe.Pointer(bp + 104 /* erroroffset */))
			return rc
		}
	}

	// If buffptr is not NULL, and what it points to is not NULL, we are being
	// provided with a buffer and a length, so set them as the buffer to use.

	if buffptr != uintptr(0) && *(*uintptr)(unsafe.Pointer(buffptr)) != uintptr(0) {
		use_buffer = *(*uintptr)(unsafe.Pointer(buffptr))
		use_length = *(*uint64)(unsafe.Pointer(bufflenptr))
	}

	// Call an individual converter, either just once (if a buffer was provided or
	// just the length is needed), or twice (if a memory allocation is required).

	for i = 0; i < 2; i++ {
		var allocated uintptr
		var dummyrun int32 = libc.Bool32(buffptr == uintptr(0) || *(*uintptr)(unsafe.Pointer(buffptr)) == uintptr(0))

		switch pattype {
		case DPCRE2_CONVERT_GLOB:
			rc = convert_glob(tls, options&libc.CplUint32(DPCRE2_CONVERT_GLOB), pattern, plength, utf,
				use_buffer, use_length, bufflenptr, dummyrun, ccontext)
			break

		case DPCRE2_CONVERT_POSIX_BASIC:
			fallthrough
		case DPCRE2_CONVERT_POSIX_EXTENDED:
			rc = convert_posix(tls, pattype, pattern, plength, utf, use_buffer, use_length,
				bufflenptr, dummyrun, ccontext)
			break

		default:
			*(*uint64)(unsafe.Pointer(bufflenptr)) = uint64(0) // Error offset
			return -44
		}

		if rc != 0 || buffptr == uintptr(0) || *(*uintptr)(unsafe.Pointer(buffptr)) != uintptr(0) { // Buffer was provided or allocated
			return rc
		}

		// Allocate memory for the buffer, with hidden space for an allocator at
		//   the start. The next time round the loop runs the conversion for real.

		allocated = X_pcre2_memctl_malloc_8(tls, uint64(unsafe.Sizeof(Tpcre2_memctl{}))+(*(*uint64)(unsafe.Pointer(bufflenptr))+uint64(1))*uint64(DPCRE2_CODE_UNIT_WIDTH), ccontext)
		if allocated == uintptr(0) {
			return -48
		}
		*(*uintptr)(unsafe.Pointer(buffptr)) = allocated + uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))

		use_buffer = *(*uintptr)(unsafe.Pointer(buffptr))
		use_length = *(*uint64)(unsafe.Pointer(bufflenptr)) + uint64(1)
	}

	// Control should never get here.

	return -44
}

// ************************************************
//
//            Free converted pattern              *
//

// This frees a converted pattern that was put in newly-allocated memory.
//
// Argument:   the converted pattern
// Returns:    nothing

func Xpcre2_converted_pattern_free_8(tls *libc.TLS, converted uintptr) { /* pcre2_convert.c:1171:1: */
	if converted != uintptr(0) {
		var memctl uintptr = converted - uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, memctl, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
}

// End of pcre2_convert.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//      Code parameters and static tables         *
//

// These are offsets that are used to turn the OP_TYPESTAR and friends opcodes
// into others, under special conditions. A gap of 20 between the blocks should be
// enough. The resulting opcodes don't have to be less than 256 because they are
// never stored, so we push them well clear of the normal opcodes.

// This table identifies those opcodes that are followed immediately by a
// character that is to be tested in some way. This makes it possible to
// centralize the loading of these characters. In the case of Type * etc, the
// "character" is the opcode for \D, \d, \S, \s, \W, or \w, which will always be a
// small value. Non-zero values in the table are the offsets from the opcode where
// the character is to be found. ***NOTE*** If the start of this table is
// modified, the three tables that follow must also be modified.

var coptable = [168]uint8{
	uint8(0),                                         // End
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // \A, \G, \K, \B, \b
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // \D, \d, \S, \s, \W, \w
	uint8(0), uint8(0), uint8(0), // Any, AllAny, Anybyte
	uint8(0), uint8(0), // \P, \p
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // \R, \H, \h, \V, \v
	uint8(0),                                                   // \X
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // \Z, \z, $, $M, ^, ^M
	uint8(1), // Char
	uint8(1), // Chari
	uint8(1), // not
	uint8(1), // noti
	// Positive single-char repeats
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // *, *?, +, +?, ?, ??
	uint8(1 + DIMM2_SIZE), uint8(1 + DIMM2_SIZE),
	uint8(1 + DIMM2_SIZE),
	uint8(1), uint8(1), uint8(1), uint8(1 + DIMM2_SIZE),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // *I, *?I, +I, +?I, ?I, ??I
	uint8(1 + DIMM2_SIZE), uint8(1 + DIMM2_SIZE),
	uint8(1 + DIMM2_SIZE),
	uint8(1), uint8(1), uint8(1), uint8(1 + DIMM2_SIZE),
	// Negative single-char repeats - only for chars < 256
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // NOT *, *?, +, +?, ?, ??
	uint8(1 + DIMM2_SIZE), uint8(1 + DIMM2_SIZE),
	uint8(1 + DIMM2_SIZE),
	uint8(1), uint8(1), uint8(1), uint8(1 + DIMM2_SIZE),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // NOT *I, *?I, +I, +?I, ?I, ??I
	uint8(1 + DIMM2_SIZE), uint8(1 + DIMM2_SIZE),
	uint8(1 + DIMM2_SIZE),
	uint8(1), uint8(1), uint8(1), uint8(1 + DIMM2_SIZE),
	// Positive type repeats
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // Type *, *?, +, +?, ?, ??
	uint8(1 + DIMM2_SIZE), uint8(1 + DIMM2_SIZE),
	uint8(1 + DIMM2_SIZE),
	uint8(1), uint8(1), uint8(1), uint8(1 + DIMM2_SIZE),
	// Character class & ref repeats
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // *, *?, +, +?, ?, ??
	uint8(0), uint8(0), // CRRANGE, CRMINRANGE
	uint8(0), uint8(0), uint8(0), uint8(0), // Possessive *+, ++, ?+, CRPOSRANGE
	uint8(0),                                         // CLASS
	uint8(0),                                         // NCLASS
	uint8(0),                                         // XCLASS - variable length
	uint8(0),                                         // REF
	uint8(0),                                         // REFI
	uint8(0),                                         // DNREF
	uint8(0),                                         // DNREFI
	uint8(0),                                         // RECURSE
	uint8(0),                                         // CALLOUT
	uint8(0),                                         // CALLOUT_STR
	uint8(0),                                         // Alt
	uint8(0),                                         // Ket
	uint8(0),                                         // KetRmax
	uint8(0),                                         // KetRmin
	uint8(0),                                         // KetRpos
	uint8(0),                                         // Reverse
	uint8(0),                                         // Assert
	uint8(0),                                         // Assert not
	uint8(0),                                         // Assert behind
	uint8(0),                                         // Assert behind not
	uint8(0),                                         // NA assert
	uint8(0),                                         // NA assert behind
	uint8(0),                                         // ONCE
	uint8(0),                                         // SCRIPT_RUN
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // BRA, BRAPOS, CBRA, CBRAPOS, COND
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND
	uint8(0), uint8(0), // CREF, DNCREF
	uint8(0), uint8(0), // RREF, DNRREF
	uint8(0), uint8(0), // FALSE, TRUE
	uint8(0), uint8(0), uint8(0), // BRAZERO, BRAMINZERO, BRAPOSZERO
	uint8(0), uint8(0), uint8(0), // MARK, PRUNE, PRUNE_ARG
	uint8(0), uint8(0), uint8(0), uint8(0), // SKIP, SKIP_ARG, THEN, THEN_ARG
	uint8(0), uint8(0), // COMMIT, COMMIT_ARG
	uint8(0), uint8(0), uint8(0), // FAIL, ACCEPT, ASSERT_ACCEPT
	uint8(0), uint8(0), uint8(0), // CLOSE, SKIPZERO, DEFINE
} /* pcre2_dfa_match.c:116:22 */

// This table identifies those opcodes that inspect a character. It is used to
// remember the fact that a character could have been inspected when the end of
// the subject is reached. ***NOTE*** If the start of this table is modified, the
// two tables that follow must also be modified.

var poptable = [168]uint8{
	uint8(0),                                         // End
	uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), // \A, \G, \K, \B, \b
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // \D, \d, \S, \s, \W, \w
	uint8(1), uint8(1), uint8(1), // Any, AllAny, Anybyte
	uint8(1), uint8(1), // \P, \p
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // \R, \H, \h, \V, \v
	uint8(1),                                                   // \X
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // \Z, \z, $, $M, ^, ^M
	uint8(1), // Char
	uint8(1), // Chari
	uint8(1), // not
	uint8(1), // noti
	// Positive single-char repeats
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // *, *?, +, +?, ?, ??
	uint8(1), uint8(1), uint8(1), // upto, minupto, exact
	uint8(1), uint8(1), uint8(1), uint8(1), // *+, ++, ?+, upto+
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // *I, *?I, +I, +?I, ?I, ??I
	uint8(1), uint8(1), uint8(1), // upto I, minupto I, exact I
	uint8(1), uint8(1), uint8(1), uint8(1), // *+I, ++I, ?+I, upto+I
	// Negative single-char repeats - only for chars < 256
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // NOT *, *?, +, +?, ?, ??
	uint8(1), uint8(1), uint8(1), // NOT upto, minupto, exact
	uint8(1), uint8(1), uint8(1), uint8(1), // NOT *+, ++, ?+, upto+
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // NOT *I, *?I, +I, +?I, ?I, ??I
	uint8(1), uint8(1), uint8(1), // NOT upto I, minupto I, exact I
	uint8(1), uint8(1), uint8(1), uint8(1), // NOT *+I, ++I, ?+I, upto+I
	// Positive type repeats
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // Type *, *?, +, +?, ?, ??
	uint8(1), uint8(1), uint8(1), // Type upto, minupto, exact
	uint8(1), uint8(1), uint8(1), uint8(1), // Type *+, ++, ?+, upto+
	// Character class & ref repeats
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), // *, *?, +, +?, ?, ??
	uint8(1), uint8(1), // CRRANGE, CRMINRANGE
	uint8(1), uint8(1), uint8(1), uint8(1), // Possessive *+, ++, ?+, CRPOSRANGE
	uint8(1),                                         // CLASS
	uint8(1),                                         // NCLASS
	uint8(1),                                         // XCLASS - variable length
	uint8(0),                                         // REF
	uint8(0),                                         // REFI
	uint8(0),                                         // DNREF
	uint8(0),                                         // DNREFI
	uint8(0),                                         // RECURSE
	uint8(0),                                         // CALLOUT
	uint8(0),                                         // CALLOUT_STR
	uint8(0),                                         // Alt
	uint8(0),                                         // Ket
	uint8(0),                                         // KetRmax
	uint8(0),                                         // KetRmin
	uint8(0),                                         // KetRpos
	uint8(0),                                         // Reverse
	uint8(0),                                         // Assert
	uint8(0),                                         // Assert not
	uint8(0),                                         // Assert behind
	uint8(0),                                         // Assert behind not
	uint8(0),                                         // NA assert
	uint8(0),                                         // NA assert behind
	uint8(0),                                         // ONCE
	uint8(0),                                         // SCRIPT_RUN
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // BRA, BRAPOS, CBRA, CBRAPOS, COND
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), // SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND
	uint8(0), uint8(0), // CREF, DNCREF
	uint8(0), uint8(0), // RREF, DNRREF
	uint8(0), uint8(0), // FALSE, TRUE
	uint8(0), uint8(0), uint8(0), // BRAZERO, BRAMINZERO, BRAPOSZERO
	uint8(0), uint8(0), uint8(0), // MARK, PRUNE, PRUNE_ARG
	uint8(0), uint8(0), uint8(0), uint8(0), // SKIP, SKIP_ARG, THEN, THEN_ARG
	uint8(0), uint8(0), // COMMIT, COMMIT_ARG
	uint8(0), uint8(0), uint8(0), // FAIL, ACCEPT, ASSERT_ACCEPT
	uint8(0), uint8(0), uint8(0), // CLOSE, SKIPZERO, DEFINE
} /* pcre2_dfa_match.c:198:22 */

// These 2 tables allow for compact code for testing for \D, \d, \S, \s, \W,
// and \w

var toptable1 = [14]uint8{
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
	uint8(Dctype_digit), uint8(Dctype_digit),
	uint8(Dctype_space), uint8(Dctype_space),
	uint8(Dctype_word), uint8(Dctype_word),
	uint8(0), uint8(0), // OP_ANY, OP_ALLANY
} /* pcre2_dfa_match.c:273:22 */

var toptable2 = [14]uint8{
	uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
	uint8(Dctype_digit), uint8(0),
	uint8(Dctype_space), uint8(0),
	uint8(Dctype_word), uint8(0),
	uint8(1), uint8(1), // OP_ANY, OP_ALLANY
} /* pcre2_dfa_match.c:281:22 */

// Structure for holding data about a particular state, which is in effect the
// current data for an active path through the match tree. It must consist
// entirely of ints because the working vector we are passed, and which we put
// these structures in, is a vector of ints.

type Sstateblock = struct {
	Foffset int32
	Fcount  int32
	Fdata   int32
} /* pcre2_dfa_match.c:295:9 */

// Structure for holding data about a particular state, which is in effect the
// current data for an active path through the match tree. It must consist
// entirely of ints because the working vector we are passed, and which we put
// these structures in, is a vector of ints.

type Tstateblock = Sstateblock /* pcre2_dfa_match.c:299:3 */

// Before version 10.32 the recursive calls of internal_dfa_match() were passed
// local working space and output vectors that were created on the stack. This has
// caused issues for some patterns, especially in small-stack environments such as
// Windows. A new scheme is now in use which sets up a vector on the stack, but if
// this is too small, heap memory is used, up to the heap_limit. The main
// parameters are all numbers of ints because the workspace is a vector of ints.
//
// The size of the starting stack vector, DFA_START_RWS_SIZE, is in bytes, and is
// defined in pcre2_internal.h so as to be available to pcre2test when it is
// finding the minimum heap requirement for a match.

// This structure is at the start of each workspace block.

type SRWS_anchor = struct {
	Fnext uintptr
	Fsize uint32
	Ffree uint32
} /* pcre2_dfa_match.c:324:9 */

// Before version 10.32 the recursive calls of internal_dfa_match() were passed
// local working space and output vectors that were created on the stack. This has
// caused issues for some patterns, especially in small-stack environments such as
// Windows. A new scheme is now in use which sets up a vector on the stack, but if
// this is too small, heap memory is used, up to the heap_limit. The main
// parameters are all numbers of ints because the workspace is a vector of ints.
//
// The size of the starting stack vector, DFA_START_RWS_SIZE, is in bytes, and is
// defined in pcre2_internal.h so as to be available to pcre2test when it is
// finding the minimum heap requirement for a match.

// This structure is at the start of each workspace block.

type TRWS_anchor = SRWS_anchor /* pcre2_dfa_match.c:328:3 */

// ************************************************
//
//               Process a callout                *
//

// This function is called to perform a callout.
//
// Arguments:
//   code              current code pointer
//   offsets           points to current capture offsets
//   current_subject   start of current subject match
//   ptr               current position in subject
//   mb                the match block
//   extracode         extra code offset when called from condition
//   lengthptr         where to return the callout length
//
// Returns:            the return from the callout

func do_callout_dfa(tls *libc.TLS, code uintptr, offsets uintptr, current_subject uintptr, ptr uintptr, mb uintptr, extracode uint64, lengthptr uintptr) int32 { /* pcre2_dfa_match.c:353:1: */
	var cb uintptr = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcb

	*(*uint64)(unsafe.Pointer(lengthptr)) = func() uint64 {
		if int32(*(*uint8)(unsafe.Pointer(code + uintptr(extracode)))) == OP_CALLOUT {
			return uint64(X_pcre2_OP_lengths_8[OP_CALLOUT])
		}
		return uint64(uint32(int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1+2*DLINK_SIZE)+extracode))))<<8 | int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1+2*DLINK_SIZE)+extracode+uint64(1)))))))
	}()

	if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout == uintptr(0) {
		return 0
	} // No callout provided

	// Fixed fields in the callout block are set once and for all at the start of
	// matching.

	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Foffset_vector = offsets
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fstart_match = uint64((int64(current_subject) - int64((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcurrent_position = uint64((int64(ptr) - int64((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fpattern_position = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1)+extracode))))<<8 | int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1)+extracode+uint64(1)))))))
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fnext_item_length = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1+DLINK_SIZE)+extracode))))<<8 | int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1+DLINK_SIZE)+extracode+uint64(1)))))))

	if int32(*(*uint8)(unsafe.Pointer(code + uintptr(extracode)))) == OP_CALLOUT {
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_number = uint32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1+2*DLINK_SIZE)+extracode))))
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_offset = uint64(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string = uintptr(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_length = uint64(0)
	} else {
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_number = uint32(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_offset = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1+3*DLINK_SIZE)+extracode))))<<8 | int32(*(*uint8)(unsafe.Pointer(code + uintptr(uint64(1+3*DLINK_SIZE)+extracode+uint64(1)))))))
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string = code + uintptr(uint64(1+4*DLINK_SIZE)+extracode) + uintptr(1)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_length = *(*uint64)(unsafe.Pointer(lengthptr)) - uint64(1+4*DLINK_SIZE) - uint64(2)
	}

	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout})).f(tls, cb, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout_data)
}

// ************************************************
//
//         Expand local workspace memory          *
//

// This function is called when internal_dfa_match() is about to be called
// recursively and there is insufficient working space left in the current
// workspace block. If there's an existing next block, use it; otherwise get a new
// block unless the heap limit is reached.
//
// Arguments:
//   rwsptr     pointer to block pointer (updated)
//   ovecsize   space needed for an ovector
//   mb         the match block
//
// Returns:     0 rwsptr has been updated
//             !0 an error code

func more_workspace(tls *libc.TLS, rwsptr uintptr, ovecsize uint32, mb uintptr) int32 { /* pcre2_dfa_match.c:413:1: */
	var rws uintptr = *(*uintptr)(unsafe.Pointer(rwsptr))
	var new uintptr

	if (*TRWS_anchor)(unsafe.Pointer(rws)).Fnext != uintptr(0) {
		new = (*TRWS_anchor)(unsafe.Pointer(rws)).Fnext
	} else {
		var newsize uint32
		if (*TRWS_anchor)(unsafe.Pointer(rws)).Fsize >= 4294967295/uint32(2) {
			newsize = 4294967295 / uint32(2)
		} else {
			newsize = (*TRWS_anchor)(unsafe.Pointer(rws)).Fsize * uint32(2)
		}
		var newsizeK uint32 = uint32(uint64(newsize) / (uint64(1024) / uint64(unsafe.Sizeof(int32(0)))))

		if uint64(newsizeK)+(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_used > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit {
			newsizeK = uint32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit - (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_used)
		}
		newsize = uint32(uint64(newsizeK) * (uint64(1024) / uint64(unsafe.Sizeof(int32(0)))))

		if uint64(newsize) < uint64(uint32(DRWS_RSIZE)+ovecsize)+uint64(unsafe.Sizeof(TRWS_anchor{}))/uint64(unsafe.Sizeof(int32(0))) {
			return -63
		}
		new = (*struct {
			f func(*libc.TLS, uint64, uintptr) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmalloc})).f(tls, uint64(newsize)*uint64(unsafe.Sizeof(int32(0))), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmemory_data)
		if new == uintptr(0) {
			return -48
		}
		*(*uint64)(unsafe.Pointer(mb + 88)) += uint64(newsizeK)
		(*TRWS_anchor)(unsafe.Pointer(new)).Fnext = uintptr(0)
		(*TRWS_anchor)(unsafe.Pointer(new)).Fsize = newsize
		(*TRWS_anchor)(unsafe.Pointer(rws)).Fnext = new
	}

	(*TRWS_anchor)(unsafe.Pointer(new)).Ffree = uint32(uint64((*TRWS_anchor)(unsafe.Pointer(new)).Fsize) - uint64(unsafe.Sizeof(TRWS_anchor{}))/uint64(unsafe.Sizeof(int32(0))))
	*(*uintptr)(unsafe.Pointer(rwsptr)) = new
	return 0
}

// ************************************************
//
//     Match a Regular Expression - DFA engine    *
//

// This internal function applies a compiled pattern to a subject string,
// starting at a given point, using a DFA engine. This function is called from the
// external one, possibly multiple times if the pattern is not anchored. The
// function calls itself recursively for some kinds of subpattern.
//
// Arguments:
//   mb                the match_data block with fixed information
//   this_start_code   the opening bracket of this subexpression's code
//   current_subject   where we currently are in the subject string
//   start_offset      start offset in the subject string
//   offsets           vector to contain the matching string offsets
//   offsetcount       size of same
//   workspace         vector of workspace
//   wscount           size of same
//   rlevel            function call recursion level
//
// Returns:            > 0 => number of match offset pairs placed in offsets
//                     = 0 => offsets overflowed; longest matches are present
//                      -1 => failed to match
//                    < -1 => some kind of unexpected problem
//
// The following macros are used for adding states to the two state vectors (one
// for the current character, one for the following character).

// And now, here is the code

func internal_dfa_match(tls *libc.TLS, mb uintptr, this_start_code uintptr, current_subject uintptr, start_offset uint64, offsets uintptr, offsetcount uint32, workspace uintptr, wscount int32, rlevel uint32, RWS uintptr) int32 { /* pcre2_dfa_match.c:522:1: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var active_states uintptr
	var new_states uintptr
	var temp_states uintptr
	var next_active_state uintptr
	var next_new_state uintptr
	var ctypes uintptr
	var lcc uintptr
	var fcc uintptr
	var ptr uintptr
	var end_code uintptr
	// var new_recursive Tdfa_recursion_info at bp+48, 24

	var active_count int32
	var new_count int32
	var match_count int32

	// Some fields in the mb block are frequently referenced, so we load them into
	// independent variables in the hope that this will perform better.

	var start_subject uintptr
	var end_subject uintptr
	var start_code uintptr
	var utf int32
	var utf_or_ucp int32
	var reset_could_continue int32
	var back uint64
	var current_offset uint64
	var bstate int32
	var revlen uint32
	var back1 uint64
	var max_back uint64
	var gone_back uint64
	var length int32
	var cat uint32
	var temp uintptr
	var temp1 uintptr
	var cat1 uint32
	var left_word int32
	var right_word int32
	var OK int32
	var cp uintptr
	var prop uintptr
	var OK1 int32
	var cp1 uintptr
	var prop1 uintptr
	// var ncount int32 at bp, 4

	var ncount1 int32
	var OK2 int32
	var OK3 int32
	var OK4 int32
	var cp2 uintptr
	var prop2 uintptr
	// var ncount2 int32 at bp+4, 4

	var ncount3 int32
	var OK5 int32
	var OK6 int32
	var OK7 int32
	var cp3 uintptr
	var prop3 uintptr
	var nptr uintptr
	// var ncount4 int32 at bp+8, 4

	var ncount5 int32
	var OK8 int32
	var OK9 int32
	var othercase uint32
	// var ncount6 int32 at bp+12, 4

	var nptr1 uintptr
	var otherd uint32
	var otherd1 uint32
	var otherd2 uint32
	var otherd3 uint32
	var otherd4 uint32
	var otherd5 uint32
	var max int32
	var isinclass int32
	var next_state_offset int32
	var ecode uintptr
	var rc int32
	var local_workspace uintptr
	var local_offsets uintptr
	var endasscode uintptr
	// var rws uintptr at bp+16, 8

	// var callout_length uint64 at bp+24, 8

	var value uint32
	var rc1 int32
	var local_workspace1 uintptr
	var local_offsets1 uintptr
	var asscode uintptr
	var endasscode1 uintptr
	// var rws1 uintptr at bp+32, 8

	var codelink int32
	var condcode uint8
	var p uintptr
	var pp uintptr
	var charcount uint64
	var rc2 int32
	var local_workspace2 uintptr
	var local_offsets2 uintptr
	// var rws2 uintptr at bp+40, 8

	var ri uintptr
	var callpat uintptr
	var recno uint32
	var p1 uintptr
	var pp1 uintptr
	var end_subpattern uintptr
	var next_state_offset1 int32
	var rc3 int32
	var local_workspace3 uintptr
	var local_offsets3 uintptr
	var charcount1 uint64
	var matched_count uint64
	var local_ptr uintptr
	// var rws3 uintptr at bp+72, 8

	var allow_zero int32
	var p2 uintptr
	var pp2 uintptr
	var end_subpattern1 uintptr
	var charcount2 uint64
	var next_state_offset2 int32
	var repeat_state_offset int32
	var rc4 int32
	var local_workspace4 uintptr
	var local_offsets4 uintptr
	// var rws4 uintptr at bp+80, 8

	// var callout_length1 uint64 at bp+88, 8

	var current_state uintptr
	var caseless int32
	var code uintptr
	var codevalue uint32
	var state_offset int32
	var rrc int32
	var count int32
	var i int32
	var j int32
	var clen int32
	var dlen int32
	var c uint32
	var d uint32
	var forced_fail int32
	var partial_newline int32
	var could_continue int32
	start_subject = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject
	end_subject = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject
	start_code = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_code
	utf = libc.Bool32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UTF != uint32(0))
	utf_or_ucp = libc.Bool32(utf != 0 || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != uint32(0))
	reset_could_continue = DFALSE

	if !(libc.PostIncUint32(&(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_call_count, 1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit) {
		goto __1
	}
	return -47
__1:
	;
	if !(libc.PostIncUint32(&rlevel, 1) > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth) {
		goto __2
	}
	return -53
__2:
	;
	offsetcount = offsetcount & libc.Uint32(libc.Uint32FromInt32(-2)) // Round down

	wscount = wscount - 2
	wscount = (wscount - wscount%(int32(uint64(unsafe.Sizeof(Tstateblock{}))/uint64(unsafe.Sizeof(int32(0))))*2)) / (2 * int32(uint64(unsafe.Sizeof(Tstateblock{}))/uint64(unsafe.Sizeof(int32(0)))))

	ctypes = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dcbits_offset+Dcbit_length)
	lcc = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dlcc_offset)
	fcc = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dfcc_offset)

	match_count = -1 // A negative number

	active_states = workspace + uintptr(2)*4
	next_new_state = libc.AssignUintptr(&new_states, active_states+uintptr(wscount)*12)
	new_count = 0

	// The first thing in any (sub) pattern is a bracket of some sort. Push all
	// the alternative states onto the list, and find out where the end is. This
	// makes is possible to use this function recursively, when we want to stop at a
	// matching internal ket rather than at the end.
	//
	// If we are dealing with a backward assertion we have to find out the maximum
	// amount to move back, and set up each alternative appropriately.

	if !(int32(*(*uint8)(unsafe.Pointer(this_start_code))) == OP_ASSERTBACK || int32(*(*uint8)(unsafe.Pointer(this_start_code))) == OP_ASSERTBACK_NOT) {
		goto __3
	}

	max_back = uint64(0)

	end_code = this_start_code
__5:

	back = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(end_code + 4)))<<8 | int32(*(*uint8)(unsafe.Pointer(end_code + 5)))))
	if !(back > max_back) {
		goto __8
	}
	max_back = back
__8:
	;
	end_code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(end_code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(end_code + 2)))))
	goto __6
__6:
	if int32(*(*uint8)(unsafe.Pointer(end_code))) == OP_ALT {
		goto __5
	}
	goto __7
__7:
	;

	// If we can't go back the amount required for the longest lookbehind
	//   pattern, go back as far as we can; some alternatives may still be viable.

	// In character mode we have to step back character by character

	if !(utf != 0) {
		goto __9
	}

	gone_back = uint64(0)
__11:
	if !(gone_back < max_back) {
		goto __13
	}

	if !(current_subject <= start_subject) {
		goto __14
	}
	goto __13
__14:
	;
	current_subject--
__15:
	if !(current_subject > start_subject && uint32(*(*uint8)(unsafe.Pointer(current_subject)))&0xc0 == 0x80) {
		goto __16
	}
	current_subject--
	goto __15
__16:
	;
	goto __12
__12:
	gone_back++
	goto __11
	goto __13
__13:
	;
	goto __10
__9:

	/* In byte-mode we can do this quickly. */

	current_offset = uint64((int64(current_subject) - int64(start_subject)) / 1)
	if current_offset < max_back {
		gone_back = current_offset
	} else {
		gone_back = max_back
	}
	current_subject -= uintptr(gone_back)
__10:
	;

	// Save the earliest consulted character

	if !(current_subject < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __17
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = current_subject
__17:
	;

	// Now we can process the individual branches. There will be an OP_REVERSE at
	//   the start of each branch, except when the length of the branch is zero.

	end_code = this_start_code
__18:

	if int32(*(*uint8)(unsafe.Pointer(end_code + 3))) == OP_REVERSE {
		revlen = uint32(1 + DLINK_SIZE)
	} else {
		revlen = uint32(0)
	}
	if revlen == uint32(0) {
		back1 = uint64(0)
	} else {
		back1 = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(end_code + 4)))<<8 | int32(*(*uint8)(unsafe.Pointer(end_code + 5)))))
	}
	if !(back1 <= gone_back) {
		goto __21
	}

	bstate = int32((int64(end_code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE) + int64(revlen))
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __22
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -bstate
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(gone_back - back1)
	next_new_state += 12
	goto __23
__22:
	return -43
__23:
	;
__21:
	;
	end_code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(end_code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(end_code + 2)))))
	goto __19
__19:
	if int32(*(*uint8)(unsafe.Pointer(end_code))) == OP_ALT {
		goto __18
	}
	goto __20
__20:
	;
	goto __4
__3:

	end_code = this_start_code

	// Restarting

	if !(rlevel == uint32(1) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_DFA_RESTART != uint32(0)) {
		goto __24
	}

__26:
	end_code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(end_code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(end_code + 2)))))
	goto __27
__27:
	if int32(*(*uint8)(unsafe.Pointer(end_code))) == OP_ALT {
		goto __26
	}
	goto __28
__28:
	;
	new_count = *(*int32)(unsafe.Pointer(workspace + 1*4))
	if !!(*(*int32)(unsafe.Pointer(workspace)) != 0) {
		goto __29
	}
	libc.Xmemcpy(tls, new_states, active_states, uint64(new_count)*uint64(unsafe.Sizeof(Tstateblock{})))
__29:
	;
	goto __25
__24:

	length = 1 + DLINK_SIZE + func() int32 {
		if int32(*(*uint8)(unsafe.Pointer(this_start_code))) == OP_CBRA || int32(*(*uint8)(unsafe.Pointer(this_start_code))) == OP_SCBRA || int32(*(*uint8)(unsafe.Pointer(this_start_code))) == OP_CBRAPOS || int32(*(*uint8)(unsafe.Pointer(this_start_code))) == OP_SCBRAPOS {
			return DIMM2_SIZE
		}
		return 0
	}()
__30:

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __33
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = int32((int64(end_code)-int64(start_code))/1 + int64(length))
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __34
__33:
	return -43
__34:
	;
	end_code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(end_code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(end_code + 2)))))
	length = 1 + DLINK_SIZE
	goto __31
__31:
	if int32(*(*uint8)(unsafe.Pointer(end_code))) == OP_ALT {
		goto __30
	}
	goto __32
__32:
	;
__25:
	;
__4:
	;

	*(*int32)(unsafe.Pointer(workspace)) = 0 // Bit indicating which vector is current

	// Loop for scanning the subject

	ptr = current_subject
__35:
	forced_fail = 0
	partial_newline = DFALSE
	could_continue = reset_could_continue
	reset_could_continue = DFALSE

	if !(ptr > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __38
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = ptr
__38:
	;

	// Make the new state list into the active state list and empty the
	//   new state list.

	temp_states = active_states
	active_states = new_states
	new_states = temp_states
	active_count = new_count
	new_count = 0

	*(*int32)(unsafe.Pointer(workspace)) ^= 1 // Remember for the restarting feature
	*(*int32)(unsafe.Pointer(workspace + 1*4)) = active_count

	// Set the pointers for adding new states

	next_active_state = active_states + uintptr(active_count)*12
	next_new_state = new_states

	// Load the current character from the subject outside the loop, as many
	//   different states may want to look at it, and we assume that at least one
	//   will.

	if !(ptr < end_subject) {
		goto __39
	}

	clen = 1 // Number of data items in the character
	c = uint32(*(*uint8)(unsafe.Pointer(ptr)))
	if !(utf != 0 && c >= 0xc0) {
		goto __41
	}
	if !(c&0x20 == uint32(0)) {
		goto __42
	}
	c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f
	clen++
	goto __43
__42:
	if !(c&0x10 == uint32(0)) {
		goto __44
	}
	c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f
	clen = clen + 2
	goto __45
__44:
	if !(c&0x08 == uint32(0)) {
		goto __46
	}
	c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f
	clen = clen + 3
	goto __47
__46:
	if !(c&0x04 == uint32(0)) {
		goto __48
	}
	c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f
	clen = clen + 4
	goto __49
__48:
	c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 5)))&0x3f
	clen = clen + 5
__49:
	;
__47:
	;
__45:
	;
__43:
	;
__41:
	;

	goto __40
__39:

	clen = 0 // This indicates the end of the subject
	c = DNOTACHAR // This value should never actually be used
__40:
	;

	// Scan up the active states and act on each one. The result of an action
	//   may be to add more states to the currently active list (e.g. on hitting a
	//   parenthesis) or it may be to put states on the new list, for considering
	//   when we move the character pointer on.

	i = 0
__50:
	if !(i < active_count) {
		goto __52
	}
	current_state = active_states + uintptr(i)*12
	caseless = DFALSE
	state_offset = (*Tstateblock)(unsafe.Pointer(current_state)).Foffset

	// A negative offset is a special case meaning "hold off going to this
	//     (negated) state until the number of characters in the data field have
	//     been skipped". If the could_continue flag was passed over from a previous
	//     state, arrange for it to passed on.

	if !(state_offset < 0) {
		goto __53
	}

	if !((*Tstateblock)(unsafe.Pointer(current_state)).Fdata > 0) {
		goto __54
	}

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __56
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = (*Tstateblock)(unsafe.Pointer(current_state)).Fdata - 1
	next_new_state += 12
	goto __57
__56:
	return -43
__57:
	;
	if !(could_continue != 0) {
		goto __58
	}
	reset_could_continue = DTRUE
__58:
	;
	goto __51
	goto __55
__54:

	(*Tstateblock)(unsafe.Pointer(current_state)).Foffset = libc.AssignInt32(&state_offset, -state_offset)
__55:
	;
__53:
	;

	// Check for a duplicate state with the same count, and skip if found.
	//     See the note at the head of this module about the possibility of improving
	//     performance here.

	j = 0
__59:
	if !(j < i) {
		goto __61
	}

	if !((*Tstateblock)(unsafe.Pointer(active_states+uintptr(j)*12)).Foffset == state_offset && (*Tstateblock)(unsafe.Pointer(active_states+uintptr(j)*12)).Fcount == (*Tstateblock)(unsafe.Pointer(current_state)).Fcount) {
		goto __62
	}
	goto NEXT_ACTIVE_STATE
__62:
	;
	goto __60
__60:
	j++
	goto __59
	goto __61
__61:
	;

	// The state offset is the offset to the opcode

	code = start_code + uintptr(state_offset)
	codevalue = uint32(*(*uint8)(unsafe.Pointer(code)))

	// If this opcode inspects a character, but we are at the end of the
	//     subject, remember the fact for use when testing for a partial match.

	if !(clen == 0 && int32(poptable[codevalue]) != 0) {
		goto __63
	}
	could_continue = DTRUE
__63:
	;

	// If this opcode is followed by an inline character, load it. It is
	//     tempting to test for the presence of a subject character here, but that
	//     is wrong, because sometimes zero repetitions of the subject are
	//     permitted.
	//
	//     We also use this mechanism for opcodes such as OP_TYPEPLUS that take an
	//     argument that is not a data character - but is always one byte long because
	//     the values are small. We have to take special action to deal with  \P, \p,
	//     \H, \h, \V, \v and \X in this case. To keep the other cases fast, convert
	//     these ones to new opcodes.

	if !(int32(coptable[codevalue]) > 0) {
		goto __64
	}

	dlen = 1
	if !(utf != 0) {
		goto __66
	}
	d = uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]))))
	if !(d >= 0xc0) {
		goto __68
	}
	if !(d&0x20 == uint32(0)) {
		goto __69
	}
	d = d&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f
	dlen++
	goto __70
__69:
	if !(d&0x10 == uint32(0)) {
		goto __71
	}
	d = d&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 2)))&0x3f
	dlen = dlen + 2
	goto __72
__71:
	if !(d&0x08 == uint32(0)) {
		goto __73
	}
	d = d&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 3)))&0x3f
	dlen = dlen + 3
	goto __74
__73:
	if !(d&0x04 == uint32(0)) {
		goto __75
	}
	d = d&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 4)))&0x3f
	dlen = dlen + 4
	goto __76
__75:
	d = d&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]) + 5)))&0x3f
	dlen = dlen + 5
__76:
	;
__74:
	;
__72:
	;
__70:
	;
__68:
	;

	goto __67
__66:
	d = uint32(*(*uint8)(unsafe.Pointer(code + uintptr(coptable[codevalue]))))
__67:
	;
	if !(codevalue >= OP_TYPESTAR) {
		goto __77
	}

	switch d {
	case OP_ANYBYTE:
		goto __79
	case OP_NOTPROP:
		goto __80
	case OP_PROP:
		goto __81
	case OP_ANYNL:
		goto __82
	case OP_EXTUNI:
		goto __83
	case OP_NOT_HSPACE:
		goto __84
	case OP_HSPACE:
		goto __85
	case OP_NOT_VSPACE:
		goto __86
	case OP_VSPACE:
		goto __87
	default:
		goto __88
	}
	goto __78

__79:
	return -42
__80:
__81:
	codevalue = codevalue + uint32(DOP_PROP_EXTRA)
	goto __78
__82:
	codevalue = codevalue + uint32(DOP_ANYNL_EXTRA)
	goto __78
__83:
	codevalue = codevalue + uint32(DOP_EXTUNI_EXTRA)
	goto __78
__84:
__85:
	codevalue = codevalue + uint32(DOP_HSPACE_EXTRA)
	goto __78
__86:
__87:
	codevalue = codevalue + uint32(DOP_VSPACE_EXTRA)
	goto __78
__88:
	goto __78
__78:
	;
__77:
	;
	goto __65
__64:

	dlen = 0 // Not strictly necessary, but compilers moan
	d = DNOTACHAR // if these variables are not set.
__65:
	;

	// Now process the individual opcodes

	switch codevalue {
	// ==========================================================================
	// These cases are never obeyed. This is a fudge that causes a compile-
	//       time error if the vectors coptable or poptable, which are indexed by
	//       opcode, are not the correct length. It seems to be the only way to do
	//       such a check at compile time, as the sizeof() operator does not work
	//       in the C preprocessor.

	case OP_TABLE_LENGTH:
		goto __90
	case uint32(OP_TABLE_LENGTH + libc.Bool32(uint64(unsafe.Sizeof(coptable)) == OP_TABLE_LENGTH && uint64(unsafe.Sizeof(poptable)) == OP_TABLE_LENGTH)):
		goto __91

		// ==========================================================================
	// Reached a closing bracket. If not at the end of the pattern, carry
	//       on with the next opcode. For repeating opcodes, also add the repeat
	//       state. Note that KETRPOS will always be encountered at the end of the
	//       subpattern, because the possessive subpattern repeats are always handled
	//       using recursive calls. Thus, it never adds any new states.
	//
	//       At the end of the (sub)pattern, unless we have an empty string and
	//       PCRE2_NOTEMPTY is set, or PCRE2_NOTEMPTY_ATSTART is set and we are at the
	//       start of the subject, save the match data, shifting up all previous
	//       matches so we always have the longest first.

	case OP_KET:
		goto __92
	case OP_KETRMIN:
		goto __93
	case OP_KETRMAX:
		goto __94
	case OP_KETRPOS:
		goto __95

		// ==========================================================================
	// These opcodes add to the current list of states without looking
	//       at the current character.

	//-----------------------------------------------------------------
	case OP_ALT:
		goto __96

	//-----------------------------------------------------------------
	case OP_BRA:
		goto __97
	case OP_SBRA:
		goto __98

	//-----------------------------------------------------------------
	case OP_CBRA:
		goto __99
	case OP_SCBRA:
		goto __100

	//-----------------------------------------------------------------
	case OP_BRAZERO:
		goto __101
	case OP_BRAMINZERO:
		goto __102

	//-----------------------------------------------------------------
	case OP_SKIPZERO:
		goto __103

	//-----------------------------------------------------------------
	case OP_CIRC:
		goto __104

	//-----------------------------------------------------------------
	case OP_CIRCM:
		goto __105

	//-----------------------------------------------------------------
	case OP_EOD:
		goto __106

	//-----------------------------------------------------------------
	case OP_SOD:
		goto __107

	//-----------------------------------------------------------------
	case OP_SOM:
		goto __108

		// ==========================================================================
	// These opcodes inspect the next subject character, and sometimes
	//       the previous one as well, but do not have an argument. The variable
	//       clen contains the length of the current character and is zero if we are
	//       at the end of the subject.

	//-----------------------------------------------------------------
	case OP_ANY:
		goto __109

	//-----------------------------------------------------------------
	case OP_ALLANY:
		goto __110

	//-----------------------------------------------------------------
	case OP_EODN:
		goto __111

	//-----------------------------------------------------------------
	case OP_DOLL:
		goto __112

	//-----------------------------------------------------------------
	case OP_DOLLM:
		goto __113

	//-----------------------------------------------------------------

	case OP_DIGIT:
		goto __114
	case OP_WHITESPACE:
		goto __115
	case OP_WORDCHAR:
		goto __116

	//-----------------------------------------------------------------
	case OP_NOT_DIGIT:
		goto __117
	case OP_NOT_WHITESPACE:
		goto __118
	case OP_NOT_WORDCHAR:
		goto __119

	//-----------------------------------------------------------------
	case OP_WORD_BOUNDARY:
		goto __120
	case OP_NOT_WORD_BOUNDARY:
		goto __121

	//-----------------------------------------------------------------
	// Check the next character by Unicode property. We will get here only
	//       if the support is in the binary; otherwise a compile-time error occurs.
	//

	case OP_PROP:
		goto __122
	case OP_NOTPROP:
		goto __123

		// ==========================================================================
	// These opcodes likewise inspect the subject character, but have an
	//       argument that is not a data character. It is one of these opcodes:
	//       OP_ANY, OP_ALLANY, OP_DIGIT, OP_NOT_DIGIT, OP_WHITESPACE, OP_NOT_SPACE,
	//       OP_WORDCHAR, OP_NOT_WORDCHAR. The value is loaded into d.

	case OP_TYPEPLUS:
		goto __124
	case OP_TYPEMINPLUS:
		goto __125
	case OP_TYPEPOSPLUS:
		goto __126

	//-----------------------------------------------------------------
	case OP_TYPEQUERY:
		goto __127
	case OP_TYPEMINQUERY:
		goto __128
	case OP_TYPEPOSQUERY:
		goto __129

	//-----------------------------------------------------------------
	case OP_TYPESTAR:
		goto __130
	case OP_TYPEMINSTAR:
		goto __131
	case OP_TYPEPOSSTAR:
		goto __132

	//-----------------------------------------------------------------
	case OP_TYPEEXACT:
		goto __133

	//-----------------------------------------------------------------
	case OP_TYPEUPTO:
		goto __134
	case OP_TYPEMINUPTO:
		goto __135
	case OP_TYPEPOSUPTO:
		goto __136

		// ==========================================================================
	// These are virtual opcodes that are used when something like
	//       OP_TYPEPLUS has OP_PROP, OP_NOTPROP, OP_ANYNL, or OP_EXTUNI as its
	//       argument. It keeps the code above fast for the other cases. The argument
	//       is in the d variable.

	case uint32(DOP_PROP_EXTRA + OP_TYPEPLUS):
		goto __137
	case uint32(DOP_PROP_EXTRA + OP_TYPEMINPLUS):
		goto __138
	case uint32(DOP_PROP_EXTRA + OP_TYPEPOSPLUS):
		goto __139

	//-----------------------------------------------------------------
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEPLUS):
		goto __140
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEMINPLUS):
		goto __141
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEPOSPLUS):
		goto __142

	//-----------------------------------------------------------------
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEPLUS):
		goto __143
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEMINPLUS):
		goto __144
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEPOSPLUS):
		goto __145

	//-----------------------------------------------------------------
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEPLUS):
		goto __146
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEMINPLUS):
		goto __147
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEPOSPLUS):
		goto __148

	//-----------------------------------------------------------------
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEPLUS):
		goto __149
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEMINPLUS):
		goto __150
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEPOSPLUS):
		goto __151

	//-----------------------------------------------------------------
	case uint32(DOP_PROP_EXTRA + OP_TYPEQUERY):
		goto __152
	case uint32(DOP_PROP_EXTRA + OP_TYPEMINQUERY):
		goto __153
	case uint32(DOP_PROP_EXTRA + OP_TYPEPOSQUERY):
		goto __154

	case uint32(DOP_PROP_EXTRA + OP_TYPESTAR):
		goto __155
	case uint32(DOP_PROP_EXTRA + OP_TYPEMINSTAR):
		goto __156
	case uint32(DOP_PROP_EXTRA + OP_TYPEPOSSTAR):
		goto __157

	//-----------------------------------------------------------------
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEQUERY):
		goto __158
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEMINQUERY):
		goto __159
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEPOSQUERY):
		goto __160

	case uint32(DOP_EXTUNI_EXTRA + OP_TYPESTAR):
		goto __161
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEMINSTAR):
		goto __162
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEPOSSTAR):
		goto __163

	//-----------------------------------------------------------------
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEQUERY):
		goto __164
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEMINQUERY):
		goto __165
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEPOSQUERY):
		goto __166

	case uint32(DOP_ANYNL_EXTRA + OP_TYPESTAR):
		goto __167
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEMINSTAR):
		goto __168
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEPOSSTAR):
		goto __169

	//-----------------------------------------------------------------
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEQUERY):
		goto __170
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEMINQUERY):
		goto __171
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEPOSQUERY):
		goto __172

	case uint32(DOP_VSPACE_EXTRA + OP_TYPESTAR):
		goto __173
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEMINSTAR):
		goto __174
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEPOSSTAR):
		goto __175

	//-----------------------------------------------------------------
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEQUERY):
		goto __176
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEMINQUERY):
		goto __177
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEPOSQUERY):
		goto __178

	case uint32(DOP_HSPACE_EXTRA + OP_TYPESTAR):
		goto __179
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEMINSTAR):
		goto __180
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEPOSSTAR):
		goto __181

	//-----------------------------------------------------------------
	case uint32(DOP_PROP_EXTRA + OP_TYPEEXACT):
		goto __182
	case uint32(DOP_PROP_EXTRA + OP_TYPEUPTO):
		goto __183
	case uint32(DOP_PROP_EXTRA + OP_TYPEMINUPTO):
		goto __184
	case uint32(DOP_PROP_EXTRA + OP_TYPEPOSUPTO):
		goto __185

	//-----------------------------------------------------------------
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEEXACT):
		goto __186
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEUPTO):
		goto __187
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEMINUPTO):
		goto __188
	case uint32(DOP_EXTUNI_EXTRA + OP_TYPEPOSUPTO):
		goto __189

	//-----------------------------------------------------------------
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEEXACT):
		goto __190
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEUPTO):
		goto __191
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEMINUPTO):
		goto __192
	case uint32(DOP_ANYNL_EXTRA + OP_TYPEPOSUPTO):
		goto __193

	//-----------------------------------------------------------------
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEEXACT):
		goto __194
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEUPTO):
		goto __195
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEMINUPTO):
		goto __196
	case uint32(DOP_VSPACE_EXTRA + OP_TYPEPOSUPTO):
		goto __197

	//-----------------------------------------------------------------
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEEXACT):
		goto __198
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEUPTO):
		goto __199
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEMINUPTO):
		goto __200
	case uint32(DOP_HSPACE_EXTRA + OP_TYPEPOSUPTO):
		goto __201

		// ==========================================================================
	// These opcodes are followed by a character that is usually compared
	//       to the current subject character; it is loaded into d. We still get
	//       here even if there is no subject character, because in some cases zero
	//       repetitions are permitted.

	//-----------------------------------------------------------------
	case OP_CHAR:
		goto __202

	//-----------------------------------------------------------------
	case OP_CHARI:
		goto __203

	//-----------------------------------------------------------------
	// This is a tricky one because it can match more than one character.
	//       Find out how many characters to skip, and then set up a negative state
	//       to wait for them to pass before continuing.

	case OP_EXTUNI:
		goto __204

	//-----------------------------------------------------------------
	// This is a tricky like EXTUNI because it too can match more than one
	//       character (when CR is followed by LF). In this case, set up a negative
	//       state to wait for one character to pass before continuing.

	case OP_ANYNL:
		goto __205

	//-----------------------------------------------------------------
	case OP_NOT_VSPACE:
		goto __206

	//-----------------------------------------------------------------
	case OP_VSPACE:
		goto __207

	//-----------------------------------------------------------------
	case OP_NOT_HSPACE:
		goto __208

	//-----------------------------------------------------------------
	case OP_HSPACE:
		goto __209

	//-----------------------------------------------------------------
	// Match a negated single character casefully.

	case OP_NOT:
		goto __210

	//-----------------------------------------------------------------
	// Match a negated single character caselessly.

	case OP_NOTI:
		goto __211

	//-----------------------------------------------------------------
	case OP_PLUSI:
		goto __212
	case OP_MINPLUSI:
		goto __213
	case OP_POSPLUSI:
		goto __214
	case OP_NOTPLUSI:
		goto __215
	case OP_NOTMINPLUSI:
		goto __216
	case OP_NOTPOSPLUSI:
		goto __217

	// Fall through
	case OP_PLUS:
		goto __218
	case OP_MINPLUS:
		goto __219
	case OP_POSPLUS:
		goto __220
	case OP_NOTPLUS:
		goto __221
	case OP_NOTMINPLUS:
		goto __222
	case OP_NOTPOSPLUS:
		goto __223

	//-----------------------------------------------------------------
	case OP_QUERYI:
		goto __224
	case OP_MINQUERYI:
		goto __225
	case OP_POSQUERYI:
		goto __226
	case OP_NOTQUERYI:
		goto __227
	case OP_NOTMINQUERYI:
		goto __228
	case OP_NOTPOSQUERYI:
		goto __229
	// Fall through
	case OP_QUERY:
		goto __230
	case OP_MINQUERY:
		goto __231
	case OP_POSQUERY:
		goto __232
	case OP_NOTQUERY:
		goto __233
	case OP_NOTMINQUERY:
		goto __234
	case OP_NOTPOSQUERY:
		goto __235

	//-----------------------------------------------------------------
	case OP_STARI:
		goto __236
	case OP_MINSTARI:
		goto __237
	case OP_POSSTARI:
		goto __238
	case OP_NOTSTARI:
		goto __239
	case OP_NOTMINSTARI:
		goto __240
	case OP_NOTPOSSTARI:
		goto __241
	// Fall through
	case OP_STAR:
		goto __242
	case OP_MINSTAR:
		goto __243
	case OP_POSSTAR:
		goto __244
	case OP_NOTSTAR:
		goto __245
	case OP_NOTMINSTAR:
		goto __246
	case OP_NOTPOSSTAR:
		goto __247

	//-----------------------------------------------------------------
	case OP_EXACTI:
		goto __248
	case OP_NOTEXACTI:
		goto __249
	// Fall through
	case OP_EXACT:
		goto __250
	case OP_NOTEXACT:
		goto __251

	//-----------------------------------------------------------------
	case OP_UPTOI:
		goto __252
	case OP_MINUPTOI:
		goto __253
	case OP_POSUPTOI:
		goto __254
	case OP_NOTUPTOI:
		goto __255
	case OP_NOTMINUPTOI:
		goto __256
	case OP_NOTPOSUPTOI:
		goto __257
	// Fall through
	case OP_UPTO:
		goto __258
	case OP_MINUPTO:
		goto __259
	case OP_POSUPTO:
		goto __260
	case OP_NOTUPTO:
		goto __261
	case OP_NOTMINUPTO:
		goto __262
	case OP_NOTPOSUPTO:
		goto __263

		// ==========================================================================
	// These are the class-handling opcodes

	case OP_CLASS:
		goto __264
	case OP_NCLASS:
		goto __265
	case OP_XCLASS:
		goto __266

		// ==========================================================================
	// These are the opcodes for fancy brackets of various kinds. We have
	//       to use recursion in order to handle them. The "always failing" assertion
	//       (?!) is optimised to OP_FAIL when compiling, so we have to support that,
	//       though the other "backtracking verbs" are not supported.

	case OP_FAIL:
		goto __267

	case OP_ASSERT:
		goto __268
	case OP_ASSERT_NOT:
		goto __269
	case OP_ASSERTBACK:
		goto __270
	case OP_ASSERTBACK_NOT:
		goto __271

	//-----------------------------------------------------------------
	case OP_COND:
		goto __272
	case OP_SCOND:
		goto __273

	//-----------------------------------------------------------------
	case OP_RECURSE:
		goto __274

	//-----------------------------------------------------------------
	case OP_BRAPOS:
		goto __275
	case OP_SBRAPOS:
		goto __276
	case OP_CBRAPOS:
		goto __277
	case OP_SCBRAPOS:
		goto __278
	case OP_BRAPOSZERO:
		goto __279

	//-----------------------------------------------------------------
	case OP_ONCE:
		goto __280

		// ==========================================================================
	// Handle callouts

	case OP_CALLOUT:
		goto __281
	case OP_CALLOUT_STR:
		goto __282

		// ==========================================================================
	default:
		goto __283
	}
	goto __89

	// ==========================================================================
	// These cases are never obeyed. This is a fudge that causes a compile-
	//       time error if the vectors coptable or poptable, which are indexed by
	//       opcode, are not the correct length. It seems to be the only way to do
	//       such a check at compile time, as the sizeof() operator does not work
	//       in the C preprocessor.

__90:
__91:
	return 0

	// ==========================================================================
	// Reached a closing bracket. If not at the end of the pattern, carry
	//       on with the next opcode. For repeating opcodes, also add the repeat
	//       state. Note that KETRPOS will always be encountered at the end of the
	//       subpattern, because the possessive subpattern repeats are always handled
	//       using recursive calls. Thus, it never adds any new states.
	//
	//       At the end of the (sub)pattern, unless we have an empty string and
	//       PCRE2_NOTEMPTY is set, or PCRE2_NOTEMPTY_ATSTART is set and we are at the
	//       start of the subject, save the match data, shifting up all previous
	//       matches so we always have the longest first.

__92:
__93:
__94:
__95:
	if !(code != end_code) {
		goto __284
	}

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __286
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1 + DLINK_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __287
__286:
	return -43
__287:
	;
	if !(codevalue != OP_KET) {
		goto __288
	}

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __289
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset - int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __290
__289:
	return -43
__290:
	;
__288:
	;
	goto __285
__284:

	if !(ptr > current_subject || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEMPTY == uint32(0) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEMPTY_ATSTART == uint32(0) || current_subject > start_subject+uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_offset))) {
		goto __291
	}

	if !(match_count < 0) {
		goto __292
	}
	if offsetcount >= uint32(2) {
		match_count = 1
	} else {
		match_count = 0
	}
	goto __293
__292:
	if !(match_count > 0 && libc.PreIncInt32(&match_count, 1)*2 > int32(offsetcount)) {
		goto __294
	}
	match_count = 0
__294:
	;
__293:
	;
	count = func() int32 {
		if match_count == 0 {
			return int32(offsetcount)
		}
		return match_count * 2
	}() - 2
	if !(count > 0) {
		goto __295
	}
	libc.Xmemmove(tls, offsets+uintptr(2)*8, offsets,
		uint64(count)*uint64(unsafe.Sizeof(uint64(0))))
__295:
	;
	if !(offsetcount >= uint32(2)) {
		goto __296
	}

	*(*uint64)(unsafe.Pointer(offsets)) = uint64((int64(current_subject) - int64(start_subject)) / 1)
	*(*uint64)(unsafe.Pointer(offsets + 1*8)) = uint64((int64(ptr) - int64(start_subject)) / 1)
__296:
	;
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_DFA_SHORTEST != uint32(0)) {
		goto __297
	}
	return match_count
__297:
	;
__291:
	;
__285:
	;
	goto __89

	// ==========================================================================
	// These opcodes add to the current list of states without looking
	//       at the current character.

	//-----------------------------------------------------------------
__96:
__298:
	code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	goto __299
__299:
	if int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT {
		goto __298
	}
	goto __300
__300:
	;
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __301
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code) - int64(start_code)) / 1)
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __302
__301:
	return -43
__302:
	;
	goto __89

	//-----------------------------------------------------------------
__97:
__98:
__303:

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __306
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __307
__306:
	return -43
__307:
	;
	code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	goto __304
__304:
	if int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT {
		goto __303
	}
	goto __305
__305:
	;
	goto __89

	//-----------------------------------------------------------------
__99:
__100:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __308
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE) + int64(DIMM2_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __309
__308:
	return -43
__309:
	;
	code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
__310:
	if !(int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT) {
		goto __311
	}

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __312
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __313
__312:
	return -43
__313:
	;
	code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	goto __310
__311:
	;
	goto __89

	//-----------------------------------------------------------------
__101:
__102:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __314
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __315
__314:
	return -43
__315:
	;
	code += uintptr(uint32(1) + uint32(int32(*(*uint8)(unsafe.Pointer(code + 2)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 3)))))
__316:
	if !(int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT) {
		goto __317
	}
	code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	goto __316
__317:
	;
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __318
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __319
__318:
	return -43
__319:
	;
	goto __89

	//-----------------------------------------------------------------
__103:
	code += uintptr(uint32(1) + uint32(int32(*(*uint8)(unsafe.Pointer(code + 2)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 3)))))
__320:
	if !(int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT) {
		goto __321
	}
	code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	goto __320
__321:
	;
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __322
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(code)-int64(start_code))/1 + int64(1) + int64(DLINK_SIZE))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __323
__322:
	return -43
__323:
	;
	goto __89

	//-----------------------------------------------------------------
__104:
	if !(ptr == start_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTBOL == uint32(0)) {
		goto __324
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __325
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __326
__325:
	return -43
__326:
	;
__324:
	;
	goto __89

	//-----------------------------------------------------------------
__105:
	if !(ptr == start_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTBOL == uint32(0) || (ptr != end_subject || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_ALT_CIRCUMFLEX != uint32(0)) &&
		func() int32 {
			if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
				return libc.Bool32(ptr > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+120, utf) != 0)
			}
			return libc.Bool32(ptr >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
		}() != 0) {
		goto __327
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __328
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __329
__328:
	return -43
__329:
	;
__327:
	;
	goto __89

	//-----------------------------------------------------------------
__106:
	if !(ptr >= end_subject) {
		goto __330
	}

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __331
	}
	return -2
	goto __332
__331:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __333
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __334
__333:
	return -43
__334:
	;
__332:
	;
__330:
	;
	goto __89

	//-----------------------------------------------------------------
__107:
	if !(ptr == start_subject) {
		goto __335
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __336
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __337
__336:
	return -43
__337:
	;
__335:
	;
	goto __89

	//-----------------------------------------------------------------
__108:
	if !(ptr == start_subject+uintptr(start_offset)) {
		goto __338
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __339
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __340
__339:
	return -43
__340:
	;
__338:
	;
	goto __89

	// ==========================================================================
	// These opcodes inspect the next subject character, and sometimes
	//       the previous one as well, but do not have an argument. The variable
	//       clen contains the length of the current character and is zero if we are
	//       at the end of the subject.

	//-----------------------------------------------------------------
__109:
	if !(clen > 0 && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __341
	}

	if !(ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && c == uint32(*(*uint8)(unsafe.Pointer(mb + 128)))) {
		goto __342
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __343
__342:

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __344
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __345
__344:
	return -43
__345:
	;
__343:
	;
__341:
	;
	goto __89

	//-----------------------------------------------------------------
__110:
	if !(clen > 0) {
		goto __346
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __347
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __348
__347:
	return -43
__348:
	;
__346:
	;
	goto __89

	//-----------------------------------------------------------------
__111:
	if !(clen == 0 || func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0 && ptr == end_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)) {
		goto __349
	}

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __350
	}
	return -2
__350:
	;
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __351
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __352
__351:
	return -43
__352:
	;
__349:
	;
	goto __89

	//-----------------------------------------------------------------
__112:
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEOL == uint32(0)) {
		goto __353
	}

	if !(clen == 0 && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __354
	}
	could_continue = DTRUE
	goto __355
__354:
	if !(clen == 0 || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_DOLLAR_ENDONLY == uint32(0) && func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0 && ptr == end_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)) {
		goto __356
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __358
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __359
__358:
	return -43
__359:
	;
	goto __357
__356:
	if !(ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) != uint32(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && c == uint32(*(*uint8)(unsafe.Pointer(mb + 128)))) {
		goto __360
	}

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __361
	}

	reset_could_continue = DTRUE
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __363
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 1
	next_new_state += 12
	goto __364
__363:
	return -43
__364:
	;
	goto __362
__361:
	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
__362:
	;
__360:
	;
__357:
	;
__355:
	;
__353:
	;
	goto __89

	//-----------------------------------------------------------------
__113:
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEOL == uint32(0)) {
		goto __365
	}

	if !(clen == 0 && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __367
	}
	could_continue = DTRUE
	goto __368
__367:
	if !(clen == 0 || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_DOLLAR_ENDONLY == uint32(0) && func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0) {
		goto __369
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __371
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __372
__371:
	return -43
__372:
	;
	goto __370
__369:
	if !(ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) != uint32(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && c == uint32(*(*uint8)(unsafe.Pointer(mb + 128)))) {
		goto __373
	}

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __374
	}

	reset_could_continue = DTRUE
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __376
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 1
	next_new_state += 12
	goto __377
__376:
	return -43
__377:
	;
	goto __375
__374:
	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
__375:
	;
__373:
	;
__370:
	;
__368:
	;
	goto __366
__365:
	if !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0) {
		goto __378
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __379
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __380
__379:
	return -43
__380:
	;
__378:
	;
__366:
	;
	goto __89

	//-----------------------------------------------------------------

__114:
__115:
__116:
	if !(clen > 0 && c < uint32(256) && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[codevalue])^int32(toptable2[codevalue]) != 0) {
		goto __381
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __382
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __383
__382:
	return -43
__383:
	;
__381:
	;
	goto __89

	//-----------------------------------------------------------------
__117:
__118:
__119:
	if !(clen > 0 && (c >= uint32(256) || int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[codevalue])^int32(toptable2[codevalue]) != 0)) {
		goto __384
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __385
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __386
__385:
	return -43
__386:
	;
__384:
	;
	goto __89

	//-----------------------------------------------------------------
__120:
__121:

	if !(ptr > start_subject) {
		goto __387
	}

	temp = ptr - uintptr(1)
	if !(temp < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __389
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = temp
__389:
	;
	if !(utf != 0) {
		goto __390
	}
__391:
	if !(uint32(*(*uint8)(unsafe.Pointer(temp)))&0xc0 == 0x80) {
		goto __392
	}
	temp--
	goto __391
__392:
	;
__390:
	;
	d = uint32(*(*uint8)(unsafe.Pointer(temp)))
	if !(utf != 0 && d >= 0xc0) {
		goto __393
	}
	if !(d&0x20 == uint32(0)) {
		goto __394
	}
	d = d&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(temp + 1)))&0x3f
	goto __395
__394:
	if !(d&0x10 == uint32(0)) {
		goto __396
	}
	d = d&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(temp + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(temp + 2)))&0x3f
	goto __397
__396:
	if !(d&0x08 == uint32(0)) {
		goto __398
	}
	d = d&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(temp + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(temp + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(temp + 3)))&0x3f
	goto __399
__398:
	if !(d&0x04 == uint32(0)) {
		goto __400
	}
	d = d&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(temp + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(temp + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(temp + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(temp + 4)))&0x3f
	goto __401
__400:
	d = d&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(temp + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(temp + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(temp + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(temp + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(temp + 5)))&0x3f
__401:
	;
__399:
	;
__397:
	;
__395:
	;
__393:
	;

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != uint32(0)) {
		goto __402
	}

	if !(d == uint32('_')) {
		goto __404
	}
	left_word = DTRUE
	goto __405
__404:

	cat = X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fchartype]
	left_word = libc.Bool32(cat == ucp_L || cat == ucp_N)
__405:
	;
	goto __403
__402:
	left_word = libc.Bool32(d < uint32(256) && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(d))))&Dctype_word != 0)
__403:
	;
	goto __388
__387:
	left_word = DFALSE
__388:
	;

	if !(clen > 0) {
		goto __406
	}

	if !(ptr >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __408
	}

	temp1 = ptr + uintptr(1)
	if !(utf != 0) {
		goto __409
	}
__410:
	if !(temp1 < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer(temp1)))&0xc0 == 0x80) {
		goto __411
	}
	temp1++
	goto __410
__411:
	;
__409:
	;
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = temp1
__408:
	;
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != uint32(0)) {
		goto __412
	}

	if !(c == uint32('_')) {
		goto __414
	}
	right_word = DTRUE
	goto __415
__414:

	cat1 = X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fchartype]
	right_word = libc.Bool32(cat1 == ucp_L || cat1 == ucp_N)
__415:
	;
	goto __413
__412:
	right_word = libc.Bool32(c < uint32(256) && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(c))))&Dctype_word != 0)
__413:
	;
	goto __407
__406:
	right_word = DFALSE
__407:
	;

	if !(libc.Bool32(left_word == right_word) == libc.Bool32(codevalue == OP_NOT_WORD_BOUNDARY)) {
		goto __416
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __417
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __418
__417:
	return -43
__418:
	;
__416:
	;

	goto __89

	//-----------------------------------------------------------------
	// Check the next character by Unicode property. We will get here only
	//       if the support is in the binary; otherwise a compile-time error occurs.
	//

__122:
__123:
	if !(clen > 0) {
		goto __419
	}

	prop = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
	switch int32(*(*uint8)(unsafe.Pointer(code + 1))) {
	case DPT_ANY:
		goto __421

	case DPT_LAMP:
		goto __422

	case DPT_GC:
		goto __423

	case DPT_PC:
		goto __424

	case DPT_SC:
		goto __425

	case DPT_SCX:
		goto __426

	// These are specials for combination cases.

	case DPT_ALNUM:
		goto __427

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __428 // Perl space
	case DPT_PXSPACE:
		goto __429

	case DPT_WORD:
		goto __430

	case DPT_CLIST:
		goto __431

	case DPT_UCNC:
		goto __432

	case DPT_BIDICL:
		goto __433

	case DPT_BOOL:
		goto __434

	// Should never occur, but keep compilers from grumbling.

	default:
		goto __435
	}
	goto __420

__421:
	OK = DTRUE
	goto __420

__422:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lt)
	goto __420

__423:
	OK = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == uint32(*(*uint8)(unsafe.Pointer(code + 2))))
	goto __420

__424:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == int32(*(*uint8)(unsafe.Pointer(code + 2))))
	goto __420

__425:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) == int32(*(*uint8)(unsafe.Pointer(code + 2))))
	goto __420

__426:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) == int32(*(*uint8)(unsafe.Pointer(code + 2))) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(code + 2)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(code + 2)))%32)) != uint32(0))
	goto __420

	// These are specials for combination cases.

__427:
	OK = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N)
	goto __420

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__428: // Perl space
__429: // POSIX space
	switch c {
	case uint32('\011'):
		goto __437
	case uint32('\040'):
		goto __438
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __439
	case uint32(0x1680):
		goto __440 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __441 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __442 /* EN QUAD */
	case uint32(0x2001):
		goto __443 /* EM QUAD */
	case uint32(0x2002):
		goto __444 /* EN SPACE */
	case uint32(0x2003):
		goto __445 /* EM SPACE */
	case uint32(0x2004):
		goto __446 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __447 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __448 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __449 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __450 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __451 /* THIN SPACE */
	case uint32(0x200A):
		goto __452 /* HAIR SPACE */
	case uint32(0x202f):
		goto __453 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __454 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __455
	case uint32('\012'):
		goto __456
	case uint32('\013'):
		goto __457
	case uint32('\014'):
		goto __458
	case uint32('\015'):
		goto __459
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __460
	case uint32(0x2028):
		goto __461 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __462

	default:
		goto __463
	}
	goto __436

__437:
__438:
__439:
__440: /* OGHAM SPACE MARK */
__441: /* MONGOLIAN VOWEL SEPARATOR */
__442: /* EN QUAD */
__443: /* EM QUAD */
__444: /* EN SPACE */
__445: /* EM SPACE */
__446: /* THREE-PER-EM SPACE */
__447: /* FOUR-PER-EM SPACE */
__448: /* SIX-PER-EM SPACE */
__449: /* FIGURE SPACE */
__450: /* PUNCTUATION SPACE */
__451: /* THIN SPACE */
__452: /* HAIR SPACE */
__453: /* NARROW NO-BREAK SPACE */
__454: /* MEDIUM MATHEMATICAL SPACE */
__455:
__456:
__457:
__458:
__459:
__460:
__461: /* LINE SEPARATOR */
__462:
	OK = DTRUE
	goto __436

__463:
	OK = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_Z)
	goto __436
__436:
	;
	goto __420

__430:
	OK = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N || c == uint32('\137'))
	goto __420

__431:
	cp = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint8)(unsafe.Pointer(code + 2)))*4
__464:

	if !(c < *(*uint32)(unsafe.Pointer(cp))) {
		goto __467
	}
	OK = DFALSE
	goto __466
__467:
	;
	if !(c == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&cp, 4)))) {
		goto __468
	}
	OK = DTRUE
	goto __466
__468:
	;
	goto __465
__465:
	goto __464
	goto __466
__466:
	;
	goto __420

__432:
	OK = libc.Bool32(c == uint32('\044') || c == uint32('\100') || c == uint32('\140') || c >= uint32(0xa0) && c <= uint32(0xd7ff) || c >= uint32(0xe000))
	goto __420

__433:
	OK = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*uint8)(unsafe.Pointer(code + 2))))
	goto __420

__434:
	OK = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(code + 2)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(code + 2)))%32)) != uint32(0))
	goto __420

	// Should never occur, but keep compilers from grumbling.

__435:
	OK = libc.Bool32(codevalue != OP_PROP)
	goto __420
__420:
	;

	if !(OK == libc.Bool32(codevalue == OP_PROP)) {
		goto __469
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __470
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 3
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __471
__470:
	return -43
__471:
	;
__469:
	;
__419:
	;
	goto __89

	// ==========================================================================
	// These opcodes likewise inspect the subject character, but have an
	//       argument that is not a data character. It is one of these opcodes:
	//       OP_ANY, OP_ALLANY, OP_DIGIT, OP_NOT_DIGIT, OP_WHITESPACE, OP_NOT_SPACE,
	//       OP_WORDCHAR, OP_NOT_WORDCHAR. The value is loaded into d.

__124:
__125:
__126:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __472
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __473
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __474
__473:
	return -43
__474:
	;
__472:
	;
	if !(clen > 0) {
		goto __475
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && c == uint32(*(*uint8)(unsafe.Pointer(mb + 128)))) {
		goto __476
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __477
__476:
	if !(c >= uint32(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < uint32(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __478
	}

	if !(count > 0 && codevalue == OP_TYPEPOSPLUS) {
		goto __479
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__479:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __480
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __481
__480:
	return -43
__481:
	;
__478:
	;
__477:
	;
__475:
	;
	goto __89

	//-----------------------------------------------------------------
__127:
__128:
__129:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __482
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __483
__482:
	return -43
__483:
	;
	if !(clen > 0) {
		goto __484
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && c == uint32(*(*uint8)(unsafe.Pointer(mb + 128)))) {
		goto __485
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __486
__485:
	if !(c >= uint32(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < uint32(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __487
	}

	if !(codevalue == OP_TYPEPOSQUERY) {
		goto __488
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__488:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __489
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __490
__489:
	return -43
__490:
	;
__487:
	;
__486:
	;
__484:
	;
	goto __89

	//-----------------------------------------------------------------
__130:
__131:
__132:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __491
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __492
__491:
	return -43
__492:
	;
	if !(clen > 0) {
		goto __493
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && c == uint32(*(*uint8)(unsafe.Pointer(mb + 128)))) {
		goto __494
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __495
__494:
	if !(c >= uint32(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < uint32(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __496
	}

	if !(codevalue == OP_TYPEPOSSTAR) {
		goto __497
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__497:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __498
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __499
__498:
	return -43
__499:
	;
__496:
	;
__495:
	;
__493:
	;
	goto __89

	//-----------------------------------------------------------------
__133:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __500
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && c == uint32(*(*uint8)(unsafe.Pointer(mb + 128)))) {
		goto __501
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __502
__501:
	if !(c >= uint32(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < uint32(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __503
	}

	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __504
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __506
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1 + DIMM2_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __507
__506:
	return -43
__507:
	;
	goto __505
__504:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __508
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __509
__508:
	return -43
__509:
	;
__505:
	;
__503:
	;
__502:
	;
__500:
	;
	goto __89

	//-----------------------------------------------------------------
__134:
__135:
__136:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __510
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __511
__510:
	return -43
__511:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __512
	}

	if !(d == OP_ANY && ptr+uintptr(1) >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && c == uint32(*(*uint8)(unsafe.Pointer(mb + 128)))) {
		goto __513
	}

	could_continue = libc.AssignInt32(&partial_newline, DTRUE)
	goto __514
__513:
	if !(c >= uint32(256) && d != OP_DIGIT && d != OP_WHITESPACE && d != OP_WORDCHAR || c < uint32(256) && (d != OP_ANY || !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(ptr < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, ptr, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(ptr <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(ptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(c))))&int32(toptable1[d])^int32(toptable2[d]) != 0) {
		goto __515
	}

	if !(codevalue == OP_TYPEPOSUPTO) {
		goto __516
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__516:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __517
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __519
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __520
__519:
	return -43
__520:
	;
	goto __518
__517:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __521
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __522
__521:
	return -43
__522:
	;
__518:
	;
__515:
	;
__514:
	;
__512:
	;
	goto __89

	// ==========================================================================
	// These are virtual opcodes that are used when something like
	//       OP_TYPEPLUS has OP_PROP, OP_NOTPROP, OP_ANYNL, or OP_EXTUNI as its
	//       argument. It keeps the code above fast for the other cases. The argument
	//       is in the d variable.

__137:
__138:
__139:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __523
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __524
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 4
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __525
__524:
	return -43
__525:
	;
__523:
	;
	if !(clen > 0) {
		goto __526
	}

	prop1 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
	switch int32(*(*uint8)(unsafe.Pointer(code + 2))) {
	case DPT_ANY:
		goto __528

	case DPT_LAMP:
		goto __529

	case DPT_GC:
		goto __530

	case DPT_PC:
		goto __531

	case DPT_SC:
		goto __532

	case DPT_SCX:
		goto __533

	// These are specials for combination cases.

	case DPT_ALNUM:
		goto __534

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __535 // Perl space
	case DPT_PXSPACE:
		goto __536

	case DPT_WORD:
		goto __537

	case DPT_CLIST:
		goto __538

	case DPT_UCNC:
		goto __539

	case DPT_BIDICL:
		goto __540

	case DPT_BOOL:
		goto __541

	// Should never occur, but keep compilers from grumbling.

	default:
		goto __542
	}
	goto __527

__528:
	OK1 = DTRUE
	goto __527

__529:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop1)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop1)).Fchartype) == ucp_Lt)
	goto __527

__530:
	OK1 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == uint32(*(*uint8)(unsafe.Pointer(code + 3))))
	goto __527

__531:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fchartype) == int32(*(*uint8)(unsafe.Pointer(code + 3))))
	goto __527

__532:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fscript) == int32(*(*uint8)(unsafe.Pointer(code + 3))))
	goto __527

__533:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fscript) == int32(*(*uint8)(unsafe.Pointer(code + 3))) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(code + 3)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(code + 3)))%32)) != uint32(0))
	goto __527

	// These are specials for combination cases.

__534:
	OK1 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_N)
	goto __527

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__535: // Perl space
__536: // POSIX space
	switch c {
	case uint32('\011'):
		goto __544
	case uint32('\040'):
		goto __545
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __546
	case uint32(0x1680):
		goto __547 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __548 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __549 /* EN QUAD */
	case uint32(0x2001):
		goto __550 /* EM QUAD */
	case uint32(0x2002):
		goto __551 /* EN SPACE */
	case uint32(0x2003):
		goto __552 /* EM SPACE */
	case uint32(0x2004):
		goto __553 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __554 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __555 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __556 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __557 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __558 /* THIN SPACE */
	case uint32(0x200A):
		goto __559 /* HAIR SPACE */
	case uint32(0x202f):
		goto __560 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __561 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __562
	case uint32('\012'):
		goto __563
	case uint32('\013'):
		goto __564
	case uint32('\014'):
		goto __565
	case uint32('\015'):
		goto __566
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __567
	case uint32(0x2028):
		goto __568 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __569

	default:
		goto __570
	}
	goto __543

__544:
__545:
__546:
__547: /* OGHAM SPACE MARK */
__548: /* MONGOLIAN VOWEL SEPARATOR */
__549: /* EN QUAD */
__550: /* EM QUAD */
__551: /* EN SPACE */
__552: /* EM SPACE */
__553: /* THREE-PER-EM SPACE */
__554: /* FOUR-PER-EM SPACE */
__555: /* SIX-PER-EM SPACE */
__556: /* FIGURE SPACE */
__557: /* PUNCTUATION SPACE */
__558: /* THIN SPACE */
__559: /* HAIR SPACE */
__560: /* NARROW NO-BREAK SPACE */
__561: /* MEDIUM MATHEMATICAL SPACE */
__562:
__563:
__564:
__565:
__566:
__567:
__568: /* LINE SEPARATOR */
__569:
	OK1 = DTRUE
	goto __543

__570:
	OK1 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_Z)
	goto __543
__543:
	;
	goto __527

__537:
	OK1 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop1)).Fchartype] == ucp_N || c == uint32('\137'))
	goto __527

__538:
	cp1 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint8)(unsafe.Pointer(code + 3)))*4
__571:

	if !(c < *(*uint32)(unsafe.Pointer(cp1))) {
		goto __574
	}
	OK1 = DFALSE
	goto __573
__574:
	;
	if !(c == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&cp1, 4)))) {
		goto __575
	}
	OK1 = DTRUE
	goto __573
__575:
	;
	goto __572
__572:
	goto __571
	goto __573
__573:
	;
	goto __527

__539:
	OK1 = libc.Bool32(c == uint32('\044') || c == uint32('\100') || c == uint32('\140') || c >= uint32(0xa0) && c <= uint32(0xd7ff) || c >= uint32(0xe000))
	goto __527

__540:
	OK1 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*uint8)(unsafe.Pointer(code + 3))))
	goto __527

__541:
	OK1 = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(code + 3)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(code + 3)))%32)) != uint32(0))
	goto __527

	// Should never occur, but keep compilers from grumbling.

__542:
	OK1 = libc.Bool32(codevalue != OP_PROP)
	goto __527
__527:
	;

	if !(OK1 == libc.Bool32(d == OP_PROP)) {
		goto __576
	}

	if !(count > 0 && codevalue == uint32(DOP_PROP_EXTRA+OP_TYPEPOSPLUS)) {
		goto __577
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__577:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __578
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __579
__578:
	return -43
__579:
	;
__576:
	;
__526:
	;
	goto __89

	//-----------------------------------------------------------------
__140:
__141:
__142:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __580
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __581
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __582
__581:
	return -43
__582:
	;
__580:
	;
	if !(clen > 0) {
		goto __583
	}

	*(*int32)(unsafe.Pointer(bp /* ncount */)) = 0
	if !(count > 0 && codevalue == uint32(DOP_EXTUNI_EXTRA+OP_TYPEPOSPLUS)) {
		goto __584
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__584:
	;
	X_pcre2_extuni_8(tls, c, ptr+uintptr(clen), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, end_subject, utf,
		bp)
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __585
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp))
	next_new_state += 12
	goto __586
__585:
	return -43
__586:
	;
__583:
	;
	goto __89

	//-----------------------------------------------------------------
__143:
__144:
__145:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __587
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __588
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __589
__588:
	return -43
__589:
	;
__587:
	;
	if !(clen > 0) {
		goto __590
	}
	ncount1 = 0
	switch c {
	case uint32('\013'):
		goto __592
	case uint32('\014'):
		goto __593
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __594
	case uint32(0x2028):
		goto __595
	case uint32(0x2029):
		goto __596

	case uint32('\015'):
		goto __597
	case uint32('\012'):
		goto __598

	default:
		goto __599
	}
	goto __591

__592:
__593:
__594:
__595:
__596:
	if !(int32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __600
	}
	goto __591
__600:
	;
	goto ANYNL01

__597:
	if !(ptr+uintptr(1) < end_subject && int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == '\012') {
		goto __601
	}
	ncount1 = 1
__601:
	;
	// Fall through

ANYNL01:
__598:
	if !(count > 0 && codevalue == uint32(DOP_ANYNL_EXTRA+OP_TYPEPOSPLUS)) {
		goto __602
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__602:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __603
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = ncount1
	next_new_state += 12
	goto __604
__603:
	return -43
__604:
	;
	goto __591

__599:
	goto __591
__591:
	;
__590:
	;
	goto __89

	//-----------------------------------------------------------------
__146:
__147:
__148:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __605
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __606
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __607
__606:
	return -43
__607:
	;
__605:
	;
	if !(clen > 0) {
		goto __608
	}

	switch c {
	case uint32('\012'):
		goto __610
	case uint32('\013'):
		goto __611
	case uint32('\014'):
		goto __612
	case uint32('\015'):
		goto __613
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __614
	case uint32(0x2028):
		goto __615 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __616

	default:
		goto __617
	}
	goto __609

__610:
__611:
__612:
__613:
__614:
__615: /* LINE SEPARATOR */
__616:
	OK2 = DTRUE
	goto __609

__617:
	OK2 = DFALSE
	goto __609
__609:
	;

	if !(OK2 == libc.Bool32(d == OP_VSPACE)) {
		goto __618
	}

	if !(count > 0 && codevalue == uint32(DOP_VSPACE_EXTRA+OP_TYPEPOSPLUS)) {
		goto __619
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__619:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __620
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __621
__620:
	return -43
__621:
	;
__618:
	;
__608:
	;
	goto __89

	//-----------------------------------------------------------------
__149:
__150:
__151:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __622
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __623
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __624
__623:
	return -43
__624:
	;
__622:
	;
	if !(clen > 0) {
		goto __625
	}

	switch c {
	case uint32('\011'):
		goto __627
	case uint32('\040'):
		goto __628
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __629
	case uint32(0x1680):
		goto __630 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __631 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __632 /* EN QUAD */
	case uint32(0x2001):
		goto __633 /* EM QUAD */
	case uint32(0x2002):
		goto __634 /* EN SPACE */
	case uint32(0x2003):
		goto __635 /* EM SPACE */
	case uint32(0x2004):
		goto __636 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __637 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __638 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __639 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __640 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __641 /* THIN SPACE */
	case uint32(0x200A):
		goto __642 /* HAIR SPACE */
	case uint32(0x202f):
		goto __643 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __644 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __645

	default:
		goto __646
	}
	goto __626

__627:
__628:
__629:
__630: /* OGHAM SPACE MARK */
__631: /* MONGOLIAN VOWEL SEPARATOR */
__632: /* EN QUAD */
__633: /* EM QUAD */
__634: /* EN SPACE */
__635: /* EM SPACE */
__636: /* THREE-PER-EM SPACE */
__637: /* FOUR-PER-EM SPACE */
__638: /* SIX-PER-EM SPACE */
__639: /* FIGURE SPACE */
__640: /* PUNCTUATION SPACE */
__641: /* THIN SPACE */
__642: /* HAIR SPACE */
__643: /* NARROW NO-BREAK SPACE */
__644: /* MEDIUM MATHEMATICAL SPACE */
__645:
	OK3 = DTRUE
	goto __626

__646:
	OK3 = DFALSE
	goto __626
__626:
	;

	if !(OK3 == libc.Bool32(d == OP_HSPACE)) {
		goto __647
	}

	if !(count > 0 && codevalue == uint32(DOP_HSPACE_EXTRA+OP_TYPEPOSPLUS)) {
		goto __648
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__648:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __649
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __650
__649:
	return -43
__650:
	;
__647:
	;
__625:
	;
	goto __89

	//-----------------------------------------------------------------
__152:
__153:
__154:
	count = 4
	goto QS1

__155:
__156:
__157:
	count = 0

QS1:

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __651
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 4
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __652
__651:
	return -43
__652:
	;
	if !(clen > 0) {
		goto __653
	}

	prop2 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
	switch int32(*(*uint8)(unsafe.Pointer(code + 2))) {
	case DPT_ANY:
		goto __655

	case DPT_LAMP:
		goto __656

	case DPT_GC:
		goto __657

	case DPT_PC:
		goto __658

	case DPT_SC:
		goto __659

	case DPT_SCX:
		goto __660

	// These are specials for combination cases.

	case DPT_ALNUM:
		goto __661

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __662 // Perl space
	case DPT_PXSPACE:
		goto __663

	case DPT_WORD:
		goto __664

	case DPT_CLIST:
		goto __665

	case DPT_UCNC:
		goto __666

	case DPT_BIDICL:
		goto __667

	case DPT_BOOL:
		goto __668

	// Should never occur, but keep compilers from grumbling.

	default:
		goto __669
	}
	goto __654

__655:
	OK4 = DTRUE
	goto __654

__656:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop2)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop2)).Fchartype) == ucp_Lt)
	goto __654

__657:
	OK4 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == uint32(*(*uint8)(unsafe.Pointer(code + 3))))
	goto __654

__658:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fchartype) == int32(*(*uint8)(unsafe.Pointer(code + 3))))
	goto __654

__659:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fscript) == int32(*(*uint8)(unsafe.Pointer(code + 3))))
	goto __654

__660:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fscript) == int32(*(*uint8)(unsafe.Pointer(code + 3))) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(code + 3)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(code + 3)))%32)) != uint32(0))
	goto __654

	// These are specials for combination cases.

__661:
	OK4 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_N)
	goto __654

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__662: // Perl space
__663: // POSIX space
	switch c {
	case uint32('\011'):
		goto __671
	case uint32('\040'):
		goto __672
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __673
	case uint32(0x1680):
		goto __674 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __675 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __676 /* EN QUAD */
	case uint32(0x2001):
		goto __677 /* EM QUAD */
	case uint32(0x2002):
		goto __678 /* EN SPACE */
	case uint32(0x2003):
		goto __679 /* EM SPACE */
	case uint32(0x2004):
		goto __680 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __681 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __682 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __683 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __684 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __685 /* THIN SPACE */
	case uint32(0x200A):
		goto __686 /* HAIR SPACE */
	case uint32(0x202f):
		goto __687 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __688 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __689
	case uint32('\012'):
		goto __690
	case uint32('\013'):
		goto __691
	case uint32('\014'):
		goto __692
	case uint32('\015'):
		goto __693
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __694
	case uint32(0x2028):
		goto __695 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __696

	default:
		goto __697
	}
	goto __670

__671:
__672:
__673:
__674: /* OGHAM SPACE MARK */
__675: /* MONGOLIAN VOWEL SEPARATOR */
__676: /* EN QUAD */
__677: /* EM QUAD */
__678: /* EN SPACE */
__679: /* EM SPACE */
__680: /* THREE-PER-EM SPACE */
__681: /* FOUR-PER-EM SPACE */
__682: /* SIX-PER-EM SPACE */
__683: /* FIGURE SPACE */
__684: /* PUNCTUATION SPACE */
__685: /* THIN SPACE */
__686: /* HAIR SPACE */
__687: /* NARROW NO-BREAK SPACE */
__688: /* MEDIUM MATHEMATICAL SPACE */
__689:
__690:
__691:
__692:
__693:
__694:
__695: /* LINE SEPARATOR */
__696:
	OK4 = DTRUE
	goto __670

__697:
	OK4 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_Z)
	goto __670
__670:
	;
	goto __654

__664:
	OK4 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop2)).Fchartype] == ucp_N || c == uint32('\137'))
	goto __654

__665:
	cp2 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint8)(unsafe.Pointer(code + 3)))*4
__698:

	if !(c < *(*uint32)(unsafe.Pointer(cp2))) {
		goto __701
	}
	OK4 = DFALSE
	goto __700
__701:
	;
	if !(c == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&cp2, 4)))) {
		goto __702
	}
	OK4 = DTRUE
	goto __700
__702:
	;
	goto __699
__699:
	goto __698
	goto __700
__700:
	;
	goto __654

__666:
	OK4 = libc.Bool32(c == uint32('\044') || c == uint32('\100') || c == uint32('\140') || c >= uint32(0xa0) && c <= uint32(0xd7ff) || c >= uint32(0xe000))
	goto __654

__667:
	OK4 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*uint8)(unsafe.Pointer(code + 3))))
	goto __654

__668:
	OK4 = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(code + 3)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(code + 3)))%32)) != uint32(0))
	goto __654

	// Should never occur, but keep compilers from grumbling.

__669:
	OK4 = libc.Bool32(codevalue != OP_PROP)
	goto __654
__654:
	;

	if !(OK4 == libc.Bool32(d == OP_PROP)) {
		goto __703
	}

	if !(codevalue == uint32(DOP_PROP_EXTRA+OP_TYPEPOSSTAR) || codevalue == uint32(DOP_PROP_EXTRA+OP_TYPEPOSQUERY)) {
		goto __704
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__704:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __705
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __706
__705:
	return -43
__706:
	;
__703:
	;
__653:
	;
	goto __89

	//-----------------------------------------------------------------
__158:
__159:
__160:
	count = 2
	goto QS2

__161:
__162:
__163:
	count = 0

QS2:

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __707
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __708
__707:
	return -43
__708:
	;
	if !(clen > 0) {
		goto __709
	}

	*(*int32)(unsafe.Pointer(bp + 4 /* ncount2 */)) = 0
	if !(codevalue == uint32(DOP_EXTUNI_EXTRA+OP_TYPEPOSSTAR) || codevalue == uint32(DOP_EXTUNI_EXTRA+OP_TYPEPOSQUERY)) {
		goto __710
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__710:
	;
	X_pcre2_extuni_8(tls, c, ptr+uintptr(clen), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, end_subject, utf,
		bp+4)
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __711
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + count)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp + 4))
	next_new_state += 12
	goto __712
__711:
	return -43
__712:
	;
__709:
	;
	goto __89

	//-----------------------------------------------------------------
__164:
__165:
__166:
	count = 2
	goto QS3

__167:
__168:
__169:
	count = 0

QS3:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __713
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __714
__713:
	return -43
__714:
	;
	if !(clen > 0) {
		goto __715
	}
	ncount3 = 0
	switch c {
	case uint32('\013'):
		goto __717
	case uint32('\014'):
		goto __718
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __719
	case uint32(0x2028):
		goto __720
	case uint32(0x2029):
		goto __721

	case uint32('\015'):
		goto __722
	case uint32('\012'):
		goto __723

	default:
		goto __724
	}
	goto __716

__717:
__718:
__719:
__720:
__721:
	if !(int32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __725
	}
	goto __716
__725:
	;
	goto ANYNL02

__722:
	if !(ptr+uintptr(1) < end_subject && int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == '\012') {
		goto __726
	}
	ncount3 = 1
__726:
	;
	// Fall through

ANYNL02:
__723:
	if !(codevalue == uint32(DOP_ANYNL_EXTRA+OP_TYPEPOSSTAR) || codevalue == uint32(DOP_ANYNL_EXTRA+OP_TYPEPOSQUERY)) {
		goto __727
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__727:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __728
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + count)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = ncount3
	next_new_state += 12
	goto __729
__728:
	return -43
__729:
	;
	goto __716

__724:
	goto __716
__716:
	;
__715:
	;
	goto __89

	//-----------------------------------------------------------------
__170:
__171:
__172:
	count = 2
	goto QS4

__173:
__174:
__175:
	count = 0

QS4:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __730
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __731
__730:
	return -43
__731:
	;
	if !(clen > 0) {
		goto __732
	}

	switch c {
	case uint32('\012'):
		goto __734
	case uint32('\013'):
		goto __735
	case uint32('\014'):
		goto __736
	case uint32('\015'):
		goto __737
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __738
	case uint32(0x2028):
		goto __739 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __740

	default:
		goto __741
	}
	goto __733

__734:
__735:
__736:
__737:
__738:
__739: /* LINE SEPARATOR */
__740:
	OK5 = DTRUE
	goto __733

__741:
	OK5 = DFALSE
	goto __733
__733:
	;
	if !(OK5 == libc.Bool32(d == OP_VSPACE)) {
		goto __742
	}

	if !(codevalue == uint32(DOP_VSPACE_EXTRA+OP_TYPEPOSSTAR) || codevalue == uint32(DOP_VSPACE_EXTRA+OP_TYPEPOSQUERY)) {
		goto __743
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__743:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __744
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + count)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __745
__744:
	return -43
__745:
	;
__742:
	;
__732:
	;
	goto __89

	//-----------------------------------------------------------------
__176:
__177:
__178:
	count = 2
	goto QS5

__179:
__180:
__181:
	count = 0

QS5:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __746
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __747
__746:
	return -43
__747:
	;
	if !(clen > 0) {
		goto __748
	}

	switch c {
	case uint32('\011'):
		goto __750
	case uint32('\040'):
		goto __751
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __752
	case uint32(0x1680):
		goto __753 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __754 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __755 /* EN QUAD */
	case uint32(0x2001):
		goto __756 /* EM QUAD */
	case uint32(0x2002):
		goto __757 /* EN SPACE */
	case uint32(0x2003):
		goto __758 /* EM SPACE */
	case uint32(0x2004):
		goto __759 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __760 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __761 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __762 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __763 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __764 /* THIN SPACE */
	case uint32(0x200A):
		goto __765 /* HAIR SPACE */
	case uint32(0x202f):
		goto __766 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __767 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __768

	default:
		goto __769
	}
	goto __749

__750:
__751:
__752:
__753: /* OGHAM SPACE MARK */
__754: /* MONGOLIAN VOWEL SEPARATOR */
__755: /* EN QUAD */
__756: /* EM QUAD */
__757: /* EN SPACE */
__758: /* EM SPACE */
__759: /* THREE-PER-EM SPACE */
__760: /* FOUR-PER-EM SPACE */
__761: /* SIX-PER-EM SPACE */
__762: /* FIGURE SPACE */
__763: /* PUNCTUATION SPACE */
__764: /* THIN SPACE */
__765: /* HAIR SPACE */
__766: /* NARROW NO-BREAK SPACE */
__767: /* MEDIUM MATHEMATICAL SPACE */
__768:
	OK6 = DTRUE
	goto __749

__769:
	OK6 = DFALSE
	goto __749
__749:
	;

	if !(OK6 == libc.Bool32(d == OP_HSPACE)) {
		goto __770
	}

	if !(codevalue == uint32(DOP_HSPACE_EXTRA+OP_TYPEPOSSTAR) || codevalue == uint32(DOP_HSPACE_EXTRA+OP_TYPEPOSQUERY)) {
		goto __771
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__771:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __772
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + count)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __773
__772:
	return -43
__773:
	;
__770:
	;
__748:
	;
	goto __89

	//-----------------------------------------------------------------
__182:
__183:
__184:
__185:
	if !(codevalue != uint32(DOP_PROP_EXTRA+OP_TYPEEXACT)) {
		goto __774
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __775
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 1 + DIMM2_SIZE + 3
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __776
__775:
	return -43
__776:
	;
__774:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __777
	}

	prop3 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
	switch int32(*(*uint8)(unsafe.Pointer(code + 4))) {
	case DPT_ANY:
		goto __779

	case DPT_LAMP:
		goto __780

	case DPT_GC:
		goto __781

	case DPT_PC:
		goto __782

	case DPT_SC:
		goto __783

	case DPT_SCX:
		goto __784

	// These are specials for combination cases.

	case DPT_ALNUM:
		goto __785

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __786 // Perl space
	case DPT_PXSPACE:
		goto __787

	case DPT_WORD:
		goto __788

	case DPT_CLIST:
		goto __789

	case DPT_UCNC:
		goto __790

	case DPT_BIDICL:
		goto __791

	case DPT_BOOL:
		goto __792

	// Should never occur, but keep compilers from grumbling.

	default:
		goto __793
	}
	goto __778

__779:
	OK7 = DTRUE
	goto __778

__780:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop3)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop3)).Fchartype) == ucp_Lt)
	goto __778

__781:
	OK7 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == uint32(*(*uint8)(unsafe.Pointer(code + 5))))
	goto __778

__782:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fchartype) == int32(*(*uint8)(unsafe.Pointer(code + 5))))
	goto __778

__783:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fscript) == int32(*(*uint8)(unsafe.Pointer(code + 5))))
	goto __778

__784:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fscript) == int32(*(*uint8)(unsafe.Pointer(code + 5))) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(code + 5)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(code + 5)))%32)) != uint32(0))
	goto __778

	// These are specials for combination cases.

__785:
	OK7 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_N)
	goto __778

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__786: // Perl space
__787: // POSIX space
	switch c {
	case uint32('\011'):
		goto __795
	case uint32('\040'):
		goto __796
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __797
	case uint32(0x1680):
		goto __798 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __799 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __800 /* EN QUAD */
	case uint32(0x2001):
		goto __801 /* EM QUAD */
	case uint32(0x2002):
		goto __802 /* EN SPACE */
	case uint32(0x2003):
		goto __803 /* EM SPACE */
	case uint32(0x2004):
		goto __804 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __805 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __806 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __807 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __808 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __809 /* THIN SPACE */
	case uint32(0x200A):
		goto __810 /* HAIR SPACE */
	case uint32(0x202f):
		goto __811 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __812 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __813
	case uint32('\012'):
		goto __814
	case uint32('\013'):
		goto __815
	case uint32('\014'):
		goto __816
	case uint32('\015'):
		goto __817
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __818
	case uint32(0x2028):
		goto __819 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __820

	default:
		goto __821
	}
	goto __794

__795:
__796:
__797:
__798: /* OGHAM SPACE MARK */
__799: /* MONGOLIAN VOWEL SEPARATOR */
__800: /* EN QUAD */
__801: /* EM QUAD */
__802: /* EN SPACE */
__803: /* EM SPACE */
__804: /* THREE-PER-EM SPACE */
__805: /* FOUR-PER-EM SPACE */
__806: /* SIX-PER-EM SPACE */
__807: /* FIGURE SPACE */
__808: /* PUNCTUATION SPACE */
__809: /* THIN SPACE */
__810: /* HAIR SPACE */
__811: /* NARROW NO-BREAK SPACE */
__812: /* MEDIUM MATHEMATICAL SPACE */
__813:
__814:
__815:
__816:
__817:
__818:
__819: /* LINE SEPARATOR */
__820:
	OK7 = DTRUE
	goto __794

__821:
	OK7 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_Z)
	goto __794
__794:
	;
	goto __778

__788:
	OK7 = libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop3)).Fchartype] == ucp_N || c == uint32('\137'))
	goto __778

__789:
	cp3 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint8)(unsafe.Pointer(code + 5)))*4
__822:

	if !(c < *(*uint32)(unsafe.Pointer(cp3))) {
		goto __825
	}
	OK7 = DFALSE
	goto __824
__825:
	;
	if !(c == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&cp3, 4)))) {
		goto __826
	}
	OK7 = DTRUE
	goto __824
__826:
	;
	goto __823
__823:
	goto __822
	goto __824
__824:
	;
	goto __778

__790:
	OK7 = libc.Bool32(c == uint32('\044') || c == uint32('\100') || c == uint32('\140') || c >= uint32(0xa0) && c <= uint32(0xd7ff) || c >= uint32(0xe000))
	goto __778

__791:
	OK7 = libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*uint8)(unsafe.Pointer(code + 5))))
	goto __778

__792:
	OK7 = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(code + 5)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(code + 5)))%32)) != uint32(0))
	goto __778

	// Should never occur, but keep compilers from grumbling.

__793:
	OK7 = libc.Bool32(codevalue != OP_PROP)
	goto __778
__778:
	;

	if !(OK7 == libc.Bool32(d == OP_PROP)) {
		goto __827
	}

	if !(codevalue == uint32(DOP_PROP_EXTRA+OP_TYPEPOSUPTO)) {
		goto __828
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__828:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __829
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __831
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1 + DIMM2_SIZE + 3
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __832
__831:
	return -43
__832:
	;
	goto __830
__829:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __833
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __834
__833:
	return -43
__834:
	;
__830:
	;
__827:
	;
__777:
	;
	goto __89

	//-----------------------------------------------------------------
__186:
__187:
__188:
__189:
	if !(codevalue != uint32(DOP_EXTUNI_EXTRA+OP_TYPEEXACT)) {
		goto __835
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __836
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __837
__836:
	return -43
__837:
	;
__835:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __838
	}

	*(*int32)(unsafe.Pointer(bp + 8 /* ncount4 */)) = 0
	if !(codevalue == uint32(DOP_EXTUNI_EXTRA+OP_TYPEPOSUPTO)) {
		goto __839
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__839:
	;
	nptr = X_pcre2_extuni_8(tls, c, ptr+uintptr(clen), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, end_subject, utf,
		bp+8)
	if !(nptr >= end_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __840
	}
	reset_could_continue = DTRUE
__840:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __841
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __843
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 2 + DIMM2_SIZE)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp + 8))
	next_new_state += 12
	goto __844
__843:
	return -43
__844:
	;
	goto __842
__841:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __845
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp + 8))
	next_new_state += 12
	goto __846
__845:
	return -43
__846:
	;
__842:
	;
__838:
	;
	goto __89

	//-----------------------------------------------------------------
__190:
__191:
__192:
__193:
	if !(codevalue != uint32(DOP_ANYNL_EXTRA+OP_TYPEEXACT)) {
		goto __847
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __848
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __849
__848:
	return -43
__849:
	;
__847:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __850
	}
	ncount5 = 0
	switch c {
	case uint32('\013'):
		goto __852
	case uint32('\014'):
		goto __853
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __854
	case uint32(0x2028):
		goto __855
	case uint32(0x2029):
		goto __856

	case uint32('\015'):
		goto __857
	case uint32('\012'):
		goto __858

	default:
		goto __859
	}
	goto __851

__852:
__853:
__854:
__855:
__856:
	if !(int32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __860
	}
	goto __851
__860:
	;
	goto ANYNL03

__857:
	if !(ptr+uintptr(1) < end_subject && int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == '\012') {
		goto __861
	}
	ncount5 = 1
__861:
	;
	// Fall through

ANYNL03:
__858:
	if !(codevalue == uint32(DOP_ANYNL_EXTRA+OP_TYPEPOSUPTO)) {
		goto __862
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__862:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __863
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __865
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 2 + DIMM2_SIZE)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = ncount5
	next_new_state += 12
	goto __866
__865:
	return -43
__866:
	;
	goto __864
__863:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __867
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = ncount5
	next_new_state += 12
	goto __868
__867:
	return -43
__868:
	;
__864:
	;
	goto __851

__859:
	goto __851
__851:
	;
__850:
	;
	goto __89

	//-----------------------------------------------------------------
__194:
__195:
__196:
__197:
	if !(codevalue != uint32(DOP_VSPACE_EXTRA+OP_TYPEEXACT)) {
		goto __869
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __870
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __871
__870:
	return -43
__871:
	;
__869:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __872
	}

	switch c {
	case uint32('\012'):
		goto __874
	case uint32('\013'):
		goto __875
	case uint32('\014'):
		goto __876
	case uint32('\015'):
		goto __877
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __878
	case uint32(0x2028):
		goto __879 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __880

	default:
		goto __881
	}
	goto __873

__874:
__875:
__876:
__877:
__878:
__879: /* LINE SEPARATOR */
__880:
	OK8 = DTRUE
	goto __873

__881:
	OK8 = DFALSE
__873:
	;

	if !(OK8 == libc.Bool32(d == OP_VSPACE)) {
		goto __882
	}

	if !(codevalue == uint32(DOP_VSPACE_EXTRA+OP_TYPEPOSUPTO)) {
		goto __883
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__883:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __884
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __886
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 2 + DIMM2_SIZE)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __887
__886:
	return -43
__887:
	;
	goto __885
__884:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __888
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __889
__888:
	return -43
__889:
	;
__885:
	;
__882:
	;
__872:
	;
	goto __89

	//-----------------------------------------------------------------
__198:
__199:
__200:
__201:
	if !(codevalue != uint32(DOP_HSPACE_EXTRA+OP_TYPEEXACT)) {
		goto __890
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __891
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __892
__891:
	return -43
__892:
	;
__890:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __893
	}

	switch c {
	case uint32('\011'):
		goto __895
	case uint32('\040'):
		goto __896
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __897
	case uint32(0x1680):
		goto __898 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __899 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __900 /* EN QUAD */
	case uint32(0x2001):
		goto __901 /* EM QUAD */
	case uint32(0x2002):
		goto __902 /* EN SPACE */
	case uint32(0x2003):
		goto __903 /* EM SPACE */
	case uint32(0x2004):
		goto __904 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __905 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __906 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __907 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __908 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __909 /* THIN SPACE */
	case uint32(0x200A):
		goto __910 /* HAIR SPACE */
	case uint32(0x202f):
		goto __911 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __912 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __913

	default:
		goto __914
	}
	goto __894

__895:
__896:
__897:
__898: /* OGHAM SPACE MARK */
__899: /* MONGOLIAN VOWEL SEPARATOR */
__900: /* EN QUAD */
__901: /* EM QUAD */
__902: /* EN SPACE */
__903: /* EM SPACE */
__904: /* THREE-PER-EM SPACE */
__905: /* FOUR-PER-EM SPACE */
__906: /* SIX-PER-EM SPACE */
__907: /* FIGURE SPACE */
__908: /* PUNCTUATION SPACE */
__909: /* THIN SPACE */
__910: /* HAIR SPACE */
__911: /* NARROW NO-BREAK SPACE */
__912: /* MEDIUM MATHEMATICAL SPACE */
__913:
	OK9 = DTRUE
	goto __894

__914:
	OK9 = DFALSE
	goto __894
__894:
	;

	if !(OK9 == libc.Bool32(d == OP_HSPACE)) {
		goto __915
	}

	if !(codevalue == uint32(DOP_HSPACE_EXTRA+OP_TYPEPOSUPTO)) {
		goto __916
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__916:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __917
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __919
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 2 + DIMM2_SIZE)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __920
__919:
	return -43
__920:
	;
	goto __918
__917:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __921
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 0
	next_new_state += 12
	goto __922
__921:
	return -43
__922:
	;
__918:
	;
__915:
	;
__893:
	;
	goto __89

	// ==========================================================================
	// These opcodes are followed by a character that is usually compared
	//       to the current subject character; it is loaded into d. We still get
	//       here even if there is no subject character, because in some cases zero
	//       repetitions are permitted.

	//-----------------------------------------------------------------
__202:
	if !(clen > 0 && c == d) {
		goto __923
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __924
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __925
__924:
	return -43
__925:
	;
__923:
	;
	goto __89

	//-----------------------------------------------------------------
__203:
	if !(clen == 0) {
		goto __926
	}
	goto __89
__926:
	;

	if !(utf_or_ucp != 0) {
		goto __927
	}

	if !(c == d) {
		goto __929
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __931
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __932
__931:
	return -43
__932:
	;
	goto __930
__929:

	if !(c < uint32(128)) {
		goto __933
	}
	othercase = uint32(*(*uint8)(unsafe.Pointer(fcc + uintptr(c))))
	goto __934
__933:
	othercase = uint32(int32(c) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fother_case)
__934:
	;
	if !(d == othercase) {
		goto __935
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __936
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __937
__936:
	return -43
__937:
	;
__935:
	;
__930:
	;
	goto __928
__927:
	/* Not UTF or UCP mode */

	if !(int32(*(*uint8)(unsafe.Pointer(lcc + uintptr(c)))) == int32(*(*uint8)(unsafe.Pointer(lcc + uintptr(d))))) {
		goto __938
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __939
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 2
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __940
__939:
	return -43
__940:
	;
__938:
	;
__928:
	;
	goto __89

	//-----------------------------------------------------------------
	// This is a tricky one because it can match more than one character.
	//       Find out how many characters to skip, and then set up a negative state
	//       to wait for them to pass before continuing.

__204:
	if !(clen > 0) {
		goto __941
	}

	*(*int32)(unsafe.Pointer(bp + 12 /* ncount6 */)) = 0
	nptr1 = X_pcre2_extuni_8(tls, c, ptr+uintptr(clen), (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject,
		end_subject, utf, bp+12)
	if !(nptr1 >= end_subject && (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __942
	}
	reset_could_continue = DTRUE
__942:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __943
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = *(*int32)(unsafe.Pointer(bp + 12))
	next_new_state += 12
	goto __944
__943:
	return -43
__944:
	;
__941:
	;
	goto __89

	//-----------------------------------------------------------------
	// This is a tricky like EXTUNI because it too can match more than one
	//       character (when CR is followed by LF). In this case, set up a negative
	//       state to wait for one character to pass before continuing.

__205:
	if !(clen > 0) {
		goto __945
	}
	switch c {
	case uint32('\013'):
		goto __947
	case uint32('\014'):
		goto __948
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __949
	case uint32(0x2028):
		goto __950
	case uint32(0x2029):
		goto __951
	// Fall through

	case uint32('\012'):
		goto __952

	case uint32('\015'):
		goto __953
	}
	goto __946

__947:
__948:
__949:
__950:
__951:
	if !(int32((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __954
	}
	goto __946
__954:
	;
	// Fall through

__952:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __955
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __956
__955:
	return -43
__956:
	;
	goto __946

__953:
	if !(ptr+uintptr(1) >= end_subject) {
		goto __957
	}

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __959
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __960
__959:
	return -43
__960:
	;
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0)) {
		goto __961
	}
	reset_could_continue = DTRUE
__961:
	;
	goto __958
__957:
	if !(int32(*(*uint8)(unsafe.Pointer(ptr + uintptr(1)))) == '\012') {
		goto __962
	}

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __964
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = 1
	next_new_state += 12
	goto __965
__964:
	return -43
__965:
	;
	goto __963
__962:

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __966
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __967
__966:
	return -43
__967:
	;
__963:
	;
__958:
	;
	goto __946
__946:
	;
__945:
	;
	goto __89

	//-----------------------------------------------------------------
__206:
	if !(clen > 0) {
		goto __968
	}
	switch c {
	case uint32('\012'):
		goto __970
	case uint32('\013'):
		goto __971
	case uint32('\014'):
		goto __972
	case uint32('\015'):
		goto __973
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __974
	case uint32(0x2028):
		goto __975 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __976

	default:
		goto __977
	}
	goto __969

__970:
__971:
__972:
__973:
__974:
__975: /* LINE SEPARATOR */
__976:
	goto __969

__977:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __978
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __979
__978:
	return -43
__979:
	;
	goto __969
__969:
	;
__968:
	;
	goto __89

	//-----------------------------------------------------------------
__207:
	if !(clen > 0) {
		goto __980
	}
	switch c {
	case uint32('\012'):
		goto __982
	case uint32('\013'):
		goto __983
	case uint32('\014'):
		goto __984
	case uint32('\015'):
		goto __985
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __986
	case uint32(0x2028):
		goto __987 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __988

	default:
		goto __989
	}
	goto __981

__982:
__983:
__984:
__985:
__986:
__987: /* LINE SEPARATOR */
__988:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __990
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __991
__990:
	return -43
__991:
	;
	goto __981

__989:
	goto __981
__981:
	;
__980:
	;
	goto __89

	//-----------------------------------------------------------------
__208:
	if !(clen > 0) {
		goto __992
	}
	switch c {
	case uint32('\011'):
		goto __994
	case uint32('\040'):
		goto __995
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __996
	case uint32(0x1680):
		goto __997 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __998 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __999 /* EN QUAD */
	case uint32(0x2001):
		goto __1000 /* EM QUAD */
	case uint32(0x2002):
		goto __1001 /* EN SPACE */
	case uint32(0x2003):
		goto __1002 /* EM SPACE */
	case uint32(0x2004):
		goto __1003 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __1004 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __1005 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __1006 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __1007 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __1008 /* THIN SPACE */
	case uint32(0x200A):
		goto __1009 /* HAIR SPACE */
	case uint32(0x202f):
		goto __1010 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __1011 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __1012

	default:
		goto __1013
	}
	goto __993

__994:
__995:
__996:
__997: /* OGHAM SPACE MARK */
__998: /* MONGOLIAN VOWEL SEPARATOR */
__999: /* EN QUAD */
__1000: /* EM QUAD */
__1001: /* EN SPACE */
__1002: /* EM SPACE */
__1003: /* THREE-PER-EM SPACE */
__1004: /* FOUR-PER-EM SPACE */
__1005: /* SIX-PER-EM SPACE */
__1006: /* FIGURE SPACE */
__1007: /* PUNCTUATION SPACE */
__1008: /* THIN SPACE */
__1009: /* HAIR SPACE */
__1010: /* NARROW NO-BREAK SPACE */
__1011: /* MEDIUM MATHEMATICAL SPACE */
__1012:
	goto __993

__1013:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1014
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1015
__1014:
	return -43
__1015:
	;
	goto __993
__993:
	;
__992:
	;
	goto __89

	//-----------------------------------------------------------------
__209:
	if !(clen > 0) {
		goto __1016
	}
	switch c {
	case uint32('\011'):
		goto __1018
	case uint32('\040'):
		goto __1019
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __1020
	case uint32(0x1680):
		goto __1021 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __1022 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __1023 /* EN QUAD */
	case uint32(0x2001):
		goto __1024 /* EM QUAD */
	case uint32(0x2002):
		goto __1025 /* EN SPACE */
	case uint32(0x2003):
		goto __1026 /* EM SPACE */
	case uint32(0x2004):
		goto __1027 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __1028 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __1029 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __1030 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __1031 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __1032 /* THIN SPACE */
	case uint32(0x200A):
		goto __1033 /* HAIR SPACE */
	case uint32(0x202f):
		goto __1034 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __1035 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __1036

	default:
		goto __1037
	}
	goto __1017

__1018:
__1019:
__1020:
__1021: /* OGHAM SPACE MARK */
__1022: /* MONGOLIAN VOWEL SEPARATOR */
__1023: /* EN QUAD */
__1024: /* EM QUAD */
__1025: /* EN SPACE */
__1026: /* EM SPACE */
__1027: /* THREE-PER-EM SPACE */
__1028: /* FOUR-PER-EM SPACE */
__1029: /* SIX-PER-EM SPACE */
__1030: /* FIGURE SPACE */
__1031: /* PUNCTUATION SPACE */
__1032: /* THIN SPACE */
__1033: /* HAIR SPACE */
__1034: /* NARROW NO-BREAK SPACE */
__1035: /* MEDIUM MATHEMATICAL SPACE */
__1036:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1038
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1039
__1038:
	return -43
__1039:
	;
	goto __1017

__1037:
	goto __1017
__1017:
	;
__1016:
	;
	goto __89

	//-----------------------------------------------------------------
	// Match a negated single character casefully.

__210:
	if !(clen > 0 && c != d) {
		goto __1040
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1041
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1042
__1041:
	return -43
__1042:
	;
__1040:
	;
	goto __89

	//-----------------------------------------------------------------
	// Match a negated single character caselessly.

__211:
	if !(clen > 0) {
		goto __1043
	}

	if !(utf_or_ucp != 0 && d >= uint32(128)) {
		goto __1044
	}
	otherd = uint32(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1045
__1044:
	otherd = uint32(*(*uint8)(unsafe.Pointer(fcc + uintptr(d))))
__1045:
	;
	if !(c != d && c != otherd) {
		goto __1046
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1047
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1048
__1047:
	return -43
__1048:
	;
__1046:
	;
__1043:
	;
	goto __89

	//-----------------------------------------------------------------
__212:
__213:
__214:
__215:
__216:
__217:
	caseless = DTRUE
	codevalue = codevalue - uint32(OP_STARI-OP_STAR)

	// Fall through
__218:
__219:
__220:
__221:
__222:
__223:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __1049
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1050
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1051
__1050:
	return -43
__1051:
	;
__1049:
	;
	if !(clen > 0) {
		goto __1052
	}

	otherd1 = DNOTACHAR
	if !(caseless != 0) {
		goto __1053
	}

	if !(utf_or_ucp != 0 && d >= uint32(128)) {
		goto __1054
	}
	otherd1 = uint32(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1055
__1054:
	otherd1 = uint32(*(*uint8)(unsafe.Pointer(fcc + uintptr(d))))
__1055:
	;
__1053:
	;
	if !(libc.Bool32(c == d || c == otherd1) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1056
	}

	if !(count > 0 && (codevalue == OP_POSPLUS || codevalue == OP_NOTPOSPLUS)) {
		goto __1057
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1057:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1058
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1059
__1058:
	return -43
__1059:
	;
__1056:
	;
__1052:
	;
	goto __89

	//-----------------------------------------------------------------
__224:
__225:
__226:
__227:
__228:
__229:
	caseless = DTRUE
	codevalue = codevalue - uint32(OP_STARI-OP_STAR)
	// Fall through
__230:
__231:
__232:
__233:
__234:
__235:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1060
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1061
__1060:
	return -43
__1061:
	;
	if !(clen > 0) {
		goto __1062
	}

	otherd2 = DNOTACHAR
	if !(caseless != 0) {
		goto __1063
	}

	if !(utf_or_ucp != 0 && d >= uint32(128)) {
		goto __1064
	}
	otherd2 = uint32(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1065
__1064:
	otherd2 = uint32(*(*uint8)(unsafe.Pointer(fcc + uintptr(d))))
__1065:
	;
__1063:
	;
	if !(libc.Bool32(c == d || c == otherd2) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1066
	}

	if !(codevalue == OP_POSQUERY || codevalue == OP_NOTPOSQUERY) {
		goto __1067
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1067:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1068
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1069
__1068:
	return -43
__1069:
	;
__1066:
	;
__1062:
	;
	goto __89

	//-----------------------------------------------------------------
__236:
__237:
__238:
__239:
__240:
__241:
	caseless = DTRUE
	codevalue = codevalue - uint32(OP_STARI-OP_STAR)
	// Fall through
__242:
__243:
__244:
__245:
__246:
__247:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1070
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + dlen + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1071
__1070:
	return -43
__1071:
	;
	if !(clen > 0) {
		goto __1072
	}

	otherd3 = DNOTACHAR
	if !(caseless != 0) {
		goto __1073
	}

	if !(utf_or_ucp != 0 && d >= uint32(128)) {
		goto __1074
	}
	otherd3 = uint32(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1075
__1074:
	otherd3 = uint32(*(*uint8)(unsafe.Pointer(fcc + uintptr(d))))
__1075:
	;
__1073:
	;
	if !(libc.Bool32(c == d || c == otherd3) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1076
	}

	if !(codevalue == OP_POSSTAR || codevalue == OP_NOTPOSSTAR) {
		goto __1077
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1077:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1078
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1079
__1078:
	return -43
__1079:
	;
__1076:
	;
__1072:
	;
	goto __89

	//-----------------------------------------------------------------
__248:
__249:
	caseless = DTRUE
	codevalue = codevalue - uint32(OP_STARI-OP_STAR)
	// Fall through
__250:
__251:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __1080
	}

	otherd4 = DNOTACHAR
	if !(caseless != 0) {
		goto __1081
	}

	if !(utf_or_ucp != 0 && d >= uint32(128)) {
		goto __1082
	}
	otherd4 = uint32(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1083
__1082:
	otherd4 = uint32(*(*uint8)(unsafe.Pointer(fcc + uintptr(d))))
__1083:
	;
__1081:
	;
	if !(libc.Bool32(c == d || c == otherd4) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1084
	}

	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __1085
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1087
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1088
__1087:
	return -43
__1088:
	;
	goto __1086
__1085:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1089
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1090
__1089:
	return -43
__1090:
	;
__1086:
	;
__1084:
	;
__1080:
	;
	goto __89

	//-----------------------------------------------------------------
__252:
__253:
__254:
__255:
__256:
__257:
	caseless = DTRUE
	codevalue = codevalue - uint32(OP_STARI-OP_STAR)
	// Fall through
__258:
__259:
__260:
__261:
__262:
__263:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1091
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + dlen + 1 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1092
__1091:
	return -43
__1092:
	;
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Number already matched
	if !(clen > 0) {
		goto __1093
	}

	otherd5 = DNOTACHAR
	if !(caseless != 0) {
		goto __1094
	}

	if !(utf_or_ucp != 0 && d >= uint32(128)) {
		goto __1095
	}
	otherd5 = uint32(int32(d) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __1096
__1095:
	otherd5 = uint32(*(*uint8)(unsafe.Pointer(fcc + uintptr(d))))
__1096:
	;
__1094:
	;
	if !(libc.Bool32(c == d || c == otherd5) == libc.Bool32(codevalue < OP_NOTSTAR)) {
		goto __1097
	}

	if !(codevalue == OP_POSUPTO || codevalue == OP_NOTPOSUPTO) {
		goto __1098
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1098:
	;
	if !(libc.PreIncInt32(&count, 1) >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))) {
		goto __1099
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1101
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset + dlen + 1 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1102
__1101:
	return -43
__1102:
	;
	goto __1100
__1099:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1103
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1104
__1103:
	return -43
__1104:
	;
__1100:
	;
__1097:
	;
__1093:
	;
	goto __89

	// ==========================================================================
	// These are the class-handling opcodes

__264:
__265:
__266:

	isinclass = DFALSE

	// For a simple class, there is always just a 32-byte table, and we
	//         can set isinclass from it.

	if !(codevalue != OP_XCLASS) {
		goto __1105
	}

	ecode = code + uintptr(1) + uintptr(uint64(32)/uint64(unsafe.Sizeof(uint8(0))))
	if !(clen > 0) {
		goto __1107
	}

	if c > uint32(255) {
		isinclass = libc.Bool32(codevalue == OP_NCLASS)
	} else {
		isinclass = libc.Bool32(uint32(*(*uint8)(unsafe.Pointer(code + uintptr(1) + uintptr(c/uint32(8)))))&(uint32(1)<<(c&uint32(7))) != uint32(0))
	}
__1107:
	;
	goto __1106
__1105:

	ecode = code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	if !(clen > 0) {
		goto __1108
	}
	isinclass = X_pcre2_xclass_8(tls, c, code+uintptr(1)+uintptr(DLINK_SIZE), utf)
__1108:
	;
__1106:
	;

	// At this point, isinclass is set for all kinds of class, and ecode
	//         points to the byte after the end of the class. If there is a
	//         quantifier, this is where it will be.

	next_state_offset = int32((int64(ecode) - int64(start_code)) / 1)

	switch int32(*(*uint8)(unsafe.Pointer(ecode))) {
	case OP_CRSTAR:
		goto __1110
	case OP_CRMINSTAR:
		goto __1111
	case OP_CRPOSSTAR:
		goto __1112

	case OP_CRPLUS:
		goto __1113
	case OP_CRMINPLUS:
		goto __1114
	case OP_CRPOSPLUS:
		goto __1115

	case OP_CRQUERY:
		goto __1116
	case OP_CRMINQUERY:
		goto __1117
	case OP_CRPOSQUERY:
		goto __1118

	case OP_CRRANGE:
		goto __1119
	case OP_CRMINRANGE:
		goto __1120
	case OP_CRPOSRANGE:
		goto __1121

	default:
		goto __1122
	}
	goto __1109

__1110:
__1111:
__1112:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1123
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1124
__1123:
	return -43
__1124:
	;
	if !(isinclass != 0) {
		goto __1125
	}

	if !(int32(*(*uint8)(unsafe.Pointer(ecode))) == OP_CRPOSSTAR) {
		goto __1126
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1126:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1127
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1128
__1127:
	return -43
__1128:
	;
__1125:
	;
	goto __1109

__1113:
__1114:
__1115:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count > 0) {
		goto __1129
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1130
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1131
__1130:
	return -43
__1131:
	;
__1129:
	;
	if !(isinclass != 0) {
		goto __1132
	}

	if !(count > 0 && int32(*(*uint8)(unsafe.Pointer(ecode))) == OP_CRPOSPLUS) {
		goto __1133
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1133:
	;
	count++
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1134
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1135
__1134:
	return -43
__1135:
	;
__1132:
	;
	goto __1109

__1116:
__1117:
__1118:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1136
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1137
__1136:
	return -43
__1137:
	;
	if !(isinclass != 0) {
		goto __1138
	}

	if !(int32(*(*uint8)(unsafe.Pointer(ecode))) == OP_CRPOSQUERY) {
		goto __1139
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1139:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1140
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset + 1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1141
__1140:
	return -43
__1141:
	;
__1138:
	;
	goto __1109

__1119:
__1120:
__1121:
	count = (*Tstateblock)(unsafe.Pointer(current_state)).Fcount // Already matched
	if !(count >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(ecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(ecode + 2)))))) {
		goto __1142
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1143
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset + 1 + 2*DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1144
__1143:
	return -43
__1144:
	;
__1142:
	;
	if !(isinclass != 0) {
		goto __1145
	}

	max = int32(uint32(int32(*(*uint8)(unsafe.Pointer(ecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(ecode + 4)))))

	if !(int32(*(*uint8)(unsafe.Pointer(ecode))) == OP_CRPOSRANGE && count >= int32(uint32(int32(*(*uint8)(unsafe.Pointer(ecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(ecode + 2)))))) {
		goto __1146
	}

	active_count-- // Remove non-match possibility
	next_active_state -= 12
__1146:
	;

	if !(libc.PreIncInt32(&count, 1) >= max && max != 0) {
		goto __1147
	} /* Max 0 => no limit */
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1149
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset + 1 + 2*DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1150
__1149:
	return -43
__1150:
	;
	goto __1148
__1147:
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1151
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = count
	next_new_state += 12
	goto __1152
__1151:
	return -43
__1152:
	;
__1148:
	;
__1145:
	;
	goto __1109

__1122:
	if !(isinclass != 0) {
		goto __1153
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1154
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1155
__1154:
	return -43
__1155:
	;
__1153:
	;
	goto __1109
__1109:
	;

	goto __89

	// ==========================================================================
	// These are the opcodes for fancy brackets of various kinds. We have
	//       to use recursion in order to handle them. The "always failing" assertion
	//       (?!) is optimised to OP_FAIL when compiling, so we have to support that,
	//       though the other "backtracking verbs" are not supported.

__267:
	forced_fail++ // Count FAILs for multiple states
	goto __89

__268:
__269:
__270:
__271:

	endasscode = code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	*(*uintptr)(unsafe.Pointer(bp + 16 /* rws */)) = RWS

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Ffree) < uint64(DRWS_RSIZE)+uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1156
	}

	rc = more_workspace(tls, bp+16, uint32(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc != 0) {
		goto __1157
	}
	return rc
__1157:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 16 /* rws */))
__1156:
	;

	local_offsets = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Ffree)*4
	local_workspace = local_offsets + uintptr(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

__1158:
	if !(int32(*(*uint8)(unsafe.Pointer(endasscode))) == OP_ALT) {
		goto __1159
	}
	endasscode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(endasscode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(endasscode + 2)))))
	goto __1158
__1159:
	;

	rc = internal_dfa_match(tls,
		mb,   // static match data
		code, // this subexpression's code
		ptr,  // where we currently are
		uint64((int64(ptr)-int64(start_subject))/1),
		local_offsets, // offset vector
		uint32(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace, // workspace vector
		DRWS_RSIZE,      // size of same
		rlevel,          // function recursion level
		RWS)             // recursion workspace

	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

	if !(rc < 0 && rc != -1) {
		goto __1160
	}
	return rc
__1160:
	;
	if !(libc.Bool32(rc >= 0) == libc.Bool32(codevalue == OP_ASSERT || codevalue == OP_ASSERTBACK)) {
		goto __1161
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1162
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(endasscode+uintptr(DLINK_SIZE)+uintptr(1)) - int64(start_code)) / 1)
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1163
__1162:
	return -43
__1163:
	;
__1161:
	;

	goto __89

	//-----------------------------------------------------------------
__272:
__273:

	codelink = int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))

	// Because of the way auto-callout works during compile, a callout item
	//         is inserted between OP_COND and an assertion condition. This does not
	//         happen for the other conditions.

	if !(int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_CALLOUT ||
		int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_CALLOUT_STR) {
		goto __1164
	}

	rrc = do_callout_dfa(tls, code, offsets, current_subject, ptr, mb,
		uint64(1+DLINK_SIZE), bp+24)
	if !(rrc < 0) {
		goto __1165
	}
	return rrc
__1165:
	; // Abandon
	if !(rrc > 0) {
		goto __1166
	}
	goto __89
__1166:
	;                                                                         // Fail this thread
	code += uintptr(*(*uint64)(unsafe.Pointer(bp + 24 /* callout_length */))) // Skip callout data
__1164:
	;

	condcode = *(*uint8)(unsafe.Pointer(code + 3))

	// Back reference conditions and duplicate named recursion conditions
	//         are not supported

	if !(int32(condcode) == OP_CREF || int32(condcode) == OP_DNCREF || int32(condcode) == OP_DNRREF) {
		goto __1167
	}
	return -40
__1167:
	;

	// The DEFINE condition is always false, and the assertion (?!) is
	//         converted to OP_FAIL.

	if !(int32(condcode) == OP_FALSE || int32(condcode) == OP_FAIL) {
		goto __1168
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1170
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + codelink + DLINK_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1171
__1170:
	return -43
__1171:
	;
	goto __1169
__1168:
	if !(int32(condcode) == OP_TRUE) {
		goto __1172
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1174
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + DLINK_SIZE + 2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1175
__1174:
	return -43
__1175:
	;
	goto __1173
__1172:
	if !(int32(condcode) == OP_RREF) {
		goto __1176
	}

	value = uint32(int32(*(*uint8)(unsafe.Pointer(code + 4)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 5))))
	if !(value != uint32(DRREF_ANY)) {
		goto __1178
	}
	return -40
__1178:
	;
	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive != uintptr(0)) {
		goto __1179
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1181
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + DLINK_SIZE + 2 + DIMM2_SIZE
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1182
__1181:
	return -43
__1182:
	;
	goto __1180
__1179:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1183
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + codelink + DLINK_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1184
__1183:
	return -43
__1184:
	;
__1180:
	;
	goto __1177
__1176:

	asscode = code + uintptr(DLINK_SIZE) + uintptr(1)
	endasscode1 = asscode + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(asscode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(asscode + 2)))))
	*(*uintptr)(unsafe.Pointer(bp + 32 /* rws1 */)) = RWS

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Ffree) < uint64(DRWS_RSIZE)+uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1185
	}

	rc1 = more_workspace(tls, bp+32, uint32(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc1 != 0) {
		goto __1186
	}
	return rc1
__1186:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 32 /* rws1 */))
__1185:
	;

	local_offsets1 = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).Ffree)*4
	local_workspace1 = local_offsets1 + uintptr(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

__1187:
	if !(int32(*(*uint8)(unsafe.Pointer(endasscode1))) == OP_ALT) {
		goto __1188
	}
	endasscode1 += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(endasscode1 + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(endasscode1 + 2)))))
	goto __1187
__1188:
	;

	rc1 = internal_dfa_match(tls,
		mb,      // fixed match data
		asscode, // this subexpression's code
		ptr,     // where we currently are
		uint64((int64(ptr)-int64(start_subject))/1),
		local_offsets1, // offset vector
		uint32(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace1, // workspace vector
		DRWS_RSIZE,       // size of same
		rlevel,           // function recursion level
		RWS)              // recursion workspace

	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

	if !(rc1 < 0 && rc1 != -1) {
		goto __1189
	}
	return rc1
__1189:
	;
	if !(libc.Bool32(rc1 >= 0) == libc.Bool32(int32(condcode) == OP_ASSERT || int32(condcode) == OP_ASSERTBACK)) {
		goto __1190
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1192
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = int32((int64(endasscode1+uintptr(DLINK_SIZE)+uintptr(1)) - int64(start_code)) / 1)
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1193
__1192:
	return -43
__1193:
	;
	goto __1191
__1190:
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1194
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + codelink + DLINK_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1195
__1194:
	return -43
__1195:
	;
__1191:
	;
__1177:
	;
__1173:
	;
__1169:
	;

	goto __89

	//-----------------------------------------------------------------
__274:

	*(*uintptr)(unsafe.Pointer(bp + 40 /* rws2 */)) = RWS
	callpat = start_code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	if callpat == (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_code {
		recno = uint32(0)
	} else {
		recno = uint32(int32(*(*uint8)(unsafe.Pointer(callpat + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(callpat + 4))))
	}

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Ffree) < uint64(DRWS_RSIZE)+uint64(1000)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1196
	}

	rc2 = more_workspace(tls, bp+40, uint32(uint64(1000)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc2 != 0) {
		goto __1197
	}
	return rc2
__1197:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 40 /* rws2 */))
__1196:
	;

	local_offsets2 = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))).Ffree)*4
	local_workspace2 = local_offsets2 + uintptr(uint64(1000)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(1000)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

	// Check for repeating a recursion without advancing the subject
	//         pointer. This should catch convoluted mutual recursions. (Some simple
	//         cases are caught at compile time.)

	ri = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive
__1198:
	if !(ri != uintptr(0)) {
		goto __1200
	}
	if !(recno == (*Tdfa_recursion_info)(unsafe.Pointer(ri)).Fgroup_num && ptr == (*Tdfa_recursion_info)(unsafe.Pointer(ri)).Fsubject_position) {
		goto __1201
	}
	return -52
__1201:
	;
	goto __1199
__1199:
	ri = (*Tdfa_recursion_info)(unsafe.Pointer(ri)).Fprevrec
	goto __1198
	goto __1200
__1200:
	;

	// Remember this recursion and where we started it so as to
	//         catch infinite loops.

	(*Tdfa_recursion_info)(unsafe.Pointer(bp + 48 /* &new_recursive */)).Fgroup_num = recno
	(*Tdfa_recursion_info)(unsafe.Pointer(bp + 48 /* &new_recursive */)).Fsubject_position = ptr
	(*Tdfa_recursion_info)(unsafe.Pointer(bp + 48 /* &new_recursive */)).Fprevrec = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive = bp + 48 /* &new_recursive */

	rc2 = internal_dfa_match(tls,
		mb,      // fixed match data
		callpat, // this subexpression's code
		ptr,     // where we currently are
		uint64((int64(ptr)-int64(start_subject))/1),
		local_offsets2, // offset vector
		uint32(uint64(1000)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace2, // workspace vector
		DRWS_RSIZE,       // size of same
		rlevel,           // function recursion level
		RWS)              // recursion workspace

	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(1000)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive = (*Tdfa_recursion_info)(unsafe.Pointer(bp + 48 /* &new_recursive */)).Fprevrec // Done this recursion

	// Ran out of internal offsets

	if !(rc2 == 0) {
		goto __1202
	}
	return -39
__1202:
	;

	// For each successful matched substring, set up the next state with a
	//         count of characters to skip before trying it. Note that the count is in
	//         characters, not bytes.

	if !(rc2 > 0) {
		goto __1203
	}

	rc2 = rc2*2 - 2
__1205:
	if !(rc2 >= 0) {
		goto __1207
	}

	charcount = *(*uint64)(unsafe.Pointer(local_offsets2 + uintptr(rc2+1)*8)) - *(*uint64)(unsafe.Pointer(local_offsets2 + uintptr(rc2)*8))
	if !(utf != 0) {
		goto __1208
	}

	p = start_subject + uintptr(*(*uint64)(unsafe.Pointer(local_offsets2 + uintptr(rc2)*8)))
	pp = start_subject + uintptr(*(*uint64)(unsafe.Pointer(local_offsets2 + uintptr(rc2+1)*8)))
__1209:
	if !(p < pp) {
		goto __1210
	}
	if !(uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))&0xc0 == 0x80) {
		goto __1211
	}
	charcount--
__1211:
	;
	goto __1209
__1210:
	;
__1208:
	;
	if !(charcount > uint64(0)) {
		goto __1212
	}

	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1214
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -(state_offset + DLINK_SIZE + 1)
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(charcount - uint64(1))
	next_new_state += 12
	goto __1215
__1214:
	return -43
__1215:
	;
	goto __1213
__1212:

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1216
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + DLINK_SIZE + 1
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1217
__1216:
	return -43
__1217:
	;
__1213:
	;
	goto __1206
__1206:
	rc2 = rc2 - 2
	goto __1205
	goto __1207
__1207:
	;
	goto __1204
__1203:
	if !(rc2 != -1) {
		goto __1218
	}
	return rc2
__1218:
	;
__1204:
	;

	goto __89

	//-----------------------------------------------------------------
__275:
__276:
__277:
__278:
__279:

	local_ptr = ptr
	*(*uintptr)(unsafe.Pointer(bp + 72 /* rws3 */)) = RWS

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)))).Ffree) < uint64(DRWS_RSIZE)+uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1219
	}

	rc3 = more_workspace(tls, bp+72, uint32(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc3 != 0) {
		goto __1220
	}
	return rc3
__1220:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 72 /* rws3 */))
__1219:
	;

	local_offsets3 = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)))).Ffree)*4
	local_workspace3 = local_offsets3 + uintptr(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

	if !(codevalue == OP_BRAPOSZERO) {
		goto __1221
	}

	allow_zero = DTRUE
	codevalue = uint32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&code, 1)))) // Codevalue will be one of above BRAs
	goto __1222
__1221:
	allow_zero = DFALSE
__1222:
	;

	// Loop to match the subpattern as many times as possible as if it were
	//         a complete pattern.

	matched_count = uint64(0)
__1223:
	;

	rc3 = internal_dfa_match(tls,
		mb,        // fixed match data
		code,      // this subexpression's code
		local_ptr, // where we currently are
		uint64((int64(ptr)-int64(start_subject))/1),
		local_offsets3, // offset vector
		uint32(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace3, // workspace vector
		DRWS_RSIZE,       // size of same
		rlevel,           // function recursion level
		RWS)              // recursion workspace

	// Failed to match

	if !(rc3 < 0) {
		goto __1226
	}

	if !(rc3 != -1) {
		goto __1227
	}
	return rc3
__1227:
	;
	goto __1225
__1226:
	;

	// Matched: break the loop if zero characters matched.

	charcount1 = *(*uint64)(unsafe.Pointer(local_offsets3 + 1*8)) - *(*uint64)(unsafe.Pointer(local_offsets3))
	if !(charcount1 == uint64(0)) {
		goto __1228
	}
	goto __1225
__1228:
	;
	local_ptr += uintptr(charcount1) // Advance temporary position ptr
	goto __1224
__1224:
	matched_count++
	goto __1223
	goto __1225
__1225:
	;

	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

	// At this point we have matched the subpattern matched_count
	//         times, and local_ptr is pointing to the character after the end of the
	//         last match.

	if !(matched_count > uint64(0) || allow_zero != 0) {
		goto __1229
	}

	end_subpattern = code

__1230:
	end_subpattern += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(end_subpattern + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(end_subpattern + 2)))))
	goto __1231
__1231:
	if int32(*(*uint8)(unsafe.Pointer(end_subpattern))) == OP_ALT {
		goto __1230
	}
	goto __1232
__1232:
	;
	next_state_offset1 = int32((int64(end_subpattern)-int64(start_code))/1 + int64(DLINK_SIZE) + int64(1))

	// Optimization: if there are no more active states, and there
	//           are no new states yet set up, then skip over the subject string
	//           right here, to save looping. Otherwise, set up the new state to swing
	//           into action when the end of the matched substring is reached.

	if !(i+1 >= active_count && new_count == 0) {
		goto __1233
	}

	ptr = local_ptr
	clen = 0
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1235
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1236
__1235:
	return -43
__1236:
	;
	goto __1234
__1233:

	p1 = ptr
	pp1 = local_ptr
	charcount1 = uint64((int64(pp1) - int64(p1)) / 1)
	if !(utf != 0) {
		goto __1237
	}
__1238:
	if !(p1 < pp1) {
		goto __1239
	}
	if !(uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1))))&0xc0 == 0x80) {
		goto __1240
	}
	charcount1--
__1240:
	;
	goto __1238
__1239:
	;
__1237:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1241
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -next_state_offset1
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(charcount1 - uint64(1))
	next_new_state += 12
	goto __1242
__1241:
	return -43
__1242:
	;
__1234:
	;
__1229:
	;

	goto __89

	//-----------------------------------------------------------------
__280:

	*(*uintptr)(unsafe.Pointer(bp + 80 /* rws4 */)) = RWS

	if !(uint64((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))).Ffree) < uint64(DRWS_RSIZE)+uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))) {
		goto __1243
	}

	rc4 = more_workspace(tls, bp+80, uint32(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))), mb)
	if !(rc4 != 0) {
		goto __1244
	}
	return rc4
__1244:
	;
	RWS = *(*uintptr)(unsafe.Pointer(bp + 80 /* rws4 */))
__1243:
	;

	local_offsets4 = RWS + uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))).Fsize)*4 - uintptr((*TRWS_anchor)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))).Ffree)*4
	local_workspace4 = local_offsets4 + uintptr(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))*4
	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)) + 12)) -= uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

	rc4 = internal_dfa_match(tls,
		mb,   // fixed match data
		code, // this subexpression's code
		ptr,  // where we currently are
		uint64((int64(ptr)-int64(start_subject))/1),
		local_offsets4, // offset vector
		uint32(uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))/(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0))))),
		local_workspace4, // workspace vector
		DRWS_RSIZE,       // size of same
		rlevel,           // function recursion level
		RWS)              // recursion workspace

	*(*uint32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)) + 12)) += uint32(uint64(DRWS_RSIZE) + uint64(2)*(uint64(unsafe.Sizeof(uint64(0)))/uint64(unsafe.Sizeof(int32(0)))))

	if !(rc4 >= 0) {
		goto __1245
	}

	end_subpattern1 = code
	charcount2 = *(*uint64)(unsafe.Pointer(local_offsets4 + 1*8)) - *(*uint64)(unsafe.Pointer(local_offsets4))

__1247:
	end_subpattern1 += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(end_subpattern1 + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(end_subpattern1 + 2)))))
	goto __1248
__1248:
	if int32(*(*uint8)(unsafe.Pointer(end_subpattern1))) == OP_ALT {
		goto __1247
	}
	goto __1249
__1249:
	;
	next_state_offset2 = int32((int64(end_subpattern1)-int64(start_code))/1 + int64(DLINK_SIZE) + int64(1))

	// If the end of this subpattern is KETRMAX or KETRMIN, we must
	//           arrange for the repeat state also to be added to the relevant list.
	//           Calculate the offset, or set -1 for no repeat.

	if int32(*(*uint8)(unsafe.Pointer(end_subpattern1))) == OP_KETRMAX || int32(*(*uint8)(unsafe.Pointer(end_subpattern1))) == OP_KETRMIN {
		repeat_state_offset = int32((int64(end_subpattern1)-int64(start_code))/1 - int64(uint32(int32(*(*uint8)(unsafe.Pointer(end_subpattern1 + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(end_subpattern1 + 2))))))
	} else {
		repeat_state_offset = -1
	}

	// If we have matched an empty string, add the next state at the
	//           current character pointer. This is important so that the duplicate
	//           checking kicks in, which is what breaks infinite loops that match an
	//           empty string.

	if !(charcount2 == uint64(0)) {
		goto __1250
	}

	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1252
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = next_state_offset2
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1253
__1252:
	return -43
__1253:
	;
	goto __1251
__1250:
	if !(i+1 >= active_count && new_count == 0) {
		goto __1254
	}

	ptr += uintptr(charcount2)
	clen = 0
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1256
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = next_state_offset2
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	next_new_state += 12
	goto __1257
__1256:
	return -43
__1257:
	;

	// If we are adding a repeat state at the new character position,
	//             we must fudge things so that it is the only current state.
	//             Otherwise, it might be a duplicate of one we processed before, and
	//             that would cause it to be skipped.

	if !(repeat_state_offset >= 0) {
		goto __1258
	}

	next_active_state = active_states
	active_count = 0
	i = -1
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1259
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = repeat_state_offset
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1260
__1259:
	return -43
__1260:
	;
__1258:
	;
	goto __1255
__1254:

	if !(utf != 0) {
		goto __1261
	}

	p2 = start_subject + uintptr(*(*uint64)(unsafe.Pointer(local_offsets4)))
	pp2 = start_subject + uintptr(*(*uint64)(unsafe.Pointer(local_offsets4 + 1*8)))
__1262:
	if !(p2 < pp2) {
		goto __1263
	}
	if !(uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p2, 1))))&0xc0 == 0x80) {
		goto __1264
	}
	charcount2--
__1264:
	;
	goto __1262
__1263:
	;
__1261:
	;
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1265
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -next_state_offset2
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(charcount2 - uint64(1))
	next_new_state += 12
	goto __1266
__1265:
	return -43
__1266:
	;
	if !(repeat_state_offset >= 0) {
		goto __1267
	}
	if !(libc.PostIncInt32(&new_count, 1) < wscount) {
		goto __1268
	}
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Foffset = -repeat_state_offset
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fcount = 0
	(*Tstateblock)(unsafe.Pointer(next_new_state)).Fdata = int32(charcount2 - uint64(1))
	next_new_state += 12
	goto __1269
__1268:
	return -43
__1269:
	;
__1267:
	;
__1255:
	;
__1251:
	;
	goto __1246
__1245:
	if !(rc4 != -1) {
		goto __1270
	}
	return rc4
__1270:
	;
__1246:
	;

	goto __89

	// ==========================================================================
	// Handle callouts

__281:
__282:

	rrc = do_callout_dfa(tls, code, offsets, current_subject, ptr, mb, uint64(0),
		bp+88)
	if !(rrc < 0) {
		goto __1271
	}
	return rrc
__1271:
	; // Abandon
	if !(rrc == 0) {
		goto __1272
	}
	if !(libc.PostIncInt32(&active_count, 1) < wscount) {
		goto __1273
	}
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Foffset = state_offset + int32(*(*uint64)(unsafe.Pointer(bp + 88)))
	(*Tstateblock)(unsafe.Pointer(next_active_state)).Fcount = 0
	next_active_state += 12
	goto __1274
__1273:
	return -43
__1274:
	;
__1272:
	;

	goto __89

	// ==========================================================================
__283: // Unsupported opcode
	return -42
__89:
	;

NEXT_ACTIVE_STATE:
	goto __51

	goto __51
__51:
	i++
	goto __50
	goto __52
__52:
	; // End of loop scanning active states

	// We have finished the processing at the current subject character. If no
	//   new states have been set for the next character, we have found all the
	//   matches that we are going to find. If partial matching has been requested,
	//   check for appropriate conditions.
	//
	//   The "forced_ fail" variable counts the number of (*F) encountered for the
	//   character. If it is equal to the original active_count (saved in
	//   workspace[1]) it means that (*F) was found on every active state. In this
	//   case we don't want to give a partial match.
	//
	//   The "could_continue" variable is true if a state could have continued but
	//   for the fact that the end of the subject was reached.

	if !(new_count <= 0) {
		goto __1275
	}

	if !(could_continue != 0 && forced_fail != *(*int32)(unsafe.Pointer(workspace + 1*4)) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_HARD != uint32(0) ||
		(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_PARTIAL_SOFT != uint32(0) && match_count < 0) && (partial_newline != 0 || ptr >= end_subject && (ptr > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0))) {
		goto __1276
	}
	match_count = -2
__1276:
	;
	goto __37 // Exit from loop along the subject string
__1275:
	;

	// One or more states are active for the next character.

	ptr += uintptr(clen) // Advance to next subject character
	goto __36
__36:
	goto __35
	goto __37
__37:
	; // Loop to move along the subject string

	// Control gets here from "break" a few lines above. If we have a match and
	// PCRE2_ENDANCHORED is set, the match fails.

	if !(match_count >= 0 && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions|(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions)&DPCRE2_ENDANCHORED != uint32(0) && ptr < end_subject) {
		goto __1277
	}
	match_count = -1
__1277:
	;

	return match_count
}

// ************************************************
//
//     Match a pattern using the DFA algorithm    *
//

// This function matches a compiled pattern to a subject string, using the
// alternate matching algorithm that finds all matches at once.
//
// Arguments:
//   code          points to the compiled pattern
//   subject       subject string
//   length        length of subject string
//   startoffset   where to start matching in the subject
//   options       option bits
//   match_data    points to a match data structure
//   gcontext      points to a match context
//   workspace     pointer to workspace
//   wscount       size of workspace
//
// Returns:        > 0 => number of match offset pairs placed in offsets
//                 = 0 => offsets overflowed; longest matches are present
//                  -1 => failed to match
//                < -1 => some kind of unexpected problem

func Xpcre2_dfa_match_8(tls *libc.TLS, code uintptr, subject uintptr, length uint64, start_offset uint64, options uint32, match_data uintptr, mcontext uintptr, workspace uintptr, wscount uint64) int32 { /* pcre2_dfa_match.c:3297:1: */
	bp := tls.Alloc(31000)
	defer tls.Free(31000)

	var rc int32
	var was_zero_terminated int32
	var re uintptr
	var start_match uintptr
	var end_subject uintptr
	var bumpalong_limit uintptr
	var req_cu_ptr uintptr
	var utf int32
	var anchored int32
	var startline int32
	var firstline int32
	var has_first_cu int32
	var has_req_cu int32
	var memchr_found_first_cu uintptr
	var memchr_found_first_cu2 uintptr
	var first_cu uint8
	var first_cu2 uint8
	var req_cu uint8
	var req_cu2 uint8
	var start_bits uintptr

	// We need to have mb pointing to a match block, because the IS_NEWLINE macro
	// is used below, and it expects NLBLOCK to be defined as a pointer.

	// var cb Tpcre2_callout_block_8 at bp+30888, 112

	// var actual_match_block Tdfa_match_block_8 at bp, 168

	var mb uintptr

	// Set up a starting block of memory for use during recursive calls to
	// internal_dfa_match(). By putting this on the stack, it minimizes resource use
	// in the case when it is not needed. If this is too small, more memory is
	// obtained from the heap. At the start of each block is an anchor structure.

	// var base_recursion_workspace [7680]int32 at bp+168, 30720

	var rws uintptr
	var i uint32
	var check_subject uintptr
	var t uintptr
	var c uint8
	var ok int32
	// In 16-bit and 32_bit modes we have to do our own search, so can
	//           look for both cases at once.

	// In 8-bit mode, the use of memchr() gives a big speed up, even
	//           though we have to call it twice in order to find the earliest
	//           occurrence of the code unit in either of its cases. Caching is used
	//           to remember the positions of previously found code units. This can
	//           make a huge difference when the strings are very long and only one
	//           case is actually present.

	var pp1 uintptr
	var pp2 uintptr
	var searchlength uint64
	var c1 uint32
	var pp uintptr
	var check_length uint64
	var p uintptr
	var next uintptr
	was_zero_terminated = 0
	re = code
	has_first_cu = DFALSE
	has_req_cu = DFALSE
	memchr_found_first_cu = uintptr(0)
	memchr_found_first_cu2 = uintptr(0)
	first_cu = uint8(0)
	first_cu2 = uint8(0)
	req_cu = uint8(0)
	req_cu2 = uint8(0)
	start_bits = uintptr(0)
	mb = bp        /* &actual_match_block */
	rws = bp + 168 /* base_recursion_workspace */
	(*TRWS_anchor)(unsafe.Pointer(rws)).Fnext = uintptr(0)
	(*TRWS_anchor)(unsafe.Pointer(rws)).Fsize = uint32(uint64(DDFA_START_RWS_SIZE) / uint64(unsafe.Sizeof(int32(0))))
	(*TRWS_anchor)(unsafe.Pointer(rws)).Ffree = uint32(uint64(DDFA_START_RWS_SIZE)/uint64(unsafe.Sizeof(int32(0))) - uint64(unsafe.Sizeof(TRWS_anchor{}))/uint64(unsafe.Sizeof(int32(0))))

	// Recognize NULL, length 0 as an empty string.

	if !(subject == uintptr(0) && length == uint64(0)) {
		goto __1
	}
	subject = ts + 797 /* "" */
__1:
	;

	// Plausibility checks

	if !(options&libc.CplUint32(DPCRE2_ANCHORED|DPCRE2_ENDANCHORED|DPCRE2_NOTBOL|DPCRE2_NOTEOL|DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART|DPCRE2_NO_UTF_CHECK|DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT|DPCRE2_DFA_SHORTEST|DPCRE2_DFA_RESTART|DPCRE2_COPY_MATCHED_SUBJECT) != uint32(0)) {
		goto __2
	}
	return -34
__2:
	;
	if !(re == uintptr(0) || subject == uintptr(0) || workspace == uintptr(0) || match_data == uintptr(0)) {
		goto __3
	}
	return -51
__3:
	;

	if !(length == libc.CplUint64(uint64(0))) {
		goto __4
	}

	length = X_pcre2_strlen_8(tls, subject)
	was_zero_terminated = 1
__4:
	;

	if !(wscount < uint64(20)) {
		goto __5
	}
	return -43
__5:
	;
	if !(start_offset > length) {
		goto __6
	}
	return -33
__6:
	;

	// Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same
	// time.

	if !(options&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) != uint32(0) && ((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options|options)&DPCRE2_ENDANCHORED != uint32(0)) {
		goto __7
	}
	return -34
__7:
	;

	// Invalid UTF support is not available for DFA matching.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_INVALID_UTF != uint32(0)) {
		goto __8
	}
	return -66
__8:
	;

	// Check that the first field in the block is the magic number. If it is not,
	// return with PCRE2_ERROR_BADMAGIC.

	if !(uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER) {
		goto __9
	}
	return -31
__9:
	;

	// Check the code unit width.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_MODE8|DPCRE2_MODE16|DPCRE2_MODE32) != uint32(DPCRE2_CODE_UNIT_WIDTH/8)) {
		goto __10
	}
	return -32
__10:
	;

	// PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the
	// options variable for this function. Users of PCRE2 who are not calling the
	// function directly would like to have a way of setting these flags, in the same
	// way that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with
	// constructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and
	// (*NOTEMPTY_ATSTART) set bits in the pattern's "flag" function which can now be
	// transferred to the options for this function. The bits are guaranteed to be
	// adjacent, but do not have the same values. This bit of Boolean trickery assumes
	// that the match-time bits are not more significant than the flag bits. If by
	// accident this is not the case, a compile-time division by zero error will
	// occur.

	options = options | (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)/(uint32((DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)&(libc.CplInt32(DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)+1))/((DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART)&(libc.CplUint32(DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART)+uint32(1))))

	// If restarting after a partial match, do some sanity checks on the contents
	// of the workspace.

	if !(options&DPCRE2_DFA_RESTART != uint32(0)) {
		goto __11
	}

	if !(*(*int32)(unsafe.Pointer(workspace))&-2 != 0 || *(*int32)(unsafe.Pointer(workspace + 1*4)) < 1 || *(*int32)(unsafe.Pointer(workspace + 1*4)) > int32((wscount-uint64(2))/uint64(int32(uint64(unsafe.Sizeof(Tstateblock{}))/uint64(unsafe.Sizeof(int32(0))))))) {
		goto __12
	}
	return -38
__12:
	;
__11:
	;

	// Set some local values

	utf = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF != uint32(0))
	start_match = subject + uintptr(start_offset)
	end_subject = subject + uintptr(length)
	req_cu_ptr = start_match - uintptr(1)
	anchored = libc.Bool32(options&(DPCRE2_ANCHORED|DPCRE2_DFA_RESTART) != uint32(0) || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_ANCHORED != uint32(0))

	// The "must be at the start of a line" flags are used in a loop when finding
	// where to start.

	startline = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_STARTLINE) != uint32(0))
	firstline = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_FIRSTLINE != uint32(0))
	bumpalong_limit = end_subject

	// Initialize and set up the fixed fields in the callout block, with a pointer
	// in the match block.

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcb = bp + 30888 /* &cb */
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fversion = uint32(2)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fsubject = subject
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fsubject_length = uint64((int64(end_subject) - int64(subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fcallout_flags = uint32(0)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fcapture_top = uint32(1) // No capture support
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fcapture_last = uint32(0)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 30888 /* &cb */)).Fmark = uintptr(0) // No (*MARK) support

	// Get data from the match context, if present, and fill in the remaining
	// fields in the match block. It is an error to set an offset limit without
	// setting the flag at compile time.

	if !(mcontext == uintptr(0)) {
		goto __13
	}

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout = uintptr(0)
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmemctl
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit = X_pcre2_default_match_context_8.Fmatch_limit
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth = X_pcre2_default_match_context_8.Fdepth_limit
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit = uint64(X_pcre2_default_match_context_8.Fheap_limit)
	goto __14
__13:

	if !((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit != libc.CplUint64(uint64(0))) {
		goto __15
	}

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_USE_OFFSET_LIMIT == uint32(0)) {
		goto __16
	}
	return -56
__16:
	;
	bumpalong_limit = subject + uintptr((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit)
__15:
	;
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fcallout_data = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout_data
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmatch_limit
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fdepth_limit
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit = uint64((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fheap_limit)
__14:
	;

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit > (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match) {
		goto __17
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match
__17:
	;

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth > (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth) {
		goto __18
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth
__18:
	;

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit > uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap)) {
		goto __19
	}
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_limit = uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap)
__19:
	;

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_code = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) + uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size))
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject = subject
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject = end_subject
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_offset = start_offset
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fallowemptypartial = libc.Bool32(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind) > 0 || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_MATCH_EMPTY) != uint32(0))
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions = options
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fpoptions = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmatch_call_count = uint32(0)
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fheap_used = uint64(0)

	// Process the \R and newline settings.

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fbsr_convention = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fbsr_convention
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype = uint32(DNLTYPE_FIXED)
	switch int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fnewline_convention) {
	case DPCRE2_NEWLINE_CR:
		goto __21

	case DPCRE2_NEWLINE_LF:
		goto __22

	case DPCRE2_NEWLINE_NUL:
		goto __23

	case DPCRE2_NEWLINE_CRLF:
		goto __24

	case DPCRE2_NEWLINE_ANY:
		goto __25

	case DPCRE2_NEWLINE_ANYCRLF:
		goto __26

	default:
		goto __27
	}
	goto __20

__21:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(mb + 128)) = uint8('\015')
	goto __20

__22:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(mb + 128)) = uint8('\012')
	goto __20

__23:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(mb + 128)) = uint8(0)
	goto __20

__24:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen = uint32(2)
	*(*uint8)(unsafe.Pointer(mb + 128)) = uint8('\015')
	*(*uint8)(unsafe.Pointer(mb + 128 + 1)) = uint8('\012')
	goto __20

__25:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype = uint32(DNLTYPE_ANY)
	goto __20

__26:
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype = uint32(DNLTYPE_ANYCRLF)
	goto __20

__27:
	return -44
__20:
	;

	// Check a UTF string for validity if required. For 8-bit and 16-bit strings,
	// we must also check that a starting offset does not point into the middle of a
	// multiunit character. We check only the portion of the subject that is going to
	// be inspected during matching - from the offset minus the maximum back reference
	// to the given length. This saves time when a small part of a large subject is
	// being matched by the use of a starting offset. Note that the maximum lookbehind
	// is a number of characters, not code units.

	if !(utf != 0 && options&DPCRE2_NO_UTF_CHECK == uint32(0)) {
		goto __28
	}

	check_subject = start_match // start_match includes offset

	if !(start_offset > uint64(0)) {
		goto __29
	}

	if !(start_match < end_subject && uint32(*(*uint8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __30
	}
	return -36
__30:
	;
	i = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind)
__31:
	if !(i > uint32(0) && check_subject > subject) {
		goto __33
	}

	check_subject--
__34:
	if !(check_subject > subject && int32(*(*uint8)(unsafe.Pointer(check_subject)))&0xc0 == 0x80) {
		goto __35
	}
	check_subject--
	goto __34
__35:
	;
	goto __32
__32:
	i--
	goto __31
	goto __33
__33:
	;
__29:
	;

	// Validate the relevant portion of the subject. After an error, adjust the
	//   offset to be an absolute offset in the whole string.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = X_pcre2_valid_utf_8(tls, check_subject,
		length-uint64((int64(check_subject)-int64(subject))/1), match_data+80)
	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc != 0) {
		goto __36
	}

	*(*uint64)(unsafe.Pointer(match_data + 80)) += uint64((int64(check_subject) - int64(subject)) / 1)
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
__36:
	;
__28:
	;

	// Set up the first code unit to match, if available. If there's no first code
	// unit there may be a bitmap of possible first characters.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTSET) != uint32(0)) {
		goto __37
	}

	has_first_cu = DTRUE
	first_cu = libc.AssignUint8(&first_cu2, uint8((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit))
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTCASELESS) != uint32(0)) {
		goto __39
	}

	first_cu2 = *(*uint8)(unsafe.Pointer((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dfcc_offset) + uintptr(first_cu)))
	if !(int32(first_cu) > 127 && !(utf != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UCP != uint32(0)) {
		goto __40
	}
	first_cu2 = uint8(uint32(int32(first_cu) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(first_cu)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(first_cu)%DUCD_BLOCK_SIZE])*12)).Fother_case))
__40:
	;
__39:
	;
	goto __38
__37:
	if !(!(startline != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTMAPSET) != uint32(0)) {
		goto __41
	}
	start_bits = re + 40 /* &.start_bitmap */
__41:
	;
__38:
	;

	// There may be a "last known required code unit" set.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_LASTSET) != uint32(0)) {
		goto __42
	}

	has_req_cu = DTRUE
	req_cu = libc.AssignUint8(&req_cu2, uint8((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit))
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_LASTCASELESS) != uint32(0)) {
		goto __43
	}

	req_cu2 = *(*uint8)(unsafe.Pointer((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Ftables + uintptr(Dfcc_offset) + uintptr(req_cu)))
	if !(int32(req_cu) > 127 && !(utf != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UCP != uint32(0)) {
		goto __44
	}
	req_cu2 = uint8(uint32(int32(req_cu) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(req_cu)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(req_cu)%DUCD_BLOCK_SIZE])*12)).Fother_case))
__44:
	;
__43:
	;
__42:
	;

	// If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,
	// free the memory that was obtained.

	if !(uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fflags)&DPCRE2_MD_COPIED_SUBJECT != uint32(0)) {
		goto __45
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	*(*uint8)(unsafe.Pointer(match_data + 89)) &= libc.Uint8FromUint32(libc.CplUint32(DPCRE2_MD_COPIED_SUBJECT))
__45:
	;

	// Fill in fields that are always returned in the match data.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode = re
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = uintptr(0) // Default for no match
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmark = uintptr(0)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby = PCRE2_MATCHEDBY_DFA_INTERPRETER

	// Call the main matching function, looping for a non-anchored regex after a
	// failed match. If not restarting, perform certain optimizations at the start of
	// a match.

__46:

	// ----------------- Start of match optimizations ----------------

	// There are some optimizations that avoid running the match if a known
	//   starting point is not found, or if a known later code unit is not present.
	//   However, there is an option (settable at compile time) that disables
	//   these, for testing and for ensuring that all callouts do actually occur.
	//   The optimizations must also be avoided when restarting a DFA match.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_NO_START_OPTIMIZE == uint32(0) && options&DPCRE2_DFA_RESTART == uint32(0)) {
		goto __49
	}

	// If firstline is TRUE, the start of the match is constrained to the first
	//     line of a multiline string. That is, the match must be before or at the
	//     first newline following the start of matching. Temporarily adjust
	//     end_subject so that we stop the optimization scans for a first code unit
	//     immediately after the first character of a newline (the first code unit can
	//     legitimately be a newline). If the match fails at the newline, later code
	//     breaks this loop.

	if !(firstline != 0) {
		goto __50
	}

	t = start_match
	if !(utf != 0) {
		goto __51
	}

__53:
	if !(t < end_subject && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(t < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, t, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(t <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(t))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(t + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __54
	}

	t++
__55:
	if !(t < end_subject && uint32(*(*uint8)(unsafe.Pointer(t)))&0xc0 == 0x80) {
		goto __56
	}
	t++
	goto __55
__56:
	;
	goto __53
__54:
	;
	goto __52
__51:
__57:
	if !(t < end_subject && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(t < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, t, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(t <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(t))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(t + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __58
	}
	t++
	goto __57
__58:
	;
__52:
	;
	end_subject = t
__50:
	;

	// Anchored: check the first code unit if one is recorded. This may seem
	//     pointless but it can help in detecting a no match case without scanning for
	//     the required code unit.

	if !(anchored != 0) {
		goto __59
	}

	if !(has_first_cu != 0 || start_bits != uintptr(0)) {
		goto __61
	}

	ok = libc.Bool32(start_match < end_subject)
	if !(ok != 0) {
		goto __62
	}

	c = *(*uint8)(unsafe.Pointer(start_match))
	ok = libc.Bool32(has_first_cu != 0 && (int32(c) == int32(first_cu) || int32(c) == int32(first_cu2)))
	if !(!(ok != 0) && start_bits != uintptr(0)) {
		goto __63
	}

	ok = libc.Bool32(uint32(*(*uint8)(unsafe.Pointer(start_bits + uintptr(int32(c)/8))))&(uint32(1)<<(int32(c)&7)) != uint32(0))
__63:
	;
__62:
	;
	if !!(ok != 0) {
		goto __64
	}
	goto __48
__64:
	;
__61:
	;
	goto __60
__59:

	if !(has_first_cu != 0) {
		goto __65
	}

	if !(int32(first_cu) != int32(first_cu2)) {
		goto __67
	} /* Caseless */

	// In 16-bit and 32_bit modes we have to do our own search, so can
	//           look for both cases at once.

	// In 8-bit mode, the use of memchr() gives a big speed up, even
	//           though we have to call it twice in order to find the earliest
	//           occurrence of the code unit in either of its cases. Caching is used
	//           to remember the positions of previously found code units. This can
	//           make a huge difference when the strings are very long and only one
	//           case is actually present.

	pp1 = uintptr(0)
	pp2 = uintptr(0)
	searchlength = uint64((int64(end_subject) - int64(start_match)) / 1)

	// If we haven't got a previously found position for first_cu, or if
	//           the current starting position is later, we need to do a search. If
	//           the code unit is not found, set it to the end.

	if !(memchr_found_first_cu == uintptr(0) || start_match > memchr_found_first_cu) {
		goto __69
	}

	pp1 = libc.Xmemchr(tls, start_match, int32(first_cu), searchlength)
	if pp1 == uintptr(0) {
		memchr_found_first_cu = end_subject
	} else {
		memchr_found_first_cu = pp1
	}
	goto __70
__69:
	if memchr_found_first_cu == end_subject {
		pp1 = uintptr(0)
	} else {
		pp1 = memchr_found_first_cu
	}
__70:
	;

	// Do the same thing for the other case.

	if !(memchr_found_first_cu2 == uintptr(0) || start_match > memchr_found_first_cu2) {
		goto __71
	}

	pp2 = libc.Xmemchr(tls, start_match, int32(first_cu2), searchlength)
	if pp2 == uintptr(0) {
		memchr_found_first_cu2 = end_subject
	} else {
		memchr_found_first_cu2 = pp2
	}
	goto __72
__71:
	if memchr_found_first_cu2 == end_subject {
		pp2 = uintptr(0)
	} else {
		pp2 = memchr_found_first_cu2
	}
__72:
	;

	// Set the start to the end of the subject if neither case was found.
	//           Otherwise, use the earlier found point.

	if !(pp1 == uintptr(0)) {
		goto __73
	}
	if pp2 == uintptr(0) {
		start_match = end_subject
	} else {
		start_match = pp2
	}
	goto __74
__73:
	if pp2 == uintptr(0) || pp1 < pp2 {
		start_match = pp1
	} else {
		start_match = pp2
	}
__74:
	;

	goto __68
__67:

	start_match = libc.Xmemchr(tls, start_match, int32(first_cu), uint64((int64(end_subject)-int64(start_match))/1))
	if !(start_match == uintptr(0)) {
		goto __75
	}
	start_match = end_subject
__75:
	;
__68:
	;

	// If we can't find the required code unit, having reached the true end
	//         of the subject, break the bumpalong loop, to force a match failure,
	//         except when doing partial matching, when we let the next cycle run at
	//         the end of the subject. To see why, consider the pattern /(?<=abc)def/,
	//         which partially matches "abc", even though the string does not contain
	//         the starting character "d". If we have not reached the true end of the
	//         subject (PCRE2_FIRSTLINE caused end_subject to be temporarily modified)
	//         we also let the cycle run, because the matching string is legitimately
	//         allowed to start with the first code unit of a newline.

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) == uint32(0) && start_match >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __76
	}
	goto __48
__76:
	;
	goto __66
__65:
	if !(startline != 0) {
		goto __77
	}

	if !(start_match > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr(start_offset)) {
		goto __79
	}

	if !(utf != 0) {
		goto __80
	}

__82:
	if !(start_match < end_subject && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(start_match > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, start_match, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(start_match >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(start_match - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(start_match - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __83
	}

	start_match++
__84:
	if !(start_match < end_subject && uint32(*(*uint8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __85
	}
	start_match++
	goto __84
__85:
	;
	goto __82
__83:
	;
	goto __81
__80:
__86:
	if !(start_match < end_subject && !(func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(start_match > (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, start_match, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(start_match >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(start_match - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(start_match - uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0)) {
		goto __87
	}
	start_match++
	goto __86
__87:
	;
__81:
	;

	// If we have just passed a CR and the newline option is ANY or
	//           ANYCRLF, and we are now at a LF, advance the match position by one
	//           more code unit.

	if !(int32(*(*uint8)(unsafe.Pointer(start_match + libc.UintptrFromInt32(-1)))) == '\015' && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_ANY) || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_ANYCRLF)) && start_match < end_subject && int32(*(*uint8)(unsafe.Pointer(start_match))) == '\012') {
		goto __88
	}
	start_match++
__88:
	;
__79:
	;
	goto __78
__77:
	if !(start_bits != uintptr(0)) {
		goto __89
	}

__90:
	if !(start_match < end_subject) {
		goto __91
	}

	c1 = uint32(*(*uint8)(unsafe.Pointer(start_match)))
	if !(uint32(*(*uint8)(unsafe.Pointer(start_bits + uintptr(c1/uint32(8)))))&(uint32(1)<<(c1&uint32(7))) != uint32(0)) {
		goto __92
	}
	goto __91
__92:
	;
	start_match++
	goto __90
__91:
	;

	// See comment above in first_cu checking about the next line.

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) == uint32(0) && start_match >= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __93
	}
	goto __48
__93:
	;
__89:
	;
__78:
	;
__66:
	;
__60:
	; // End of first code unit handling

	// Restore fudged end_subject

	end_subject = (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject

	// The following two optimizations are disabled for partial matching.

	if !((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmoptions&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) == uint32(0)) {
		goto __94
	}

	// The minimum matching length is a lower bound; no actual string of that
	//       length may actually match the pattern. Although the value is, strictly,
	//       in characters, we treat it as code units to avoid spending too much time
	//       in this optimization.

	if !((int64(end_subject)-int64(start_match))/1 < int64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength)) {
		goto __95
	}
	goto NOMATCH_EXIT
__95:
	;

	// If req_cu is set, we know that that code unit must appear in the
	//       subject for the match to succeed. If the first code unit is set, req_cu
	//       must be later in the subject; otherwise the test starts at the match
	//       point. This optimization can save a huge amount of backtracking in
	//       patterns with nested unlimited repeats that aren't going to match.
	//       Writing separate code for cased/caseless versions makes it go faster, as
	//       does using an autoincrement and backing off on a match. As in the case of
	//       the first code unit, using memchr() in the 8-bit library gives a big
	//       speed up. Unlike the first_cu check above, we do not need to call
	//       memchr() twice in the caseless case because we only need to check for the
	//       presence of the character in either case, not find the first occurrence.
	//
	//       The search can be skipped if the code unit was found later than the
	//       current starting point in a previous iteration of the bumpalong loop.
	//
	//       HOWEVER: when the subject string is very, very long, searching to its end
	//       can take a long time, and give bad performance on quite ordinary
	//       patterns. This showed up when somebody was matching something like
	//       /^\d+C/ on a 32-megabyte string... so we don't do this when the string is
	//       sufficiently long, but it's worth searching a lot more for unanchored
	//       patterns.

	p = start_match + uintptr(func() int32 {
		if has_first_cu != 0 {
			return 1
		}
		return 0
	}())
	if !(has_req_cu != 0 && p > req_cu_ptr) {
		goto __96
	}

	check_length = uint64((int64(end_subject) - int64(start_match)) / 1)

	if !(check_length < uint64(DREQ_CU_MAX) || !(anchored != 0) && check_length < uint64(DREQ_CU_MAX*1000)) {
		goto __97
	}

	if !(int32(req_cu) != int32(req_cu2)) {
		goto __98
	} /* Caseless */

	pp = p
	p = libc.Xmemchr(tls, pp, int32(req_cu), uint64((int64(end_subject)-int64(pp))/1))
	if !(p == uintptr(0)) {
		goto __100
	}

	p = libc.Xmemchr(tls, pp, int32(req_cu2), uint64((int64(end_subject)-int64(pp))/1))
	if !(p == uintptr(0)) {
		goto __101
	}
	p = end_subject
__101:
	;
__100:
	;
	goto __99
__98:

	p = libc.Xmemchr(tls, p, int32(req_cu), uint64((int64(end_subject)-int64(p))/1))
	if !(p == uintptr(0)) {
		goto __102
	}
	p = end_subject
__102:
	;
__99:
	;

	// If we can't find the required code unit, break the matching loop,
	//           forcing a match failure.

	if !(p >= end_subject) {
		goto __103
	}
	goto __48
__103:
	;

	// If we have found the required code unit, save the point where we
	//           found it, so that we don't search again next time round the loop if
	//           the start hasn't passed this code unit yet.

	req_cu_ptr = p
__97:
	;
__96:
	;
__94:
	;
__49:
	;

	// ------------ End of start of match optimizations ------------

	// Give no match if we have passed the bumpalong limit.

	if !(start_match > bumpalong_limit) {
		goto __104
	}
	goto __48
__104:
	;

	// OK, now we can do the business

	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = start_match
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = start_match
	(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Frecursive = uintptr(0)

	rc = internal_dfa_match(tls,
		mb, // fixed match data
		(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_code, // this subexpression's code
		start_match,  // where we currently are
		start_offset, // start offset in subject
		match_data+96,
		uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)*uint32(2),
		workspace,      // workspace vector
		int32(wscount), // size of same
		uint32(0),      // function recurse level
		bp+168)         // initial workspace for recursion

	// Anything other than "no match" means we are done, always; otherwise, carry
	//   on only if not anchored.

	if !(rc != -1 || anchored != 0) {
		goto __105
	}

	if !(rc == -2 && int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) > 0) {
		goto __106
	}

	*(*uint64)(unsafe.Pointer(match_data + 96)) = uint64((int64(start_match) - int64(subject)) / 1)
	*(*uint64)(unsafe.Pointer(match_data + 96 + 1*8)) = uint64((int64(end_subject) - int64(subject)) / 1)
__106:
	;
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = uint64((int64((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frightchar = uint64((int64((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar = uint64((int64(start_match) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = rc

	if !(rc >= 0 && options&DPCRE2_COPY_MATCHED_SUBJECT != uint32(0)) {
		goto __107
	}

	length = (length + uint64(was_zero_terminated)) * uint64(DPCRE2_CODE_UNIT_WIDTH/8)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmalloc})).f(tls, length,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject == uintptr(0)) {
		goto __109
	}
	return -48
__109:
	;
	libc.Xmemcpy(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject, subject, length)
	*(*uint8)(unsafe.Pointer(match_data + 89)) |= uint8(DPCRE2_MD_COPIED_SUBJECT)
	goto __108
__107:

	if !(rc >= 0 || rc == -2) {
		goto __110
	}
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = subject
__110:
	;
__108:
	;
	goto EXIT
__105:
	;

	// Advance to the next subject character unless we are at the end of a line
	//   and firstline is set.

	if !(firstline != 0 && func() int32 {
		if (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(start_match < (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, start_match, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+120, utf) != 0)
		}
		return libc.Bool32(start_match <= (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(start_match))) == int32(*(*uint8)(unsafe.Pointer(mb + 128))) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(start_match + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 128 + 1)))))
	}() != 0) {
		goto __111
	}
	goto __48
__111:
	;
	start_match++
	if !(utf != 0) {
		goto __112
	}

__113:
	if !(start_match < end_subject && uint32(*(*uint8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __114
	}
	start_match++
	goto __113
__114:
	;
__112:
	;
	if !(start_match > end_subject) {
		goto __115
	}
	goto __48
__115:
	;

	// If we have just passed a CR and we are now at a LF, and the pattern does
	//   not contain any explicit matches for \r or \n, and the newline option is CRLF
	//   or ANY or ANYCRLF, advance the match position by one more character.

	if !(int32(*(*uint8)(unsafe.Pointer(start_match - uintptr(1)))) == '\015' && start_match < end_subject && int32(*(*uint8)(unsafe.Pointer(start_match))) == '\012' && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_HASCRORLF) == uint32(0) && ((*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_ANY) || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_ANYCRLF) || (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2))) {
		goto __116
	}
	start_match++
__116:
	;

	goto __47
__47:
	goto __46
	goto __48
__48:
	; // "Bumpalong" loop

NOMATCH_EXIT:
	rc = -1

EXIT:
__117:
	if !((*TRWS_anchor)(unsafe.Pointer(rws)).Fnext != uintptr(0)) {
		goto __118
	}

	next = (*TRWS_anchor)(unsafe.Pointer(rws)).Fnext
	(*TRWS_anchor)(unsafe.Pointer(rws)).Fnext = (*TRWS_anchor)(unsafe.Pointer(next)).Fnext
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl.Ffree})).f(tls, next, (*Tdfa_match_block_8)(unsafe.Pointer(mb)).Fmemctl.Fmemory_data)
	goto __117
__118:
	;

	return rc
}

// These #undefs are here to enable unity builds with CMake.

// End of pcre2_dfa_match.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// The texts of compile-time error messages. Compile-time error numbers start
// at COMPILE_ERROR_BASE (100).
//
// This used to be a table of strings, but in order to reduce the number of
// relocations needed when a shared library is loaded dynamically, it is now one
// long string. We cannot use a table of offsets, because the lengths of inserts
// such as XSTRING(MAX_NAME_SIZE) are not known. Instead,
// pcre2_get_error_message() counts through to the one it wants - this isn't a
// performance issue because these strings are used only when there is an error.
//
// Each substring ends with \0 to insert a null character. This includes the final
// substring, so that the whole string ends with \0\0, which can be detected when
// counting through.

var compile_error_texts =

// 5

// 10

// 15

// 20

// 25

// 30

// 35

// 40

// 45

// 50

// 55

// "an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)\0"
// Was the above
// 60

// 65

// 70

// 75

// 80

// 85

// 90

// 95

*(*[4381]uint8)(unsafe.Pointer(ts + 798)) /* pcre2_error.c:65:28 */

// Match-time and UTF error texts are in the same format.

var match_error_texts =

// 5

// 10

// 15

// 20

// 25

// 30

// 35

// Never returned by PCRE2 itself

// 40

// 45

// 50

// 55

// 60

// 65

*(*[2476]uint8)(unsafe.Pointer(ts + 5179)) /* pcre2_error.c:194:28 */

// ************************************************
//
//            Return error message                *
//

// This function copies an error message into a buffer whose units are of an
// appropriate width. Error numbers are positive for compile-time errors, and
// negative for match-time errors (except for UTF errors), but the numbers are all
// distinct.
//
// Arguments:
//   enumber       error number
//   buffer        where to put the message (zero terminated)
//   size          size of the buffer in code units
//
// Returns:        length of message if all is well
//                 negative on error

func Xpcre2_get_error_message_8(tls *libc.TLS, enumber int32, buffer uintptr, size uint64) int32 { /* pcre2_error.c:297:1: */
	var message uintptr
	var i uint64
	var n int32

	if size == uint64(0) {
		return -48
	}

	if enumber >= DCOMPILE_ERROR_BASE {
		message = uintptr(unsafe.Pointer(&compile_error_texts))
		n = enumber - DCOMPILE_ERROR_BASE
	} else if enumber < 0 {
		message = uintptr(unsafe.Pointer(&match_error_texts))
		n = -enumber
	} else {
		message = ts + 7655 /* "\x00" */ // Empty message list
		n = 1
	}

	for ; n > 0; n-- {
		for int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&message, 1)))) != 0 {
		}

		if int32(*(*uint8)(unsafe.Pointer(message))) == 0 {
			return -29
		}
	}

	for i = uint64(0); int32(*(*uint8)(unsafe.Pointer(message))) != 0; i++ {
		if i >= size-uint64(1) {
			*(*uint8)(unsafe.Pointer(buffer + uintptr(i))) = uint8(0) // Terminate partial message
			return -48
		}
		*(*uint8)(unsafe.Pointer(buffer + uintptr(i))) = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&message, 1)))
	}

	*(*uint8)(unsafe.Pointer(buffer + uintptr(i))) = uint8(0)
	return int32(i)
}

// End of pcre2_error.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Dummy function

// ************************************************
//
//      Match an extended grapheme sequence       *
//

//
// Arguments:
//   c              the first character
//   eptr           pointer to next character
//   start_subject  pointer to start of subject
//   end_subject    pointer to end of subject
//   utf            TRUE if in UTF mode
//   xcount         pointer to count of additional characters,
//                    or NULL if count not needed
//
// Returns:         pointer after the end of the sequence

func X_pcre2_extuni_8(tls *libc.TLS, c uint32, eptr uintptr, start_subject uintptr, end_subject uintptr, utf int32, xcount uintptr) uintptr { /* pcre2_extuni.c:92:1: */
	var lgb int32 = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fgbprop)

	for eptr < end_subject {
		var rgb int32
		var len int32 = 1
		if !(utf != 0) {
			c = uint32(*(*uint8)(unsafe.Pointer(eptr)))
		} else {
			c = uint32(*(*uint8)(unsafe.Pointer(eptr)))
			if c >= 0xc0 {
				if c&0x20 == uint32(0) {
					c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f
					len++
				} else if c&0x10 == uint32(0) {
					c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 2)))&0x3f
					len = len + 2
				} else if c&0x08 == uint32(0) {
					c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(eptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 3)))&0x3f
					len = len + 3
				} else if c&0x04 == uint32(0) {
					c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(eptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(eptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 4)))&0x3f
					len = len + 4
				} else {
					c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(eptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(eptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(eptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 5)))&0x3f
					len = len + 5
				}
			}

		}
		rgb = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fgbprop)
		if X_pcre2_ucp_gbtable_8[lgb]&(uint32(1)<<rgb) == uint32(0) {
			break
		}

		// Not breaking between Regional Indicators is allowed only if there
		//   are an even number of preceding RIs.

		if lgb == ucp_gbRegional_Indicator && rgb == ucp_gbRegional_Indicator {
			var ricount int32 = 0
			var bptr uintptr = eptr - uintptr(1)
			if utf != 0 {
				for uint32(*(*uint8)(unsafe.Pointer(bptr)))&0xc0 == 0x80 {
					bptr--
				}
			}

			// bptr is pointing to the left-hand character

			for bptr > start_subject {
				bptr--
				if utf != 0 {
					for uint32(*(*uint8)(unsafe.Pointer(bptr)))&0xc0 == 0x80 {
						bptr--
					}
					c = uint32(*(*uint8)(unsafe.Pointer(bptr)))
					if c >= 0xc0 {
						if c&0x20 == uint32(0) {
							c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(bptr + 1)))&0x3f
						} else if c&0x10 == uint32(0) {
							c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(bptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(bptr + 2)))&0x3f
						} else if c&0x08 == uint32(0) {
							c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(bptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(bptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(bptr + 3)))&0x3f
						} else if c&0x04 == uint32(0) {
							c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(bptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(bptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(bptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(bptr + 4)))&0x3f
						} else {
							c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(bptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(bptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(bptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(bptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(bptr + 5)))&0x3f
						}
					}

				} else {
					c = uint32(*(*uint8)(unsafe.Pointer(bptr)))
				}
				if int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fgbprop) != ucp_gbRegional_Indicator {
					break
				}
				ricount++
			}
			if ricount&1 != 0 {
				break
			} // Grapheme break required
		}

		// If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this
		//   allows any number of them before a following Extended_Pictographic.

		if rgb != ucp_gbExtend && rgb != ucp_gbZWJ || lgb != ucp_gbExtended_Pictographic {
			lgb = rgb
		}

		eptr += uintptr(len)
		if xcount != uintptr(0) {
			*(*int32)(unsafe.Pointer(xcount)) += 1
		}
	}

	return eptr
}

// End of pcre2_extuni.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//    Scan compiled regex for specific bracket    *
//

//
// Arguments:
//   code        points to start of expression
//   utf         TRUE in UTF mode
//   number      the required bracket number or negative to find a lookbehind
//
// Returns:      pointer to the opcode for the bracket, or NULL if not found

func X_pcre2_find_bracket_8(tls *libc.TLS, code uintptr, utf int32, number int32) uintptr { /* pcre2_find_bracket.c:70:1: */
	for {
		var c uint8 = *(*uint8)(unsafe.Pointer(code))

		if int32(c) == OP_END {
			return uintptr(0)
		}

		// XCLASS is used for classes that cannot be represented just by a bit map.
		//   This includes negated single high-valued characters. CALLOUT_STR is used for
		//   callouts with string arguments. In both cases the length in the table is
		//   zero; the actual length is stored in the compiled code.

		if int32(c) == OP_XCLASS {
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2)))))
		} else if int32(c) == OP_CALLOUT_STR {
			code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 6)))))
		} else if int32(c) == OP_REVERSE {
			if number < 0 {
				return code
			}
			code += uintptr(X_pcre2_OP_lengths_8[c])
		} else if int32(c) == OP_CBRA || int32(c) == OP_SCBRA || int32(c) == OP_CBRAPOS || int32(c) == OP_SCBRAPOS {
			var n int32 = int32(uint32(int32(*(*uint8)(unsafe.Pointer(code + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 4)))))
			if n == number {
				return code
			}
			code += uintptr(X_pcre2_OP_lengths_8[c])
		} else {
			switch int32(c) {
			case OP_TYPESTAR:
				fallthrough
			case OP_TYPEMINSTAR:
				fallthrough
			case OP_TYPEPLUS:
				fallthrough
			case OP_TYPEMINPLUS:
				fallthrough
			case OP_TYPEQUERY:
				fallthrough
			case OP_TYPEMINQUERY:
				fallthrough
			case OP_TYPEPOSSTAR:
				fallthrough
			case OP_TYPEPOSPLUS:
				fallthrough
			case OP_TYPEPOSQUERY:
				if int32(*(*uint8)(unsafe.Pointer(code + 1))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(code + 1))) == OP_NOTPROP {
					code += uintptr(2)
				}
				break
				fallthrough

			case OP_TYPEUPTO:
				fallthrough
			case OP_TYPEMINUPTO:
				fallthrough
			case OP_TYPEEXACT:
				fallthrough
			case OP_TYPEPOSUPTO:
				if int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(code + 3))) == OP_NOTPROP {
					code += uintptr(2)
				}
				break
				fallthrough

			case OP_MARK:
				fallthrough
			case OP_COMMIT_ARG:
				fallthrough
			case OP_PRUNE_ARG:
				fallthrough
			case OP_SKIP_ARG:
				fallthrough
			case OP_THEN_ARG:
				code += uintptr(*(*uint8)(unsafe.Pointer(code + 1)))
				break
			}

			// Add in the fixed length from the table

			code += uintptr(X_pcre2_OP_lengths_8[c])

			// In UTF-8 and UTF-16 modes, opcodes that are followed by a character may be
			//   followed by a multi-byte character. The length in the table is a minimum, so
			//   we have to arrange to skip the extra bytes.

			if utf != 0 {
				switch int32(c) {
				case OP_CHAR:
					fallthrough
				case OP_CHARI:
					fallthrough
				case OP_NOT:
					fallthrough
				case OP_NOTI:
					fallthrough
				case OP_EXACT:
					fallthrough
				case OP_EXACTI:
					fallthrough
				case OP_NOTEXACT:
					fallthrough
				case OP_NOTEXACTI:
					fallthrough
				case OP_UPTO:
					fallthrough
				case OP_UPTOI:
					fallthrough
				case OP_NOTUPTO:
					fallthrough
				case OP_NOTUPTOI:
					fallthrough
				case OP_MINUPTO:
					fallthrough
				case OP_MINUPTOI:
					fallthrough
				case OP_NOTMINUPTO:
					fallthrough
				case OP_NOTMINUPTOI:
					fallthrough
				case OP_POSUPTO:
					fallthrough
				case OP_POSUPTOI:
					fallthrough
				case OP_NOTPOSUPTO:
					fallthrough
				case OP_NOTPOSUPTOI:
					fallthrough
				case OP_STAR:
					fallthrough
				case OP_STARI:
					fallthrough
				case OP_NOTSTAR:
					fallthrough
				case OP_NOTSTARI:
					fallthrough
				case OP_MINSTAR:
					fallthrough
				case OP_MINSTARI:
					fallthrough
				case OP_NOTMINSTAR:
					fallthrough
				case OP_NOTMINSTARI:
					fallthrough
				case OP_POSSTAR:
					fallthrough
				case OP_POSSTARI:
					fallthrough
				case OP_NOTPOSSTAR:
					fallthrough
				case OP_NOTPOSSTARI:
					fallthrough
				case OP_PLUS:
					fallthrough
				case OP_PLUSI:
					fallthrough
				case OP_NOTPLUS:
					fallthrough
				case OP_NOTPLUSI:
					fallthrough
				case OP_MINPLUS:
					fallthrough
				case OP_MINPLUSI:
					fallthrough
				case OP_NOTMINPLUS:
					fallthrough
				case OP_NOTMINPLUSI:
					fallthrough
				case OP_POSPLUS:
					fallthrough
				case OP_POSPLUSI:
					fallthrough
				case OP_NOTPOSPLUS:
					fallthrough
				case OP_NOTPOSPLUSI:
					fallthrough
				case OP_QUERY:
					fallthrough
				case OP_QUERYI:
					fallthrough
				case OP_NOTQUERY:
					fallthrough
				case OP_NOTQUERYI:
					fallthrough
				case OP_MINQUERY:
					fallthrough
				case OP_MINQUERYI:
					fallthrough
				case OP_NOTMINQUERY:
					fallthrough
				case OP_NOTMINQUERYI:
					fallthrough
				case OP_POSQUERY:
					fallthrough
				case OP_POSQUERYI:
					fallthrough
				case OP_NOTPOSQUERY:
					fallthrough
				case OP_NOTPOSQUERYI:
					if int32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1)))) >= 0xc0 {
						code += uintptr(X_pcre2_utf8_table4[uint32(*(*uint8)(unsafe.Pointer(code + libc.UintptrFromInt32(-1))))&0x3f])
					}
					break
				}
			}
		}
	}
	return uintptr(0)
}

// End of pcre2_find_bracket.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//        JIT compile a Regular Expression        *
//

// This function used JIT to convert a previously-compiled pattern into machine
// code.
//
// Arguments:
//   code          a compiled pattern
//   options       JIT option bits
//
// Returns:        0: success or (*NOJIT) was used
//                <0: an error code

func Xpcre2_jit_compile_8(tls *libc.TLS, code uintptr, options uint32) int32 { /* pcre2_jit_compile.c:14382:1: */
	var re uintptr = code

	if code == uintptr(0) {
		return -51
	}

	if options&libc.CplUint32(DPCRE2_JIT_COMPLETE|DPCRE2_JIT_PARTIAL_SOFT|DPCRE2_JIT_PARTIAL_HARD|DPCRE2_JIT_INVALID_UTF) != uint32(0) {
		return -45
	}

	// Support for invalid UTF was first introduced in JIT, with the option
	// PCRE2_JIT_INVALID_UTF. Later, support was added to the interpreter, and the
	// compile-time option PCRE2_MATCH_INVALID_UTF was created. This is now the
	// preferred feature, with the earlier option deprecated. However, for backward
	// compatibility, if the earlier option is set, it forces the new option so that
	// if JIT matching falls back to the interpreter, there is still support for
	// invalid UTF. However, if this function has already been successfully called
	// without PCRE2_JIT_INVALID_UTF and without PCRE2_MATCH_INVALID_UTF (meaning that
	// non-invalid-supporting JIT code was compiled), give an error.
	//
	// If in the future support for PCRE2_JIT_INVALID_UTF is withdrawn, the following
	// actions are needed:
	//
	//   1. Remove the definition from pcre2.h.in and from the list in
	//      PUBLIC_JIT_COMPILE_OPTIONS above.
	//
	//   2. Replace PCRE2_JIT_INVALID_UTF with a local flag in this module.
	//
	//   3. Replace PCRE2_JIT_INVALID_UTF in pcre2_jit_test.c.
	//
	//   4. Delete the following short block of code. The setting of "re" and
	//      "functions" can be moved into the JIT-only block below, but if that is
	//      done, (void)re and (void)functions will be needed in the non-JIT case, to
	//      avoid compiler warnings.

	if options&DPCRE2_JIT_INVALID_UTF != uint32(0) {
		if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_INVALID_UTF == uint32(0) {
			*(*uint32)(unsafe.Pointer(re + 88)) |= DPCRE2_MATCH_INVALID_UTF
		}
	}

	// The above tests are run with and without JIT support. This means that
	// PCRE2_JIT_INVALID_UTF propagates back into the regex options (ensuring
	// interpreter support) even in the absence of JIT. But now, if there is no JIT
	// support, give an error return.

	return -45
}

// JIT compiler uses an all-in-one approach. This improves security,
//    since the code generator functions are not exported.

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2018 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// ************************************************
//
//              Do a JIT pattern match            *
//

// This function runs a JIT pattern match.
//
// Arguments:
//   code            points to the compiled expression
//   subject         points to the subject string
//   length          length of subject string (may contain binary zeros)
//   start_offset    where to start in the subject string
//   options         option bits
//   match_data      points to a match_data block
//   mcontext        points to a match context
//
// Returns:          > 0 => success; value is the number of ovector pairs filled
//                   = 0 => success, but ovector is not big enough
//                    -1 => failed to match (PCRE_ERROR_NOMATCH)
//                  < -1 => some kind of unexpected problem

func Xpcre2_jit_match_8(tls *libc.TLS, code uintptr, subject uintptr, length uint64, start_offset uint64, options uint32, match_data uintptr, mcontext uintptr) int32 { /* pcre2_jit_match.c:85:1: */

	_ = code
	_ = subject
	_ = length
	_ = start_offset
	_ = options
	_ = match_data
	_ = mcontext
	return -45

}

// End of pcre2_jit_match.c
// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//          New API code Copyright (c) 2016 University of Cambridge
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// ************************************************
//
//           Free JIT read-only data              *
//

func X_pcre2_jit_free_rodata_8(tls *libc.TLS, current uintptr, allocator_data uintptr) { /* pcre2_jit_misc.c:53:1: */
	_ = current
	_ = allocator_data
}

// ************************************************
//
//           Free JIT compiled code               *
//

func X_pcre2_jit_free_8(tls *libc.TLS, executable_jit uintptr, memctl uintptr) { /* pcre2_jit_misc.c:78:1: */
	_ = executable_jit
	_ = memctl
}

// ************************************************
//
//            Free unused JIT memory              *
//

func Xpcre2_jit_free_unused_memory_8(tls *libc.TLS, gcontext uintptr) { /* pcre2_jit_misc.c:107:1: */
	_ = gcontext // Suppress warning
}

// ************************************************
//
//            Allocate a JIT stack                *
//

func Xpcre2_jit_stack_create_8(tls *libc.TLS, startsize uint64, maxsize uint64, gcontext uintptr) uintptr { /* pcre2_jit_misc.c:125:32: */

	_ = gcontext
	_ = startsize
	_ = maxsize
	return uintptr(0)

}

// ************************************************
//
//         Assign a JIT stack to a pattern        *
//

func Xpcre2_jit_stack_assign_8(tls *libc.TLS, mcontext uintptr, callback uintptr, callback_data uintptr) { /* pcre2_jit_misc.c:166:1: */
	_ = mcontext
	_ = callback
	_ = callback_data
}

// ************************************************
//
//               Free a JIT stack                 *
//

func Xpcre2_jit_stack_free_8(tls *libc.TLS, jit_stack uintptr) { /* pcre2_jit_misc.c:188:1: */
	_ = jit_stack
}

// ************************************************
//
//               Get target CPU type              *
//

func X_pcre2_jit_get_target_8(tls *libc.TLS) uintptr { /* pcre2_jit_misc.c:206:11: */
	return ts + 7657 /* "JIT is not suppo..." */
}

// ************************************************
//
//              Get size of JIT code              *
//

func X_pcre2_jit_get_size_8(tls *libc.TLS, executable_jit uintptr) uint64 { /* pcre2_jit_misc.c:222:1: */
	_ = executable_jit
	return uint64(0)
}

// End of pcre2_jit_misc.c

// End of pcre2_jit_compile.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//           Create PCRE2 character tables        *
//

// This function builds a set of character tables for use by PCRE2 and returns
// a pointer to them. They are build using the ctype functions, and consequently
// their contents will depend upon the current locale setting. When compiled as
// part of the library, the store is obtained via a general context malloc, if
// supplied, but when PCRE2_DFTABLES is defined (when compiling the pcre2_dftables
// freestanding auxiliary program) malloc() is used, and the function has a
// different name so as not to clash with the prototype in pcre2.h.
//
// Arguments:   none when PCRE2_DFTABLES is defined
//                else a PCRE2 general context or NULL
// Returns:     pointer to the contiguous block of data
//                else NULL if memory allocation failed

func Xpcre2_maketables_8(tls *libc.TLS, gcontext uintptr) uintptr { /* pcre2_maketables.c:81:30: */
	var yield uintptr = func() uintptr {
		if gcontext != uintptr(0) {
			return (*struct {
				f func(*libc.TLS, uint64, uintptr) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmalloc})).f(tls, uint64(Dcbits_offset+Dcbit_length+256), (*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data)
		}
		return libc.Xmalloc(tls, uint64(Dcbits_offset+Dcbit_length+256))
	}()
	var i int32
	var p uintptr

	if yield == uintptr(0) {
		return uintptr(0)
	}
	p = yield

	// First comes the lower casing table

	for i = 0; i < 256; i++ {
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(libc.Xtolower(tls, i))
	}

	// Next the case-flipping table

	for i = 0; i < 256; i++ {
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = func() uint8 {
			if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISlower) != 0 {
				return uint8(libc.Xtoupper(tls, i))
			}
			return uint8(libc.Xtolower(tls, i))
		}()
	}

	// Then the character class tables. Don't try to be clever and save effort on
	// exclusive ones - in some locales things may be different.
	//
	// Note that the table for "space" includes everything "isspace" gives, including
	// VT in the default locale. This makes it work for the POSIX class [:space:].
	// From PCRE1 release 8.34 and for all PCRE2 releases it is also correct for Perl
	// space, because Perl added VT at release 5.18.
	//
	// Note also that it is possible for a character to be alnum or alpha without
	// being lower or upper, such as "male and female ordinals" (\xAA and \xBA) in the
	// fr_FR locale (at least under Debian Linux's locales as of 12/2005). So we must
	// test for alnum specially.

	libc.Xmemset(tls, p, 0, uint64(Dcbit_length))
	for i = 0; i < 256; i++ {
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISdigit) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_digit+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISupper) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_upper+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISlower) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_lower+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISalnum) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_word+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if i == '_' {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_word+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISspace) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_space+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISxdigit) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_xdigit+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISgraph) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_graph+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISprint) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_print+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISpunct) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_punct+i/8))) |= uint8(uint32(1) << (i & 7))
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_IScntrl) != 0 {
			*(*uint8)(unsafe.Pointer(p + uintptr(Dcbit_cntrl+i/8))) |= uint8(uint32(1) << (i & 7))
		}
	}
	p += uintptr(Dcbit_length)

	// Finally, the character type table. In this, we used to exclude VT from the
	// white space chars, because Perl didn't recognize it as such for \s and for
	// comments within regexes. However, Perl changed at release 5.18, so PCRE1
	// changed at release 8.34 and it's always been this way for PCRE2.

	for i = 0; i < 256; i++ {
		var x int32 = 0
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISspace) != 0 {
			x = x + Dctype_space
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISalpha) != 0 {
			x = x + Dctype_letter
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISlower) != 0 {
			x = x + Dctype_lcletter
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISdigit) != 0 {
			x = x + Dctype_digit
		}
		if int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(libc.X__ctype_b_loc(tls))) + uintptr(i)*2)))&int32(_ISalnum) != 0 || i == '_' {
			x = x + Dctype_word
		}
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(x)
	}

	return yield
}

func Xpcre2_maketables_free_8(tls *libc.TLS, gcontext uintptr, tables uintptr) { /* pcre2_maketables.c:154:1: */
	if gcontext != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Ffree})).f(tls, tables, (*Tpcre2_general_context_8)(unsafe.Pointer(gcontext)).Fmemctl.Fmemory_data)
	} else {
		libc.Xfree(tls, tables)
	}
}

// End of pcre2_maketables.c

// Min and max values for the common repeats; a maximum of UINT32_MAX =>
// infinity.

var rep_min = [11]uint32{
	uint32(0), uint32(0), // * and *?
	uint32(1), uint32(1), // + and +?
	uint32(0), uint32(0), // ? and ??
	uint32(0), uint32(0), // dummy placefillers for OP_CR[MIN]RANGE
	uint32(0), uint32(1), uint32(0)} /* pcre2_match.c:123:23 */ // OP_CRPOS{STAR, PLUS, QUERY}

var rep_max = [11]uint32{
	4294967295, 4294967295,
	4294967295, 4294967295,
	uint32(1), uint32(1), // ? and ??
	uint32(0), uint32(0), // dummy placefillers for OP_CR[MIN]RANGE
	4294967295, 4294967295, uint32(1)} /* pcre2_match.c:130:23 */ // OP_CRPOS{STAR, PLUS, QUERY}

// Repetition types - must include OP_CRPOSRANGE (not needed above)

var rep_typ = [12]uint32{
	REPTYPE_MAX, REPTYPE_MIN, // * and *?
	REPTYPE_MAX, REPTYPE_MIN, // + and +?
	REPTYPE_MAX, REPTYPE_MIN, // ? and ??
	REPTYPE_MAX, REPTYPE_MIN, // OP_CRRANGE and OP_CRMINRANGE
	REPTYPE_POS, REPTYPE_POS, // OP_CRPOSSTAR, OP_CRPOSPLUS
	REPTYPE_POS, REPTYPE_POS} /* pcre2_match.c:139:23 */

// Define short names for general fields in the current backtrack frame, which
// is always pointed to by the F variable. Occasional references to fields in
// other frames are written out explicitly. There are also some fields in the
// current frame whose names start with "temp" that are used for short-term,
// localised backtracking memory. These are #defined with Lxxx names at the point
// of use and undefined afterwards.

// ************************************************
//
//                Process a callout               *
//

// This function is called for all callouts, whether "standalone" or at the
// start of a conditional group. Feptr will be pointing to either OP_CALLOUT or
// OP_CALLOUT_STR. A callout block is allocated in pcre2_match() and initialized
// with fixed values.
//
// Arguments:
//   F          points to the current backtracking frame
//   mb         points to the match block
//   lengthptr  where to return the length of the callout item
//
// Returns:     the return from the callout
//              or 0 if no callout function exists

func do_callout(tls *libc.TLS, F uintptr, mb uintptr, lengthptr uintptr) int32 { /* pcre2_match.c:268:1: */
	var rc int32
	var save0 uint64
	var save1 uint64
	var callout_ovector uintptr
	var cb uintptr

	*(*uint64)(unsafe.Pointer(lengthptr)) = func() uint64 {
		if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CALLOUT {
			return uint64(X_pcre2_OP_lengths_8[OP_CALLOUT])
		}
		return uint64(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 6)))))
	}()

	if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout == uintptr(0) {
		return 0
	} // No callout function provided

	// The original matching code (pre 10.30) worked directly with the ovector
	// passed by the user, and this was passed to callouts. Now that the working
	// ovector is in the backtracking frame, it no longer needs to reserve space for
	// the overall match offsets (which would waste space in the frame). For backward
	// compatibility, however, we pass capture_top and offset_vector to the callout as
	// if for the extended ovector, and we ensure that the first two slots are unset
	// by preserving and restoring their current contents. Picky compilers complain if
	// references such as Fovector[-2] are use directly, so we set up a separate
	// pointer.

	callout_ovector = F + 128 - uintptr(2)*8

	// The cb->version, cb->subject, cb->subject_length, and cb->start_match fields
	// are set externally. The first 3 never change; the last is updated for each
	// bumpalong.

	cb = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcb
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcapture_top = uint32((*Theapframe)(unsafe.Pointer(F)).Foffset_top)/uint32(2) + uint32(1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcapture_last = (*Theapframe)(unsafe.Pointer(F)).Fcapture_last
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Foffset_vector = callout_ovector
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fmark = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnomatch_mark
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcurrent_position = uint64((int64((*Theapframe)(unsafe.Pointer(F)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fpattern_position = uint64(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fnext_item_length = uint64(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))))

	if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CALLOUT {
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_number = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_offset = uint64(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string = uintptr(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_length = uint64(0)
	} else {
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_number = uint32(0)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_offset = uint64(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 7)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 8)))))
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1+4*DLINK_SIZE) + uintptr(1)
		(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_string_length = *(*uint64)(unsafe.Pointer(lengthptr)) - uint64(1+4*DLINK_SIZE) - uint64(2)
	}

	save0 = *(*uint64)(unsafe.Pointer(callout_ovector))
	save1 = *(*uint64)(unsafe.Pointer(callout_ovector + 1*8))
	*(*uint64)(unsafe.Pointer(callout_ovector)) = libc.AssignPtrUint64(callout_ovector+1*8, libc.CplUint64(uint64(0)))
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout})).f(tls, cb, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout_data)
	*(*uint64)(unsafe.Pointer(callout_ovector)) = save0
	*(*uint64)(unsafe.Pointer(callout_ovector + 1*8)) = save1
	(*Tpcre2_callout_block_8)(unsafe.Pointer(cb)).Fcallout_flags = uint32(0)
	return rc
}

// ************************************************
//
//          Match a back-reference                *
//

// This function is called only when it is known that the offset lies within
// the offsets that have so far been used in the match. Note that in caseless
// UTF-8 mode, the number of subject bytes matched may be different to the number
// of reference bytes. (In theory this could also happen in UTF-16 mode, but it
// seems unlikely.)
//
// Arguments:
//   offset      index into the offset vector
//   caseless    TRUE if caseless
//   F           the current backtracking frame pointer
//   mb          points to match block
//   lengthptr   pointer for returning the length matched
//
// Returns:      = 0 sucessful match; number of code units matched is set
//               < 0 no match
//               > 0 partial match

func match_ref(tls *libc.TLS, offset uint64, caseless int32, F uintptr, mb uintptr, lengthptr uintptr) int32 { /* pcre2_match.c:356:1: */
	var p uintptr
	var length uint64
	var eptr uintptr
	var eptr_start uintptr

	// Deal with an unset group. The default is no match, but there is an option to
	// match an empty string.

	if offset >= (*Theapframe)(unsafe.Pointer(F)).Foffset_top || *(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) == libc.CplUint64(uint64(0)) {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_MATCH_UNSET_BACKREF != uint32(0) {
			*(*uint64)(unsafe.Pointer(lengthptr)) = uint64(0)
			return 0 // Match
		} else {
			return -1
		} // No match
	}

	// Separate the caseless and UTF cases for speed.

	eptr = libc.AssignUintptr(&eptr_start, (*Theapframe)(unsafe.Pointer(F)).Feptr)
	p = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject + uintptr(*(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset)*8)))
	length = *(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset+uint64(1))*8)) - *(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset)*8))

	if caseless != 0 {
		var utf int32 = libc.Bool32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UTF != uint32(0))

		if utf != 0 || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != uint32(0) {
			var endptr uintptr = p + uintptr(length)

			// Match characters up to the end of the reference. NOTE: the number of
			//     code units matched may differ, because in UTF-8 there are some characters
			//     whose upper and lower case codes have different numbers of bytes. For
			//     example, U+023A (2 bytes in UTF-8) is the upper case version of U+2C65 (3
			//     bytes in UTF-8); a sequence of 3 of the former uses 6 bytes, as does a
			//     sequence of two of the latter. It is important, therefore, to check the
			//     length along the reference, not along the subject (earlier code did this
			//     wrong). UCP without uses Unicode properties but without UTF encoding.

			for p < endptr {
				var c uint32
				var d uint32
				var ur uintptr
				if eptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject {
					return 1
				} // Partial match

				if utf != 0 {
					c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&eptr, 1))))
					if c >= 0xc0 {
						if c&0x20 == uint32(0) {
							c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&eptr, 1))))&0x3f
						} else if c&0x10 == uint32(0) {
							c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(eptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f
							eptr += uintptr(2)
						} else if c&0x08 == uint32(0) {
							c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(eptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 2)))&0x3f
							eptr += uintptr(3)
						} else if c&0x04 == uint32(0) {
							c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(eptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(eptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 3)))&0x3f
							eptr += uintptr(4)
						} else {
							c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(eptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(eptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(eptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(eptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(eptr + 4)))&0x3f
							eptr += uintptr(5)
						}
					}

					d = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))
					if d >= 0xc0 {
						if d&0x20 == uint32(0) {
							d = d&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))&0x3f
						} else if d&0x10 == uint32(0) {
							d = d&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(p)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(p + 1)))&0x3f
							p += uintptr(2)
						} else if d&0x08 == uint32(0) {
							d = d&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(p)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(p + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(p + 2)))&0x3f
							p += uintptr(3)
						} else if d&0x04 == uint32(0) {
							d = d&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(p)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(p + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(p + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(p + 3)))&0x3f
							p += uintptr(4)
						} else {
							d = d&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(p)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(p + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(p + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(p + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(p + 4)))&0x3f
							p += uintptr(5)
						}
					}

				} else {
					c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&eptr, 1))))
					d = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))
				}

				ur = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(d)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(d)%DUCD_BLOCK_SIZE])*12
				if c != d && c != uint32(int32(d)+(*Tucd_record)(unsafe.Pointer(ur)).Fother_case) {
					var pp uintptr = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr((*Tucd_record)(unsafe.Pointer(ur)).Fcaseset)*4
					for {
						if c < *(*uint32)(unsafe.Pointer(pp)) {
							return -1
						} // No match
						if c == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&pp, 4))) {
							break
						}
					}
				}
			}
		} else {
			for ; length > uint64(0); length-- {
				var cc uint32
				var cp uint32
				if eptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject {
					return 1
				} // Partial match
				cc = uint32(*(*uint8)(unsafe.Pointer(eptr)))
				cp = uint32(*(*uint8)(unsafe.Pointer(p)))
				if int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(cp)))) != int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(cc)))) {
					return -1
				} // No match
				p++
				eptr++
			}
		}
	} else {
		if int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 {
			for ; length > uint64(0); length-- {
				if eptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject {
					return 1
				} // Partial match
				if int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))) != int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&eptr, 1)))) {
					return -1
				} // No match
			}
		} else {
			if uint64((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64(eptr))/1) < length {
				return 1
			} // Partial
			if libc.Xmemcmp(tls, p, eptr, length*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) != 0 {
				return -1
			} // No match
			eptr += uintptr(length)
		}
	}

	*(*uint64)(unsafe.Pointer(lengthptr)) = uint64((int64(eptr) - int64(eptr_start)) / 1)
	return 0 // Match
}

//*****************************************************************************
//
//                    "Recursion" in the match() function
//
// The original match() function was highly recursive, but this proved to be the
// source of a number of problems over the years, mostly because of the relatively
// small system stacks that are commonly found. As new features were added to
// patterns, various kludges were invented to reduce the amount of stack used,
// making the code hard to understand in places.
//
// A version did exist that used individual frames on the heap instead of calling
// match() recursively, but this ran substantially slower. The current version is
// a refactoring that uses a vector of frames to remember backtracking points.
// This runs no slower, and possibly even a bit faster than the original recursive
// implementation.
//
// At first, an initial vector of size START_FRAMES_SIZE (enough for maybe 50
// frames) was allocated on the system stack. If this was not big enough, the heap
// was used for a larger vector. However, it turns out that there are environments
// where taking as little as 20KiB from the system stack is an embarrassment.
// After another refactoring, the heap is used exclusively, but a pointer the
// frames vector and its size are cached in the match_data block, so that there is
// no new memory allocation if the same match_data block is used for multiple
// matches (unless the frames vector has to be extended).
// *******************************************************************************
// *****************************************************************************

// ************************************************
//
//       Macros for the match() function          *
//

// These macros pack up tests that are used for partial matching several times
// in the code. The second one is used when we already know we are past the end of
// the subject. We set the "hit end" flag if the pointer is at the end of the
// subject and either (a) the pointer is past the earliest inspected character
// (i.e. something has been matched, even if not part of the actual matched
// string), or (b) the pattern contains a lookbehind. These are the conditions for
// which adding more characters may allow the current match to continue.
//
// For hard partial matching, we immediately return a partial match. Otherwise,
// carrying on means that a complete match on the current subject will be sought.
// A partial match is returned only if no complete match can be found.

// These macros are used to implement backtracking. They simulate a recursive
// call to the match() function by means of a local vector of frames which
// remember the backtracking points.

// ************************************************
//
//         Match from current position            *
//

// This function is called to run one match attempt at a single starting point
// in the subject.
//
// Performance note: It might be tempting to extract commonly used fields from the
// mb structure (e.g. end_subject) into individual variables to improve
// performance. Tests using gcc on a SPARC disproved this; in the first case, it
// made performance worse.
//
// Arguments:
//    start_eptr   starting character in subject
//    start_ecode  starting position in compiled code
//    top_bracket  number of capturing parentheses in the pattern
//    frame_size   size of each backtracking frame
//    match_data   pointer to the match_data block
//    mb           pointer to "static" variables block
//
// Returns:        MATCH_MATCH if matched            )  these values are >= 0
//                 MATCH_NOMATCH if failed to match  )
//                 negative MATCH_xxx value for PRUNE, SKIP, etc
//                 negative PCRE2_ERROR_xxx value if aborted by an error condition
//                 (e.g. stopped by repeated call or depth limit)

func match(tls *libc.TLS, start_eptr uintptr, start_ecode uintptr, top_bracket uint16, frame_size uint64, match_data uintptr, mb uintptr) int32 { /* pcre2_match.c:589:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// Frame-handling variables

	var F uintptr // Current frame pointer
	var N uintptr // Temporary frame pointers
	var P uintptr
	var frames_top uintptr          // End of frames vector
	var assert_accept_frame uintptr // For passing back a frame with captures
	var heapframes_size uint64      // Usable size of frames vector
	var frame_copy_size uint64      // Amount to copy when creating a new frame

	// Local variables that do not need to be preserved over calls to RRMATCH().

	var bracode uintptr // Temp pointer to start of group
	var offset uint64   // Used for group offsets
	// var length uint64 at bp, 8
	// Used for various length calculations

	var rrc int32      // Return from functions & backtracking "recursions"
	var proptype int32 // Type of character property

	var i uint32                // Used for local loops
	var fc uint32               // Character values
	var number uint32           // Used for group and other numbers
	var reptype uint32          // Type of repetition (0 to avoid compiler warning)
	var group_frame_type uint32 // Specifies type for new group frames

	var condition int32    // Used in conditional groups
	var cur_is_word int32  // Used in "word" tests
	var prev_is_word int32 // Used in "word" tests

	// UTF and UCP flags

	var utf int32
	var ucp int32
	var maxsize uint64
	var new uintptr
	var newsize uint64
	var cc uint32
	var dc uint32
	var cc1 uint32
	var ch uint32
	var ch1 uint32
	var ch2 uint32
	var othercase uint32
	var cc2 uint32
	var cc3 uint32
	var cc4 uint32
	var d uint32
	var d1 uint32
	var len int32
	var d2 uint32
	var d3 uint32
	var d4 uint32
	var len1 int32
	var d5 uint32
	var len2 int32
	var len3 int32
	var ok int32
	var ok1 int32
	var cp uintptr
	var prop uintptr
	var notmatch int32
	var chartype int32
	var ok2 int32
	var prop1 uintptr
	var category int32
	var category1 int32
	var cp1 uintptr
	var ok3 int32
	var prop2 uintptr
	var notmatch1 int32
	var cc5 uint32
	var cc6 uint32
	var cc7 uint32
	var cc8 uint32
	var cc9 uint32
	var chartype1 int32
	var ok4 int32
	var prop3 uintptr
	var category2 int32
	var category3 int32
	var cp2 uintptr
	var ok5 int32
	var prop4 uintptr
	var len4 int32
	var chartype2 int32
	var len5 int32
	var len6 int32
	var len7 int32
	var len8 int32
	var ok6 int32
	var prop5 uintptr
	var len9 int32
	var category4 int32
	var len10 int32
	var len11 int32
	var category5 int32
	var len12 int32
	var cp3 uintptr
	var len13 int32
	var len14 int32
	var len15 int32
	var ok7 int32
	var prop6 uintptr
	var len16 int32
	var notmatch2 int32
	var lgb int32
	var rgb int32
	var fptr uintptr
	var len17 int32
	var gotspace int32
	var len18 int32
	var gotspace1 int32
	var len19 int32
	var len20 int32
	var len21 int32
	var len22 int32
	var len23 int32
	var len24 int32
	var len25 int32
	var count int32
	var slot uintptr
	// var slength uint64 at bp+8, 8

	// var slength1 uint64 at bp+16, 8

	// var slength2 uint64 at bp+24, 8

	// var slength3 uint64 at bp+32, 8

	var samelengths int32
	var next_ecode uintptr
	var next_ecode1 uintptr
	var next_ecode2 uintptr
	var count1 int32
	var slot1 uintptr
	var count2 int32
	var slot2 uintptr
	var y uint32
	var cat int32
	var lastptr uintptr
	var cat1 int32
	var nextptr uintptr
	N = uintptr(0)
	P = uintptr(0)
	assert_accept_frame = uintptr(0)
	reptype = uint32(0)
	utf = libc.Bool32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UTF != uint32(0))
	ucp = libc.Bool32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != uint32(0))

	// This is the length of the last part of a backtracking frame that must be
	// copied when a new frame is created.

	frame_copy_size = frame_size - uint64(uintptr(0)+80)

	// Set up the first frame and the end of the frames vector. We set the local
	// heapframes_size to the usuable amount of the vector, that is, a whole number of
	// frames.

	F = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes
	heapframes_size = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes_size / frame_size * frame_size
	frames_top = F + uintptr(heapframes_size)

	(*Theapframe)(unsafe.Pointer(F)).Frdepth = uint32(0)                                    // "Recursion" depth
	(*Theapframe)(unsafe.Pointer(F)).Fcapture_last = uint32(0)                              // Number of most recent capture
	(*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse = DRECURSE_UNSET                      // Not pattern recursing.
	(*Theapframe)(unsafe.Pointer(F)).Fstart_match = libc.AssignPtrUintptr(F+80, start_eptr) // Current data pointer and start match
	(*Theapframe)(unsafe.Pointer(F)).Fmark = uintptr(0)                                     // Most recent mark
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = uint64(0)                                // End of captures within the frame
	(*Theapframe)(unsafe.Pointer(F)).Flast_group_offset = libc.CplUint64(uint64(0))         // Saved frame of most recent group
	group_frame_type = uint32(0)                                                            // Not a start of group frame
	goto NEW_FRAME                                                                          // Start processing with this frame

	// Come back here when we want to create a new frame for remembering a
	// backtracking point.

MATCH_RECURSE:

	// Set up a new backtracking frame. If the vector is full, get a new one,
	// doubling the size, but constrained by the heap limit (which is in KiB).

	N = F + uintptr(frame_size)
	if !(N >= frames_top) {
		goto __1
	}

	newsize = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes_size * uint64(2)

	if !(newsize > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit) {
		goto __2
	}

	maxsize = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit / frame_size * frame_size
	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes_size >= maxsize) {
		goto __3
	}
	return -63
__3:
	;
	newsize = maxsize
__2:
	;

	new = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmalloc})).f(tls, newsize, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	if !(new == uintptr(0)) {
		goto __4
	}
	return -48
__4:
	;
	libc.Xmemcpy(tls, new, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes, heapframes_size)

	F = new + uintptr((int64(F)-int64((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes))/1)
	N = F + uintptr(frame_size)

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes = new
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes_size = newsize

	heapframes_size = newsize / frame_size * frame_size
	frames_top = new + uintptr(heapframes_size)
__1:
	;

	// Copy those fields that must be copied into the new frame, increase the
	// "recursion" depth (i.e. the new frame's index) and then make the new frame
	// current.

	libc.Xmemcpy(tls, N+uintptr(uint64(uintptr(0)+80)),
		F+uintptr(uint64(uintptr(0)+80)),
		frame_copy_size)

	(*Theapframe)(unsafe.Pointer(N)).Frdepth = (*Theapframe)(unsafe.Pointer(F)).Frdepth + uint32(1)
	F = N

	// Carry on processing with a new frame.

NEW_FRAME:
	(*Theapframe)(unsafe.Pointer(F)).Fgroup_frame_type = group_frame_type
	(*Theapframe)(unsafe.Pointer(F)).Fecode = start_ecode     // Starting code pointer
	(*Theapframe)(unsafe.Pointer(F)).Fback_frame = frame_size // Default is go back one frame

	// If this is a special type of group frame, remember its offset for quick
	// access at the end of the group. If this is a recursion, set a new current
	// recursion value.

	if !(group_frame_type != uint32(0)) {
		goto __5
	}

	(*Theapframe)(unsafe.Pointer(F)).Flast_group_offset = uint64((int64(F) - int64((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes)) / 1)
	if !(group_frame_type&0xffff0000 == DGF_RECURSE) {
		goto __6
	}
	(*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse = group_frame_type & 0x0000ffff
__6:
	;
	group_frame_type = uint32(0)
__5:
	;

	// =========================================================================
	// This is the main processing loop. First check that we haven't recorded too
	// many backtracks (search tree is too large), or that we haven't exceeded the
	// recursive depth limit (used too many backtracking frames). If not, process the
	// opcodes.

	if !(libc.PostIncUint32(&(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_call_count, 1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_limit) {
		goto __7
	}
	return -47
__7:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Frdepth >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth) {
		goto __8
	}
	return -53
__8:
	;

__9:

	(*Theapframe)(unsafe.Pointer(F)).Fop = *(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)) // Cast needed for 16-bit and 32-bit modes
	switch int32((*Theapframe)(unsafe.Pointer(F)).Fop) {
	// =====================================================================
	// Before OP_ACCEPT there may be any number of OP_CLOSE opcodes, to close
	//     any currently open capturing brackets. Unlike reaching the end of a group,
	//     where we know the starting frame is at the top of the chained frames, in
	//     this case we have to search back for the relevant frame in case other types
	//     of group that use chained frames have intervened. Multiple OP_CLOSEs always
	//     come innermost first, which matches the chain order. We can ignore this in
	//     a recursion, because captures are not passed out of recursions.

	case OP_CLOSE:
		goto __13

	// =====================================================================
	// Real or forced end of the pattern, assertion, or recursion. In an
	//     assertion ACCEPT, update the last used pointer and remember the current
	//     frame so that the captures and mark can be fished out of it.

	case OP_ASSERT_ACCEPT:
		goto __14

	// If recursing, we have to find the most recent recursion.

	case OP_ACCEPT:
		goto __15
	case OP_END:
		goto __16 // Note: NOT RRETURN

	//=====================================================================
	// Match any single character type except newline; have to take care with
	//     CRLF newlines and partial matching.

	case OP_ANY:
		goto __17
	// Fall through

	// Match any single character whatsoever.

	case OP_ALLANY:
		goto __18

	// =====================================================================
	// Match a single code unit, even in UTF mode. This opcode really does
	//     match any code unit, even newline. (It really should be called ANYCODEUNIT,
	//     of course - the byte name is from pre-16 bit days.)

	case OP_ANYBYTE:
		goto __19

	// =====================================================================
	// Match a single character, casefully

	case OP_CHAR:
		goto __20

	// =====================================================================
	// Match a single character, caselessly. If we are at the end of the
	//     subject, give up immediately. We get here only when the pattern character
	//     has at most one other case. Characters with more than two cases are coded
	//     as OP_PROP with the pseudo-property PT_CLIST.

	case OP_CHARI:
		goto __21

	// =====================================================================
	// Match not a single character.

	case OP_NOT:
		goto __22
	case OP_NOTI:
		goto __23

	// =====================================================================
	// Match a single character repeatedly.

	case OP_EXACT:
		goto __24
	case OP_EXACTI:
		goto __25

	case OP_POSUPTO:
		goto __26
	case OP_POSUPTOI:
		goto __27

	case OP_UPTO:
		goto __28
	case OP_UPTOI:
		goto __29

	case OP_MINUPTO:
		goto __30
	case OP_MINUPTOI:
		goto __31

	case OP_POSSTAR:
		goto __32
	case OP_POSSTARI:
		goto __33

	case OP_POSPLUS:
		goto __34
	case OP_POSPLUSI:
		goto __35

	case OP_POSQUERY:
		goto __36
	case OP_POSQUERYI:
		goto __37

	case OP_STAR:
		goto __38
	case OP_STARI:
		goto __39
	case OP_MINSTAR:
		goto __40
	case OP_MINSTARI:
		goto __41
	case OP_PLUS:
		goto __42
	case OP_PLUSI:
		goto __43
	case OP_MINPLUS:
		goto __44
	case OP_MINPLUSI:
		goto __45
	case OP_QUERY:
		goto __46
	case OP_QUERYI:
		goto __47
	case OP_MINQUERY:
		goto __48
	case OP_MINQUERYI:
		goto __49

	// =====================================================================
	// Match a negated single one-byte character repeatedly. This is almost a
	//     repeat of the code for a repeated single character, but I haven't found a
	//     nice way of commoning these up that doesn't require a test of the
	//     positive/negative option for each character match. Maybe that wouldn't add
	//     very much to the time taken, but character matching *is* what this is all
	//     about...

	case OP_NOTEXACT:
		goto __50
	case OP_NOTEXACTI:
		goto __51

	case OP_NOTUPTO:
		goto __52
	case OP_NOTUPTOI:
		goto __53

	case OP_NOTMINUPTO:
		goto __54
	case OP_NOTMINUPTOI:
		goto __55

	case OP_NOTPOSSTAR:
		goto __56
	case OP_NOTPOSSTARI:
		goto __57

	case OP_NOTPOSPLUS:
		goto __58
	case OP_NOTPOSPLUSI:
		goto __59

	case OP_NOTPOSQUERY:
		goto __60
	case OP_NOTPOSQUERYI:
		goto __61

	case OP_NOTPOSUPTO:
		goto __62
	case OP_NOTPOSUPTOI:
		goto __63

	case OP_NOTSTAR:
		goto __64
	case OP_NOTSTARI:
		goto __65
	case OP_NOTMINSTAR:
		goto __66
	case OP_NOTMINSTARI:
		goto __67
	case OP_NOTPLUS:
		goto __68
	case OP_NOTPLUSI:
		goto __69
	case OP_NOTMINPLUS:
		goto __70
	case OP_NOTMINPLUSI:
		goto __71
	case OP_NOTQUERY:
		goto __72
	case OP_NOTQUERYI:
		goto __73
	case OP_NOTMINQUERY:
		goto __74
	case OP_NOTMINQUERYI:
		goto __75

	// =====================================================================
	// Match a bit-mapped character class, possibly repeatedly. These opcodes
	//     are used when all the characters in the class have values in the range
	//     0-255, and either the matching is caseful, or the characters are in the
	//     range 0-127 when UTF processing is enabled. The only difference between
	//     OP_CLASS and OP_NCLASS occurs when a data character outside the range is
	//     encountered.

	case OP_NCLASS:
		goto __76
	case OP_CLASS:
		goto __77
	// Control never gets here

	// =====================================================================
	// Match an extended character class. In the 8-bit library, this opcode is
	//     encountered only when UTF-8 mode mode is supported. In the 16-bit and
	//     32-bit libraries, codepoints greater than 255 may be encountered even when
	//     UTF is not supported.

	case OP_XCLASS:
		goto __78

	// =====================================================================
	// Match various character types when PCRE2_UCP is not set. These opcodes
	//     are not generated when PCRE2_UCP is set - instead appropriate property
	//     tests are compiled.

	case OP_NOT_DIGIT:
		goto __79

	case OP_DIGIT:
		goto __80

	case OP_NOT_WHITESPACE:
		goto __81

	case OP_WHITESPACE:
		goto __82

	case OP_NOT_WORDCHAR:
		goto __83

	case OP_WORDCHAR:
		goto __84

	case OP_ANYNL:
		goto __85

	case OP_NOT_HSPACE:
		goto __86

	case OP_HSPACE:
		goto __87

	case OP_NOT_VSPACE:
		goto __88

	case OP_VSPACE:
		goto __89

	// =====================================================================
	// Check the next character by Unicode property. We will get here only
	//     if the support is in the binary; otherwise a compile-time error occurs.

	case OP_PROP:
		goto __90
	case OP_NOTPROP:
		goto __91

	// =====================================================================
	// Match an extended Unicode sequence. We will get here only if the support
	//     is in the binary; otherwise a compile-time error occurs.

	case OP_EXTUNI:
		goto __92

	// =====================================================================
	// Match a single character type repeatedly. Note that the property type
	//     does not need to be in a stack frame as it is not used within an RMATCH()
	//     loop.

	case OP_TYPEEXACT:
		goto __93

	case OP_TYPEUPTO:
		goto __94
	case OP_TYPEMINUPTO:
		goto __95

	case OP_TYPEPOSSTAR:
		goto __96

	case OP_TYPEPOSPLUS:
		goto __97

	case OP_TYPEPOSQUERY:
		goto __98

	case OP_TYPEPOSUPTO:
		goto __99

	case OP_TYPESTAR:
		goto __100
	case OP_TYPEMINSTAR:
		goto __101
	case OP_TYPEPLUS:
		goto __102
	case OP_TYPEMINPLUS:
		goto __103
	case OP_TYPEQUERY:
		goto __104
	case OP_TYPEMINQUERY:
		goto __105 // End of repeat character type processing

	// =====================================================================
	// Match a back reference, possibly repeatedly. Look past the end of the
	//     item to see if there is repeat information following. The OP_REF and
	//     OP_REFI opcodes are used for a reference to a numbered group or to a
	//     non-duplicated named group. For a duplicated named group, OP_DNREF and
	//     OP_DNREFI are used. In this case we must scan the list of groups to which
	//     the name refers, and use the first one that is set.

	case OP_DNREF:
		goto __106
	case OP_DNREFI:
		goto __107

	case OP_REF:
		goto __108
	case OP_REFI:
		goto __109
	// Control never gets here

	// =========================================================================
	//           Opcodes for the start of various parenthesized items
	// =========================================================================

	// In all cases, if the result of RMATCH() is MATCH_THEN, check whether the
	//     (*THEN) is within the current branch by comparing the address of OP_THEN
	//     that is passed back with the end of the branch. If (*THEN) is within the
	//     current branch, and the branch is one of two or more alternatives (it
	//     either starts or ends with OP_ALT), we have reached the limit of THEN's
	//     action, so convert the return code to NOMATCH, which will cause normal
	//     backtracking to happen from now on. Otherwise, THEN is passed back to an
	//     outer alternative. This implements Perl's treatment of parenthesized
	//     groups, where a group not containing | does not affect the current
	//     alternative, that is, (X) is NOT the same as (X|(*F)).

	// =====================================================================
	// BRAZERO, BRAMINZERO and SKIPZERO occur just before a non-possessive
	//     bracket group, indicating that it may occur zero times. It may repeat
	//     infinitely, or not at all - i.e. it could be ()* or ()? or even (){0} in
	//     the pattern. Brackets with fixed upper repeat limits are compiled as a
	//     number of copies, with the optional ones preceded by BRAZERO or BRAMINZERO.
	//     Possessive groups with possible zero repeats are preceded by BRAPOSZERO.

	case OP_BRAZERO:
		goto __110

	case OP_BRAMINZERO:
		goto __111

	case OP_SKIPZERO:
		goto __112

	// =====================================================================
	// Handle possessive brackets with an unlimited repeat. The end of these
	//     brackets will always be OP_KETRPOS, which returns MATCH_KETRPOS without
	//     going further in the pattern.

	case OP_BRAPOSZERO:
		goto __113

	case OP_BRAPOS:
		goto __114
	case OP_SBRAPOS:
		goto __115

	case OP_CBRAPOS:
		goto __116
	case OP_SCBRAPOS:
		goto __117

	// =====================================================================
	// Handle non-capturing brackets that cannot match an empty string. When we
	//     get to the final alternative within the brackets, as long as there are no
	//     THEN's in the pattern, we can optimize by not recording a new backtracking
	//     point. (Ideally we should test for a THEN within this group, but we don't
	//     have that information.) Don't do this if we are at the very top level,
	//     however, because that would make handling assertions and once-only brackets
	//     messier when there is nothing to go back to.

	case OP_BRA:
		goto __118

	// =====================================================================
	// Handle a capturing bracket, other than those that are possessive with an
	//     unlimited repeat.

	case OP_CBRA:
		goto __119
	case OP_SCBRA:
		goto __120

	// =====================================================================
	// Atomic groups and non-capturing brackets that can match an empty string
	//     must record a backtracking point and also set up a chained frame.

	case OP_ONCE:
		goto __121
	case OP_SCRIPT_RUN:
		goto __122
	case OP_SBRA:
		goto __123
	// Control never reaches here.

	// =====================================================================
	// Recursion either matches the current regex, or some subexpression. The
	//     offset data is the offset to the starting bracket from the start of the
	//     whole pattern. (This is so that it works from duplicated subpatterns.)

	case OP_RECURSE:
		goto __124
	// Control never reaches here.

	// =====================================================================
	// Positive assertions are like other groups except that PCRE doesn't allow
	//     the effect of (*THEN) to escape beyond an assertion; it is therefore
	//     treated as NOMATCH. (*ACCEPT) is treated as successful assertion, with its
	//     captures and mark retained. Any other return is an error.

	case OP_ASSERT:
		goto __125
	case OP_ASSERTBACK:
		goto __126
	case OP_ASSERT_NA:
		goto __127
	case OP_ASSERTBACK_NA:
		goto __128

	// =====================================================================
	// Handle negative assertions. Loop for each non-matching branch as for
	//     positive assertions.

	case OP_ASSERT_NOT:
		goto __129
	case OP_ASSERTBACK_NOT:
		goto __130

	// =====================================================================
	// The callout item calls an external function, if one is provided, passing
	//     details of the match so far. This is mainly for debugging, though the
	//     function is able to force a failure.

	case OP_CALLOUT:
		goto __131
	case OP_CALLOUT_STR:
		goto __132

	// =====================================================================
	// Conditional group: compilation checked that there are no more than two
	//     branches. If the condition is false, skipping the first branch takes us
	//     past the end of the item if there is only one branch, but that's exactly
	//     what we want.

	case OP_COND:
		goto __133
	case OP_SCOND:
		goto __134

		// =========================================================================
		//                  End of start of parenthesis opcodes
		// =========================================================================

	// =====================================================================
	// Move the subject pointer back. This occurs only at the start of each
	//     branch of a lookbehind assertion. If we are too close to the start to move
	//     back, fail. When working with UTF-8 we move back a number of characters,
	//     not bytes.

	case OP_REVERSE:
		goto __135

	// =====================================================================
	// An alternation is the end of a branch; scan along to find the end of the
	//     bracketed group.

	case OP_ALT:
		goto __136

	// =====================================================================
	// The end of a parenthesized group. For all but OP_BRA and OP_COND, the
	//     starting frame was added to the chained frames in order to remember the
	//     starting subject position for the group.

	case OP_KET:
		goto __137
	case OP_KETRMIN:
		goto __138
	case OP_KETRMAX:
		goto __139
	case OP_KETRPOS:
		goto __140

	// =====================================================================
	// Start and end of line assertions, not multiline mode.

	case OP_CIRC:
		goto __141

	case OP_SOD:
		goto __142

	// When PCRE2_NOTEOL is unset, assert before the subject end, or a
	//     terminating newline unless PCRE2_DOLLAR_ENDONLY is set.

	case OP_DOLL:
		goto __143

	// Fall through
	// Unconditional end of subject assertion (\z)

	case OP_EOD:
		goto __144

	// End of subject or ending \n assertion (\Z)

	case OP_EODN:
		goto __145

	// =====================================================================
	// Start and end of line assertions, multiline mode.

	// Start of subject unless notbol, or after any newline except for one at
	//     the very end, unless PCRE2_ALT_CIRCUMFLEX is set.

	case OP_CIRCM:
		goto __146

	// Assert before any newline, or before end of subject unless noteol is
	//     set.

	case OP_DOLLM:
		goto __147

	// =====================================================================
	// Start of match assertion

	case OP_SOM:
		goto __148

	// =====================================================================
	// Reset the start of match point

	case OP_SET_SOM:
		goto __149

	// =====================================================================
	// Word boundary assertions. Find out if the previous and current
	//     characters are "word" characters. It takes a bit more work in UTF mode.
	//     Characters > 255 are assumed to be "non-word" characters when PCRE2_UCP is
	//     not set. When it is set, use Unicode properties if available, even when not
	//     in UTF mode. Remember the earliest and latest consulted characters.

	case OP_NOT_WORD_BOUNDARY:
		goto __150
	case OP_WORD_BOUNDARY:
		goto __151

	// =====================================================================
	// Backtracking (*VERB)s, with and without arguments. Note that if the
	//     pattern is successfully matched, we do not come back from RMATCH.

	case OP_MARK:
		goto __152

	case OP_FAIL:
		goto __153

	// Record the current recursing group number in mb->verb_current_recurse
	//     when a backtracking return such as MATCH_COMMIT is given. This enables the
	//     recurse processing to catch verbs from within the recursion.

	case OP_COMMIT:
		goto __154

	case OP_COMMIT_ARG:
		goto __155

	case OP_PRUNE:
		goto __156

	case OP_PRUNE_ARG:
		goto __157

	case OP_SKIP:
		goto __158

	// Note that, for Perl compatibility, SKIP with an argument does NOT set
	//     nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was
	//     not a matching mark, we have to re-run the match, ignoring the SKIP_ARG
	//     that failed and any that precede it (either they also failed, or were not
	//     triggered). To do this, we maintain a count of executed SKIP_ARGs. If a
	//     SKIP_ARG gets to top level, the match is re-run with mb->ignore_skip_arg
	//     set to the count of the one that failed.

	case OP_SKIP_ARG:
		goto __159

	// For THEN (and THEN_ARG) we pass back the address of the opcode, so that
	//     the branch in which it occurs can be determined.

	case OP_THEN:
		goto __160

	case OP_THEN_ARG:
		goto __161

	// =====================================================================
	// There's been some horrible disaster. Arrival here can only mean there is
	//     something seriously wrong in the code above or the OP_xxx definitions.

	default:
		goto __162
	}
	goto __12

	// =====================================================================
	// Before OP_ACCEPT there may be any number of OP_CLOSE opcodes, to close
	//     any currently open capturing brackets. Unlike reaching the end of a group,
	//     where we know the starting frame is at the top of the chained frames, in
	//     this case we have to search back for the relevant frame in case other types
	//     of group that use chained frames have intervened. Multiple OP_CLOSEs always
	//     come innermost first, which matches the chain order. We can ignore this in
	//     a recursion, because captures are not passed out of recursions.

__13:
	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse == DRECURSE_UNSET) {
		goto __163
	}

	number = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	offset = (*Theapframe)(unsafe.Pointer(F)).Flast_group_offset
__164:

	if !(offset == libc.CplUint64(uint64(0))) {
		goto __167
	}
	return -44
__167:
	;
	N = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes + uintptr(offset)
	P = N - uintptr(frame_size)
	if !((*Theapframe)(unsafe.Pointer(N)).Fgroup_frame_type == DGF_CAPTURE|number) {
		goto __168
	}
	goto __166
__168:
	;
	offset = (*Theapframe)(unsafe.Pointer(P)).Flast_group_offset
	goto __165
__165:
	goto __164
	goto __166
__166:
	;
	offset = uint64(number<<1 - uint32(2))
	(*Theapframe)(unsafe.Pointer(F)).Fcapture_last = number
	*(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) = uint64((int64((*Theapframe)(unsafe.Pointer(P)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	*(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset+uint64(1))*8)) = uint64((int64((*Theapframe)(unsafe.Pointer(F)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	if !(offset >= (*Theapframe)(unsafe.Pointer(F)).Foffset_top) {
		goto __169
	}
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = offset + uint64(2)
__169:
	;
__163:
	;
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	goto __12

	// =====================================================================
	// Real or forced end of the pattern, assertion, or recursion. In an
	//     assertion ACCEPT, update the last used pointer and remember the current
	//     frame so that the captures and mark can be fished out of it.

__14:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __170
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__170:
	;
	assert_accept_frame = F
	rrc = -999
	goto RETURN_SWITCH

	// If recursing, we have to find the most recent recursion.

__15:
__16:

	// Handle end of a recursion.

	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse != DRECURSE_UNSET) {
		goto __171
	}

	offset = (*Theapframe)(unsafe.Pointer(F)).Flast_group_offset
__172:

	if !(offset == libc.CplUint64(uint64(0))) {
		goto __175
	}
	return -44
__175:
	;
	N = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes + uintptr(offset)
	P = N - uintptr(frame_size)
	if !((*Theapframe)(unsafe.Pointer(N)).Fgroup_frame_type&0xffff0000 == DGF_RECURSE) {
		goto __176
	}
	goto __174
__176:
	;
	offset = (*Theapframe)(unsafe.Pointer(P)).Flast_group_offset
	goto __173
__173:
	goto __172
	goto __174
__174:
	;

	// N is now the frame of the recursion; the previous frame is at the
	//       OP_RECURSE position. Go back there, copying the current subject position
	//       and mark, and the start_match position (\K might have changed it), and
	//       then move on past the OP_RECURSE.

	(*Theapframe)(unsafe.Pointer(P)).Feptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
	(*Theapframe)(unsafe.Pointer(P)).Fmark = (*Theapframe)(unsafe.Pointer(F)).Fmark
	(*Theapframe)(unsafe.Pointer(P)).Fstart_match = (*Theapframe)(unsafe.Pointer(F)).Fstart_match
	F = P
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DLINK_SIZE)
	goto __10
__171:
	;

	// Not a recursion. Fail for an empty string match if either PCRE2_NOTEMPTY
	//     is set, or if PCRE2_NOTEMPTY_ATSTART is set and we have matched at the
	//     start of the subject. In both cases, backtracking will then try other
	//     alternatives, if any.

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == (*Theapframe)(unsafe.Pointer(F)).Fstart_match && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEMPTY != uint32(0) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEMPTY_ATSTART != uint32(0) && (*Theapframe)(unsafe.Pointer(F)).Fstart_match == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_offset))) {
		goto __177
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__177:
	;

	// Also fail if PCRE2_ENDANCHORED is set and the end of the match is not
	//     the end of the subject. After (*ACCEPT) we fail the entire match (at this
	//     position) but backtrack on reaching the end of the pattern.

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions|(*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions)&DPCRE2_ENDANCHORED != uint32(0)) {
		goto __178
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_END) {
		goto __179
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__179:
	;

	return DMATCH_NOMATCH
__178:
	;

	// We have a successful match of the whole pattern. Record the result and
	//     then do a direct return from the function. If there is space in the offset
	//     vector, set any pairs that follow the highest-numbered captured string but
	//     are less than the number of capturing groups in the pattern to PCRE2_UNSET.
	//     It is documented that this happens. "Gaps" are set to PCRE2_UNSET
	//     dynamically. It is only those at the end that need setting here.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_match_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr        // Record where we ended
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_offset_top = (*Theapframe)(unsafe.Pointer(F)).Foffset_top // and how many extracts were taken
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmark = (*Theapframe)(unsafe.Pointer(F)).Fmark                 // and the last success mark
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __180
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__180:
	;

	*(*uint64)(unsafe.Pointer(match_data + 96)) = uint64((int64((*Theapframe)(unsafe.Pointer(F)).Fstart_match) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	*(*uint64)(unsafe.Pointer(match_data + 96 + 1*8)) = uint64((int64((*Theapframe)(unsafe.Pointer(F)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)

	// Set i to the smaller of the sizes of the external and frame ovectors.

	i = uint32(2 * func() int32 {
		if int32(top_bracket)+1 > int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			return int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)
		}
		return int32(top_bracket) + 1
	}())
	libc.Xmemcpy(tls, match_data+96+uintptr(2)*8, F+128, uint64(i-uint32(2))*uint64(unsafe.Sizeof(uint64(0))))
__181:
	if !(uint64(libc.PreDecUint32(&i, 1)) >= (*Theapframe)(unsafe.Pointer(F)).Foffset_top+uint64(2)) {
		goto __182
	}
	*(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(i)*8)) = libc.CplUint64(uint64(0))
	goto __181
__182:
	;
	return DMATCH_MATCH // Note: NOT RRETURN

	//=====================================================================
	// Match any single character type except newline; have to take care with
	//     CRLF newlines and partial matching.

__17:
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __183
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__183:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr(1) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __184
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __185
	}
	return -2
__185:
	;
__184:
	;
	// Fall through

	// Match any single character whatsoever.

__18:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __186
	} /* DO NOT merge the Feptr++ here; it must */
	// not be updated before SCHECK_PARTIAL.
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __187
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __188
	}
	return -2
__188:
	;
__187:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__186:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	if !(utf != 0) {
		goto __189
	}
__190:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __191
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __190
__191:
	;
__189:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// =====================================================================
	// Match a single code unit, even in UTF mode. This opcode really does
	//     match any code unit, even newline. (It really should be called ANYCODEUNIT,
	//     of course - the byte name is from pre-16 bit days.)

__19:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __192
	} /* DO NOT merge the Feptr++ here; it must */
	// not be updated before SCHECK_PARTIAL.
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __193
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __194
	}
	return -2
__194:
	;
__193:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__192:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// =====================================================================
	// Match a single character, casefully

__20:
	if !(utf != 0) {
		goto __195
	}

	(*Theapframe)(unsafe.Pointer(F)).Flength = uint64(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))
	if !(fc >= 0xc0) {
		goto __197
	}
	if !(fc&0x20 == uint32(0)) {
		goto __198
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	(*Theapframe)(unsafe.Pointer(F)).Flength++
	goto __199
__198:
	if !(fc&0x10 == uint32(0)) {
		goto __200
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(2)
	goto __201
__200:
	if !(fc&0x08 == uint32(0)) {
		goto __202
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(3)
	goto __203
__202:
	if !(fc&0x04 == uint32(0)) {
		goto __204
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(4)
	goto __205
__204:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(5)
__205:
	;
__203:
	;
__201:
	;
__199:
	;
__197:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Flength > uint64((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64((*Theapframe)(unsafe.Pointer(F)).Feptr))/1)) {
		goto __206
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __207
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __208
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __209
	}
	return -2
__209:
	;
__208:
	;
__207:
	;
	/* Not SCHECK_PARTIAL() */
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__206:
	;
__210:
	if !((*Theapframe)(unsafe.Pointer(F)).Flength > uint64(0)) {
		goto __212
	}

	if !(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) != int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __213
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__213:
	;

	goto __211
__211:
	(*Theapframe)(unsafe.Pointer(F)).Flength--
	goto __210
	goto __212
__212:
	;
	goto __196
__195:

	/* Not UTF mode */

	if !((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64((*Theapframe)(unsafe.Pointer(F)).Feptr))/1 < int64(1)) {
		goto __214
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __215
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __216
	}
	return -2
__216:
	;
__215:
	;
	/* This one can use SCHECK_PARTIAL() */
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__214:
	;
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1))) != int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __217
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__217:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(2)
__196:
	;
	goto __12

	// =====================================================================
	// Match a single character, caselessly. If we are at the end of the
	//     subject, give up immediately. We get here only when the pattern character
	//     has at most one other case. Characters with more than two cases are coded
	//     as OP_PROP with the pseudo-property PT_CLIST.

__21:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __218
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __219
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __220
	}
	return -2
__220:
	;
__219:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__218:
	;

	if !(utf != 0) {
		goto __221
	}

	(*Theapframe)(unsafe.Pointer(F)).Flength = uint64(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))
	if !(fc >= 0xc0) {
		goto __223
	}
	if !(fc&0x20 == uint32(0)) {
		goto __224
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	(*Theapframe)(unsafe.Pointer(F)).Flength++
	goto __225
__224:
	if !(fc&0x10 == uint32(0)) {
		goto __226
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(2)
	goto __227
__226:
	if !(fc&0x08 == uint32(0)) {
		goto __228
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(3)
	goto __229
__228:
	if !(fc&0x04 == uint32(0)) {
		goto __230
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(4)
	goto __231
__230:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(5)
__231:
	;
__229:
	;
__227:
	;
__225:
	;
__223:
	;

	// If the pattern character's value is < 128, we know that its other case
	//       (if any) is also < 128 (and therefore only one code unit long in all
	//       code-unit widths), so we can use the fast lookup table. We checked above
	//       that there is at least one character left in the subject.

	if !(fc < uint32(128)) {
		goto __232
	}

	cc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(fc)))) != int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(cc))))) {
		goto __234
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__234:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __233
__232:

	dc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(dc >= 0xc0) {
		goto __235
	}
	if !(dc&0x20 == uint32(0)) {
		goto __236
	}
	dc = dc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __237
__236:
	if !(dc&0x10 == uint32(0)) {
		goto __238
	}
	dc = dc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __239
__238:
	if !(dc&0x08 == uint32(0)) {
		goto __240
	}
	dc = dc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __241
__240:
	if !(dc&0x04 == uint32(0)) {
		goto __242
	}
	dc = dc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __243
__242:
	dc = dc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__243:
	;
__241:
	;
__239:
	;
__237:
	;
__235:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)
	if !(dc != fc && dc != uint32(int32(fc)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fother_case)) {
		goto __244
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__244:
	;

__233:
	;
	goto __222
__221:
	if !(ucp != 0) {
		goto __245
	}

	cc1 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	if !(fc < uint32(128)) {
		goto __247
	}

	if !(int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(fc)))) != int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(cc1))))) {
		goto __249
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__249:
	;

	goto __248
__247:

	if !(cc1 != fc && cc1 != uint32(int32(fc)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fother_case)) {
		goto __250
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__250:
	;

__248:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(2)
	goto __246
__245:

	/* Not UTF or UCP mode; use the table for characters < 256. */

	if !(int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))))) !=
		int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))) {
		goto __251
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__251:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(2)
__246:
	;
__222:
	;
	goto __12

	// =====================================================================
	// Match not a single character.

__22:
__23:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __252
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __253
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __254
	}
	return -2
__254:
	;
__253:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__252:
	;

	if !(utf != 0) {
		goto __255
	}

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	ch = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
	if !(ch >= 0xc0) {
		goto __257
	}
	if !(ch&0x20 == uint32(0)) {
		goto __258
	}
	ch = ch&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))&0x3f
	goto __259
__258:
	if !(ch&0x10 == uint32(0)) {
		goto __260
	}
	ch = ch&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(2)
	goto __261
__260:
	if !(ch&0x08 == uint32(0)) {
		goto __262
	}
	ch = ch&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(3)
	goto __263
__262:
	if !(ch&0x04 == uint32(0)) {
		goto __264
	}
	ch = ch&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(4)
	goto __265
__264:
	ch = ch&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(5)
__265:
	;
__263:
	;
__261:
	;
__259:
	;
__257:
	;

	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __266
	}
	if !(fc&0x20 == uint32(0)) {
		goto __267
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __268
__267:
	if !(fc&0x10 == uint32(0)) {
		goto __269
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __270
__269:
	if !(fc&0x08 == uint32(0)) {
		goto __271
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __272
__271:
	if !(fc&0x04 == uint32(0)) {
		goto __273
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __274
__273:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__274:
	;
__272:
	;
__270:
	;
__268:
	;
__266:
	;

	if !(ch == fc) {
		goto __275
	}

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
	// Caseful match
	goto __276
__275:
	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_NOTI) {
		goto __277
	} /* If caseless */

	if !(ch > uint32(127)) {
		goto __278
	}
	ch = uint32(int32(ch) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(ch)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(ch)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __279
__278:
	ch = uint32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(ch))))
__279:
	;
	if !(ch == fc) {
		goto __280
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__280:
	;

__277:
	;
__276:
	;
	goto __256
__255:
	if !(ucp != 0) {
		goto __281
	}

	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	ch1 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(2)

	if !(ch1 == fc) {
		goto __283
	}

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
	// Caseful match
	goto __284
__283:
	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_NOTI) {
		goto __285
	} /* If caseless */

	if !(ch1 > uint32(127)) {
		goto __286
	}
	ch1 = uint32(int32(ch1) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(ch1)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(ch1)%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __287
__286:
	ch1 = uint32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(ch1))))
__287:
	;
	if !(ch1 == fc) {
		goto __288
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__288:
	;

__285:
	;
__284:
	;
	goto __282
__281:

	/* Neither UTF nor UCP is set */

	ch2 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(ch2 == fc || int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_NOTI && uint32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(ch2)))) == fc) {
		goto __289
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__289:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(2)
__282:
	;
__256:
	;
	goto __12

	// =====================================================================
	// Match a single character repeatedly.

__24:
__25:
	*(*uint32)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATCHAR

__26:
__27:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATCHAR

__28:
__29:
	reptype = REPTYPE_MAX
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATCHAR

__30:
__31:
	reptype = REPTYPE_MIN
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATCHAR

__32:
__33:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATCHAR

__34:
__35:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(1)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATCHAR

__36:
__37:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATCHAR

__38:
__39:
__40:
__41:
__42:
__43:
__44:
__45:
__46:
__47:
__48:
__49:
	fc = uint32(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - func() int32 {
		if int32((*Theapframe)(unsafe.Pointer(F)).Fop) < OP_STARI {
			return OP_STAR
		}
		return OP_STARI
	}())
	*(*uint32)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]

	// Common code for all repeated single-character matches. We first check
	//     for the minimum number of characters. If the minimum equals the maximum, we
	//     are done. Otherwise, if minimizing, check the rest of the pattern for a
	//     match; if there isn't one, advance up to the maximum, one character at a
	//     time.
	//
	//     If maximizing, advance up to the maximum number of matching characters,
	//     until Feptr is past the end of the maximum run. If possessive, we are
	//     then done (no backing up). Otherwise, match at this position; anything
	//     other than no match is immediately returned. For nomatch, back up one
	//     character, unless we are matching \R and the last thing matched was
	//     \r\n, in which case, back up two code units until we reach the first
	//     optional character position.
	//
	//     The various UTF/non-UTF and caseful/caseless cases are handled separately,
	//     for speed.

REPEATCHAR:
	if !(utf != 0) {
		goto __290
	}

	(*Theapframe)(unsafe.Pointer(F)).Flength = uint64(1)
	*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))
	if !(fc >= 0xc0) {
		goto __292
	}
	if !(fc&0x20 == uint32(0)) {
		goto __293
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	(*Theapframe)(unsafe.Pointer(F)).Flength++
	goto __294
__293:
	if !(fc&0x10 == uint32(0)) {
		goto __295
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(2)
	goto __296
__295:
	if !(fc&0x08 == uint32(0)) {
		goto __297
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(3)
	goto __298
__297:
	if !(fc&0x04 == uint32(0)) {
		goto __299
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(4)
	goto __300
__299:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 5)))&0x3f
	*(*uint64)(unsafe.Pointer(F + 24)) += uint64(5)
__300:
	;
__298:
	;
__296:
	;
__294:
	;
__292:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)

	// Handle multi-code-unit character matching, caseful and caseless.

	if !((*Theapframe)(unsafe.Pointer(F)).Flength > uint64(1)) {
		goto __301
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) >= OP_STARI && libc.AssignUint32(&othercase, uint32(int32(fc)+(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fother_case)) != fc) {
		goto __302
	}
	(*Theapframe)(unsafe.Pointer(F)).Ftemp_size = uint64(X_pcre2_ord2utf_8(tls, othercase, F+74))
	goto __303
__302:
	(*Theapframe)(unsafe.Pointer(F)).Ftemp_size = uint64(0)
__303:
	;

	i = uint32(1)
__304:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __306
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Flength) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, *(*uintptr)(unsafe.Pointer(F + 8 + 1*8)), (*Theapframe)(unsafe.Pointer(F)).Flength*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __307
	}
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)
	goto __308
__307:
	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size > uint64(0) && (*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, F+74, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __309
	}
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)
	goto __310
__309:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __311
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __312
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __313
	}
	return -2
__313:
	;
__312:
	;
__311:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__310:
	;
__308:
	;
	goto __305
__305:
	i++
	goto __304
	goto __306
__306:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __314
	}
	goto __10
__314:
	;

	if !(reptype == REPTYPE_MIN) {
		goto __315
	}

__317:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM202
	goto MATCH_RECURSE
L_RM202:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __320
	}
	rrc = rrc
	goto RETURN_SWITCH
__320:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __321
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__321:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Flength) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, *(*uintptr)(unsafe.Pointer(F + 8 + 1*8)), (*Theapframe)(unsafe.Pointer(F)).Flength*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __322
	}
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)
	goto __323
__322:
	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size > uint64(0) && (*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, F+74, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __324
	}
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)
	goto __325
__324:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __326
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __327
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __328
	}
	return -2
__328:
	;
__327:
	;
__326:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__325:
	;
__323:
	;
	goto __318
__318:
	goto __317
	goto __319
__319:
	;
	// Control never gets here
	goto __316
__315: /* Maximize */

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr
	i = *(*uint32)(unsafe.Pointer(F + 56))
__329:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __331
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Flength) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, *(*uintptr)(unsafe.Pointer(F + 8 + 1*8)), (*Theapframe)(unsafe.Pointer(F)).Flength*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __332
	}
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)
	goto __333
__332:
	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size > uint64(0) && (*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size) && libc.Xmemcmp(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, F+74, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size*uint64(DPCRE2_CODE_UNIT_WIDTH/8)) == 0) {
		goto __334
	}
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)
	goto __335
__334:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __336
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __337
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __338
	}
	return -2
__338:
	;
__337:
	;
__336:
	;

	goto __331
__335:
	;
__333:
	;
	goto __330
__330:
	i++
	goto __329
	goto __331
__331:
	;

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//           Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//           go too far.

	if !(reptype != REPTYPE_POS) {
		goto __339
	}
__340:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __343
	}
	goto __342
__343:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM203
	goto MATCH_RECURSE
L_RM203:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __344
	}
	rrc = rrc
	goto RETURN_SWITCH
__344:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__345:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __346
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __345
__346:
	;
	goto __341
__341:
	goto __340
	goto __342
__342:
	;
__339:
	;
__316:
	;
	goto __12 // End of repeated wide character handling
__301:
	;

	// Length of UTF character is 1. Put it into the preserved variable and
	//       fall through to the non-UTF code.

	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = fc
	goto __291
__290:

	// When not in UTF mode, load a single-code-unit character. Then proceed as
	//     above, using Unicode casing if either UTF or UCP is set.

	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
__291:
	;

	// Caseless comparison

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) >= OP_STARI) {
		goto __347
	}

	if !(ucp != 0 && !(utf != 0) && *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) > uint32(127)) {
		goto __349
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 3*4)) = uint32(int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)))%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __350
__349:
	// Lc will be < 128 in UTF-8 mode.
	*(*uint32)(unsafe.Pointer(F + 56 + 3*4)) = uint32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))))))
__350:
	;

	i = uint32(1)
__351:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __353
	}
	// Faster than PCRE2_UCHAR
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __354
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __355
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __356
	}
	return -2
__356:
	;
__355:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__354:
	;
	cc2 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) != cc2 && *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) != cc2) {
		goto __357
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__357:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __352
__352:
	i++
	goto __351
	goto __353
__353:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __358
	}
	goto __10
__358:
	;

	if !(reptype == REPTYPE_MIN) {
		goto __359
	}

__361:
	/* Faster than PCRE2_UCHAR */
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM25
	goto MATCH_RECURSE
L_RM25:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __364
	}
	rrc = rrc
	goto RETURN_SWITCH
__364:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __365
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__365:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __366
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __367
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __368
	}
	return -2
__368:
	;
__367:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__366:
	;
	cc3 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) != cc3 && *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) != cc3) {
		goto __369
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__369:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __362
__362:
	goto __361
	goto __363
__363:
	;
	// Control never gets here
	goto __360
__359: /* Maximize */

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr
	i = *(*uint32)(unsafe.Pointer(F + 56))
__370:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __372
	}
	// Faster than PCRE2_UCHAR
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __373
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __374
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __375
	}
	return -2
__375:
	;
__374:
	;

	goto __372
__373:
	;
	cc4 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) != cc4 && *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) != cc4) {
		goto __376
	}
	goto __372
__376:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __371
__371:
	i++
	goto __370
	goto __372
__372:
	;
	if !(reptype != REPTYPE_POS) {
		goto __377
	}
__378:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __381
	}
	goto __380
__381:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM26
	goto MATCH_RECURSE
L_RM26:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !(rrc != DMATCH_NOMATCH) {
		goto __382
	}
	rrc = rrc
	goto RETURN_SWITCH
__382:
	;

	goto __379
__379:
	goto __378
	goto __380
__380:
	;
__377:
	;
__360:
	;
	goto __348
__347:

	i = uint32(1)
__383:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __385
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __386
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __387
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __388
	}
	return -2
__388:
	;
__387:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__386:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) != uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __389
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__389:
	;

	goto __384
__384:
	i++
	goto __383
	goto __385
__385:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __390
	}
	goto __10
__390:
	;

	if !(reptype == REPTYPE_MIN) {
		goto __391
	}

__393:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM27
	goto MATCH_RECURSE
L_RM27:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __396
	}
	rrc = rrc
	goto RETURN_SWITCH
__396:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __397
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__397:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __398
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __399
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __400
	}
	return -2
__400:
	;
__399:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__398:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) != uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __401
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__401:
	;

	goto __394
__394:
	goto __393
	goto __395
__395:
	;
	// Control never gets here
	goto __392
__391: /* Maximize */

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr
	i = *(*uint32)(unsafe.Pointer(F + 56))
__402:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __404
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __405
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __406
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __407
	}
	return -2
__407:
	;
__406:
	;

	goto __404
__405:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) != uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __408
	}
	goto __404
__408:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __403
__403:
	i++
	goto __402
	goto __404
__404:
	;

	if !(reptype != REPTYPE_POS) {
		goto __409
	}
__410:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __413
	}
	goto __412
__413:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM28
	goto MATCH_RECURSE
L_RM28:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !(rrc != DMATCH_NOMATCH) {
		goto __414
	}
	rrc = rrc
	goto RETURN_SWITCH
__414:
	;

	goto __411
__411:
	goto __410
	goto __412
__412:
	;
__409:
	;
__392:
	;
__348:
	;
	goto __12

	// =====================================================================
	// Match a negated single one-byte character repeatedly. This is almost a
	//     repeat of the code for a repeated single character, but I haven't found a
	//     nice way of commoning these up that doesn't require a test of the
	//     positive/negative option for each character match. Maybe that wouldn't add
	//     very much to the time taken, but character matching *is* what this is all
	//     about...

__50:
__51:
	*(*uint32)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATNOTCHAR

__52:
__53:
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	reptype = REPTYPE_MAX
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATNOTCHAR

__54:
__55:
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	reptype = REPTYPE_MIN
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATNOTCHAR

__56:
__57:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATNOTCHAR

__58:
__59:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(1)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATNOTCHAR

__60:
__61:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATNOTCHAR

__62:
__63:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATNOTCHAR

__64:
__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
__74:
__75:
	fc = uint32(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - func() int32 {
		if int32((*Theapframe)(unsafe.Pointer(F)).Fop) >= OP_NOTSTARI {
			return OP_NOTSTARI
		}
		return OP_NOTSTAR
	}())
	*(*uint32)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]

	// Common code for all repeated single-character non-matches.

REPEATNOTCHAR:
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) >= 0xc0) {
		goto __415
	}
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x20 == uint32(0)) {
		goto __416
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = *(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))&0x3f
	goto __417
__416:
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x10 == uint32(0)) {
		goto __418
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = *(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(2)
	goto __419
__418:
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x08 == uint32(0)) {
		goto __420
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = *(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(3)
	goto __421
__420:
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x04 == uint32(0)) {
		goto __422
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = *(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(4)
	goto __423
__422:
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = *(*uint32)(unsafe.Pointer(F + 56 + 2*4))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(5)
__423:
	;
__421:
	;
__419:
	;
__417:
	;
__415:
	;

	// The code is duplicated for the caseless and caseful cases, for speed,
	//     since matching characters is likely to be quite common. First, ensure the
	//     minimum number of matches are present. If Lmin = Lmax, we are done.
	//     Otherwise, if minimizing, keep trying the rest of the expression and
	//     advancing one matching character if failing, up to the maximum.
	//     Alternatively, if maximizing, find the maximum number of characters and
	//     work backwards.

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) >= OP_NOTSTARI) {
		goto __424
	} /* Caseless */

	if !((utf != 0 || ucp != 0) && *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) > uint32(127)) {
		goto __426
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 3*4)) = uint32(int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)))%DUCD_BLOCK_SIZE])*12)).Fother_case)
	goto __427
__426:

	*(*uint32)(unsafe.Pointer(F + 56 + 3*4)) = uint32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))))))
__427:
	; // Other case from table

	if !(utf != 0) {
		goto __428
	}

	i = uint32(1)
__430:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __432
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __433
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __434
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __435
	}
	return -2
__435:
	;
__434:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__433:
	;
	d = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(d >= 0xc0) {
		goto __436
	}
	if !(d&0x20 == uint32(0)) {
		goto __437
	}
	d = d&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __438
__437:
	if !(d&0x10 == uint32(0)) {
		goto __439
	}
	d = d&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __440
__439:
	if !(d&0x08 == uint32(0)) {
		goto __441
	}
	d = d&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __442
__441:
	if !(d&0x04 == uint32(0)) {
		goto __443
	}
	d = d&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __444
__443:
	d = d&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__444:
	;
__442:
	;
__440:
	;
__438:
	;
__436:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == d || *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) == d) {
		goto __445
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__445:
	;

	goto __431
__431:
	i++
	goto __430
	goto __432
__432:
	;
	goto __429
__428:

	/* Not UTF mode */

	i = uint32(1)
__446:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __448
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __449
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __450
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __451
	}
	return -2
__451:
	;
__450:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__449:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) || *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) == uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __452
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__452:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __447
__447:
	i++
	goto __446
	goto __448
__448:
	;
__429:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __453
	}
	goto __10
__453:
	; // Finished for exact count

	if !(reptype == REPTYPE_MIN) {
		goto __454
	}

	if !(utf != 0) {
		goto __456
	}

__458:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM204
	goto MATCH_RECURSE
L_RM204:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __461
	}
	rrc = rrc
	goto RETURN_SWITCH
__461:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __462
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__462:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __463
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __464
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __465
	}
	return -2
__465:
	;
__464:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__463:
	;
	d1 = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(d1 >= 0xc0) {
		goto __466
	}
	if !(d1&0x20 == uint32(0)) {
		goto __467
	}
	d1 = d1&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __468
__467:
	if !(d1&0x10 == uint32(0)) {
		goto __469
	}
	d1 = d1&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __470
__469:
	if !(d1&0x08 == uint32(0)) {
		goto __471
	}
	d1 = d1&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __472
__471:
	if !(d1&0x04 == uint32(0)) {
		goto __473
	}
	d1 = d1&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __474
__473:
	d1 = d1&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__474:
	;
__472:
	;
__470:
	;
__468:
	;
__466:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == d1 || *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) == d1) {
		goto __475
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__475:
	;

	goto __459
__459:
	goto __458
	goto __460
__460:
	;
	goto __457
__456:

	/* Not UTF mode */

__476:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM29
	goto MATCH_RECURSE
L_RM29:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __479
	}
	rrc = rrc
	goto RETURN_SWITCH
__479:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __480
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__480:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __481
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __482
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __483
	}
	return -2
__483:
	;
__482:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__481:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) || *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) == uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __484
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__484:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __477
__477:
	goto __476
	goto __478
__478:
	;
__457:
	;
	// Control never gets here
	goto __455
__454:

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr

	if !(utf != 0) {
		goto __485
	}

	i = *(*uint32)(unsafe.Pointer(F + 56))
__487:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __489
	}

	len = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __490
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __491
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __492
	}
	return -2
__492:
	;
__491:
	;

	goto __489
__490:
	;
	d2 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(d2 >= 0xc0) {
		goto __493
	}
	if !(d2&0x20 == uint32(0)) {
		goto __494
	}
	d2 = d2&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len++
	goto __495
__494:
	if !(d2&0x10 == uint32(0)) {
		goto __496
	}
	d2 = d2&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len = len + 2
	goto __497
__496:
	if !(d2&0x08 == uint32(0)) {
		goto __498
	}
	d2 = d2&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len = len + 3
	goto __499
__498:
	if !(d2&0x04 == uint32(0)) {
		goto __500
	}
	d2 = d2&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len = len + 4
	goto __501
__500:
	d2 = d2&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len = len + 5
__501:
	;
__499:
	;
__497:
	;
__495:
	;
__493:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == d2 || *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) == d2) {
		goto __502
	}
	goto __489
__502:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len)
	goto __488
__488:
	i++
	goto __487
	goto __489
__489:
	;

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//           Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//           go too far.

	if !(reptype != REPTYPE_POS) {
		goto __503
	}
__504:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __507
	}
	goto __506
__507:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM205
	goto MATCH_RECURSE
L_RM205:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __508
	}
	rrc = rrc
	goto RETURN_SWITCH
__508:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__509:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __510
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __509
__510:
	;
	goto __505
__505:
	goto __504
	goto __506
__506:
	;
__503:
	;
	goto __486
__485:

	/* Not UTF mode */

	i = *(*uint32)(unsafe.Pointer(F + 56))
__511:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __513
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __514
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __515
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __516
	}
	return -2
__516:
	;
__515:
	;

	goto __513
__514:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) || *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) == uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __517
	}
	goto __513
__517:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __512
__512:
	i++
	goto __511
	goto __513
__513:
	;
	if !(reptype != REPTYPE_POS) {
		goto __518
	}
__519:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __522
	}
	goto __521
__522:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM30
	goto MATCH_RECURSE
L_RM30:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __523
	}
	rrc = rrc
	goto RETURN_SWITCH
__523:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __520
__520:
	goto __519
	goto __521
__521:
	;
__518:
	;
__486:
	;
__455:
	;
	goto __425
__424:

	if !(utf != 0) {
		goto __524
	}

	i = uint32(1)
__526:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __528
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __529
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __530
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __531
	}
	return -2
__531:
	;
__530:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__529:
	;
	d3 = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(d3 >= 0xc0) {
		goto __532
	}
	if !(d3&0x20 == uint32(0)) {
		goto __533
	}
	d3 = d3&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __534
__533:
	if !(d3&0x10 == uint32(0)) {
		goto __535
	}
	d3 = d3&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __536
__535:
	if !(d3&0x08 == uint32(0)) {
		goto __537
	}
	d3 = d3&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __538
__537:
	if !(d3&0x04 == uint32(0)) {
		goto __539
	}
	d3 = d3&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __540
__539:
	d3 = d3&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__540:
	;
__538:
	;
__536:
	;
__534:
	;
__532:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == d3) {
		goto __541
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__541:
	;

	goto __527
__527:
	i++
	goto __526
	goto __528
__528:
	;
	goto __525
__524:
	/* Not UTF mode */

	i = uint32(1)
__542:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __544
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __545
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __546
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __547
	}
	return -2
__547:
	;
__546:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__545:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __548
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__548:
	;

	goto __543
__543:
	i++
	goto __542
	goto __544
__544:
	;
__525:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __549
	}
	goto __10
__549:
	;

	if !(reptype == REPTYPE_MIN) {
		goto __550
	}

	if !(utf != 0) {
		goto __552
	}

__554:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM206
	goto MATCH_RECURSE
L_RM206:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __557
	}
	rrc = rrc
	goto RETURN_SWITCH
__557:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __558
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__558:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __559
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __560
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __561
	}
	return -2
__561:
	;
__560:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__559:
	;
	d4 = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(d4 >= 0xc0) {
		goto __562
	}
	if !(d4&0x20 == uint32(0)) {
		goto __563
	}
	d4 = d4&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __564
__563:
	if !(d4&0x10 == uint32(0)) {
		goto __565
	}
	d4 = d4&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __566
__565:
	if !(d4&0x08 == uint32(0)) {
		goto __567
	}
	d4 = d4&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __568
__567:
	if !(d4&0x04 == uint32(0)) {
		goto __569
	}
	d4 = d4&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __570
__569:
	d4 = d4&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__570:
	;
__568:
	;
__566:
	;
__564:
	;
__562:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == d4) {
		goto __571
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__571:
	;

	goto __555
__555:
	goto __554
	goto __556
__556:
	;
	goto __553
__552:
	/* Not UTF mode */

__572:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM31
	goto MATCH_RECURSE
L_RM31:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __575
	}
	rrc = rrc
	goto RETURN_SWITCH
__575:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __576
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__576:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __577
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __578
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __579
	}
	return -2
__579:
	;
__578:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__577:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))) {
		goto __580
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__580:
	;

	goto __573
__573:
	goto __572
	goto __574
__574:
	;
__553:
	;
	// Control never gets here
	goto __551
__550:

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr

	if !(utf != 0) {
		goto __581
	}

	i = *(*uint32)(unsafe.Pointer(F + 56))
__583:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __585
	}

	len1 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __586
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __587
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __588
	}
	return -2
__588:
	;
__587:
	;

	goto __585
__586:
	;
	d5 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(d5 >= 0xc0) {
		goto __589
	}
	if !(d5&0x20 == uint32(0)) {
		goto __590
	}
	d5 = d5&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len1++
	goto __591
__590:
	if !(d5&0x10 == uint32(0)) {
		goto __592
	}
	d5 = d5&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len1 = len1 + 2
	goto __593
__592:
	if !(d5&0x08 == uint32(0)) {
		goto __594
	}
	d5 = d5&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len1 = len1 + 3
	goto __595
__594:
	if !(d5&0x04 == uint32(0)) {
		goto __596
	}
	d5 = d5&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len1 = len1 + 4
	goto __597
__596:
	d5 = d5&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len1 = len1 + 5
__597:
	;
__595:
	;
__593:
	;
__591:
	;
__589:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == d5) {
		goto __598
	}
	goto __585
__598:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len1)
	goto __584
__584:
	i++
	goto __583
	goto __585
__585:
	;

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//           Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//           go too far.

	if !(reptype != REPTYPE_POS) {
		goto __599
	}
__600:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __603
	}
	goto __602
__603:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM207
	goto MATCH_RECURSE
L_RM207:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __604
	}
	rrc = rrc
	goto RETURN_SWITCH
__604:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__605:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __606
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __605
__606:
	;
	goto __601
__601:
	goto __600
	goto __602
__602:
	;
__599:
	;
	goto __582
__581:
	/* Not UTF mode */

	i = *(*uint32)(unsafe.Pointer(F + 56))
__607:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __609
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __610
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __611
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __612
	}
	return -2
__612:
	;
__611:
	;

	goto __609
__610:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))) {
		goto __613
	}
	goto __609
__613:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __608
__608:
	i++
	goto __607
	goto __609
__609:
	;
	if !(reptype != REPTYPE_POS) {
		goto __614
	}
__615:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __618
	}
	goto __617
__618:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM32
	goto MATCH_RECURSE
L_RM32:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __619
	}
	rrc = rrc
	goto RETURN_SWITCH
__619:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __616
__616:
	goto __615
	goto __617
__617:
	;
__614:
	;
__582:
	;
__551:
	;
__425:
	;
	goto __12

	// =====================================================================
	// Match a bit-mapped character class, possibly repeatedly. These opcodes
	//     are used when all the characters in the class have values in the range
	//     0-255, and either the matching is caseful, or the characters are in the
	//     range 0-127 when UTF processing is enabled. The only difference between
	//     OP_CLASS and OP_NCLASS occurs when a data character outside the range is
	//     encountered.

__76:
__77:

	*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1) // Save for matching
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint64(1) + uint64(32)/uint64(unsafe.Sizeof(uint8(0)))) // Advance past the item

	// Look past the end of the item to see if there is repeat information
	//       following. Then obey similar code to character type repeats.

	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) {
	case OP_CRSTAR:
		goto __621
	case OP_CRMINSTAR:
		goto __622
	case OP_CRPLUS:
		goto __623
	case OP_CRMINPLUS:
		goto __624
	case OP_CRQUERY:
		goto __625
	case OP_CRMINQUERY:
		goto __626
	case OP_CRPOSSTAR:
		goto __627
	case OP_CRPOSPLUS:
		goto __628
	case OP_CRPOSQUERY:
		goto __629

	case OP_CRRANGE:
		goto __630
	case OP_CRMINRANGE:
		goto __631
	case OP_CRPOSRANGE:
		goto __632

	default:
		goto __633
	}
	goto __620

__621:
__622:
__623:
__624:
__625:
__626:
__627:
__628:
__629:
	fc = uint32(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - OP_CRSTAR)
	*(*uint32)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]
	goto __620

__630:
__631:
__632:
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) == uint32(0)) {
		goto __634
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
__634:
	; // Max 0 => infinity
	reptype = rep_typ[int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))-OP_CRSTAR]
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + 2*DIMM2_SIZE)
	goto __620

__633: // No repeat follows
	*(*uint32)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, uint32(1))
	goto __620
__620:
	;

	// First, ensure the minimum number of matches are present.

	if !(utf != 0) {
		goto __635
	}

	i = uint32(1)
__637:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __639
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __640
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __641
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __642
	}
	return -2
__642:
	;
__641:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__640:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __643
	}
	if !(fc&0x20 == uint32(0)) {
		goto __644
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __645
__644:
	if !(fc&0x10 == uint32(0)) {
		goto __646
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __647
__646:
	if !(fc&0x08 == uint32(0)) {
		goto __648
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __649
__648:
	if !(fc&0x04 == uint32(0)) {
		goto __650
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __651
__650:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__651:
	;
__649:
	;
__647:
	;
__645:
	;
__643:
	;

	if !(fc > uint32(255)) {
		goto __652
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_CLASS) {
		goto __654
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__654:
	;

	goto __653
__652:
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/uint32(8)))))&(uint32(1)<<(fc&uint32(7))) == uint32(0)) {
		goto __655
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__655:
	;
__653:
	;

	goto __638
__638:
	i++
	goto __637
	goto __639
__639:
	;
	goto __636
__635:
	/* Not UTF mode */

	i = uint32(1)
__656:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __658
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __659
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __660
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __661
	}
	return -2
__661:
	;
__660:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__659:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/uint32(8)))))&(uint32(1)<<(fc&uint32(7))) == uint32(0)) {
		goto __662
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__662:
	;

	goto __657
__657:
	i++
	goto __656
	goto __658
__658:
	;
__636:
	;

	// If Lmax == Lmin we are done. Continue with main loop.

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __663
	}
	goto __10
__663:
	;

	// If minimizing, keep testing the rest of the expression and advancing
	//       the pointer while it matches the class.

	if !(reptype == REPTYPE_MIN) {
		goto __664
	}

	if !(utf != 0) {
		goto __666
	}

__668:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM200
	goto MATCH_RECURSE
L_RM200:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __671
	}
	rrc = rrc
	goto RETURN_SWITCH
__671:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __672
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__672:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __673
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __674
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __675
	}
	return -2
__675:
	;
__674:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__673:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __676
	}
	if !(fc&0x20 == uint32(0)) {
		goto __677
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __678
__677:
	if !(fc&0x10 == uint32(0)) {
		goto __679
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __680
__679:
	if !(fc&0x08 == uint32(0)) {
		goto __681
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __682
__681:
	if !(fc&0x04 == uint32(0)) {
		goto __683
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __684
__683:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__684:
	;
__682:
	;
__680:
	;
__678:
	;
__676:
	;

	if !(fc > uint32(255)) {
		goto __685
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_CLASS) {
		goto __687
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__687:
	;

	goto __686
__685:
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/uint32(8)))))&(uint32(1)<<(fc&uint32(7))) == uint32(0)) {
		goto __688
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__688:
	;
__686:
	;

	goto __669
__669:
	goto __668
	goto __670
__670:
	;
	goto __667
__666:
	/* Not UTF mode */

__689:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM23
	goto MATCH_RECURSE
L_RM23:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __692
	}
	rrc = rrc
	goto RETURN_SWITCH
__692:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __693
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__693:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __694
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __695
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __696
	}
	return -2
__696:
	;
__695:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__694:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/uint32(8)))))&(uint32(1)<<(fc&uint32(7))) == uint32(0)) {
		goto __697
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__697:
	;

	goto __690
__690:
	goto __689
	goto __691
__691:
	;
__667:
	;
	// Control never gets here
	goto __665
__664:

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr

	if !(utf != 0) {
		goto __698
	}

	i = *(*uint32)(unsafe.Pointer(F + 56))
__700:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __702
	}

	len2 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __703
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __704
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __705
	}
	return -2
__705:
	;
__704:
	;

	goto __702
__703:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __706
	}
	if !(fc&0x20 == uint32(0)) {
		goto __707
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len2++
	goto __708
__707:
	if !(fc&0x10 == uint32(0)) {
		goto __709
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len2 = len2 + 2
	goto __710
__709:
	if !(fc&0x08 == uint32(0)) {
		goto __711
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len2 = len2 + 3
	goto __712
__711:
	if !(fc&0x04 == uint32(0)) {
		goto __713
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len2 = len2 + 4
	goto __714
__713:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len2 = len2 + 5
__714:
	;
__712:
	;
__710:
	;
__708:
	;
__706:
	;

	if !(fc > uint32(255)) {
		goto __715
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_CLASS) {
		goto __717
	}
	goto __702
__717:
	;
	goto __716
__715:
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/uint32(8)))))&(uint32(1)<<(fc&uint32(7))) == uint32(0)) {
		goto __718
	}
	goto __702
__718:
	;
__716:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len2)
	goto __701
__701:
	i++
	goto __700
	goto __702
__702:
	;

	if !(reptype == REPTYPE_POS) {
		goto __719
	}
	goto __10
__719:
	; // No backtracking

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//           Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//           go too far.

__720:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM201
	goto MATCH_RECURSE
L_RM201:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __723
	}
	rrc = rrc
	goto RETURN_SWITCH
__723:
	;

	if !(libc.PostDecUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1) <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __724
	}
	goto __722
__724:
	; // Tried at original position
__725:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __726
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __725
__726:
	;
	goto __721
__721:
	goto __720
	goto __722
__722:
	;
	goto __699
__698:
	/* Not UTF mode */

	i = *(*uint32)(unsafe.Pointer(F + 56))
__727:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __729
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __730
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __731
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __732
	}
	return -2
__732:
	;
__731:
	;

	goto __729
__730:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) + uintptr(fc/uint32(8)))))&(uint32(1)<<(fc&uint32(7))) == uint32(0)) {
		goto __733
	}
	goto __729
__733:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __728
__728:
	i++
	goto __727
	goto __729
__729:
	;

	if !(reptype == REPTYPE_POS) {
		goto __734
	}
	goto __10
__734:
	; // No backtracking

__735:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __736
	}

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM24
	goto MATCH_RECURSE
L_RM24:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __737
	}
	rrc = rrc
	goto RETURN_SWITCH
__737:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __735
__736:
	;
__699:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__665:
	;

	// Control never gets here

	// =====================================================================
	// Match an extended character class. In the 8-bit library, this opcode is
	//     encountered only when UTF-8 mode mode is supported. In the 16-bit and
	//     32-bit libraries, codepoints greater than 255 may be encountered even when
	//     UTF is not supported.

__78:

	*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1) + uintptr(DLINK_SIZE) // Save for matching
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))) // Advance past the item

	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) {
	case OP_CRSTAR:
		goto __739
	case OP_CRMINSTAR:
		goto __740
	case OP_CRPLUS:
		goto __741
	case OP_CRMINPLUS:
		goto __742
	case OP_CRQUERY:
		goto __743
	case OP_CRMINQUERY:
		goto __744
	case OP_CRPOSSTAR:
		goto __745
	case OP_CRPOSPLUS:
		goto __746
	case OP_CRPOSQUERY:
		goto __747

	case OP_CRRANGE:
		goto __748
	case OP_CRMINRANGE:
		goto __749
	case OP_CRPOSRANGE:
		goto __750

	default:
		goto __751
	}
	goto __738

__739:
__740:
__741:
__742:
__743:
__744:
__745:
__746:
__747:
	fc = uint32(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - OP_CRSTAR)
	*(*uint32)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]
	goto __738

__748:
__749:
__750:
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) == uint32(0)) {
		goto __752
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
__752:
	; // Max 0 => infinity
	reptype = rep_typ[int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))-OP_CRSTAR]
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + 2*DIMM2_SIZE)
	goto __738

__751: // No repeat follows
	*(*uint32)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, uint32(1))
	goto __738
__738:
	;

	// First, ensure the minimum number of matches are present.

	i = uint32(1)
__753:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __755
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __756
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __757
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __758
	}
	return -2
__758:
	;
__757:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__756:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __759
	}
	if !(fc&0x20 == uint32(0)) {
		goto __760
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __761
__760:
	if !(fc&0x10 == uint32(0)) {
		goto __762
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __763
__762:
	if !(fc&0x08 == uint32(0)) {
		goto __764
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __765
__764:
	if !(fc&0x04 == uint32(0)) {
		goto __766
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __767
__766:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__767:
	;
__765:
	;
__763:
	;
__761:
	;
__759:
	;

	if !!(X_pcre2_xclass_8(tls, fc, *(*uintptr)(unsafe.Pointer(F + 8 + 1*8)), utf) != 0) {
		goto __768
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__768:
	;

	goto __754
__754:
	i++
	goto __753
	goto __755
__755:
	;

	// If Lmax == Lmin we can just continue with the main loop.

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __769
	}
	goto __10
__769:
	;

	// If minimizing, keep testing the rest of the expression and advancing
	//       the pointer while it matches the class.

	if !(reptype == REPTYPE_MIN) {
		goto __770
	}

__772:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM100
	goto MATCH_RECURSE
L_RM100:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __775
	}
	rrc = rrc
	goto RETURN_SWITCH
__775:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __776
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__776:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __777
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __778
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __779
	}
	return -2
__779:
	;
__778:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__777:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __780
	}
	if !(fc&0x20 == uint32(0)) {
		goto __781
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __782
__781:
	if !(fc&0x10 == uint32(0)) {
		goto __783
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __784
__783:
	if !(fc&0x08 == uint32(0)) {
		goto __785
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __786
__785:
	if !(fc&0x04 == uint32(0)) {
		goto __787
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __788
__787:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__788:
	;
__786:
	;
__784:
	;
__782:
	;
__780:
	;

	if !!(X_pcre2_xclass_8(tls, fc, *(*uintptr)(unsafe.Pointer(F + 8 + 1*8)), utf) != 0) {
		goto __789
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__789:
	;

	goto __773
__773:
	goto __772
	goto __774
__774:
	;
	// Control never gets here
	goto __771
__770:

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr
	i = *(*uint32)(unsafe.Pointer(F + 56))
__790:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __792
	}

	len3 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __793
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __794
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __795
	}
	return -2
__795:
	;
__794:
	;

	goto __792
__793:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __796
	}
	if !(fc&0x20 == uint32(0)) {
		goto __797
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len3++
	goto __798
__797:
	if !(fc&0x10 == uint32(0)) {
		goto __799
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len3 = len3 + 2
	goto __800
__799:
	if !(fc&0x08 == uint32(0)) {
		goto __801
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len3 = len3 + 3
	goto __802
__801:
	if !(fc&0x04 == uint32(0)) {
		goto __803
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len3 = len3 + 4
	goto __804
__803:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len3 = len3 + 5
__804:
	;
__802:
	;
__800:
	;
__798:
	;
__796:
	;

	if !!(X_pcre2_xclass_8(tls, fc, *(*uintptr)(unsafe.Pointer(F + 8 + 1*8)), utf) != 0) {
		goto __805
	}
	goto __792
__805:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len3)
	goto __791
__791:
	i++
	goto __790
	goto __792
__792:
	;

	if !(reptype == REPTYPE_POS) {
		goto __806
	}
	goto __10
__806:
	; // No backtracking

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//         Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//         go too far.

__807:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM101
	goto MATCH_RECURSE
L_RM101:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __810
	}
	rrc = rrc
	goto RETURN_SWITCH
__810:
	;

	if !(libc.PostDecUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1) <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __811
	}
	goto __809
__811:
	; // Tried at original position
	if !(utf != 0) {
		goto __812
	}
__813:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __814
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __813
__814:
	;
__812:
	;
	goto __808
__808:
	goto __807
	goto __809
__809:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__771:
	;

	// Control never gets here

	// =====================================================================
	// Match various character types when PCRE2_UCP is not set. These opcodes
	//     are not generated when PCRE2_UCP is set - instead appropriate property
	//     tests are compiled.

__79:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __815
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __816
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __817
	}
	return -2
__817:
	;
__816:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__815:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __818
	}
	if !(fc&0x20 == uint32(0)) {
		goto __819
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __820
__819:
	if !(fc&0x10 == uint32(0)) {
		goto __821
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __822
__821:
	if !(fc&0x08 == uint32(0)) {
		goto __823
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __824
__823:
	if !(fc&0x04 == uint32(0)) {
		goto __825
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __826
__825:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__826:
	;
__824:
	;
__822:
	;
__820:
	;
__818:
	;

	if !(fc <= 255 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __827
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__827:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__80:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __828
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __829
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __830
	}
	return -2
__830:
	;
__829:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__828:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __831
	}
	if !(fc&0x20 == uint32(0)) {
		goto __832
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __833
__832:
	if !(fc&0x10 == uint32(0)) {
		goto __834
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __835
__834:
	if !(fc&0x08 == uint32(0)) {
		goto __836
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __837
__836:
	if !(fc&0x04 == uint32(0)) {
		goto __838
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __839
__838:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__839:
	;
__837:
	;
__835:
	;
__833:
	;
__831:
	;

	if !(!(fc <= 255) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit == 0) {
		goto __840
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__840:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__81:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __841
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __842
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __843
	}
	return -2
__843:
	;
__842:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__841:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __844
	}
	if !(fc&0x20 == uint32(0)) {
		goto __845
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __846
__845:
	if !(fc&0x10 == uint32(0)) {
		goto __847
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __848
__847:
	if !(fc&0x08 == uint32(0)) {
		goto __849
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __850
__849:
	if !(fc&0x04 == uint32(0)) {
		goto __851
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __852
__851:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__852:
	;
__850:
	;
__848:
	;
__846:
	;
__844:
	;

	if !(fc <= 255 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space != 0) {
		goto __853
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__853:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__82:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __854
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __855
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __856
	}
	return -2
__856:
	;
__855:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__854:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __857
	}
	if !(fc&0x20 == uint32(0)) {
		goto __858
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __859
__858:
	if !(fc&0x10 == uint32(0)) {
		goto __860
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __861
__860:
	if !(fc&0x08 == uint32(0)) {
		goto __862
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __863
__862:
	if !(fc&0x04 == uint32(0)) {
		goto __864
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __865
__864:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__865:
	;
__863:
	;
__861:
	;
__859:
	;
__857:
	;

	if !(!(fc <= 255) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space == 0) {
		goto __866
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__866:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__83:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __867
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __868
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __869
	}
	return -2
__869:
	;
__868:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__867:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __870
	}
	if !(fc&0x20 == uint32(0)) {
		goto __871
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __872
__871:
	if !(fc&0x10 == uint32(0)) {
		goto __873
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __874
__873:
	if !(fc&0x08 == uint32(0)) {
		goto __875
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __876
__875:
	if !(fc&0x04 == uint32(0)) {
		goto __877
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __878
__877:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__878:
	;
__876:
	;
__874:
	;
__872:
	;
__870:
	;

	if !(fc <= 255 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0) {
		goto __879
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__879:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__84:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __880
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __881
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __882
	}
	return -2
__882:
	;
__881:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__880:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __883
	}
	if !(fc&0x20 == uint32(0)) {
		goto __884
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __885
__884:
	if !(fc&0x10 == uint32(0)) {
		goto __886
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __887
__886:
	if !(fc&0x08 == uint32(0)) {
		goto __888
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __889
__888:
	if !(fc&0x04 == uint32(0)) {
		goto __890
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __891
__890:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__891:
	;
__889:
	;
__887:
	;
__885:
	;
__883:
	;

	if !(!(fc <= 255) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word == 0) {
		goto __892
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__892:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__85:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __893
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __894
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __895
	}
	return -2
__895:
	;
__894:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__893:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __896
	}
	if !(fc&0x20 == uint32(0)) {
		goto __897
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __898
__897:
	if !(fc&0x10 == uint32(0)) {
		goto __899
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __900
__899:
	if !(fc&0x08 == uint32(0)) {
		goto __901
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __902
__901:
	if !(fc&0x04 == uint32(0)) {
		goto __903
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __904
__903:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__904:
	;
__902:
	;
__900:
	;
__898:
	;
__896:
	;

	switch fc {
	default:
		goto __906

	case uint32('\015'):
		goto __907

	case uint32('\012'):
		goto __908

	case uint32('\013'):
		goto __909
	case uint32('\014'):
		goto __910
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __911
	case uint32(0x2028):
		goto __912
	case uint32(0x2029):
		goto __913
	}
	goto __905

__906:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__907:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __914
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __916
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __917
	}
	return -2
__917:
	;
__916:
	;

	goto __915
__914:
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __918
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__918:
	;
__915:
	;
	goto __905

__908:
	goto __905

__909:
__910:
__911:
__912:
__913:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __919
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__919:
	;

	goto __905
__905:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__86:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __920
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __921
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __922
	}
	return -2
__922:
	;
__921:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__920:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __923
	}
	if !(fc&0x20 == uint32(0)) {
		goto __924
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __925
__924:
	if !(fc&0x10 == uint32(0)) {
		goto __926
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __927
__926:
	if !(fc&0x08 == uint32(0)) {
		goto __928
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __929
__928:
	if !(fc&0x04 == uint32(0)) {
		goto __930
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __931
__930:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__931:
	;
__929:
	;
__927:
	;
__925:
	;
__923:
	;

	switch fc {
	case uint32('\011'):
		goto __933
	case uint32('\040'):
		goto __934
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __935
	case uint32(0x1680):
		goto __936 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __937 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __938 /* EN QUAD */
	case uint32(0x2001):
		goto __939 /* EM QUAD */
	case uint32(0x2002):
		goto __940 /* EN SPACE */
	case uint32(0x2003):
		goto __941 /* EM SPACE */
	case uint32(0x2004):
		goto __942 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __943 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __944 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __945 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __946 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __947 /* THIN SPACE */
	case uint32(0x200A):
		goto __948 /* HAIR SPACE */
	case uint32(0x202f):
		goto __949 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __950 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __951 // Byte and multibyte cases
	default:
		goto __952
	}
	goto __932

__933:
__934:
__935:
__936: /* OGHAM SPACE MARK */
__937: /* MONGOLIAN VOWEL SEPARATOR */
__938: /* EN QUAD */
__939: /* EM QUAD */
__940: /* EN SPACE */
__941: /* EM SPACE */
__942: /* THREE-PER-EM SPACE */
__943: /* FOUR-PER-EM SPACE */
__944: /* SIX-PER-EM SPACE */
__945: /* FIGURE SPACE */
__946: /* PUNCTUATION SPACE */
__947: /* THIN SPACE */
__948: /* HAIR SPACE */
__949: /* NARROW NO-BREAK SPACE */
__950: /* MEDIUM MATHEMATICAL SPACE */
__951:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
	// Byte and multibyte cases
__952:
	goto __932
__932:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__87:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __953
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __954
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __955
	}
	return -2
__955:
	;
__954:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__953:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __956
	}
	if !(fc&0x20 == uint32(0)) {
		goto __957
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __958
__957:
	if !(fc&0x10 == uint32(0)) {
		goto __959
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __960
__959:
	if !(fc&0x08 == uint32(0)) {
		goto __961
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __962
__961:
	if !(fc&0x04 == uint32(0)) {
		goto __963
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __964
__963:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__964:
	;
__962:
	;
__960:
	;
__958:
	;
__956:
	;

	switch fc {
	case uint32('\011'):
		goto __966
	case uint32('\040'):
		goto __967
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __968
	case uint32(0x1680):
		goto __969 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __970 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __971 /* EN QUAD */
	case uint32(0x2001):
		goto __972 /* EM QUAD */
	case uint32(0x2002):
		goto __973 /* EN SPACE */
	case uint32(0x2003):
		goto __974 /* EM SPACE */
	case uint32(0x2004):
		goto __975 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __976 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __977 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __978 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __979 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __980 /* THIN SPACE */
	case uint32(0x200A):
		goto __981 /* HAIR SPACE */
	case uint32(0x202f):
		goto __982 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __983 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __984 // Byte and multibyte cases
	default:
		goto __985
	}
	goto __965

__966:
__967:
__968:
__969: /* OGHAM SPACE MARK */
__970: /* MONGOLIAN VOWEL SEPARATOR */
__971: /* EN QUAD */
__972: /* EM QUAD */
__973: /* EN SPACE */
__974: /* EM SPACE */
__975: /* THREE-PER-EM SPACE */
__976: /* FOUR-PER-EM SPACE */
__977: /* SIX-PER-EM SPACE */
__978: /* FIGURE SPACE */
__979: /* PUNCTUATION SPACE */
__980: /* THIN SPACE */
__981: /* HAIR SPACE */
__982: /* NARROW NO-BREAK SPACE */
__983: /* MEDIUM MATHEMATICAL SPACE */
__984:
	goto __965 // Byte and multibyte cases
__985:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__965:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__88:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __986
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __987
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __988
	}
	return -2
__988:
	;
__987:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__986:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __989
	}
	if !(fc&0x20 == uint32(0)) {
		goto __990
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __991
__990:
	if !(fc&0x10 == uint32(0)) {
		goto __992
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __993
__992:
	if !(fc&0x08 == uint32(0)) {
		goto __994
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __995
__994:
	if !(fc&0x04 == uint32(0)) {
		goto __996
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __997
__996:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__997:
	;
__995:
	;
__993:
	;
__991:
	;
__989:
	;

	switch fc {
	case uint32('\012'):
		goto __999
	case uint32('\013'):
		goto __1000
	case uint32('\014'):
		goto __1001
	case uint32('\015'):
		goto __1002
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __1003
	case uint32(0x2028):
		goto __1004 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __1005
	default:
		goto __1006
	}
	goto __998

__999:
__1000:
__1001:
__1002:
__1003:
__1004: /* LINE SEPARATOR */
__1005:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1006:
	goto __998
__998:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__89:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1007
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1008
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1009
	}
	return -2
__1009:
	;
__1008:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1007:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1010
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1011
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1012
__1011:
	if !(fc&0x10 == uint32(0)) {
		goto __1013
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1014
__1013:
	if !(fc&0x08 == uint32(0)) {
		goto __1015
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1016
__1015:
	if !(fc&0x04 == uint32(0)) {
		goto __1017
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1018
__1017:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1018:
	;
__1016:
	;
__1014:
	;
__1012:
	;
__1010:
	;

	switch fc {
	case uint32('\012'):
		goto __1020
	case uint32('\013'):
		goto __1021
	case uint32('\014'):
		goto __1022
	case uint32('\015'):
		goto __1023
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __1024
	case uint32(0x2028):
		goto __1025 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __1026
	default:
		goto __1027
	}
	goto __1019

__1020:
__1021:
__1022:
__1023:
__1024:
__1025: /* LINE SEPARATOR */
__1026:
	goto __1019
__1027:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1019:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// =====================================================================
	// Check the next character by Unicode property. We will get here only
	//     if the support is in the binary; otherwise a compile-time error occurs.

__90:
__91:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1028
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1029
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1030
	}
	return -2
__1030:
	;
__1029:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1028:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1031
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1032
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1033
__1032:
	if !(fc&0x10 == uint32(0)) {
		goto __1034
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1035
__1034:
	if !(fc&0x08 == uint32(0)) {
		goto __1036
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1037
__1036:
	if !(fc&0x04 == uint32(0)) {
		goto __1038
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1039
__1038:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1039:
	;
__1037:
	;
__1035:
	;
__1033:
	;
__1031:
	;

	prop = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	notmatch = libc.Bool32(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_NOTPROP)

	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1))) {
	case DPT_ANY:
		goto __1041

	case DPT_LAMP:
		goto __1042

	case DPT_GC:
		goto __1043

	case DPT_PC:
		goto __1044

	case DPT_SC:
		goto __1045

	case DPT_SCX:
		goto __1046

	// These are specials

	case DPT_ALNUM:
		goto __1047

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//         which means that Perl space and POSIX space are now identical. PCRE
	//         was changed at release 8.34.

	case DPT_SPACE:
		goto __1048 // Perl space
	case DPT_PXSPACE:
		goto __1049

	case DPT_WORD:
		goto __1050

	case DPT_CLIST:
		goto __1051

	case DPT_UCNC:
		goto __1052

	case DPT_BIDICL:
		goto __1053

	case DPT_BOOL:
		goto __1054

	// This should never occur

	default:
		goto __1055
	}
	goto __1040

__1041:
	if !(notmatch != 0) {
		goto __1056
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1056:
	;

	goto __1040

__1042:
	if !(libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lt) == notmatch) {
		goto __1057
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1057:
	;

	goto __1040

__1043:
	if !(libc.Bool32(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))) == X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype]) == notmatch) {
		goto __1058
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1058:
	;

	goto __1040

__1044:
	if !(libc.Bool32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype)) == notmatch) {
		goto __1059
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1059:
	;

	goto __1040

__1045:
	if !(libc.Bool32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript)) == notmatch) {
		goto __1060
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1060:
	;

	goto __1040

__1046:

	ok = libc.Bool32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))%32)) != uint32(0))
	if !(ok == notmatch) {
		goto __1061
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1061:
	;

	goto __1040

	// These are specials

__1047:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N) == notmatch) {
		goto __1062
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1062:
	;

	goto __1040

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//         which means that Perl space and POSIX space are now identical. PCRE
	//         was changed at release 8.34.

__1048: // Perl space
__1049: // POSIX space
	switch fc {
	case uint32('\011'):
		goto __1064
	case uint32('\040'):
		goto __1065
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __1066
	case uint32(0x1680):
		goto __1067 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __1068 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __1069 /* EN QUAD */
	case uint32(0x2001):
		goto __1070 /* EM QUAD */
	case uint32(0x2002):
		goto __1071 /* EN SPACE */
	case uint32(0x2003):
		goto __1072 /* EM SPACE */
	case uint32(0x2004):
		goto __1073 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __1074 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __1075 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __1076 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __1077 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __1078 /* THIN SPACE */
	case uint32(0x200A):
		goto __1079 /* HAIR SPACE */
	case uint32(0x202f):
		goto __1080 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __1081 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __1082
	case uint32('\012'):
		goto __1083
	case uint32('\013'):
		goto __1084
	case uint32('\014'):
		goto __1085
	case uint32('\015'):
		goto __1086
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __1087
	case uint32(0x2028):
		goto __1088 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __1089

	default:
		goto __1090
	}
	goto __1063

__1064:
__1065:
__1066:
__1067: /* OGHAM SPACE MARK */
__1068: /* MONGOLIAN VOWEL SEPARATOR */
__1069: /* EN QUAD */
__1070: /* EM QUAD */
__1071: /* EN SPACE */
__1072: /* EM SPACE */
__1073: /* THREE-PER-EM SPACE */
__1074: /* FOUR-PER-EM SPACE */
__1075: /* SIX-PER-EM SPACE */
__1076: /* FIGURE SPACE */
__1077: /* PUNCTUATION SPACE */
__1078: /* THIN SPACE */
__1079: /* HAIR SPACE */
__1080: /* NARROW NO-BREAK SPACE */
__1081: /* MEDIUM MATHEMATICAL SPACE */
__1082:
__1083:
__1084:
__1085:
__1086:
__1087:
__1088: /* LINE SEPARATOR */
__1089:
	if !(notmatch != 0) {
		goto __1091
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1091:
	;

	goto __1063

__1090:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_Z) == notmatch) {
		goto __1092
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1092:
	;

	goto __1063
__1063:
	;
	goto __1040

__1050:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N || fc == uint32('\137')) == notmatch) {
		goto __1093
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1093:
	;

	goto __1040

__1051:
	cp = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))*4
__1094:

	if !(fc < *(*uint32)(unsafe.Pointer(cp))) {
		goto __1097
	}
	if !(notmatch != 0) {
		goto __1098
	}
	goto __1096
	goto __1099
__1098:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1099:
	;
__1097:
	;
	if !(fc == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&cp, 4)))) {
		goto __1100
	}
	if !(notmatch != 0) {
		goto __1101
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
	goto __1102
__1101:
	goto __1096
__1102:
	;
__1100:
	;
	goto __1095
__1095:
	goto __1094
	goto __1096
__1096:
	;
	goto __1040

__1052:
	if !(libc.Bool32(fc == uint32('\044') || fc == uint32('\100') || fc == uint32('\140') || fc >= uint32(0xa0) && fc <= uint32(0xd7ff) || fc >= uint32(0xe000)) == notmatch) {
		goto __1103
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1103:
	;

	goto __1040

__1053:
	if !(libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))) == notmatch) {
		goto __1104
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1104:
	;

	goto __1040

__1054:

	ok1 = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))%32)) != uint32(0))
	if !(ok1 == notmatch) {
		goto __1105
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1105:
	;

	goto __1040

	// This should never occur

__1055:
	return -44
__1040:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(3)

	goto __12

	// =====================================================================
	// Match an extended Unicode sequence. We will get here only if the support
	//     is in the binary; otherwise a compile-time error occurs.

__92:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1106
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1108
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1109
	}
	return -2
__1109:
	;
__1108:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	goto __1107
__1106:

	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1110
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1111
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1112
__1111:
	if !(fc&0x10 == uint32(0)) {
		goto __1113
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1114
__1113:
	if !(fc&0x08 == uint32(0)) {
		goto __1115
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1116
__1115:
	if !(fc&0x04 == uint32(0)) {
		goto __1117
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1118
__1117:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1118:
	;
__1116:
	;
__1114:
	;
__1112:
	;
__1110:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr = X_pcre2_extuni_8(tls, fc, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, utf,
		uintptr(0))
__1107:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1119
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1120
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1121
	}
	return -2
__1121:
	;
__1120:
	;
__1119:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// =====================================================================
	// Match a single character type repeatedly. Note that the property type
	//     does not need to be in a stack frame as it is not used within an RMATCH()
	//     loop.

__93:
	*(*uint32)(unsafe.Pointer(F + 56)) = libc.AssignPtrUint32(F+56+1*4, uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATTYPE

__94:
__95:
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_TYPEMINUPTO {
		reptype = REPTYPE_MIN
	} else {
		reptype = REPTYPE_MAX
	}
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATTYPE

__96:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATTYPE

__97:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(1)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATTYPE

__98:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(1)
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto REPEATTYPE

__99:
	reptype = REPTYPE_POS
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)
	goto REPEATTYPE

__100:
__101:
__102:
__103:
__104:
__105:
	fc = uint32(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - OP_TYPESTAR)
	*(*uint32)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]

	// Common code for all repeated character type matches.

REPEATTYPE:
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) // Code for the character type

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_PROP || *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __1122
	}

	proptype = int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
	*(*uint32)(unsafe.Pointer(F + 56 + 3*4)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1))))
	goto __1123
__1122:
	proptype = -1
__1123:
	;

	// First, ensure the minimum number of matches are present. Use inline
	//     code for maximizing the speed, and do the type test once at the start
	//     (i.e. keep it out of the loops). As there are no calls to RMATCH in the
	//     loops, we can use an ordinary variable for "notmatch". The code for UTF
	//     mode is separated out for tidiness, except for Unicode property tests.

	if !(*(*uint32)(unsafe.Pointer(F + 56)) > uint32(0)) {
		goto __1124
	}

	if !(proptype >= 0) {
		goto __1125
	} /* Property tests in all modes */

	notmatch1 = libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)
	switch proptype {
	case DPT_ANY:
		goto __1128

	case DPT_LAMP:
		goto __1129

	case DPT_GC:
		goto __1130

	case DPT_PC:
		goto __1131

	case DPT_SC:
		goto __1132

	case DPT_SCX:
		goto __1133

	case DPT_ALNUM:
		goto __1134

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __1135 // Perl space
	case DPT_PXSPACE:
		goto __1136

	case DPT_WORD:
		goto __1137

	case DPT_CLIST:
		goto __1138

	case DPT_UCNC:
		goto __1139

	case DPT_BIDICL:
		goto __1140

	case DPT_BOOL:
		goto __1141

	// This should not occur

	default:
		goto __1142
	}
	goto __1127

__1128:
	if !(notmatch1 != 0) {
		goto __1143
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1143:
	;

	i = uint32(1)
__1144:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1146
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1147
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1148
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1149
	}
	return -2
__1149:
	;
__1148:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1147:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1150
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1151
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1152
__1151:
	if !(fc&0x10 == uint32(0)) {
		goto __1153
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1154
__1153:
	if !(fc&0x08 == uint32(0)) {
		goto __1155
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1156
__1155:
	if !(fc&0x04 == uint32(0)) {
		goto __1157
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1158
__1157:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1158:
	;
__1156:
	;
__1154:
	;
__1152:
	;
__1150:
	;

	goto __1145
__1145:
	i++
	goto __1144
	goto __1146
__1146:
	;
	goto __1127

__1129:
	i = uint32(1)
__1159:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1161
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1162
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1163
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1164
	}
	return -2
__1164:
	;
__1163:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1162:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1165
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1166
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1167
__1166:
	if !(fc&0x10 == uint32(0)) {
		goto __1168
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1169
__1168:
	if !(fc&0x08 == uint32(0)) {
		goto __1170
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1171
__1170:
	if !(fc&0x04 == uint32(0)) {
		goto __1172
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1173
__1172:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1173:
	;
__1171:
	;
__1169:
	;
__1167:
	;
__1165:
	;

	chartype = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(libc.Bool32(chartype == ucp_Lu || chartype == ucp_Ll || chartype == ucp_Lt) == notmatch1) {
		goto __1174
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1174:
	;

	goto __1160
__1160:
	i++
	goto __1159
	goto __1161
__1161:
	;
	goto __1127

__1130:
	i = uint32(1)
__1175:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1177
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1178
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1179
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1180
	}
	return -2
__1180:
	;
__1179:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1178:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1181
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1182
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1183
__1182:
	if !(fc&0x10 == uint32(0)) {
		goto __1184
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1185
__1184:
	if !(fc&0x08 == uint32(0)) {
		goto __1186
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1187
__1186:
	if !(fc&0x04 == uint32(0)) {
		goto __1188
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1189
__1188:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1189:
	;
__1187:
	;
__1185:
	;
__1183:
	;
__1181:
	;

	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == notmatch1) {
		goto __1190
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1190:
	;

	goto __1176
__1176:
	i++
	goto __1175
	goto __1177
__1177:
	;
	goto __1127

__1131:
	i = uint32(1)
__1191:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1193
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1194
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1195
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1196
	}
	return -2
__1196:
	;
__1195:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1194:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1197
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1198
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1199
__1198:
	if !(fc&0x10 == uint32(0)) {
		goto __1200
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1201
__1200:
	if !(fc&0x08 == uint32(0)) {
		goto __1202
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1203
__1202:
	if !(fc&0x04 == uint32(0)) {
		goto __1204
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1205
__1204:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1205:
	;
__1203:
	;
__1201:
	;
__1199:
	;
__1197:
	;

	if !(libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == notmatch1) {
		goto __1206
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1206:
	;

	goto __1192
__1192:
	i++
	goto __1191
	goto __1193
__1193:
	;
	goto __1127

__1132:
	i = uint32(1)
__1207:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1209
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1210
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1211
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1212
	}
	return -2
__1212:
	;
__1211:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1210:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1213
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1214
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1215
__1214:
	if !(fc&0x10 == uint32(0)) {
		goto __1216
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1217
__1216:
	if !(fc&0x08 == uint32(0)) {
		goto __1218
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1219
__1218:
	if !(fc&0x04 == uint32(0)) {
		goto __1220
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1221
__1220:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1221:
	;
__1219:
	;
__1217:
	;
__1215:
	;
__1213:
	;

	if !(libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscript) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == notmatch1) {
		goto __1222
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1222:
	;

	goto __1208
__1208:
	i++
	goto __1207
	goto __1209
__1209:
	;
	goto __1127

__1133:
	i = uint32(1)
__1223:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1225
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1226
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1227
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1228
	}
	return -2
__1228:
	;
__1227:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1226:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1229
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1230
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1231
__1230:
	if !(fc&0x10 == uint32(0)) {
		goto __1232
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1233
__1232:
	if !(fc&0x08 == uint32(0)) {
		goto __1234
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1235
__1234:
	if !(fc&0x04 == uint32(0)) {
		goto __1236
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1237
__1236:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1237:
	;
__1235:
	;
__1233:
	;
__1231:
	;
__1229:
	;

	prop1 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok2 = libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(prop1)).Fscript) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop1)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))/uint32(32))*4))&(uint32(1)<<(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))%uint32(32))) != uint32(0))
	if !(ok2 == notmatch1) {
		goto __1238
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1238:
	;

	goto __1224
__1224:
	i++
	goto __1223
	goto __1225
__1225:
	;
	goto __1127

__1134:
	i = uint32(1)
__1239:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1241
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1242
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1243
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1244
	}
	return -2
__1244:
	;
__1243:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1242:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1245
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1246
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1247
__1246:
	if !(fc&0x10 == uint32(0)) {
		goto __1248
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1249
__1248:
	if !(fc&0x08 == uint32(0)) {
		goto __1250
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1251
__1250:
	if !(fc&0x04 == uint32(0)) {
		goto __1252
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1253
__1252:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1253:
	;
__1251:
	;
__1249:
	;
__1247:
	;
__1245:
	;

	category = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category == ucp_L || category == ucp_N) == notmatch1) {
		goto __1254
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1254:
	;

	goto __1240
__1240:
	i++
	goto __1239
	goto __1241
__1241:
	;
	goto __1127

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__1135: // Perl space
__1136: // POSIX space
	i = uint32(1)
__1255:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1257
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1258
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1259
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1260
	}
	return -2
__1260:
	;
__1259:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1258:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1261
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1262
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1263
__1262:
	if !(fc&0x10 == uint32(0)) {
		goto __1264
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1265
__1264:
	if !(fc&0x08 == uint32(0)) {
		goto __1266
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1267
__1266:
	if !(fc&0x04 == uint32(0)) {
		goto __1268
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1269
__1268:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1269:
	;
__1267:
	;
__1265:
	;
__1263:
	;
__1261:
	;

	switch fc {
	case uint32('\011'):
		goto __1271
	case uint32('\040'):
		goto __1272
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __1273
	case uint32(0x1680):
		goto __1274 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __1275 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __1276 /* EN QUAD */
	case uint32(0x2001):
		goto __1277 /* EM QUAD */
	case uint32(0x2002):
		goto __1278 /* EN SPACE */
	case uint32(0x2003):
		goto __1279 /* EM SPACE */
	case uint32(0x2004):
		goto __1280 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __1281 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __1282 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __1283 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __1284 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __1285 /* THIN SPACE */
	case uint32(0x200A):
		goto __1286 /* HAIR SPACE */
	case uint32(0x202f):
		goto __1287 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __1288 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __1289
	case uint32('\012'):
		goto __1290
	case uint32('\013'):
		goto __1291
	case uint32('\014'):
		goto __1292
	case uint32('\015'):
		goto __1293
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __1294
	case uint32(0x2028):
		goto __1295 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __1296

	default:
		goto __1297
	}
	goto __1270

__1271:
__1272:
__1273:
__1274: /* OGHAM SPACE MARK */
__1275: /* MONGOLIAN VOWEL SEPARATOR */
__1276: /* EN QUAD */
__1277: /* EM QUAD */
__1278: /* EN SPACE */
__1279: /* EM SPACE */
__1280: /* THREE-PER-EM SPACE */
__1281: /* FOUR-PER-EM SPACE */
__1282: /* SIX-PER-EM SPACE */
__1283: /* FIGURE SPACE */
__1284: /* PUNCTUATION SPACE */
__1285: /* THIN SPACE */
__1286: /* HAIR SPACE */
__1287: /* NARROW NO-BREAK SPACE */
__1288: /* MEDIUM MATHEMATICAL SPACE */
__1289:
__1290:
__1291:
__1292:
__1293:
__1294:
__1295: /* LINE SEPARATOR */
__1296:
	if !(notmatch1 != 0) {
		goto __1298
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1298:
	;

	goto __1270

__1297:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == ucp_Z) == notmatch1) {
		goto __1299
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1299:
	;

	goto __1270
__1270:
	;
	goto __1256
__1256:
	i++
	goto __1255
	goto __1257
__1257:
	;
	goto __1127

__1137:
	i = uint32(1)
__1300:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1302
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1303
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1304
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1305
	}
	return -2
__1305:
	;
__1304:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1303:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1306
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1307
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1308
__1307:
	if !(fc&0x10 == uint32(0)) {
		goto __1309
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1310
__1309:
	if !(fc&0x08 == uint32(0)) {
		goto __1311
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1312
__1311:
	if !(fc&0x04 == uint32(0)) {
		goto __1313
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1314
__1313:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1314:
	;
__1312:
	;
__1310:
	;
__1308:
	;
__1306:
	;

	category1 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category1 == ucp_L || category1 == ucp_N || fc == uint32('\137')) == notmatch1) {
		goto __1315
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1315:
	;

	goto __1301
__1301:
	i++
	goto __1300
	goto __1302
__1302:
	;
	goto __1127

__1138:
	i = uint32(1)
__1316:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1318
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1319
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1320
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1321
	}
	return -2
__1321:
	;
__1320:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1319:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1322
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1323
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1324
__1323:
	if !(fc&0x10 == uint32(0)) {
		goto __1325
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1326
__1325:
	if !(fc&0x08 == uint32(0)) {
		goto __1327
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1328
__1327:
	if !(fc&0x04 == uint32(0)) {
		goto __1329
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1330
__1329:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1330:
	;
__1328:
	;
__1326:
	;
__1324:
	;
__1322:
	;

	cp1 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4)))*4
__1331:

	if !(fc < *(*uint32)(unsafe.Pointer(cp1))) {
		goto __1334
	}

	if !(notmatch1 != 0) {
		goto __1335
	}
	goto __1333
__1335:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1334:
	;
	if !(fc == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&cp1, 4)))) {
		goto __1336
	}

	if !(notmatch1 != 0) {
		goto __1337
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1337:
	;

	goto __1333
__1336:
	;
	goto __1332
__1332:
	goto __1331
	goto __1333
__1333:
	;
	goto __1317
__1317:
	i++
	goto __1316
	goto __1318
__1318:
	;
	goto __1127

__1139:
	i = uint32(1)
__1338:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1340
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1341
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1342
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1343
	}
	return -2
__1343:
	;
__1342:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1341:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1344
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1345
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1346
__1345:
	if !(fc&0x10 == uint32(0)) {
		goto __1347
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1348
__1347:
	if !(fc&0x08 == uint32(0)) {
		goto __1349
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1350
__1349:
	if !(fc&0x04 == uint32(0)) {
		goto __1351
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1352
__1351:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1352:
	;
__1350:
	;
__1348:
	;
__1346:
	;
__1344:
	;

	if !(libc.Bool32(fc == uint32('\044') || fc == uint32('\100') || fc == uint32('\140') || fc >= uint32(0xa0) && fc <= uint32(0xd7ff) || fc >= uint32(0xe000)) == notmatch1) {
		goto __1353
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1353:
	;

	goto __1339
__1339:
	i++
	goto __1338
	goto __1340
__1340:
	;
	goto __1127

__1140:
	i = uint32(1)
__1354:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1356
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1357
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1358
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1359
	}
	return -2
__1359:
	;
__1358:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1357:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1360
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1361
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1362
__1361:
	if !(fc&0x10 == uint32(0)) {
		goto __1363
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1364
__1363:
	if !(fc&0x08 == uint32(0)) {
		goto __1365
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1366
__1365:
	if !(fc&0x04 == uint32(0)) {
		goto __1367
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1368
__1367:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1368:
	;
__1366:
	;
__1364:
	;
__1362:
	;
__1360:
	;

	if !(libc.Bool32(uint32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == notmatch1) {
		goto __1369
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1369:
	;

	goto __1355
__1355:
	i++
	goto __1354
	goto __1356
__1356:
	;
	goto __1127

__1141:
	i = uint32(1)
__1370:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1372
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1373
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1374
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1375
	}
	return -2
__1375:
	;
__1374:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1373:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1376
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1377
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1378
__1377:
	if !(fc&0x10 == uint32(0)) {
		goto __1379
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1380
__1379:
	if !(fc&0x08 == uint32(0)) {
		goto __1381
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1382
__1381:
	if !(fc&0x04 == uint32(0)) {
		goto __1383
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1384
__1383:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1384:
	;
__1382:
	;
__1380:
	;
__1378:
	;
__1376:
	;

	prop2 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok3 = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop2)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))/uint32(32))*4))&(uint32(1)<<(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))%uint32(32))) != uint32(0))
	if !(ok3 == notmatch1) {
		goto __1385
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1385:
	;

	goto __1371
__1371:
	i++
	goto __1370
	goto __1372
__1372:
	;
	goto __1127

	// This should not occur

__1142:
	return -44
__1127:
	;
	goto __1126
__1125:
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_EXTUNI) {
		goto __1386
	}

	i = uint32(1)
__1388:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1390
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1391
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1393
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1394
	}
	return -2
__1394:
	;
__1393:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	goto __1392
__1391:

	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1395
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1396
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1397
__1396:
	if !(fc&0x10 == uint32(0)) {
		goto __1398
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1399
__1398:
	if !(fc&0x08 == uint32(0)) {
		goto __1400
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1401
__1400:
	if !(fc&0x04 == uint32(0)) {
		goto __1402
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1403
__1402:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1403:
	;
__1401:
	;
__1399:
	;
__1397:
	;
__1395:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr = X_pcre2_extuni_8(tls, fc, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject,
		(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, utf, uintptr(0))
__1392:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1404
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1405
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1406
	}
	return -2
__1406:
	;
__1405:
	;
__1404:
	;

	goto __1389
__1389:
	i++
	goto __1388
	goto __1390
__1390:
	;
	goto __1387
__1386:

	// Handle all other cases in UTF mode

	if !(utf != 0) {
		goto __1407
	}
	switch *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __1410

	case OP_ALLANY:
		goto __1411

	case OP_ANYBYTE:
		goto __1412

	case OP_ANYNL:
		goto __1413

	case OP_NOT_HSPACE:
		goto __1414

	case OP_HSPACE:
		goto __1415

	case OP_NOT_VSPACE:
		goto __1416

	case OP_VSPACE:
		goto __1417

	case OP_NOT_DIGIT:
		goto __1418

	case OP_DIGIT:
		goto __1419

	case OP_NOT_WHITESPACE:
		goto __1420

	case OP_WHITESPACE:
		goto __1421

	case OP_NOT_WORDCHAR:
		goto __1422

	case OP_WORDCHAR:
		goto __1423

	default:
		goto __1424
	}
	goto __1409

__1410:
	i = uint32(1)
__1425:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1427
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1428
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1429
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1430
	}
	return -2
__1430:
	;
__1429:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1428:
	;
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __1431
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1431:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __1432
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1433
	}
	return -2
__1433:
	;
__1432:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1434:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __1435
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1434
__1435:
	;
	goto __1426
__1426:
	i++
	goto __1425
	goto __1427
__1427:
	;
	goto __1409

__1411:
	i = uint32(1)
__1436:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1438
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1439
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1440
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1441
	}
	return -2
__1441:
	;
__1440:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1439:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1442:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __1443
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1442
__1443:
	;
	goto __1437
__1437:
	i++
	goto __1436
	goto __1438
__1438:
	;
	goto __1409

__1412:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr(*(*uint32)(unsafe.Pointer(F + 56)))) {
		goto __1444
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1444:
	;

	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(*(*uint32)(unsafe.Pointer(F + 56)))
	goto __1409

__1413:
	i = uint32(1)
__1445:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1447
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1448
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1449
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1450
	}
	return -2
__1450:
	;
__1449:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1448:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1451
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1452
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1453
__1452:
	if !(fc&0x10 == uint32(0)) {
		goto __1454
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1455
__1454:
	if !(fc&0x08 == uint32(0)) {
		goto __1456
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1457
__1456:
	if !(fc&0x04 == uint32(0)) {
		goto __1458
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1459
__1458:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1459:
	;
__1457:
	;
__1455:
	;
__1453:
	;
__1451:
	;

	switch fc {
	default:
		goto __1461

	case uint32('\015'):
		goto __1462

	case uint32('\012'):
		goto __1463

	case uint32('\013'):
		goto __1464
	case uint32('\014'):
		goto __1465
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __1466
	case uint32(0x2028):
		goto __1467
	case uint32(0x2029):
		goto __1468
	}
	goto __1460

__1461:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1462:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __1469
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1469:
	;
	goto __1460

__1463:
	goto __1460

__1464:
__1465:
__1466:
__1467:
__1468:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __1470
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1470:
	;

	goto __1460
__1460:
	;
	goto __1446
__1446:
	i++
	goto __1445
	goto __1447
__1447:
	;
	goto __1409

__1414:
	i = uint32(1)
__1471:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1473
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1474
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1475
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1476
	}
	return -2
__1476:
	;
__1475:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1474:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1477
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1478
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1479
__1478:
	if !(fc&0x10 == uint32(0)) {
		goto __1480
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1481
__1480:
	if !(fc&0x08 == uint32(0)) {
		goto __1482
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1483
__1482:
	if !(fc&0x04 == uint32(0)) {
		goto __1484
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1485
__1484:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1485:
	;
__1483:
	;
__1481:
	;
__1479:
	;
__1477:
	;

	switch fc {
	case uint32('\011'):
		goto __1487
	case uint32('\040'):
		goto __1488
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __1489
	case uint32(0x1680):
		goto __1490 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __1491 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __1492 /* EN QUAD */
	case uint32(0x2001):
		goto __1493 /* EM QUAD */
	case uint32(0x2002):
		goto __1494 /* EN SPACE */
	case uint32(0x2003):
		goto __1495 /* EM SPACE */
	case uint32(0x2004):
		goto __1496 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __1497 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __1498 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __1499 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __1500 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __1501 /* THIN SPACE */
	case uint32(0x200A):
		goto __1502 /* HAIR SPACE */
	case uint32(0x202f):
		goto __1503 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __1504 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __1505
	default:
		goto __1506
	}
	goto __1486

__1487:
__1488:
__1489:
__1490: /* OGHAM SPACE MARK */
__1491: /* MONGOLIAN VOWEL SEPARATOR */
__1492: /* EN QUAD */
__1493: /* EM QUAD */
__1494: /* EN SPACE */
__1495: /* EM SPACE */
__1496: /* THREE-PER-EM SPACE */
__1497: /* FOUR-PER-EM SPACE */
__1498: /* SIX-PER-EM SPACE */
__1499: /* FIGURE SPACE */
__1500: /* PUNCTUATION SPACE */
__1501: /* THIN SPACE */
__1502: /* HAIR SPACE */
__1503: /* NARROW NO-BREAK SPACE */
__1504: /* MEDIUM MATHEMATICAL SPACE */
__1505:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1506:
	goto __1486
__1486:
	;
	goto __1472
__1472:
	i++
	goto __1471
	goto __1473
__1473:
	;
	goto __1409

__1415:
	i = uint32(1)
__1507:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1509
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1510
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1511
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1512
	}
	return -2
__1512:
	;
__1511:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1510:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1513
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1514
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1515
__1514:
	if !(fc&0x10 == uint32(0)) {
		goto __1516
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1517
__1516:
	if !(fc&0x08 == uint32(0)) {
		goto __1518
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1519
__1518:
	if !(fc&0x04 == uint32(0)) {
		goto __1520
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1521
__1520:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1521:
	;
__1519:
	;
__1517:
	;
__1515:
	;
__1513:
	;

	switch fc {
	case uint32('\011'):
		goto __1523
	case uint32('\040'):
		goto __1524
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __1525
	case uint32(0x1680):
		goto __1526 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __1527 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __1528 /* EN QUAD */
	case uint32(0x2001):
		goto __1529 /* EM QUAD */
	case uint32(0x2002):
		goto __1530 /* EN SPACE */
	case uint32(0x2003):
		goto __1531 /* EM SPACE */
	case uint32(0x2004):
		goto __1532 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __1533 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __1534 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __1535 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __1536 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __1537 /* THIN SPACE */
	case uint32(0x200A):
		goto __1538 /* HAIR SPACE */
	case uint32(0x202f):
		goto __1539 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __1540 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __1541
	default:
		goto __1542
	}
	goto __1522

__1523:
__1524:
__1525:
__1526: /* OGHAM SPACE MARK */
__1527: /* MONGOLIAN VOWEL SEPARATOR */
__1528: /* EN QUAD */
__1529: /* EM QUAD */
__1530: /* EN SPACE */
__1531: /* EM SPACE */
__1532: /* THREE-PER-EM SPACE */
__1533: /* FOUR-PER-EM SPACE */
__1534: /* SIX-PER-EM SPACE */
__1535: /* FIGURE SPACE */
__1536: /* PUNCTUATION SPACE */
__1537: /* THIN SPACE */
__1538: /* HAIR SPACE */
__1539: /* NARROW NO-BREAK SPACE */
__1540: /* MEDIUM MATHEMATICAL SPACE */
__1541:
	goto __1522
__1542:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1522:
	;
	goto __1508
__1508:
	i++
	goto __1507
	goto __1509
__1509:
	;
	goto __1409

__1416:
	i = uint32(1)
__1543:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1545
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1546
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1547
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1548
	}
	return -2
__1548:
	;
__1547:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1546:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1549
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1550
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1551
__1550:
	if !(fc&0x10 == uint32(0)) {
		goto __1552
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1553
__1552:
	if !(fc&0x08 == uint32(0)) {
		goto __1554
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1555
__1554:
	if !(fc&0x04 == uint32(0)) {
		goto __1556
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1557
__1556:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1557:
	;
__1555:
	;
__1553:
	;
__1551:
	;
__1549:
	;

	switch fc {
	case uint32('\012'):
		goto __1559
	case uint32('\013'):
		goto __1560
	case uint32('\014'):
		goto __1561
	case uint32('\015'):
		goto __1562
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __1563
	case uint32(0x2028):
		goto __1564 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __1565
	default:
		goto __1566
	}
	goto __1558

__1559:
__1560:
__1561:
__1562:
__1563:
__1564: /* LINE SEPARATOR */
__1565:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1566:
	goto __1558
__1558:
	;
	goto __1544
__1544:
	i++
	goto __1543
	goto __1545
__1545:
	;
	goto __1409

__1417:
	i = uint32(1)
__1567:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1569
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1570
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1571
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1572
	}
	return -2
__1572:
	;
__1571:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1570:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1573
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1574
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1575
__1574:
	if !(fc&0x10 == uint32(0)) {
		goto __1576
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1577
__1576:
	if !(fc&0x08 == uint32(0)) {
		goto __1578
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1579
__1578:
	if !(fc&0x04 == uint32(0)) {
		goto __1580
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1581
__1580:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1581:
	;
__1579:
	;
__1577:
	;
__1575:
	;
__1573:
	;

	switch fc {
	case uint32('\012'):
		goto __1583
	case uint32('\013'):
		goto __1584
	case uint32('\014'):
		goto __1585
	case uint32('\015'):
		goto __1586
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __1587
	case uint32(0x2028):
		goto __1588 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __1589
	default:
		goto __1590
	}
	goto __1582

__1583:
__1584:
__1585:
__1586:
__1587:
__1588: /* LINE SEPARATOR */
__1589:
	goto __1582
__1590:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1582:
	;
	goto __1568
__1568:
	i++
	goto __1567
	goto __1569
__1569:
	;
	goto __1409

__1418:
	i = uint32(1)
__1591:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1593
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1594
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1595
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1596
	}
	return -2
__1596:
	;
__1595:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1594:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __1597
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1598
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1599
__1598:
	if !(fc&0x10 == uint32(0)) {
		goto __1600
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1601
__1600:
	if !(fc&0x08 == uint32(0)) {
		goto __1602
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1603
__1602:
	if !(fc&0x04 == uint32(0)) {
		goto __1604
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1605
__1604:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1605:
	;
__1603:
	;
__1601:
	;
__1599:
	;
__1597:
	;

	if !(fc < uint32(128) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __1606
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1606:
	;

	goto __1592
__1592:
	i++
	goto __1591
	goto __1593
__1593:
	;
	goto __1409

__1419:
	i = uint32(1)
__1607:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1609
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1610
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1611
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1612
	}
	return -2
__1612:
	;
__1611:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1610:
	;
	cc5 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc5 >= uint32(128) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc5))))&Dctype_digit == 0) {
		goto __1613
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1613:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	// No need to skip more code units - we know it has only one.
	goto __1608
__1608:
	i++
	goto __1607
	goto __1609
__1609:
	;
	goto __1409

__1420:
	i = uint32(1)
__1614:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1616
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1617
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1618
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1619
	}
	return -2
__1619:
	;
__1618:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1617:
	;
	cc6 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc6 < uint32(128) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc6))))&Dctype_space != 0) {
		goto __1620
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1620:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1621:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __1622
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1621
__1622:
	;
	goto __1615
__1615:
	i++
	goto __1614
	goto __1616
__1616:
	;
	goto __1409

__1421:
	i = uint32(1)
__1623:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1625
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1626
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1627
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1628
	}
	return -2
__1628:
	;
__1627:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1626:
	;
	cc7 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc7 >= uint32(128) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc7))))&Dctype_space == 0) {
		goto __1629
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1629:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	// No need to skip more code units - we know it has only one.
	goto __1624
__1624:
	i++
	goto __1623
	goto __1625
__1625:
	;
	goto __1409

__1422:
	i = uint32(1)
__1630:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1632
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1633
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1634
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1635
	}
	return -2
__1635:
	;
__1634:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1633:
	;
	cc8 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc8 < uint32(128) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc8))))&Dctype_word != 0) {
		goto __1636
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1636:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1637:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __1638
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1637
__1638:
	;
	goto __1631
__1631:
	i++
	goto __1630
	goto __1632
__1632:
	;
	goto __1409

__1423:
	i = uint32(1)
__1639:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1641
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1642
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1643
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1644
	}
	return -2
__1644:
	;
__1643:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1642:
	;
	cc9 = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(cc9 >= uint32(128) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(cc9))))&Dctype_word == 0) {
		goto __1645
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1645:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	// No need to skip more code units - we know it has only one.
	goto __1640
__1640:
	i++
	goto __1639
	goto __1641
__1641:
	;
	goto __1409

__1424:
	return -44
__1409:
	;
	goto __1408
__1407:

	// Code for the non-UTF case for minimum matching of operators other
	//       than OP_PROP and OP_NOTPROP.

	switch *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __1647

	case OP_ALLANY:
		goto __1648

	// This OP_ANYBYTE case will never be reached because \C gets turned
	//         into OP_ALLANY in non-UTF mode. Cut out the code so that coverage
	//         reports don't complain about it's never being used.

	// case OP_ANYBYTE:
	//        if (Feptr > mb->end_subject - Lmin)
	//          {
	//          SCHECK_PARTIAL();
	//          RRETURN(MATCH_NOMATCH);
	//          }
	//        Feptr += Lmin;
	//        break;
	case OP_ANYNL:
		goto __1649

	case OP_NOT_HSPACE:
		goto __1650

	case OP_HSPACE:
		goto __1651

	case OP_NOT_VSPACE:
		goto __1652

	case OP_VSPACE:
		goto __1653

	case OP_NOT_DIGIT:
		goto __1654

	case OP_DIGIT:
		goto __1655

	case OP_NOT_WHITESPACE:
		goto __1656

	case OP_WHITESPACE:
		goto __1657

	case OP_NOT_WORDCHAR:
		goto __1658

	case OP_WORDCHAR:
		goto __1659

	default:
		goto __1660
	}
	goto __1646

__1647:
	i = uint32(1)
__1661:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1663
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1664
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1665
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1666
	}
	return -2
__1666:
	;
__1665:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1664:
	;
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __1667
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1667:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __1668
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1669
	}
	return -2
__1669:
	;
__1668:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1662
__1662:
	i++
	goto __1661
	goto __1663
__1663:
	;
	goto __1646

__1648:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr(*(*uint32)(unsafe.Pointer(F + 56)))) {
		goto __1670
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1671
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1672
	}
	return -2
__1672:
	;
__1671:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1670:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(*(*uint32)(unsafe.Pointer(F + 56)))
	goto __1646

	// This OP_ANYBYTE case will never be reached because \C gets turned
	//         into OP_ALLANY in non-UTF mode. Cut out the code so that coverage
	//         reports don't complain about it's never being used.

	// case OP_ANYBYTE:
	//        if (Feptr > mb->end_subject - Lmin)
	//          {
	//          SCHECK_PARTIAL();
	//          RRETURN(MATCH_NOMATCH);
	//          }
	//        Feptr += Lmin;
	//        break;
__1649:
	i = uint32(1)
__1673:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1675
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1676
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1677
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1678
	}
	return -2
__1678:
	;
__1677:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1676:
	;
	switch int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	default:
		goto __1680

	case '\015':
		goto __1681

	case '\012':
		goto __1682

	case '\013':
		goto __1683
	case '\014':
		goto __1684
	case int32(libc.Uint8FromInt32(133)):
		goto __1685
	}
	goto __1679

__1680:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1681:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __1686
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__1686:
	;
	goto __1679

__1682:
	goto __1679

__1683:
__1684:
__1685:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __1687
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1687:
	;

	goto __1679
__1679:
	;
	goto __1674
__1674:
	i++
	goto __1673
	goto __1675
__1675:
	;
	goto __1646

__1650:
	i = uint32(1)
__1688:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1690
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1691
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1692
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1693
	}
	return -2
__1693:
	;
__1692:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1691:
	;
	switch int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	default:
		goto __1695
	case '\011':
		goto __1696
	case '\040':
		goto __1697
	case int32(libc.Uint8FromInt32(160)):
		goto __1698
	}
	goto __1694

__1695:
	goto __1694
__1696:
__1697:
__1698:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1694:
	;
	goto __1689
__1689:
	i++
	goto __1688
	goto __1690
__1690:
	;
	goto __1646

__1651:
	i = uint32(1)
__1699:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1701
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1702
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1703
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1704
	}
	return -2
__1704:
	;
__1703:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1702:
	;
	switch int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	default:
		goto __1706
	case '\011':
		goto __1707
	case '\040':
		goto __1708
	case int32(libc.Uint8FromInt32(160)):
		goto __1709
	}
	goto __1705

__1706:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1707:
__1708:
__1709:
	goto __1705
__1705:
	;
	goto __1700
__1700:
	i++
	goto __1699
	goto __1701
__1701:
	;
	goto __1646

__1652:
	i = uint32(1)
__1710:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1712
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1713
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1714
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1715
	}
	return -2
__1715:
	;
__1714:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1713:
	;
	switch int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	case '\012':
		goto __1717
	case '\013':
		goto __1718
	case '\014':
		goto __1719
	case '\015':
		goto __1720
	case int32(libc.Uint8FromInt32(133)):
		goto __1721
	default:
		goto __1722
	}
	goto __1716

__1717:
__1718:
__1719:
__1720:
__1721:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1722:
	goto __1716
__1716:
	;
	goto __1711
__1711:
	i++
	goto __1710
	goto __1712
__1712:
	;
	goto __1646

__1653:
	i = uint32(1)
__1723:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1725
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1726
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1727
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1728
	}
	return -2
__1728:
	;
__1727:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1726:
	;
	switch int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1)))) {
	default:
		goto __1730
	case '\012':
		goto __1731
	case '\013':
		goto __1732
	case '\014':
		goto __1733
	case '\015':
		goto __1734
	case int32(libc.Uint8FromInt32(133)):
		goto __1735
	}
	goto __1729

__1730:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1731:
__1732:
__1733:
__1734:
__1735:
	goto __1729
__1729:
	;
	goto __1724
__1724:
	i++
	goto __1723
	goto __1725
__1725:
	;
	goto __1646

__1654:
	i = uint32(1)
__1736:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1738
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1739
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1740
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1741
	}
	return -2
__1741:
	;
__1740:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1739:
	;
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_digit != 0) {
		goto __1742
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1742:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1737
__1737:
	i++
	goto __1736
	goto __1738
__1738:
	;
	goto __1646

__1655:
	i = uint32(1)
__1743:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1745
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1746
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1747
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1748
	}
	return -2
__1748:
	;
__1747:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1746:
	;
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_digit == 0) {
		goto __1749
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1749:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1744
__1744:
	i++
	goto __1743
	goto __1745
__1745:
	;
	goto __1646

__1656:
	i = uint32(1)
__1750:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1752
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1753
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1754
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1755
	}
	return -2
__1755:
	;
__1754:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1753:
	;
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_space != 0) {
		goto __1756
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1756:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1751
__1751:
	i++
	goto __1750
	goto __1752
__1752:
	;
	goto __1646

__1657:
	i = uint32(1)
__1757:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1759
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1760
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1761
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1762
	}
	return -2
__1762:
	;
__1761:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1760:
	;
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_space == 0) {
		goto __1763
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1763:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1758
__1758:
	i++
	goto __1757
	goto __1759
__1759:
	;
	goto __1646

__1658:
	i = uint32(1)
__1764:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1766
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1767
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1768
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1769
	}
	return -2
__1769:
	;
__1768:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1767:
	;
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_word != 0) {
		goto __1770
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1770:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1765
__1765:
	i++
	goto __1764
	goto __1766
__1766:
	;
	goto __1646

__1659:
	i = uint32(1)
__1771:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __1773
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1774
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1775
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1776
	}
	return -2
__1776:
	;
__1775:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1774:
	;
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_word == 0) {
		goto __1777
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1777:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __1772
__1772:
	i++
	goto __1771
	goto __1773
__1773:
	;
	goto __1646

__1660:
	return -44
__1646:
	;
__1408:
	;
__1387:
	;
__1126:
	;
__1124:
	;

	// If Lmin = Lmax we are done. Continue with the main loop.

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1778
	}
	goto __10
__1778:
	;

	// If minimizing, we have to test the rest of the pattern before each
	//     subsequent match. This means we cannot use a local "notmatch" variable as
	//     in the other cases. As all 4 temporary 32-bit values in the frame are
	//     already in use, just test the type each time.

	if !(reptype == REPTYPE_MIN) {
		goto __1779
	}

	if !(proptype >= 0) {
		goto __1781
	}

	switch proptype {
	case DPT_ANY:
		goto __1784
	// Control never gets here

	case DPT_LAMP:
		goto __1785
	// Control never gets here

	case DPT_GC:
		goto __1786
	// Control never gets here

	case DPT_PC:
		goto __1787
	// Control never gets here

	case DPT_SC:
		goto __1788
	// Control never gets here

	case DPT_SCX:
		goto __1789
	// Control never gets here

	case DPT_ALNUM:
		goto __1790
	// Control never gets here

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __1791 // Perl space
	case DPT_PXSPACE:
		goto __1792
	// Control never gets here

	case DPT_WORD:
		goto __1793
	// Control never gets here

	case DPT_CLIST:
		goto __1794
	// Control never gets here

	case DPT_UCNC:
		goto __1795
	// Control never gets here

	case DPT_BIDICL:
		goto __1796
	// Control never gets here

	case DPT_BOOL:
		goto __1797
	// Control never gets here

	// This should never occur
	default:
		goto __1798
	}
	goto __1783

__1784:
__1799:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM208
	goto MATCH_RECURSE
L_RM208:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1802
	}
	rrc = rrc
	goto RETURN_SWITCH
__1802:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1803
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1803:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1804
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1805
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1806
	}
	return -2
__1806:
	;
__1805:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1804:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1807
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1808
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1809
__1808:
	if !(fc&0x10 == uint32(0)) {
		goto __1810
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1811
__1810:
	if !(fc&0x08 == uint32(0)) {
		goto __1812
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1813
__1812:
	if !(fc&0x04 == uint32(0)) {
		goto __1814
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1815
__1814:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1815:
	;
__1813:
	;
__1811:
	;
__1809:
	;
__1807:
	;

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __1816
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1816:
	;

	goto __1800
__1800:
	goto __1799
	goto __1801
__1801:
	;
	// Control never gets here

__1785:
__1817:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM209
	goto MATCH_RECURSE
L_RM209:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1820
	}
	rrc = rrc
	goto RETURN_SWITCH
__1820:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1821
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1821:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1822
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1823
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1824
	}
	return -2
__1824:
	;
__1823:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1822:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1825
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1826
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1827
__1826:
	if !(fc&0x10 == uint32(0)) {
		goto __1828
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1829
__1828:
	if !(fc&0x08 == uint32(0)) {
		goto __1830
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1831
__1830:
	if !(fc&0x04 == uint32(0)) {
		goto __1832
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1833
__1832:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1833:
	;
__1831:
	;
__1829:
	;
__1827:
	;
__1825:
	;

	chartype1 = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(libc.Bool32(chartype1 == ucp_Lu || chartype1 == ucp_Ll || chartype1 == ucp_Lt) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1834
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1834:
	;

	goto __1818
__1818:
	goto __1817
	goto __1819
__1819:
	;
	// Control never gets here

__1786:
__1835:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM210
	goto MATCH_RECURSE
L_RM210:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1838
	}
	rrc = rrc
	goto RETURN_SWITCH
__1838:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1839
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1839:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1840
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1841
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1842
	}
	return -2
__1842:
	;
__1841:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1840:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1843
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1844
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1845
__1844:
	if !(fc&0x10 == uint32(0)) {
		goto __1846
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1847
__1846:
	if !(fc&0x08 == uint32(0)) {
		goto __1848
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1849
__1848:
	if !(fc&0x04 == uint32(0)) {
		goto __1850
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1851
__1850:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1851:
	;
__1849:
	;
__1847:
	;
__1845:
	;
__1843:
	;

	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1852
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1852:
	;

	goto __1836
__1836:
	goto __1835
	goto __1837
__1837:
	;
	// Control never gets here

__1787:
__1853:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM211
	goto MATCH_RECURSE
L_RM211:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1856
	}
	rrc = rrc
	goto RETURN_SWITCH
__1856:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1857
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1857:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1858
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1859
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1860
	}
	return -2
__1860:
	;
__1859:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1858:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1861
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1862
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1863
__1862:
	if !(fc&0x10 == uint32(0)) {
		goto __1864
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1865
__1864:
	if !(fc&0x08 == uint32(0)) {
		goto __1866
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1867
__1866:
	if !(fc&0x04 == uint32(0)) {
		goto __1868
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1869
__1868:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1869:
	;
__1867:
	;
__1865:
	;
__1863:
	;
__1861:
	;

	if !(libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1870
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1870:
	;

	goto __1854
__1854:
	goto __1853
	goto __1855
__1855:
	;
	// Control never gets here

__1788:
__1871:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM212
	goto MATCH_RECURSE
L_RM212:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1874
	}
	rrc = rrc
	goto RETURN_SWITCH
__1874:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1875
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1875:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1876
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1877
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1878
	}
	return -2
__1878:
	;
__1877:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1876:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1879
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1880
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1881
__1880:
	if !(fc&0x10 == uint32(0)) {
		goto __1882
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1883
__1882:
	if !(fc&0x08 == uint32(0)) {
		goto __1884
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1885
__1884:
	if !(fc&0x04 == uint32(0)) {
		goto __1886
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1887
__1886:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1887:
	;
__1885:
	;
__1883:
	;
__1881:
	;
__1879:
	;

	if !(libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscript) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1888
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1888:
	;

	goto __1872
__1872:
	goto __1871
	goto __1873
__1873:
	;
	// Control never gets here

__1789:
__1889:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM225
	goto MATCH_RECURSE
L_RM225:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1892
	}
	rrc = rrc
	goto RETURN_SWITCH
__1892:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1893
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1893:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1894
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1895
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1896
	}
	return -2
__1896:
	;
__1895:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1894:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1897
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1898
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1899
__1898:
	if !(fc&0x10 == uint32(0)) {
		goto __1900
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1901
__1900:
	if !(fc&0x08 == uint32(0)) {
		goto __1902
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1903
__1902:
	if !(fc&0x04 == uint32(0)) {
		goto __1904
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1905
__1904:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1905:
	;
__1903:
	;
__1901:
	;
__1899:
	;
__1897:
	;

	prop3 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok4 = libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(prop3)).Fscript) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) ||
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop3)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))/uint32(32))*4))&(uint32(1)<<(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))%uint32(32))) != uint32(0))
	if !(ok4 == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1906
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1906:
	;

	goto __1890
__1890:
	goto __1889
	goto __1891
__1891:
	;
	// Control never gets here

__1790:
__1907:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM213
	goto MATCH_RECURSE
L_RM213:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1910
	}
	rrc = rrc
	goto RETURN_SWITCH
__1910:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1911
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1911:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1912
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1913
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1914
	}
	return -2
__1914:
	;
__1913:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1912:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1915
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1916
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1917
__1916:
	if !(fc&0x10 == uint32(0)) {
		goto __1918
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1919
__1918:
	if !(fc&0x08 == uint32(0)) {
		goto __1920
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1921
__1920:
	if !(fc&0x04 == uint32(0)) {
		goto __1922
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1923
__1922:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1923:
	;
__1921:
	;
__1919:
	;
__1917:
	;
__1915:
	;

	category2 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category2 == ucp_L || category2 == ucp_N) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1924
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1924:
	;

	goto __1908
__1908:
	goto __1907
	goto __1909
__1909:
	;
	// Control never gets here

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__1791: // Perl space
__1792: // POSIX space
__1925:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM214
	goto MATCH_RECURSE
L_RM214:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1928
	}
	rrc = rrc
	goto RETURN_SWITCH
__1928:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1929
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1929:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1930
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1931
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1932
	}
	return -2
__1932:
	;
__1931:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1930:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1933
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1934
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1935
__1934:
	if !(fc&0x10 == uint32(0)) {
		goto __1936
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1937
__1936:
	if !(fc&0x08 == uint32(0)) {
		goto __1938
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1939
__1938:
	if !(fc&0x04 == uint32(0)) {
		goto __1940
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1941
__1940:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1941:
	;
__1939:
	;
__1937:
	;
__1935:
	;
__1933:
	;

	switch fc {
	case uint32('\011'):
		goto __1943
	case uint32('\040'):
		goto __1944
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __1945
	case uint32(0x1680):
		goto __1946 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __1947 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __1948 /* EN QUAD */
	case uint32(0x2001):
		goto __1949 /* EM QUAD */
	case uint32(0x2002):
		goto __1950 /* EN SPACE */
	case uint32(0x2003):
		goto __1951 /* EM SPACE */
	case uint32(0x2004):
		goto __1952 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __1953 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __1954 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __1955 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __1956 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __1957 /* THIN SPACE */
	case uint32(0x200A):
		goto __1958 /* HAIR SPACE */
	case uint32(0x202f):
		goto __1959 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __1960 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __1961
	case uint32('\012'):
		goto __1962
	case uint32('\013'):
		goto __1963
	case uint32('\014'):
		goto __1964
	case uint32('\015'):
		goto __1965
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __1966
	case uint32(0x2028):
		goto __1967 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __1968

	default:
		goto __1969
	}
	goto __1942

__1943:
__1944:
__1945:
__1946: /* OGHAM SPACE MARK */
__1947: /* MONGOLIAN VOWEL SEPARATOR */
__1948: /* EN QUAD */
__1949: /* EM QUAD */
__1950: /* EN SPACE */
__1951: /* EM SPACE */
__1952: /* THREE-PER-EM SPACE */
__1953: /* FOUR-PER-EM SPACE */
__1954: /* SIX-PER-EM SPACE */
__1955: /* FIGURE SPACE */
__1956: /* PUNCTUATION SPACE */
__1957: /* THIN SPACE */
__1958: /* HAIR SPACE */
__1959: /* NARROW NO-BREAK SPACE */
__1960: /* MEDIUM MATHEMATICAL SPACE */
__1961:
__1962:
__1963:
__1964:
__1965:
__1966:
__1967: /* LINE SEPARATOR */
__1968:
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __1970
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1970:
	;

	goto __1942

__1969:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == ucp_Z) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1971
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1971:
	;

	goto __1942
__1942:
	;
	goto __1926
__1926:
	goto __1925
	goto __1927
__1927:
	;
	// Control never gets here

__1793:
__1972:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM215
	goto MATCH_RECURSE
L_RM215:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1975
	}
	rrc = rrc
	goto RETURN_SWITCH
__1975:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1976
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1976:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1977
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1978
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1979
	}
	return -2
__1979:
	;
__1978:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1977:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1980
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1981
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __1982
__1981:
	if !(fc&0x10 == uint32(0)) {
		goto __1983
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __1984
__1983:
	if !(fc&0x08 == uint32(0)) {
		goto __1985
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __1986
__1985:
	if !(fc&0x04 == uint32(0)) {
		goto __1987
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __1988
__1987:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__1988:
	;
__1986:
	;
__1984:
	;
__1982:
	;
__1980:
	;

	category3 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category3 == ucp_L || category3 == ucp_N || fc == uint32('\137')) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __1989
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1989:
	;

	goto __1973
__1973:
	goto __1972
	goto __1974
__1974:
	;
	// Control never gets here

__1794:
__1990:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM216
	goto MATCH_RECURSE
L_RM216:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __1993
	}
	rrc = rrc
	goto RETURN_SWITCH
__1993:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __1994
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__1994:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __1995
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __1996
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __1997
	}
	return -2
__1997:
	;
__1996:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__1995:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __1998
	}
	if !(fc&0x20 == uint32(0)) {
		goto __1999
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2000
__1999:
	if !(fc&0x10 == uint32(0)) {
		goto __2001
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2002
__2001:
	if !(fc&0x08 == uint32(0)) {
		goto __2003
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2004
__2003:
	if !(fc&0x04 == uint32(0)) {
		goto __2005
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2006
__2005:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__2006:
	;
__2004:
	;
__2002:
	;
__2000:
	;
__1998:
	;

	cp2 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4)))*4
__2007:

	if !(fc < *(*uint32)(unsafe.Pointer(cp2))) {
		goto __2010
	}

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __2011
	}
	goto __2009
__2011:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2010:
	;
	if !(fc == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&cp2, 4)))) {
		goto __2012
	}

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP) {
		goto __2013
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2013:
	;

	goto __2009
__2012:
	;
	goto __2008
__2008:
	goto __2007
	goto __2009
__2009:
	;
	goto __1991
__1991:
	goto __1990
	goto __1992
__1992:
	;
	// Control never gets here

__1795:
__2014:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM217
	goto MATCH_RECURSE
L_RM217:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2017
	}
	rrc = rrc
	goto RETURN_SWITCH
__2017:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2018
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2018:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2019
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2020
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2021
	}
	return -2
__2021:
	;
__2020:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2019:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2022
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2023
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2024
__2023:
	if !(fc&0x10 == uint32(0)) {
		goto __2025
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2026
__2025:
	if !(fc&0x08 == uint32(0)) {
		goto __2027
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2028
__2027:
	if !(fc&0x04 == uint32(0)) {
		goto __2029
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2030
__2029:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__2030:
	;
__2028:
	;
__2026:
	;
__2024:
	;
__2022:
	;

	if !(libc.Bool32(fc == uint32('\044') || fc == uint32('\100') || fc == uint32('\140') || fc >= uint32(0xa0) && fc <= uint32(0xd7ff) || fc >= uint32(0xe000)) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __2031
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2031:
	;

	goto __2015
__2015:
	goto __2014
	goto __2016
__2016:
	;
	// Control never gets here

__1796:
__2032:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM224
	goto MATCH_RECURSE
L_RM224:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2035
	}
	rrc = rrc
	goto RETURN_SWITCH
__2035:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2036
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2036:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2037
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2038
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2039
	}
	return -2
__2039:
	;
__2038:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2037:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2040
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2041
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2042
__2041:
	if !(fc&0x10 == uint32(0)) {
		goto __2043
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2044
__2043:
	if !(fc&0x08 == uint32(0)) {
		goto __2045
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2046
__2045:
	if !(fc&0x04 == uint32(0)) {
		goto __2047
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2048
__2047:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__2048:
	;
__2046:
	;
__2044:
	;
__2042:
	;
__2040:
	;

	if !(libc.Bool32(uint32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __2049
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2049:
	;

	goto __2033
__2033:
	goto __2032
	goto __2034
__2034:
	;
	// Control never gets here

__1797:
__2050:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM223
	goto MATCH_RECURSE
L_RM223:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2053
	}
	rrc = rrc
	goto RETURN_SWITCH
__2053:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2054
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2054:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2055
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2056
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2057
	}
	return -2
__2057:
	;
__2056:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2055:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2058
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2059
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2060
__2059:
	if !(fc&0x10 == uint32(0)) {
		goto __2061
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2062
__2061:
	if !(fc&0x08 == uint32(0)) {
		goto __2063
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2064
__2063:
	if !(fc&0x04 == uint32(0)) {
		goto __2065
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2066
__2065:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__2066:
	;
__2064:
	;
__2062:
	;
__2060:
	;
__2058:
	;

	prop4 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok5 = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop4)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))/uint32(32))*4))&(uint32(1)<<(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))%uint32(32))) != uint32(0))
	if !(ok5 == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)) {
		goto __2067
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2067:
	;

	goto __2051
__2051:
	goto __2050
	goto __2052
__2052:
	;
	// Control never gets here

	// This should never occur
__1798:
	return -44
__1783:
	;
	goto __1782
__1781:
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_EXTUNI) {
		goto __2068
	}

__2070:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM218
	goto MATCH_RECURSE
L_RM218:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2073
	}
	rrc = rrc
	goto RETURN_SWITCH
__2073:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2074
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2074:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2075
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2077
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2078
	}
	return -2
__2078:
	;
__2077:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	goto __2076
__2075:

	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2079
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2080
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2081
__2080:
	if !(fc&0x10 == uint32(0)) {
		goto __2082
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2083
__2082:
	if !(fc&0x08 == uint32(0)) {
		goto __2084
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2085
__2084:
	if !(fc&0x04 == uint32(0)) {
		goto __2086
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2087
__2086:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__2087:
	;
__2085:
	;
__2083:
	;
__2081:
	;
__2079:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr = X_pcre2_extuni_8(tls, fc, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject,
		utf, uintptr(0))
__2076:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2088
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2089
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2090
	}
	return -2
__2090:
	;
__2089:
	;
__2088:
	;

	goto __2071
__2071:
	goto __2070
	goto __2072
__2072:
	;
	goto __2069
__2068:

	// UTF mode for non-property testing character types.

	if !(utf != 0) {
		goto __2091
	}

__2093:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM219
	goto MATCH_RECURSE
L_RM219:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2096
	}
	rrc = rrc
	goto RETURN_SWITCH
__2096:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2097
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2097:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2098
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2099
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2100
	}
	return -2
__2100:
	;
__2099:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2098:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_ANY && func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __2101
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2101:
	;

	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(fc >= 0xc0) {
		goto __2102
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2103
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2104
__2103:
	if !(fc&0x10 == uint32(0)) {
		goto __2105
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2106
__2105:
	if !(fc&0x08 == uint32(0)) {
		goto __2107
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2108
__2107:
	if !(fc&0x04 == uint32(0)) {
		goto __2109
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2110
__2109:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__2110:
	;
__2108:
	;
__2106:
	;
__2104:
	;
__2102:
	;

	switch *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __2112

	case OP_ALLANY:
		goto __2113
	case OP_ANYBYTE:
		goto __2114

	case OP_ANYNL:
		goto __2115

	case OP_NOT_HSPACE:
		goto __2116

	case OP_HSPACE:
		goto __2117

	case OP_NOT_VSPACE:
		goto __2118

	case OP_VSPACE:
		goto __2119

	case OP_NOT_DIGIT:
		goto __2120

	case OP_DIGIT:
		goto __2121

	case OP_NOT_WHITESPACE:
		goto __2122

	case OP_WHITESPACE:
		goto __2123

	case OP_NOT_WORDCHAR:
		goto __2124

	case OP_WORDCHAR:
		goto __2125

	default:
		goto __2126
	}
	goto __2111

__2112: // This is the non-NL case
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && fc == uint32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __2127
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2128
	}
	return -2
__2128:
	;
__2127:
	;
	goto __2111

__2113:
__2114:
	goto __2111

__2115:
	switch fc {
	default:
		goto __2130

	case uint32('\015'):
		goto __2131

	case uint32('\012'):
		goto __2132

	case uint32('\013'):
		goto __2133
	case uint32('\014'):
		goto __2134
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __2135
	case uint32(0x2028):
		goto __2136
	case uint32(0x2029):
		goto __2137
	}
	goto __2129

__2130:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2131:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __2138
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2138:
	;
	goto __2129

__2132:
	goto __2129

__2133:
__2134:
__2135:
__2136:
__2137:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __2139
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2139:
	;

	goto __2129
__2129:
	;
	goto __2111

__2116:
	switch fc {
	case uint32('\011'):
		goto __2141
	case uint32('\040'):
		goto __2142
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __2143
	case uint32(0x1680):
		goto __2144 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __2145 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __2146 /* EN QUAD */
	case uint32(0x2001):
		goto __2147 /* EM QUAD */
	case uint32(0x2002):
		goto __2148 /* EN SPACE */
	case uint32(0x2003):
		goto __2149 /* EM SPACE */
	case uint32(0x2004):
		goto __2150 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __2151 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __2152 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __2153 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __2154 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __2155 /* THIN SPACE */
	case uint32(0x200A):
		goto __2156 /* HAIR SPACE */
	case uint32(0x202f):
		goto __2157 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __2158 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __2159
	default:
		goto __2160
	}
	goto __2140

__2141:
__2142:
__2143:
__2144: /* OGHAM SPACE MARK */
__2145: /* MONGOLIAN VOWEL SEPARATOR */
__2146: /* EN QUAD */
__2147: /* EM QUAD */
__2148: /* EN SPACE */
__2149: /* EM SPACE */
__2150: /* THREE-PER-EM SPACE */
__2151: /* FOUR-PER-EM SPACE */
__2152: /* SIX-PER-EM SPACE */
__2153: /* FIGURE SPACE */
__2154: /* PUNCTUATION SPACE */
__2155: /* THIN SPACE */
__2156: /* HAIR SPACE */
__2157: /* NARROW NO-BREAK SPACE */
__2158: /* MEDIUM MATHEMATICAL SPACE */
__2159:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2160:
	goto __2140
__2140:
	;
	goto __2111

__2117:
	switch fc {
	case uint32('\011'):
		goto __2162
	case uint32('\040'):
		goto __2163
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __2164
	case uint32(0x1680):
		goto __2165 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __2166 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __2167 /* EN QUAD */
	case uint32(0x2001):
		goto __2168 /* EM QUAD */
	case uint32(0x2002):
		goto __2169 /* EN SPACE */
	case uint32(0x2003):
		goto __2170 /* EM SPACE */
	case uint32(0x2004):
		goto __2171 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __2172 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __2173 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __2174 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __2175 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __2176 /* THIN SPACE */
	case uint32(0x200A):
		goto __2177 /* HAIR SPACE */
	case uint32(0x202f):
		goto __2178 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __2179 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __2180
	default:
		goto __2181
	}
	goto __2161

__2162:
__2163:
__2164:
__2165: /* OGHAM SPACE MARK */
__2166: /* MONGOLIAN VOWEL SEPARATOR */
__2167: /* EN QUAD */
__2168: /* EM QUAD */
__2169: /* EN SPACE */
__2170: /* EM SPACE */
__2171: /* THREE-PER-EM SPACE */
__2172: /* FOUR-PER-EM SPACE */
__2173: /* SIX-PER-EM SPACE */
__2174: /* FIGURE SPACE */
__2175: /* PUNCTUATION SPACE */
__2176: /* THIN SPACE */
__2177: /* HAIR SPACE */
__2178: /* NARROW NO-BREAK SPACE */
__2179: /* MEDIUM MATHEMATICAL SPACE */
__2180:
	goto __2161
__2181:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2161:
	;
	goto __2111

__2118:
	switch fc {
	case uint32('\012'):
		goto __2183
	case uint32('\013'):
		goto __2184
	case uint32('\014'):
		goto __2185
	case uint32('\015'):
		goto __2186
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __2187
	case uint32(0x2028):
		goto __2188 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __2189
	default:
		goto __2190
	}
	goto __2182

__2183:
__2184:
__2185:
__2186:
__2187:
__2188: /* LINE SEPARATOR */
__2189:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2190:
	goto __2182
__2182:
	;
	goto __2111

__2119:
	switch fc {
	case uint32('\012'):
		goto __2192
	case uint32('\013'):
		goto __2193
	case uint32('\014'):
		goto __2194
	case uint32('\015'):
		goto __2195
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __2196
	case uint32(0x2028):
		goto __2197 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __2198
	default:
		goto __2199
	}
	goto __2191

__2192:
__2193:
__2194:
__2195:
__2196:
__2197: /* LINE SEPARATOR */
__2198:
	goto __2191
__2199:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2191:
	;
	goto __2111

__2120:
	if !(fc < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __2200
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2200:
	;

	goto __2111

__2121:
	if !(fc >= uint32(256) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit == 0) {
		goto __2201
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2201:
	;

	goto __2111

__2122:
	if !(fc < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space != 0) {
		goto __2202
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2202:
	;

	goto __2111

__2123:
	if !(fc >= uint32(256) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space == 0) {
		goto __2203
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2203:
	;

	goto __2111

__2124:
	if !(fc < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0) {
		goto __2204
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2204:
	;

	goto __2111

__2125:
	if !(fc >= uint32(256) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word == 0) {
		goto __2205
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2205:
	;

	goto __2111

__2126:
	return -44
__2111:
	;
	goto __2094
__2094:
	goto __2093
	goto __2095
__2095:
	;
	goto __2092
__2091:

	/* Not UTF mode */

__2206:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM33
	goto MATCH_RECURSE
L_RM33:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2209
	}
	rrc = rrc
	goto RETURN_SWITCH
__2209:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2210
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2210:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2211
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2212
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2213
	}
	return -2
__2213:
	;
__2212:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2211:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_ANY && func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __2214
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2214:
	;

	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	switch *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __2216

	case OP_ALLANY:
		goto __2217
	case OP_ANYBYTE:
		goto __2218

	case OP_ANYNL:
		goto __2219

	case OP_NOT_HSPACE:
		goto __2220

	case OP_HSPACE:
		goto __2221

	case OP_NOT_VSPACE:
		goto __2222

	case OP_VSPACE:
		goto __2223

	case OP_NOT_DIGIT:
		goto __2224

	case OP_DIGIT:
		goto __2225

	case OP_NOT_WHITESPACE:
		goto __2226

	case OP_WHITESPACE:
		goto __2227

	case OP_NOT_WORDCHAR:
		goto __2228

	case OP_WORDCHAR:
		goto __2229

	default:
		goto __2230
	}
	goto __2215

__2216: // This is the non-NL case
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && fc == uint32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __2231
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2232
	}
	return -2
__2232:
	;
__2231:
	;
	goto __2215

__2217:
__2218:
	goto __2215

__2219:
	switch fc {
	default:
		goto __2234

	case uint32('\015'):
		goto __2235

	case uint32('\012'):
		goto __2236

	case uint32('\013'):
		goto __2237
	case uint32('\014'):
		goto __2238
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __2239
	}
	goto __2233

__2234:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2235:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __2240
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2240:
	;
	goto __2233

__2236:
	goto __2233

__2237:
__2238:
__2239:
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF) {
		goto __2241
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2241:
	;

	goto __2233
__2233:
	;
	goto __2215

__2220:
	switch fc {
	default:
		goto __2243
	case uint32('\011'):
		goto __2244
	case uint32('\040'):
		goto __2245
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __2246
	}
	goto __2242

__2243:
	goto __2242
__2244:
__2245:
__2246:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2242:
	;
	goto __2215

__2221:
	switch fc {
	default:
		goto __2248
	case uint32('\011'):
		goto __2249
	case uint32('\040'):
		goto __2250
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __2251
	}
	goto __2247

__2248:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2249:
__2250:
__2251:
	goto __2247
__2247:
	;
	goto __2215

__2222:
	switch fc {
	default:
		goto __2253
	case uint32('\012'):
		goto __2254
	case uint32('\013'):
		goto __2255
	case uint32('\014'):
		goto __2256
	case uint32('\015'):
		goto __2257
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __2258
	}
	goto __2252

__2253:
	goto __2252
__2254:
__2255:
__2256:
__2257:
__2258:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2252:
	;
	goto __2215

__2223:
	switch fc {
	default:
		goto __2260
	case uint32('\012'):
		goto __2261
	case uint32('\013'):
		goto __2262
	case uint32('\014'):
		goto __2263
	case uint32('\015'):
		goto __2264
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __2265
	}
	goto __2259

__2260:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2261:
__2262:
__2263:
__2264:
__2265:
	goto __2259
__2259:
	;
	goto __2215

__2224:
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __2266
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2266:
	;

	goto __2215

__2225:
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit == 0) {
		goto __2267
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2267:
	;

	goto __2215

__2226:
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space != 0) {
		goto __2268
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2268:
	;

	goto __2215

__2227:
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space == 0) {
		goto __2269
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2269:
	;

	goto __2215

__2228:
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0) {
		goto __2270
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2270:
	;

	goto __2215

__2229:
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word == 0) {
		goto __2271
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__2271:
	;

	goto __2215

__2230:
	return -44
__2215:
	;
	goto __2207
__2207:
	goto __2206
	goto __2208
__2208:
	;
__2092:
	;
__2069:
	;
__1782:
	;
	// Control never gets here
	goto __1780
__1779:

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr // Remember where we started

	if !(proptype >= 0) {
		goto __2272
	}
	notmatch2 = libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOTPROP)
	switch proptype {
	case DPT_ANY:
		goto __2275

	case DPT_LAMP:
		goto __2276

	case DPT_GC:
		goto __2277

	case DPT_PC:
		goto __2278

	case DPT_SC:
		goto __2279

	case DPT_SCX:
		goto __2280

	case DPT_ALNUM:
		goto __2281

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

	case DPT_SPACE:
		goto __2282 // Perl space
	case DPT_PXSPACE:
		goto __2283

	case DPT_WORD:
		goto __2284

	case DPT_CLIST:
		goto __2285

	case DPT_UCNC:
		goto __2286

	case DPT_BIDICL:
		goto __2287

	case DPT_BOOL:
		goto __2288

	default:
		goto __2289
	}
	goto __2274

__2275:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2290:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2292
	}

	len4 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2293
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2294
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2295
	}
	return -2
__2295:
	;
__2294:
	;

	goto __2292
__2293:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2296
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2297
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len4++
	goto __2298
__2297:
	if !(fc&0x10 == uint32(0)) {
		goto __2299
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len4 = len4 + 2
	goto __2300
__2299:
	if !(fc&0x08 == uint32(0)) {
		goto __2301
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len4 = len4 + 3
	goto __2302
__2301:
	if !(fc&0x04 == uint32(0)) {
		goto __2303
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len4 = len4 + 4
	goto __2304
__2303:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len4 = len4 + 5
__2304:
	;
__2302:
	;
__2300:
	;
__2298:
	;
__2296:
	;

	if !(notmatch2 != 0) {
		goto __2305
	}
	goto __2292
__2305:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len4)
	goto __2291
__2291:
	i++
	goto __2290
	goto __2292
__2292:
	;
	goto __2274

__2276:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2306:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2308
	}

	len5 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2309
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2310
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2311
	}
	return -2
__2311:
	;
__2310:
	;

	goto __2308
__2309:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2312
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2313
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len5++
	goto __2314
__2313:
	if !(fc&0x10 == uint32(0)) {
		goto __2315
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len5 = len5 + 2
	goto __2316
__2315:
	if !(fc&0x08 == uint32(0)) {
		goto __2317
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len5 = len5 + 3
	goto __2318
__2317:
	if !(fc&0x04 == uint32(0)) {
		goto __2319
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len5 = len5 + 4
	goto __2320
__2319:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len5 = len5 + 5
__2320:
	;
__2318:
	;
__2316:
	;
__2314:
	;
__2312:
	;

	chartype2 = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(libc.Bool32(chartype2 == ucp_Lu || chartype2 == ucp_Ll || chartype2 == ucp_Lt) == notmatch2) {
		goto __2321
	}
	goto __2308
__2321:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len5)
	goto __2307
__2307:
	i++
	goto __2306
	goto __2308
__2308:
	;
	goto __2274

__2277:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2322:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2324
	}

	len6 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2325
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2326
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2327
	}
	return -2
__2327:
	;
__2326:
	;

	goto __2324
__2325:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2328
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2329
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len6++
	goto __2330
__2329:
	if !(fc&0x10 == uint32(0)) {
		goto __2331
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len6 = len6 + 2
	goto __2332
__2331:
	if !(fc&0x08 == uint32(0)) {
		goto __2333
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len6 = len6 + 3
	goto __2334
__2333:
	if !(fc&0x04 == uint32(0)) {
		goto __2335
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len6 = len6 + 4
	goto __2336
__2335:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len6 = len6 + 5
__2336:
	;
__2334:
	;
__2332:
	;
__2330:
	;
__2328:
	;

	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == notmatch2) {
		goto __2337
	}
	goto __2324
__2337:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len6)
	goto __2323
__2323:
	i++
	goto __2322
	goto __2324
__2324:
	;
	goto __2274

__2278:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2338:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2340
	}

	len7 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2341
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2342
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2343
	}
	return -2
__2343:
	;
__2342:
	;

	goto __2340
__2341:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2344
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2345
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len7++
	goto __2346
__2345:
	if !(fc&0x10 == uint32(0)) {
		goto __2347
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len7 = len7 + 2
	goto __2348
__2347:
	if !(fc&0x08 == uint32(0)) {
		goto __2349
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len7 = len7 + 3
	goto __2350
__2349:
	if !(fc&0x04 == uint32(0)) {
		goto __2351
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len7 = len7 + 4
	goto __2352
__2351:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len7 = len7 + 5
__2352:
	;
__2350:
	;
__2348:
	;
__2346:
	;
__2344:
	;

	if !(libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == notmatch2) {
		goto __2353
	}
	goto __2340
__2353:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len7)
	goto __2339
__2339:
	i++
	goto __2338
	goto __2340
__2340:
	;
	goto __2274

__2279:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2354:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2356
	}

	len8 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2357
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2358
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2359
	}
	return -2
__2359:
	;
__2358:
	;

	goto __2356
__2357:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2360
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2361
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len8++
	goto __2362
__2361:
	if !(fc&0x10 == uint32(0)) {
		goto __2363
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len8 = len8 + 2
	goto __2364
__2363:
	if !(fc&0x08 == uint32(0)) {
		goto __2365
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len8 = len8 + 3
	goto __2366
__2365:
	if !(fc&0x04 == uint32(0)) {
		goto __2367
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len8 = len8 + 4
	goto __2368
__2367:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len8 = len8 + 5
__2368:
	;
__2366:
	;
__2364:
	;
__2362:
	;
__2360:
	;

	if !(libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscript) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == notmatch2) {
		goto __2369
	}
	goto __2356
__2369:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len8)
	goto __2355
__2355:
	i++
	goto __2354
	goto __2356
__2356:
	;
	goto __2274

__2280:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2370:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2372
	}

	len9 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2373
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2374
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2375
	}
	return -2
__2375:
	;
__2374:
	;

	goto __2372
__2373:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2376
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2377
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len9++
	goto __2378
__2377:
	if !(fc&0x10 == uint32(0)) {
		goto __2379
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len9 = len9 + 2
	goto __2380
__2379:
	if !(fc&0x08 == uint32(0)) {
		goto __2381
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len9 = len9 + 3
	goto __2382
__2381:
	if !(fc&0x04 == uint32(0)) {
		goto __2383
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len9 = len9 + 4
	goto __2384
__2383:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len9 = len9 + 5
__2384:
	;
__2382:
	;
__2380:
	;
__2378:
	;
__2376:
	;

	prop5 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok6 = libc.Bool32(uint32((*Tucd_record)(unsafe.Pointer(prop5)).Fscript) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4)) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop5)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))/uint32(32))*4))&(uint32(1)<<(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))%uint32(32))) != uint32(0))
	if !(ok6 == notmatch2) {
		goto __2385
	}
	goto __2372
__2385:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len9)
	goto __2371
__2371:
	i++
	goto __2370
	goto __2372
__2372:
	;
	goto __2274

__2281:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2386:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2388
	}

	len10 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2389
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2390
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2391
	}
	return -2
__2391:
	;
__2390:
	;

	goto __2388
__2389:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2392
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2393
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len10++
	goto __2394
__2393:
	if !(fc&0x10 == uint32(0)) {
		goto __2395
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len10 = len10 + 2
	goto __2396
__2395:
	if !(fc&0x08 == uint32(0)) {
		goto __2397
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len10 = len10 + 3
	goto __2398
__2397:
	if !(fc&0x04 == uint32(0)) {
		goto __2399
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len10 = len10 + 4
	goto __2400
__2399:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len10 = len10 + 5
__2400:
	;
__2398:
	;
__2396:
	;
__2394:
	;
__2392:
	;

	category4 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category4 == ucp_L || category4 == ucp_N) == notmatch2) {
		goto __2401
	}
	goto __2388
__2401:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len10)
	goto __2387
__2387:
	i++
	goto __2386
	goto __2388
__2388:
	;
	goto __2274

	// Perl space used to exclude VT, but from Perl 5.18 it is included,
	//           which means that Perl space and POSIX space are now identical. PCRE
	//           was changed at release 8.34.

__2282: // Perl space
__2283: // POSIX space
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2402:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2404
	}

	len11 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2405
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2406
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2407
	}
	return -2
__2407:
	;
__2406:
	;

	goto __2404
__2405:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2408
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2409
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len11++
	goto __2410
__2409:
	if !(fc&0x10 == uint32(0)) {
		goto __2411
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len11 = len11 + 2
	goto __2412
__2411:
	if !(fc&0x08 == uint32(0)) {
		goto __2413
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len11 = len11 + 3
	goto __2414
__2413:
	if !(fc&0x04 == uint32(0)) {
		goto __2415
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len11 = len11 + 4
	goto __2416
__2415:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len11 = len11 + 5
__2416:
	;
__2414:
	;
__2412:
	;
__2410:
	;
__2408:
	;

	switch fc {
	case uint32('\011'):
		goto __2418
	case uint32('\040'):
		goto __2419
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __2420
	case uint32(0x1680):
		goto __2421 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __2422 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __2423 /* EN QUAD */
	case uint32(0x2001):
		goto __2424 /* EM QUAD */
	case uint32(0x2002):
		goto __2425 /* EN SPACE */
	case uint32(0x2003):
		goto __2426 /* EM SPACE */
	case uint32(0x2004):
		goto __2427 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __2428 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __2429 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __2430 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __2431 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __2432 /* THIN SPACE */
	case uint32(0x200A):
		goto __2433 /* HAIR SPACE */
	case uint32(0x202f):
		goto __2434 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __2435 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __2436
	case uint32('\012'):
		goto __2437
	case uint32('\013'):
		goto __2438
	case uint32('\014'):
		goto __2439
	case uint32('\015'):
		goto __2440
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __2441
	case uint32(0x2028):
		goto __2442 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __2443

	default:
		goto __2444
	}
	goto __2417

__2418:
__2419:
__2420:
__2421: /* OGHAM SPACE MARK */
__2422: /* MONGOLIAN VOWEL SEPARATOR */
__2423: /* EN QUAD */
__2424: /* EM QUAD */
__2425: /* EN SPACE */
__2426: /* EM SPACE */
__2427: /* THREE-PER-EM SPACE */
__2428: /* FOUR-PER-EM SPACE */
__2429: /* SIX-PER-EM SPACE */
__2430: /* FIGURE SPACE */
__2431: /* PUNCTUATION SPACE */
__2432: /* THIN SPACE */
__2433: /* HAIR SPACE */
__2434: /* NARROW NO-BREAK SPACE */
__2435: /* MEDIUM MATHEMATICAL SPACE */
__2436:
__2437:
__2438:
__2439:
__2440:
__2441:
__2442: /* LINE SEPARATOR */
__2443:
	if !(notmatch2 != 0) {
		goto __2445
	}
	goto ENDLOOP99
__2445:
	; // Break the loop
	goto __2417

__2444:
	if !(libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype] == ucp_Z) == notmatch2) {
		goto __2446
	}
	goto ENDLOOP99
__2446:
	; // Break the loop
	goto __2417
__2417:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len11)
	goto __2403
__2403:
	i++
	goto __2402
	goto __2404
__2404:
	;
ENDLOOP99:
	goto __2274

__2284:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2447:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2449
	}

	len12 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2450
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2451
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2452
	}
	return -2
__2452:
	;
__2451:
	;

	goto __2449
__2450:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2453
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2454
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len12++
	goto __2455
__2454:
	if !(fc&0x10 == uint32(0)) {
		goto __2456
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len12 = len12 + 2
	goto __2457
__2456:
	if !(fc&0x08 == uint32(0)) {
		goto __2458
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len12 = len12 + 3
	goto __2459
__2458:
	if !(fc&0x04 == uint32(0)) {
		goto __2460
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len12 = len12 + 4
	goto __2461
__2460:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len12 = len12 + 5
__2461:
	;
__2459:
	;
__2457:
	;
__2455:
	;
__2453:
	;

	category5 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	if !(libc.Bool32(category5 == ucp_L || category5 == ucp_N || fc == uint32('\137')) == notmatch2) {
		goto __2462
	}
	goto __2449
__2462:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len12)
	goto __2448
__2448:
	i++
	goto __2447
	goto __2449
__2449:
	;
	goto __2274

__2285:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2463:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2465
	}

	len13 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2466
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2467
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2468
	}
	return -2
__2468:
	;
__2467:
	;

	goto __2465
__2466:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2469
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2470
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len13++
	goto __2471
__2470:
	if !(fc&0x10 == uint32(0)) {
		goto __2472
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len13 = len13 + 2
	goto __2473
__2472:
	if !(fc&0x08 == uint32(0)) {
		goto __2474
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len13 = len13 + 3
	goto __2475
__2474:
	if !(fc&0x04 == uint32(0)) {
		goto __2476
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len13 = len13 + 4
	goto __2477
__2476:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len13 = len13 + 5
__2477:
	;
__2475:
	;
__2473:
	;
__2471:
	;
__2469:
	;

	cp3 = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4)))*4
__2478:

	if !(fc < *(*uint32)(unsafe.Pointer(cp3))) {
		goto __2481
	}
	if !(notmatch2 != 0) {
		goto __2482
	}
	goto __2480
	goto __2483
__2482:
	goto GOT_MAX
__2483:
	;
__2481:
	;
	if !(fc == *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&cp3, 4)))) {
		goto __2484
	}
	if !(notmatch2 != 0) {
		goto __2485
	}
	goto GOT_MAX
	goto __2486
__2485:
	goto __2480
__2486:
	;
__2484:
	;
	goto __2479
__2479:
	goto __2478
	goto __2480
__2480:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len13)
	goto __2464
__2464:
	i++
	goto __2463
	goto __2465
__2465:
	;
GOT_MAX:
	goto __2274

__2286:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2487:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2489
	}

	len14 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2490
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2491
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2492
	}
	return -2
__2492:
	;
__2491:
	;

	goto __2489
__2490:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2493
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2494
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len14++
	goto __2495
__2494:
	if !(fc&0x10 == uint32(0)) {
		goto __2496
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len14 = len14 + 2
	goto __2497
__2496:
	if !(fc&0x08 == uint32(0)) {
		goto __2498
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len14 = len14 + 3
	goto __2499
__2498:
	if !(fc&0x04 == uint32(0)) {
		goto __2500
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len14 = len14 + 4
	goto __2501
__2500:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len14 = len14 + 5
__2501:
	;
__2499:
	;
__2497:
	;
__2495:
	;
__2493:
	;

	if !(libc.Bool32(fc == uint32('\044') || fc == uint32('\100') || fc == uint32('\140') || fc >= uint32(0xa0) && fc <= uint32(0xd7ff) || fc >= uint32(0xe000)) == notmatch2) {
		goto __2502
	}
	goto __2489
__2502:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len14)
	goto __2488
__2488:
	i++
	goto __2487
	goto __2489
__2489:
	;
	goto __2274

__2287:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2503:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2505
	}

	len15 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2506
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2507
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2508
	}
	return -2
__2508:
	;
__2507:
	;

	goto __2505
__2506:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2509
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2510
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len15++
	goto __2511
__2510:
	if !(fc&0x10 == uint32(0)) {
		goto __2512
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len15 = len15 + 2
	goto __2513
__2512:
	if !(fc&0x08 == uint32(0)) {
		goto __2514
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len15 = len15 + 3
	goto __2515
__2514:
	if !(fc&0x04 == uint32(0)) {
		goto __2516
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len15 = len15 + 4
	goto __2517
__2516:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len15 = len15 + 5
__2517:
	;
__2515:
	;
__2513:
	;
__2511:
	;
__2509:
	;

	if !(libc.Bool32(uint32(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT) == *(*uint32)(unsafe.Pointer(F + 56 + 3*4))) == notmatch2) {
		goto __2518
	}
	goto __2505
__2518:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len15)
	goto __2504
__2504:
	i++
	goto __2503
	goto __2505
__2505:
	;
	goto __2274

__2288:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2519:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2521
	}

	len16 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2522
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2523
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2524
	}
	return -2
__2524:
	;
__2523:
	;

	goto __2521
__2522:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2525
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2526
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len16++
	goto __2527
__2526:
	if !(fc&0x10 == uint32(0)) {
		goto __2528
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len16 = len16 + 2
	goto __2529
__2528:
	if !(fc&0x08 == uint32(0)) {
		goto __2530
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len16 = len16 + 3
	goto __2531
__2530:
	if !(fc&0x04 == uint32(0)) {
		goto __2532
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len16 = len16 + 4
	goto __2533
__2532:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len16 = len16 + 5
__2533:
	;
__2531:
	;
__2529:
	;
__2527:
	;
__2525:
	;

	prop6 = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12
	ok7 = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop6)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))/uint32(32))*4))&(uint32(1)<<(*(*uint32)(unsafe.Pointer(F + 56 + 3*4))%uint32(32))) != uint32(0))
	if !(ok7 == notmatch2) {
		goto __2534
	}
	goto __2521
__2534:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len16)
	goto __2520
__2520:
	i++
	goto __2519
	goto __2521
__2521:
	;
	goto __2274

__2289:
	return -44
__2274:
	;

	// Feptr is now past the end of the maximum run

	if !(reptype == REPTYPE_POS) {
		goto __2535
	}
	goto __10
__2535:
	; // No backtracking

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//         Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
	//         go too far.

__2536:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __2539
	}
	goto __2538
__2539:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM222
	goto MATCH_RECURSE
L_RM222:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2540
	}
	rrc = rrc
	goto RETURN_SWITCH
__2540:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !(utf != 0) {
		goto __2541
	}
__2542:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2543
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __2542
__2543:
	;
__2541:
	;
	goto __2537
__2537:
	goto __2536
	goto __2538
__2538:
	;
	goto __2273
__2272:
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_EXTUNI) {
		goto __2544
	}

	i = *(*uint32)(unsafe.Pointer(F + 56))
__2546:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2548
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2549
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2551
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2552
	}
	return -2
__2552:
	;
__2551:
	;

	goto __2548
	goto __2550
__2549:

	fc = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))
	if !(utf != 0 && fc >= 0xc0) {
		goto __2553
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2554
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1))))&0x3f
	goto __2555
__2554:
	if !(fc&0x10 == uint32(0)) {
		goto __2556
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(2)
	goto __2557
__2556:
	if !(fc&0x08 == uint32(0)) {
		goto __2558
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(3)
	goto __2559
__2558:
	if !(fc&0x04 == uint32(0)) {
		goto __2560
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(4)
	goto __2561
__2560:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(5)
__2561:
	;
__2559:
	;
__2557:
	;
__2555:
	;
__2553:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr = X_pcre2_extuni_8(tls, fc, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject,
		utf, uintptr(0))
__2550:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2562
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2563
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2564
	}
	return -2
__2564:
	;
__2563:
	;
__2562:
	;

	goto __2547
__2547:
	i++
	goto __2546
	goto __2548
__2548:
	;

	// Feptr is now past the end of the maximum run

	if !(reptype == REPTYPE_POS) {
		goto __2565
	}
	goto __10
__2565:
	; // No backtracking

	// We use <= Lstart_eptr rather than == Lstart_eptr to detect the start
	//         of the run while backtracking because the use of \C in UTF mode can
	//         cause BACKCHAR to move back past Lstart_eptr. This is just palliative;
	//         the use of \C in UTF mode is fraught with danger.

__2566:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __2569
	}
	goto __2568
__2569:
	; /* At start of char run */
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM220
	goto MATCH_RECURSE
L_RM220:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2570
	}
	rrc = rrc
	goto RETURN_SWITCH
__2570:
	;

	// Backtracking over an extended grapheme cluster involves inspecting
	//           the previous two characters (if present) to see if a break is
	//           permitted between them.

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !!(utf != 0) {
		goto __2571
	}
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	goto __2572
__2571:

__2573:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2574
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __2573
__2574:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2575
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2576
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	goto __2577
__2576:
	if !(fc&0x10 == uint32(0)) {
		goto __2578
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	goto __2579
__2578:
	if !(fc&0x08 == uint32(0)) {
		goto __2580
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	goto __2581
__2580:
	if !(fc&0x04 == uint32(0)) {
		goto __2582
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	goto __2583
__2582:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
__2583:
	;
__2581:
	;
__2579:
	;
__2577:
	;
__2575:
	;

__2572:
	;
	rgb = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fgbprop)

__2584:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __2587
	}
	goto __2586
__2587:
	; // At start of char run
	fptr = (*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr(1)
	if !!(utf != 0) {
		goto __2588
	}
	fc = uint32(*(*uint8)(unsafe.Pointer(fptr)))
	goto __2589
__2588:

__2590:
	if !(uint32(*(*uint8)(unsafe.Pointer(fptr)))&0xc0 == 0x80) {
		goto __2591
	}
	fptr--
	goto __2590
__2591:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(fptr)))
	if !(fc >= 0xc0) {
		goto __2592
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2593
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(fptr + 1)))&0x3f
	goto __2594
__2593:
	if !(fc&0x10 == uint32(0)) {
		goto __2595
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(fptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(fptr + 2)))&0x3f
	goto __2596
__2595:
	if !(fc&0x08 == uint32(0)) {
		goto __2597
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(fptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(fptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(fptr + 3)))&0x3f
	goto __2598
__2597:
	if !(fc&0x04 == uint32(0)) {
		goto __2599
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(fptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(fptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(fptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(fptr + 4)))&0x3f
	goto __2600
__2599:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(fptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(fptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(fptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(fptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(fptr + 5)))&0x3f
__2600:
	;
__2598:
	;
__2596:
	;
__2594:
	;
__2592:
	;

__2589:
	;
	lgb = int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fgbprop)
	if !(X_pcre2_ucp_gbtable_8[lgb]&(uint32(1)<<rgb) == uint32(0)) {
		goto __2601
	}
	goto __2586
__2601:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr = fptr
	rgb = lgb
	goto __2585
__2585:
	goto __2584
	goto __2586
__2586:
	;
	goto __2567
__2567:
	goto __2566
	goto __2568
__2568:
	;
	goto __2545
__2544:

	if !(utf != 0) {
		goto __2602
	}

	switch *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __2605

	case OP_ALLANY:
		goto __2606

	// The "byte" (i.e. "code unit") case is the same as non-UTF

	case OP_ANYBYTE:
		goto __2607

	case OP_ANYNL:
		goto __2608

	case OP_NOT_HSPACE:
		goto __2609
	case OP_HSPACE:
		goto __2610

	case OP_NOT_VSPACE:
		goto __2611
	case OP_VSPACE:
		goto __2612

	case OP_NOT_DIGIT:
		goto __2613

	case OP_DIGIT:
		goto __2614

	case OP_NOT_WHITESPACE:
		goto __2615

	case OP_WHITESPACE:
		goto __2616

	case OP_NOT_WORDCHAR:
		goto __2617

	case OP_WORDCHAR:
		goto __2618

	default:
		goto __2619
	}
	goto __2604

__2605:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2620:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2622
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2623
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2624
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2625
	}
	return -2
__2625:
	;
__2624:
	;

	goto __2622
__2623:
	;
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __2626
	}
	goto __2622
__2626:
	;
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __2627
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2628
	}
	return -2
__2628:
	;
__2627:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2629:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2630
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2629
__2630:
	;
	goto __2621
__2621:
	i++
	goto __2620
	goto __2622
__2622:
	;
	goto __2604

__2606:
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) < 4294967295) {
		goto __2631
	}

	i = *(*uint32)(unsafe.Pointer(F + 56))
__2633:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2635
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2636
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2637
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2638
	}
	return -2
__2638:
	;
__2637:
	;

	goto __2635
__2636:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2639:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2640
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2639
__2640:
	;
	goto __2634
__2634:
	i++
	goto __2633
	goto __2635
__2635:
	;
	goto __2632
__2631:

	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject // Unlimited UTF-8 repeat
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2641
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2642
	}
	return -2
__2642:
	;
__2641:
	;

__2632:
	;
	goto __2604

	// The "byte" (i.e. "code unit") case is the same as non-UTF

__2607:
	fc = *(*uint32)(unsafe.Pointer(F + 56 + 1*4)) - *(*uint32)(unsafe.Pointer(F + 56))
	if !(fc > uint32((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64((*Theapframe)(unsafe.Pointer(F)).Feptr))/1)) {
		goto __2643
	}

	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2645
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2646
	}
	return -2
__2646:
	;
__2645:
	;

	goto __2644
__2643:
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(fc)
__2644:
	;
	goto __2604

__2608:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2647:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2649
	}

	len17 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2650
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2651
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2652
	}
	return -2
__2652:
	;
__2651:
	;

	goto __2649
__2650:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2653
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2654
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len17++
	goto __2655
__2654:
	if !(fc&0x10 == uint32(0)) {
		goto __2656
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len17 = len17 + 2
	goto __2657
__2656:
	if !(fc&0x08 == uint32(0)) {
		goto __2658
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len17 = len17 + 3
	goto __2659
__2658:
	if !(fc&0x04 == uint32(0)) {
		goto __2660
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len17 = len17 + 4
	goto __2661
__2660:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len17 = len17 + 5
__2661:
	;
__2659:
	;
__2657:
	;
__2655:
	;
__2653:
	;

	if !(fc == uint32('\015')) {
		goto __2662
	}

	if !(libc.PreIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2664
	}
	goto __2649
__2664:
	;
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __2665
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2665:
	;
	goto __2663
__2662:

	if !(fc != uint32('\012') && (int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF || fc != uint32('\013') && fc != uint32('\014') && fc != libc.Uint32FromUint8(libc.Uint8FromInt32(133)) &&
		fc != uint32(0x2028) && fc != uint32(0x2029))) {
		goto __2666
	}
	goto __2649
__2666:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len17)
__2663:
	;
	goto __2648
__2648:
	i++
	goto __2647
	goto __2649
__2649:
	;
	goto __2604

__2609:
__2610:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2667:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2669
	}

	len18 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2670
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2671
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2672
	}
	return -2
__2672:
	;
__2671:
	;

	goto __2669
__2670:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2673
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2674
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len18++
	goto __2675
__2674:
	if !(fc&0x10 == uint32(0)) {
		goto __2676
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len18 = len18 + 2
	goto __2677
__2676:
	if !(fc&0x08 == uint32(0)) {
		goto __2678
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len18 = len18 + 3
	goto __2679
__2678:
	if !(fc&0x04 == uint32(0)) {
		goto __2680
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len18 = len18 + 4
	goto __2681
__2680:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len18 = len18 + 5
__2681:
	;
__2679:
	;
__2677:
	;
__2675:
	;
__2673:
	;

	switch fc {
	case uint32('\011'):
		goto __2683
	case uint32('\040'):
		goto __2684
	case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
		goto __2685
	case uint32(0x1680):
		goto __2686 /* OGHAM SPACE MARK */
	case uint32(0x180e):
		goto __2687 /* MONGOLIAN VOWEL SEPARATOR */
	case uint32(0x2000):
		goto __2688 /* EN QUAD */
	case uint32(0x2001):
		goto __2689 /* EM QUAD */
	case uint32(0x2002):
		goto __2690 /* EN SPACE */
	case uint32(0x2003):
		goto __2691 /* EM SPACE */
	case uint32(0x2004):
		goto __2692 /* THREE-PER-EM SPACE */
	case uint32(0x2005):
		goto __2693 /* FOUR-PER-EM SPACE */
	case uint32(0x2006):
		goto __2694 /* SIX-PER-EM SPACE */
	case uint32(0x2007):
		goto __2695 /* FIGURE SPACE */
	case uint32(0x2008):
		goto __2696 /* PUNCTUATION SPACE */
	case uint32(0x2009):
		goto __2697 /* THIN SPACE */
	case uint32(0x200A):
		goto __2698 /* HAIR SPACE */
	case uint32(0x202f):
		goto __2699 /* NARROW NO-BREAK SPACE */
	case uint32(0x205f):
		goto __2700 /* MEDIUM MATHEMATICAL SPACE */
	case uint32(0x3000):
		goto __2701
	default:
		goto __2702
	}
	goto __2682

__2683:
__2684:
__2685:
__2686: /* OGHAM SPACE MARK */
__2687: /* MONGOLIAN VOWEL SEPARATOR */
__2688: /* EN QUAD */
__2689: /* EM QUAD */
__2690: /* EN SPACE */
__2691: /* EM SPACE */
__2692: /* THREE-PER-EM SPACE */
__2693: /* FOUR-PER-EM SPACE */
__2694: /* SIX-PER-EM SPACE */
__2695: /* FIGURE SPACE */
__2696: /* PUNCTUATION SPACE */
__2697: /* THIN SPACE */
__2698: /* HAIR SPACE */
__2699: /* NARROW NO-BREAK SPACE */
__2700: /* MEDIUM MATHEMATICAL SPACE */
__2701:
	gotspace = DTRUE
	goto __2682
__2702:
	gotspace = DFALSE
	goto __2682
__2682:
	;
	if !(gotspace == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOT_HSPACE)) {
		goto __2703
	}
	goto __2669
__2703:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len18)
	goto __2668
__2668:
	i++
	goto __2667
	goto __2669
__2669:
	;
	goto __2604

__2611:
__2612:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2704:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2706
	}

	len19 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2707
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2708
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2709
	}
	return -2
__2709:
	;
__2708:
	;

	goto __2706
__2707:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2710
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2711
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len19++
	goto __2712
__2711:
	if !(fc&0x10 == uint32(0)) {
		goto __2713
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len19 = len19 + 2
	goto __2714
__2713:
	if !(fc&0x08 == uint32(0)) {
		goto __2715
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len19 = len19 + 3
	goto __2716
__2715:
	if !(fc&0x04 == uint32(0)) {
		goto __2717
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len19 = len19 + 4
	goto __2718
__2717:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len19 = len19 + 5
__2718:
	;
__2716:
	;
__2714:
	;
__2712:
	;
__2710:
	;

	switch fc {
	case uint32('\012'):
		goto __2720
	case uint32('\013'):
		goto __2721
	case uint32('\014'):
		goto __2722
	case uint32('\015'):
		goto __2723
	case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
		goto __2724
	case uint32(0x2028):
		goto __2725 /* LINE SEPARATOR */
	case uint32(0x2029):
		goto __2726
	default:
		goto __2727
	}
	goto __2719

__2720:
__2721:
__2722:
__2723:
__2724:
__2725: /* LINE SEPARATOR */
__2726:
	gotspace1 = DTRUE
	goto __2719
__2727:
	gotspace1 = DFALSE
	goto __2719
__2719:
	;
	if !(gotspace1 == libc.Bool32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_NOT_VSPACE)) {
		goto __2728
	}
	goto __2706
__2728:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len19)
	goto __2705
__2705:
	i++
	goto __2704
	goto __2706
__2706:
	;
	goto __2604

__2613:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2729:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2731
	}

	len20 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2732
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2733
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2734
	}
	return -2
__2734:
	;
__2733:
	;

	goto __2731
__2732:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2735
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2736
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len20++
	goto __2737
__2736:
	if !(fc&0x10 == uint32(0)) {
		goto __2738
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len20 = len20 + 2
	goto __2739
__2738:
	if !(fc&0x08 == uint32(0)) {
		goto __2740
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len20 = len20 + 3
	goto __2741
__2740:
	if !(fc&0x04 == uint32(0)) {
		goto __2742
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len20 = len20 + 4
	goto __2743
__2742:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len20 = len20 + 5
__2743:
	;
__2741:
	;
__2739:
	;
__2737:
	;
__2735:
	;

	if !(fc < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit != 0) {
		goto __2744
	}
	goto __2731
__2744:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len20)
	goto __2730
__2730:
	i++
	goto __2729
	goto __2731
__2731:
	;
	goto __2604

__2614:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2745:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2747
	}

	len21 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2748
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2749
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2750
	}
	return -2
__2750:
	;
__2749:
	;

	goto __2747
__2748:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2751
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2752
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len21++
	goto __2753
__2752:
	if !(fc&0x10 == uint32(0)) {
		goto __2754
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len21 = len21 + 2
	goto __2755
__2754:
	if !(fc&0x08 == uint32(0)) {
		goto __2756
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len21 = len21 + 3
	goto __2757
__2756:
	if !(fc&0x04 == uint32(0)) {
		goto __2758
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len21 = len21 + 4
	goto __2759
__2758:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len21 = len21 + 5
__2759:
	;
__2757:
	;
__2755:
	;
__2753:
	;
__2751:
	;

	if !(fc >= uint32(256) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_digit == 0) {
		goto __2760
	}
	goto __2747
__2760:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len21)
	goto __2746
__2746:
	i++
	goto __2745
	goto __2747
__2747:
	;
	goto __2604

__2615:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2761:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2763
	}

	len22 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2764
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2765
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2766
	}
	return -2
__2766:
	;
__2765:
	;

	goto __2763
__2764:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2767
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2768
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len22++
	goto __2769
__2768:
	if !(fc&0x10 == uint32(0)) {
		goto __2770
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len22 = len22 + 2
	goto __2771
__2770:
	if !(fc&0x08 == uint32(0)) {
		goto __2772
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len22 = len22 + 3
	goto __2773
__2772:
	if !(fc&0x04 == uint32(0)) {
		goto __2774
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len22 = len22 + 4
	goto __2775
__2774:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len22 = len22 + 5
__2775:
	;
__2773:
	;
__2771:
	;
__2769:
	;
__2767:
	;

	if !(fc < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space != 0) {
		goto __2776
	}
	goto __2763
__2776:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len22)
	goto __2762
__2762:
	i++
	goto __2761
	goto __2763
__2763:
	;
	goto __2604

__2616:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2777:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2779
	}

	len23 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2780
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2781
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2782
	}
	return -2
__2782:
	;
__2781:
	;

	goto __2779
__2780:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2783
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2784
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len23++
	goto __2785
__2784:
	if !(fc&0x10 == uint32(0)) {
		goto __2786
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len23 = len23 + 2
	goto __2787
__2786:
	if !(fc&0x08 == uint32(0)) {
		goto __2788
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len23 = len23 + 3
	goto __2789
__2788:
	if !(fc&0x04 == uint32(0)) {
		goto __2790
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len23 = len23 + 4
	goto __2791
__2790:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len23 = len23 + 5
__2791:
	;
__2789:
	;
__2787:
	;
__2785:
	;
__2783:
	;

	if !(fc >= uint32(256) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_space == 0) {
		goto __2792
	}
	goto __2779
__2792:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len23)
	goto __2778
__2778:
	i++
	goto __2777
	goto __2779
__2779:
	;
	goto __2604

__2617:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2793:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2795
	}

	len24 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2796
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2797
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2798
	}
	return -2
__2798:
	;
__2797:
	;

	goto __2795
__2796:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2799
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2800
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len24++
	goto __2801
__2800:
	if !(fc&0x10 == uint32(0)) {
		goto __2802
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len24 = len24 + 2
	goto __2803
__2802:
	if !(fc&0x08 == uint32(0)) {
		goto __2804
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len24 = len24 + 3
	goto __2805
__2804:
	if !(fc&0x04 == uint32(0)) {
		goto __2806
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len24 = len24 + 4
	goto __2807
__2806:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len24 = len24 + 5
__2807:
	;
__2805:
	;
__2803:
	;
__2801:
	;
__2799:
	;

	if !(fc < uint32(256) && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0) {
		goto __2808
	}
	goto __2795
__2808:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len24)
	goto __2794
__2794:
	i++
	goto __2793
	goto __2795
__2795:
	;
	goto __2604

__2618:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2809:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2811
	}

	len25 = 1
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2812
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2813
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2814
	}
	return -2
__2814:
	;
__2813:
	;

	goto __2811
__2812:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __2815
	}
	if !(fc&0x20 == uint32(0)) {
		goto __2816
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	len25++
	goto __2817
__2816:
	if !(fc&0x10 == uint32(0)) {
		goto __2818
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	len25 = len25 + 2
	goto __2819
__2818:
	if !(fc&0x08 == uint32(0)) {
		goto __2820
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	len25 = len25 + 3
	goto __2821
__2820:
	if !(fc&0x04 == uint32(0)) {
		goto __2822
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	len25 = len25 + 4
	goto __2823
__2822:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
	len25 = len25 + 5
__2823:
	;
__2821:
	;
__2819:
	;
__2817:
	;
__2815:
	;

	if !(fc >= uint32(256) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word == 0) {
		goto __2824
	}
	goto __2811
__2824:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(len25)
	goto __2810
__2810:
	i++
	goto __2809
	goto __2811
__2811:
	;
	goto __2604

__2619:
	return -44
__2604:
	;

	if !(reptype == REPTYPE_POS) {
		goto __2825
	}
	goto __10
__2825:
	; // No backtracking

	// After \C in UTF mode, Lstart_eptr might be in the middle of a
	//         Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't go
	//         too far.

__2826:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __2829
	}
	goto __2828
__2829:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM221
	goto MATCH_RECURSE
L_RM221:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2830
	}
	rrc = rrc
	goto RETURN_SWITCH
__2830:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__2831:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __2832
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __2831
__2832:
	;
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_ANYNL && (*Theapframe)(unsafe.Pointer(F)).Feptr > *(*uintptr)(unsafe.Pointer(F + 8)) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012' && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr(1)))) == '\015') {
		goto __2833
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__2833:
	;
	goto __2827
__2827:
	goto __2826
	goto __2828
__2828:
	;
	goto __2603
__2602:

	/* Not UTF mode */

	switch *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) {
	case OP_ANY:
		goto __2835

	case OP_ALLANY:
		goto __2836
	case OP_ANYBYTE:
		goto __2837

	case OP_ANYNL:
		goto __2838

	case OP_NOT_HSPACE:
		goto __2839

	case OP_HSPACE:
		goto __2840

	case OP_NOT_VSPACE:
		goto __2841

	case OP_VSPACE:
		goto __2842

	case OP_NOT_DIGIT:
		goto __2843

	case OP_DIGIT:
		goto __2844

	case OP_NOT_WHITESPACE:
		goto __2845

	case OP_WHITESPACE:
		goto __2846

	case OP_NOT_WORDCHAR:
		goto __2847

	case OP_WORDCHAR:
		goto __2848

	default:
		goto __2849
	}
	goto __2834

__2835:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2850:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2852
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2853
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2854
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2855
	}
	return -2
__2855:
	;
__2854:
	;

	goto __2852
__2853:
	;
	if !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __2856
	}
	goto __2852
__2856:
	;
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __2857
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2858
	}
	return -2
__2858:
	;
__2857:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2851
__2851:
	i++
	goto __2850
	goto __2852
__2852:
	;
	goto __2834

__2836:
__2837:
	fc = *(*uint32)(unsafe.Pointer(F + 56 + 1*4)) - *(*uint32)(unsafe.Pointer(F + 56))
	if !(fc > uint32((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject)-int64((*Theapframe)(unsafe.Pointer(F)).Feptr))/1)) {
		goto __2859
	}

	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2861
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2862
	}
	return -2
__2862:
	;
__2861:
	;

	goto __2860
__2859:
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(fc)
__2860:
	;
	goto __2834

__2838:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2863:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2865
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2866
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2867
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2868
	}
	return -2
__2868:
	;
__2867:
	;

	goto __2865
__2866:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc == uint32('\015')) {
		goto __2869
	}

	if !(libc.PreIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Feptr, 1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2871
	}
	goto __2865
__2871:
	;
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012') {
		goto __2872
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2872:
	;
	goto __2870
__2869:

	if !(fc != uint32('\012') && (int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention) == DPCRE2_BSR_ANYCRLF || fc != uint32('\013') && fc != uint32('\014') && fc != libc.Uint32FromUint8(libc.Uint8FromInt32(133)))) {
		goto __2873
	}
	goto __2865
__2873:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
__2870:
	;
	goto __2864
__2864:
	i++
	goto __2863
	goto __2865
__2865:
	;
	goto __2834

__2839:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2874:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2876
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2877
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2878
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2879
	}
	return -2
__2879:
	;
__2878:
	;

	goto __2876
__2877:
	;
	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) {
	default:
		goto __2881
	case '\011':
		goto __2882
	case '\040':
		goto __2883
	case int32(libc.Uint8FromInt32(160)):
		goto __2884
	}
	goto __2880

__2881:
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2880
__2882:
__2883:
__2884:
	goto ENDLOOP00
__2880:
	;
	goto __2875
__2875:
	i++
	goto __2874
	goto __2876
__2876:
	;
ENDLOOP00:
	goto __2834

__2840:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2885:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2887
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2888
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2889
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2890
	}
	return -2
__2890:
	;
__2889:
	;

	goto __2887
__2888:
	;
	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) {
	default:
		goto __2892
	case '\011':
		goto __2893
	case '\040':
		goto __2894
	case int32(libc.Uint8FromInt32(160)):
		goto __2895
	}
	goto __2891

__2892:
	goto ENDLOOP01
__2893:
__2894:
__2895:
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2891
__2891:
	;
	goto __2886
__2886:
	i++
	goto __2885
	goto __2887
__2887:
	;
ENDLOOP01:
	goto __2834

__2841:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2896:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2898
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2899
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2900
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2901
	}
	return -2
__2901:
	;
__2900:
	;

	goto __2898
__2899:
	;
	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) {
	default:
		goto __2903
	case '\012':
		goto __2904
	case '\013':
		goto __2905
	case '\014':
		goto __2906
	case '\015':
		goto __2907
	case int32(libc.Uint8FromInt32(133)):
		goto __2908
	}
	goto __2902

__2903:
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2902
__2904:
__2905:
__2906:
__2907:
__2908:
	goto ENDLOOP02
__2902:
	;
	goto __2897
__2897:
	i++
	goto __2896
	goto __2898
__2898:
	;
ENDLOOP02:
	goto __2834

__2842:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2909:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2911
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2912
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2913
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2914
	}
	return -2
__2914:
	;
__2913:
	;

	goto __2911
__2912:
	;
	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) {
	default:
		goto __2916
	case '\012':
		goto __2917
	case '\013':
		goto __2918
	case '\014':
		goto __2919
	case '\015':
		goto __2920
	case int32(libc.Uint8FromInt32(133)):
		goto __2921
	}
	goto __2915

__2916:
	goto ENDLOOP03
__2917:
__2918:
__2919:
__2920:
__2921:
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2915
__2915:
	;
	goto __2910
__2910:
	i++
	goto __2909
	goto __2911
__2911:
	;
ENDLOOP03:
	goto __2834

__2843:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2922:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2924
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2925
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2926
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2927
	}
	return -2
__2927:
	;
__2926:
	;

	goto __2924
__2925:
	;
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_digit != 0) {
		goto __2928
	}
	goto __2924
__2928:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2923
__2923:
	i++
	goto __2922
	goto __2924
__2924:
	;
	goto __2834

__2844:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2929:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2931
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2932
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2933
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2934
	}
	return -2
__2934:
	;
__2933:
	;

	goto __2931
__2932:
	;
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_digit == 0) {
		goto __2935
	}
	goto __2931
__2935:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2930
__2930:
	i++
	goto __2929
	goto __2931
__2931:
	;
	goto __2834

__2845:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2936:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2938
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2939
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2940
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2941
	}
	return -2
__2941:
	;
__2940:
	;

	goto __2938
__2939:
	;
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_space != 0) {
		goto __2942
	}
	goto __2938
__2942:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2937
__2937:
	i++
	goto __2936
	goto __2938
__2938:
	;
	goto __2834

__2846:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2943:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2945
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2946
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2947
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2948
	}
	return -2
__2948:
	;
__2947:
	;

	goto __2945
__2946:
	;
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_space == 0) {
		goto __2949
	}
	goto __2945
__2949:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2944
__2944:
	i++
	goto __2943
	goto __2945
__2945:
	;
	goto __2834

__2847:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2950:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2952
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2953
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2954
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2955
	}
	return -2
__2955:
	;
__2954:
	;

	goto __2952
__2953:
	;
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_word != 0) {
		goto __2956
	}
	goto __2952
__2956:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2951
__2951:
	i++
	goto __2950
	goto __2952
__2952:
	;
	goto __2834

__2848:
	i = *(*uint32)(unsafe.Pointer(F + 56))
__2957:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __2959
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2960
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2961
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2962
	}
	return -2
__2962:
	;
__2961:
	;

	goto __2959
__2960:
	;
	if !(!(1 != 0) || int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))))))&Dctype_word == 0) {
		goto __2963
	}
	goto __2959
__2963:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr++
	goto __2958
__2958:
	i++
	goto __2957
	goto __2959
__2959:
	;
	goto __2834

__2849:
	return -44
__2834:
	;

	if !(reptype == REPTYPE_POS) {
		goto __2964
	}
	goto __10
__2964:
	; // No backtracking

__2965:

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __2968
	}
	goto __2967
__2968:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM34
	goto MATCH_RECURSE
L_RM34:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __2969
	}
	rrc = rrc
	goto RETURN_SWITCH
__2969:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) == OP_ANYNL && (*Theapframe)(unsafe.Pointer(F)).Feptr > *(*uintptr)(unsafe.Pointer(F + 8)) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == '\012' && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + libc.UintptrFromInt32(-1)))) == '\015') {
		goto __2970
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__2970:
	;
	goto __2966
__2966:
	goto __2965
	goto __2967
__2967:
	;
__2603:
	;
__2545:
	;
__2273:
	;
__1780:
	;
	goto __12 // End of repeat character type processing

	// =====================================================================
	// Match a back reference, possibly repeatedly. Look past the end of the
	//     item to see if there is repeat information following. The OP_REF and
	//     OP_REFI opcodes are used for a reference to a numbered group or to a
	//     non-duplicated named group. For a duplicated named group, OP_DNREF and
	//     OP_DNREFI are used. In this case we must scan the list of groups to which
	//     the name refers, and use the first one that is set.

__106:
__107:
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = uint32(libc.Bool32(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_DNREFI))

	count = int32(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))))
	slot = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))*uint32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + 2*DIMM2_SIZE)

__2971:
	if !(libc.PostDecInt32(&count, 1) > 0) {
		goto __2972
	}

	(*Theapframe)(unsafe.Pointer(F)).Ftemp_size = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(slot)))<<8|int32(*(*uint8)(unsafe.Pointer(slot + 1))))<<1 - uint32(2))
	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size < (*Theapframe)(unsafe.Pointer(F)).Foffset_top && *(*uint64)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)*8)) != libc.CplUint64(uint64(0))) {
		goto __2973
	}
	goto __2972
__2973:
	;
	slot += uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size)
	goto __2971
__2972:
	;

	goto REF_REPEAT

__108:
__109:
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = uint32(libc.Bool32(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_REFI))
	(*Theapframe)(unsafe.Pointer(F)).Ftemp_size = uint64(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))<<1 - uint32(2))
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DIMM2_SIZE)

	// Set up for repetition, or handle the non-repeated case. The maximum and
	//     minimum must be in the heap frame, but as they are short-term values, we
	//     use temporary fields.

REF_REPEAT:
	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) {
	case OP_CRSTAR:
		goto __2975
	case OP_CRMINSTAR:
		goto __2976
	case OP_CRPLUS:
		goto __2977
	case OP_CRMINPLUS:
		goto __2978
	case OP_CRQUERY:
		goto __2979
	case OP_CRMINQUERY:
		goto __2980

	case OP_CRRANGE:
		goto __2981
	case OP_CRMINRANGE:
		goto __2982

	default:
		goto __2983
	}
	goto __2974

__2975:
__2976:
__2977:
__2978:
__2979:
__2980:
	fc = uint32(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) - OP_CRSTAR)
	*(*uint32)(unsafe.Pointer(F + 56)) = rep_min[fc]
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = rep_max[fc]
	reptype = rep_typ[fc]
	goto __2974

__2981:
__2982:
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	reptype = rep_typ[int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))-OP_CRSTAR]
	if !(*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) == uint32(0)) {
		goto __2984
	}
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = 4294967295
__2984:
	; // Max 0 => infinity
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + 2*DIMM2_SIZE)
	goto __2974

__2983: /* No repeat follows */

	rrc = match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp)
	if !(rrc != 0) {
		goto __2985
	}

	if !(rrc > 0) {
		goto __2986
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
__2986:
	; // Partial match
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2987
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __2988
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __2989
	}
	return -2
__2989:
	;
__2988:
	;
__2987:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2985:
	;

	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(*(*uint64)(unsafe.Pointer(bp)))
	goto __10 // With the main loop
__2974:
	;

	// Handle repeated back references. If a set group has length zero, just
	//     continue with the main loop, because it matches however many times. For an
	//     unset reference, if the minimum is zero, we can also just continue. We can
	//     also continue if PCRE2_MATCH_UNSET_BACKREF is set, because this makes unset
	//     group behave as a zero-length group. For any other unset cases, carrying
	//     on will result in NOMATCH.

	if !((*Theapframe)(unsafe.Pointer(F)).Ftemp_size < (*Theapframe)(unsafe.Pointer(F)).Foffset_top && *(*uint64)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)*8)) != libc.CplUint64(uint64(0))) {
		goto __2990
	}

	if !(*(*uint64)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)*8)) == *(*uint64)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size+uint64(1))*8))) {
		goto __2992
	}
	goto __10
__2992:
	;
	goto __2991
__2990: /* Group is not set */

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == uint32(0) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_MATCH_UNSET_BACKREF != uint32(0)) {
		goto __2993
	}
	goto __10
__2993:
	;
__2991:
	;

	// First, ensure the minimum number of matches are present.

	i = uint32(1)
__2994:
	if !(i <= *(*uint32)(unsafe.Pointer(F + 56))) {
		goto __2996
	}

	rrc = match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp+8)
	if !(rrc != 0) {
		goto __2997
	}

	if !(rrc > 0) {
		goto __2998
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
__2998:
	; // Partial match
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __2999
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __3000
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3001
	}
	return -2
__3001:
	;
__3000:
	;
__2999:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__2997:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(*(*uint64)(unsafe.Pointer(bp + 8)))
	goto __2995
__2995:
	i++
	goto __2994
	goto __2996
__2996:
	;

	// If min = max, we are done. They are not both allowed to be zero.

	if !(*(*uint32)(unsafe.Pointer(F + 56)) == *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __3002
	}
	goto __10
__3002:
	;

	// If minimizing, keep trying and advancing the pointer.

	if !(reptype == REPTYPE_MIN) {
		goto __3003
	}

__3005:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM20
	goto MATCH_RECURSE
L_RM20:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3008
	}
	rrc = rrc
	goto RETURN_SWITCH
__3008:
	;

	if !(libc.PostIncUint32(&*(*uint32)(unsafe.Pointer(F + 56)), 1) >= *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __3009
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3009:
	;

	rrc = match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp+16)
	if !(rrc != 0) {
		goto __3010
	}

	if !(rrc > 0) {
		goto __3011
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject
__3011:
	; // Partial match
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3012
	}
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __3013
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3014
	}
	return -2
__3014:
	;
__3013:
	;
__3012:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3010:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(*(*uint64)(unsafe.Pointer(bp + 16)))
	goto __3006
__3006:
	goto __3005
	goto __3007
__3007:
	;
	// Control never gets here
	goto __3004
__3003:
	samelengths = DTRUE
	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr // Starting position
	(*Theapframe)(unsafe.Pointer(F)).Flength = *(*uint64)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size+uint64(1))*8)) - *(*uint64)(unsafe.Pointer(F + 128 + uintptr((*Theapframe)(unsafe.Pointer(F)).Ftemp_size)*8))

	i = *(*uint32)(unsafe.Pointer(F + 56))
__3015:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __3017
	}

	rrc = match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp+24)
	if !(rrc != 0) {
		goto __3018
	}

	// Can't use CHECK_PARTIAL because we don't want to update Feptr in
	//           the soft partial matching case.

	if !(rrc > 0 && int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __3019
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3020
	}
	return -2
__3020:
	;
__3019:
	;
	goto __3017
__3018:
	;

	if !(*(*uint64)(unsafe.Pointer(bp + 24)) != (*Theapframe)(unsafe.Pointer(F)).Flength) {
		goto __3021
	}
	samelengths = DFALSE
__3021:
	;
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(*(*uint64)(unsafe.Pointer(bp + 24)))
	goto __3016
__3016:
	i++
	goto __3015
	goto __3017
__3017:
	;

	// If the length matched for each repetition is the same as the length of
	//       the captured group, we can easily work backwards. This is the normal
	//       case. However, in caseless UTF-8 mode there are pairs of case-equivalent
	//       characters whose lengths (in terms of code units) differ. However, this
	//       is very rare, so we handle it by re-matching fewer and fewer times.

	if !(samelengths != 0) {
		goto __3022
	}

__3024:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __3025
	}

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM21
	goto MATCH_RECURSE
L_RM21:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3026
	}
	rrc = rrc
	goto RETURN_SWITCH
__3026:
	;

	*(*uintptr)(unsafe.Pointer(F + 80)) -= uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)
	goto __3024
__3025:
	;
	goto __3023
__3022:

	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = i
__3027:

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM22
	goto MATCH_RECURSE
L_RM22:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3030
	}
	rrc = rrc
	goto RETURN_SWITCH
__3030:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __3031
	}
	goto __3029
__3031:
	; // Failed after minimal repetition
	(*Theapframe)(unsafe.Pointer(F)).Feptr = *(*uintptr)(unsafe.Pointer(F + 8))
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4))--
	i = *(*uint32)(unsafe.Pointer(F + 56))
__3032:
	if !(i < *(*uint32)(unsafe.Pointer(F + 56 + 1*4))) {
		goto __3034
	}

	match_ref(tls, (*Theapframe)(unsafe.Pointer(F)).Ftemp_size, int32(*(*uint32)(unsafe.Pointer(F + 56 + 2*4))), F, mb, bp+32)
	*(*uintptr)(unsafe.Pointer(F + 80)) += uintptr(*(*uint64)(unsafe.Pointer(bp + 32)))
	goto __3033
__3033:
	i++
	goto __3032
	goto __3034
__3034:
	;
	goto __3028
__3028:
	goto __3027
	goto __3029
__3029:
	;
__3023:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3004:
	;
	// Control never gets here

	// =========================================================================
	//           Opcodes for the start of various parenthesized items
	// =========================================================================

	// In all cases, if the result of RMATCH() is MATCH_THEN, check whether the
	//     (*THEN) is within the current branch by comparing the address of OP_THEN
	//     that is passed back with the end of the branch. If (*THEN) is within the
	//     current branch, and the branch is one of two or more alternatives (it
	//     either starts or ends with OP_ALT), we have reached the limit of THEN's
	//     action, so convert the return code to NOMATCH, which will cause normal
	//     backtracking to happen from now on. Otherwise, THEN is passed back to an
	//     outer alternative. This implements Perl's treatment of parenthesized
	//     groups, where a group not containing | does not affect the current
	//     alternative, that is, (X) is NOT the same as (X|(*F)).

	// =====================================================================
	// BRAZERO, BRAMINZERO and SKIPZERO occur just before a non-possessive
	//     bracket group, indicating that it may occur zero times. It may repeat
	//     infinitely, or not at all - i.e. it could be ()* or ()? or even (){0} in
	//     the pattern. Brackets with fixed upper repeat limits are compiled as a
	//     number of copies, with the optional ones preceded by BRAZERO or BRAMINZERO.
	//     Possessive groups with possible zero repeats are preceded by BRAPOSZERO.

__110:
	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1)
	start_ecode = *(*uintptr)(unsafe.Pointer(F + 8))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM9
	goto MATCH_RECURSE
L_RM9:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3035
	}
	rrc = rrc
	goto RETURN_SWITCH
__3035:
	;

__3036:
	*(*uintptr)(unsafe.Pointer(F + 8)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8)) + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8)) + 2)))))
	goto __3037
__3037:
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8))))) == OP_ALT {
		goto __3036
	}
	goto __3038
__3038:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode = *(*uintptr)(unsafe.Pointer(F + 8)) + uintptr(1) + uintptr(DLINK_SIZE)
	goto __12

__111:
	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1)
__3039:
	*(*uintptr)(unsafe.Pointer(F + 8)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8)) + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8)) + 2)))))
	goto __3040
__3040:
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8))))) == OP_ALT {
		goto __3039
	}
	goto __3041
__3041:
	;
	start_ecode = *(*uintptr)(unsafe.Pointer(F + 8)) + uintptr(1) + uintptr(DLINK_SIZE)
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM10
	goto MATCH_RECURSE
L_RM10:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3042
	}
	rrc = rrc
	goto RETURN_SWITCH
__3042:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__112:
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
__3043:
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3044
__3044:
	if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3043
	}
	goto __3045
__3045:
	;
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DLINK_SIZE)
	goto __12

	// =====================================================================
	// Handle possessive brackets with an unlimited repeat. The end of these
	//     brackets will always be OP_KETRPOS, which returns MATCH_KETRPOS without
	//     going further in the pattern.

__113:
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = uint32(DTRUE) // Zero repeat is allowed
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1)
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CBRAPOS || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_SCBRAPOS) {
		goto __3046
	}
	goto POSSESSIVE_CAPTURE
__3046:
	;
	goto POSSESSIVE_NON_CAPTURE

__114:
__115:
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = uint32(DFALSE) // Zero repeat not allowed

POSSESSIVE_NON_CAPTURE:
	*(*uint32)(unsafe.Pointer(F + 56)) = DGF_NOCAPTURE // Remembered frame type
	goto POSSESSIVE_GROUP

__116:
__117:
	*(*uint32)(unsafe.Pointer(F + 56 + 2*4)) = uint32(DFALSE) // Zero repeat not allowed

POSSESSIVE_CAPTURE:
	number = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	*(*uint32)(unsafe.Pointer(F + 56)) = DGF_CAPTURE | number // Remembered frame type

POSSESSIVE_GROUP:
	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(DFALSE)                          // Never matched
	*(*uintptr)(unsafe.Pointer(F + 8 + 1*8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode // Start of this group

__3047:

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Feptr // Position at group start
	group_frame_type = *(*uint32)(unsafe.Pointer(F + 56))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM8
	goto MATCH_RECURSE
L_RM8:
	;

	if !(rrc == -998) {
		goto __3050
	}

	*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) = uint32(DTRUE) // Matched at least once
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == *(*uintptr)(unsafe.Pointer(F + 8))) {
		goto __3051
	} /* Empty match; skip to end */

__3052:
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3053
__3053:
	if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3052
	}
	goto __3054
__3054:
	;
	goto __3049
__3051:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode = *(*uintptr)(unsafe.Pointer(F + 8 + 1*8))
	goto __3048
__3050:
	;

	// See comment above about handling THEN.

	if !(rrc == -993) {
		goto __3055
	}

	next_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr < next_ecode && (int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT || int32(*(*uint8)(unsafe.Pointer(next_ecode))) == OP_ALT)) {
		goto __3056
	}
	rrc = DMATCH_NOMATCH
__3056:
	;
__3055:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3057
	}
	rrc = rrc
	goto RETURN_SWITCH
__3057:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) != OP_ALT) {
		goto __3058
	}
	goto __3049
__3058:
	;
	goto __3048
__3048:
	goto __3047
	goto __3049
__3049:
	;

	// Success if matched something or zero repeat allowed

	if !(*(*uint32)(unsafe.Pointer(F + 56 + 1*4)) != 0 || *(*uint32)(unsafe.Pointer(F + 56 + 2*4)) != 0) {
		goto __3059
	}

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DLINK_SIZE)
	goto __12
__3059:
	;

	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	// =====================================================================
	// Handle non-capturing brackets that cannot match an empty string. When we
	//     get to the final alternative within the brackets, as long as there are no
	//     THEN's in the pattern, we can optimize by not recording a new backtracking
	//     point. (Ideally we should test for a THEN within this group, but we don't
	//     have that information.) Don't do this if we are at the very top level,
	//     however, because that would make handling assertions and once-only brackets
	//     messier when there is nothing to go back to.

__118:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fhasthen != 0 || (*Theapframe)(unsafe.Pointer(F)).Frdepth == uint32(0)) {
		goto __3060
	}

	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(0)
	goto GROUPLOOP
__3060:
	;

__3061:

	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8))))) != OP_ALT) {
		goto __3064
	}
	goto __3063
__3064:
	;

	/* This is never the final branch. We do not need to test for MATCH_THEN
	   here because this code is not used when there is a THEN in the pattern. */

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM1
	goto MATCH_RECURSE
L_RM1:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3065
	}
	rrc = rrc
	goto RETURN_SWITCH
__3065:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode = *(*uintptr)(unsafe.Pointer(F + 8))
	goto __3062
__3062:
	goto __3061
	goto __3063
__3063:
	;

	// Hit the start of the final branch. Continue at this level.

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	goto __12

	// =====================================================================
	// Handle a capturing bracket, other than those that are possessive with an
	//     unlimited repeat.

__119:
__120:
	*(*uint32)(unsafe.Pointer(F + 56)) = DGF_CAPTURE | uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4))))
	goto GROUPLOOP

	// =====================================================================
	// Atomic groups and non-capturing brackets that can match an empty string
	//     must record a backtracking point and also set up a chained frame.

__121:
__122:
__123:
	*(*uint32)(unsafe.Pointer(F + 56)) = DGF_NOCAPTURE | uint32((*Theapframe)(unsafe.Pointer(F)).Fop)

GROUPLOOP:
__3066:

	group_frame_type = *(*uint32)(unsafe.Pointer(F + 56))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM2
	goto MATCH_RECURSE
L_RM2:
	;

	if !(rrc == -993) {
		goto __3069
	}

	next_ecode1 = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr < next_ecode1 && (int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT || int32(*(*uint8)(unsafe.Pointer(next_ecode1))) == OP_ALT)) {
		goto __3070
	}
	rrc = DMATCH_NOMATCH
__3070:
	;
__3069:
	;
	if !(rrc != DMATCH_NOMATCH) {
		goto __3071
	}
	rrc = rrc
	goto RETURN_SWITCH
__3071:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) != OP_ALT) {
		goto __3072
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3072:
	;

	goto __3067
__3067:
	goto __3066
	goto __3068
__3068:
	;
	// Control never reaches here.

	// =====================================================================
	// Recursion either matches the current regex, or some subexpression. The
	//     offset data is the offset to the starting bracket from the start of the
	//     whole pattern. (This is so that it works from duplicated subpatterns.)

__124:
	bracode = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if bracode == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_code {
		number = uint32(0)
	} else {
		number = uint32(int32(*(*uint8)(unsafe.Pointer(bracode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(bracode + 4))))
	}

	// If we are already in a recursion, check for repeating the same one
	//     without advancing the subject pointer. This should catch convoluted mutual
	//     recursions. (Some simple cases are caught at compile time.)

	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse != DRECURSE_UNSET) {
		goto __3073
	}

	offset = (*Theapframe)(unsafe.Pointer(F)).Flast_group_offset
__3074:
	if !(offset != libc.CplUint64(uint64(0))) {
		goto __3075
	}

	N = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes + uintptr(offset)
	P = N - uintptr(frame_size)
	if !((*Theapframe)(unsafe.Pointer(N)).Fgroup_frame_type == DGF_RECURSE|number) {
		goto __3076
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == (*Theapframe)(unsafe.Pointer(P)).Feptr) {
		goto __3077
	}
	return -52
__3077:
	;
	goto __3075
__3076:
	;
	offset = (*Theapframe)(unsafe.Pointer(P)).Flast_group_offset
	goto __3074
__3075:
	;
__3073:
	;

	// Now run the recursion, branch by branch.

	*(*uintptr)(unsafe.Pointer(F + 8)) = bracode
	*(*uint32)(unsafe.Pointer(F + 56)) = DGF_RECURSE | number

__3078:

	group_frame_type = *(*uint32)(unsafe.Pointer(F + 56))
	start_ecode = *(*uintptr)(unsafe.Pointer(F + 8)) + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8))))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM11
	goto MATCH_RECURSE
L_RM11:
	;

	next_ecode2 = *(*uintptr)(unsafe.Pointer(F + 8)) + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8)) + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8)) + 2)))))

	// Handle backtracking verbs, which are defined in a range that can
	//       easily be tested for. PCRE does not allow THEN, SKIP, PRUNE or COMMIT to
	//       escape beyond a recursion; they cause a NOMATCH for the entire recursion.
	//
	//       When one of these verbs triggers, the current recursion group number is
	//       recorded. If it matches the recursion we are processing, the verb
	//       happened within the recursion and we must deal with it. Otherwise it must
	//       have happened after the recursion completed, and so has to be passed
	//       back. See comment above about handling THEN.

	if !(rrc >= -997 && rrc <= -993 && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse == *(*uint32)(unsafe.Pointer(F + 56))^DGF_RECURSE) {
		goto __3081
	}

	if !(rrc == -993 && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr < next_ecode2 && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8))))) == OP_ALT || int32(*(*uint8)(unsafe.Pointer(next_ecode2))) == OP_ALT)) {
		goto __3082
	}
	rrc = DMATCH_NOMATCH
	goto __3083
__3082:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3083:
	;

__3081:
	;

	// Note that carrying on after (*ACCEPT) in a recursion is handled in the
	//       OP_ACCEPT code. Nothing needs to be done here.

	if !(rrc != DMATCH_NOMATCH) {
		goto __3084
	}
	rrc = rrc
	goto RETURN_SWITCH
__3084:
	;

	*(*uintptr)(unsafe.Pointer(F + 8)) = next_ecode2
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8))))) != OP_ALT) {
		goto __3085
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3085:
	;

	goto __3079
__3079:
	goto __3078
	goto __3080
__3080:
	;
	// Control never reaches here.

	// =====================================================================
	// Positive assertions are like other groups except that PCRE doesn't allow
	//     the effect of (*THEN) to escape beyond an assertion; it is therefore
	//     treated as NOMATCH. (*ACCEPT) is treated as successful assertion, with its
	//     captures and mark retained. Any other return is an error.

__125:
__126:
__127:
__128:
	*(*uint32)(unsafe.Pointer(F + 56)) = DGF_NOCAPTURE | uint32((*Theapframe)(unsafe.Pointer(F)).Fop)
__3086:

	group_frame_type = *(*uint32)(unsafe.Pointer(F + 56))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM3
	goto MATCH_RECURSE
L_RM3:
	;

	if !(rrc == -999) {
		goto __3089
	}

	libc.Xmemcpy(tls, F+128,
		assert_accept_frame+uintptr(uint64(uintptr(0)+128)),
		(*Theapframe)(unsafe.Pointer(assert_accept_frame)).Foffset_top*uint64(unsafe.Sizeof(uint64(0))))
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = (*Theapframe)(unsafe.Pointer(assert_accept_frame)).Foffset_top
	(*Theapframe)(unsafe.Pointer(F)).Fmark = (*Theapframe)(unsafe.Pointer(assert_accept_frame)).Fmark
	goto __3088
__3089:
	;
	if !(rrc != DMATCH_NOMATCH && rrc != -993) {
		goto __3090
	}
	rrc = rrc
	goto RETURN_SWITCH
__3090:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) != OP_ALT) {
		goto __3091
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3091:
	;

	goto __3087
__3087:
	goto __3086
	goto __3088
__3088:
	;

__3092:
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3093
__3093:
	if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3092
	}
	goto __3094
__3094:
	;
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DLINK_SIZE)
	goto __12

	// =====================================================================
	// Handle negative assertions. Loop for each non-matching branch as for
	//     positive assertions.

__129:
__130:
	*(*uint32)(unsafe.Pointer(F + 56)) = DGF_NOCAPTURE | uint32((*Theapframe)(unsafe.Pointer(F)).Fop)

__3095:

	group_frame_type = *(*uint32)(unsafe.Pointer(F + 56))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM4
	goto MATCH_RECURSE
L_RM4:
	;

	switch rrc {
	case -999:
		goto __3099 // Assertion matched, therefore it fails.
	case DMATCH_MATCH:
		goto __3100

	case DMATCH_NOMATCH:
		goto __3101 // Branch failed, try next if present.
	case -993:
		goto __3102

	case -997:
		goto __3103 // Assertion forced to fail, therefore continue.
	case -995:
		goto __3104
	case -996:
		goto __3105

	default:
		goto __3106
	}
	goto __3098

__3099: // Assertion matched, therefore it fails.
__3100:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3101: // Branch failed, try next if present.
__3102:
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) != OP_ALT) {
		goto __3107
	}
	goto ASSERT_NOT_FAILED
__3107:
	;
	goto __3098

__3103: // Assertion forced to fail, therefore continue.
__3104:
__3105:
__3108:
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3109
__3109:
	if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3108
	}
	goto __3110
__3110:
	;
	goto ASSERT_NOT_FAILED

__3106: /* Pass back any other return */
	rrc = rrc
	goto RETURN_SWITCH

__3098:
	;
	goto __3096
__3096:
	goto __3095
	goto __3097
__3097:
	;

	// None of the branches have matched or there was a backtrack to (*COMMIT),
	//     (*SKIP), (*PRUNE), or (*THEN) in the last branch. This is success for a
	//     negative assertion, so carry on.

ASSERT_NOT_FAILED:
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DLINK_SIZE)
	goto __12

	// =====================================================================
	// The callout item calls an external function, if one is provided, passing
	//     details of the match so far. This is mainly for debugging, though the
	//     function is able to force a failure.

__131:
__132:
	rrc = do_callout(tls, F, mb, bp)
	if !(rrc > 0) {
		goto __3111
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3111:
	;

	if !(rrc < 0) {
		goto __3112
	}
	rrc = rrc
	goto RETURN_SWITCH
__3112:
	;

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(*(*uint64)(unsafe.Pointer(bp)))
	goto __12

	// =====================================================================
	// Conditional group: compilation checked that there are no more than two
	//     branches. If the condition is false, skipping the first branch takes us
	//     past the end of the item if there is only one branch, but that's exactly
	//     what we want.

__133:
__134:

	// The variable Flength will be added to Fecode when the condition is
	//     false, to get to the second branch. Setting it to the offset to the ALT or
	//     KET, then incrementing Fecode achieves this effect. However, if the second
	//     branch is non-existent, we must point to the KET so that the end of the
	//     group is correctly processed. We now have Fecode pointing to the condition
	//     or callout.

	(*Theapframe)(unsafe.Pointer(F)).Flength = uint64(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))) // Offset to the second branch
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)))) != OP_ALT) {
		goto __3113
	}
	*(*uint64)(unsafe.Pointer(F + 24)) -= uint64(1 + DLINK_SIZE)
__3113:
	;
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DLINK_SIZE) // From this opcode

	// Because of the way auto-callout works during compile, a callout item is
	//     inserted between OP_COND and an assertion condition. Such a callout can
	//     also be inserted manually.

	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CALLOUT || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_CALLOUT_STR) {
		goto __3114
	}

	rrc = do_callout(tls, F, mb, bp)
	if !(rrc > 0) {
		goto __3115
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3115:
	;

	if !(rrc < 0) {
		goto __3116
	}
	rrc = rrc
	goto RETURN_SWITCH
__3116:
	;

	// Advance Fecode past the callout, so it now points to the condition. We
	//       must adjust Flength so that the value of Fecode+Flength is unchanged.

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(*(*uint64)(unsafe.Pointer(bp)))
	*(*uint64)(unsafe.Pointer(F + 24)) -= *(*uint64)(unsafe.Pointer(bp))
__3114:
	;

	// Test the various possible conditions

	condition = DFALSE
	switch int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) {
	case OP_RREF:
		goto __3118

	case OP_DNRREF:
		goto __3119

	case OP_CREF:
		goto __3120

	case OP_DNCREF:
		goto __3121

	case OP_FALSE:
		goto __3122
	case OP_FAIL:
		goto __3123

	case OP_TRUE:
		goto __3124

	// The condition is an assertion. Run code similar to the assertion code
	//       above.

	default:
		goto __3125
	}
	goto __3117

__3118: // Group recursion test
	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse != DRECURSE_UNSET) {
		goto __3126
	}

	number = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	condition = libc.Bool32(number == uint32(DRREF_ANY) || number == (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse)
__3126:
	;
	goto __3117

__3119: // Duplicate named group recursion test
	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse != DRECURSE_UNSET) {
		goto __3127
	}

	count1 = int32(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))))
	slot1 = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))*uint32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size))
__3128:
	if !(libc.PostDecInt32(&count1, 1) > 0) {
		goto __3129
	}

	number = uint32(int32(*(*uint8)(unsafe.Pointer(slot1)))<<8 | int32(*(*uint8)(unsafe.Pointer(slot1 + 1))))
	condition = libc.Bool32(number == (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse)
	if !(condition != 0) {
		goto __3130
	}
	goto __3129
__3130:
	;
	slot1 += uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size)
	goto __3128
__3129:
	;
__3127:
	;
	goto __3117

__3120: // Numbered group used test
	offset = uint64(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))<<1 - uint32(2)) // Doubled ref number
	condition = libc.Bool32(offset < (*Theapframe)(unsafe.Pointer(F)).Foffset_top && *(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) != libc.CplUint64(uint64(0)))
	goto __3117

__3121: /* Duplicate named group used test */

	count2 = int32(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 4)))))
	slot2 = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))*uint32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size))
__3131:
	if !(libc.PostDecInt32(&count2, 1) > 0) {
		goto __3132
	}

	offset = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(slot2)))<<8|int32(*(*uint8)(unsafe.Pointer(slot2 + 1))))<<1 - uint32(2))
	condition = libc.Bool32(offset < (*Theapframe)(unsafe.Pointer(F)).Foffset_top && *(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) != libc.CplUint64(uint64(0)))
	if !(condition != 0) {
		goto __3133
	}
	goto __3132
__3133:
	;
	slot2 += uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size)
	goto __3131
__3132:
	;

	goto __3117

__3122:
__3123: // The assertion (?!) becomes OP_FAIL
	goto __3117

__3124:
	condition = DTRUE
	goto __3117

	// The condition is an assertion. Run code similar to the assertion code
	//       above.

__3125:
	*(*uint32)(unsafe.Pointer(F + 56)) = uint32(libc.Bool32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ASSERT || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ASSERTBACK))
	*(*uintptr)(unsafe.Pointer(F + 8)) = (*Theapframe)(unsafe.Pointer(F)).Fecode

__3134:

	group_frame_type = DGF_CONDASSERT | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode)))
	start_ecode = *(*uintptr)(unsafe.Pointer(F + 8)) + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8))))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM5
	goto MATCH_RECURSE
L_RM5:
	;

	switch rrc {
	case -999:
		goto __3138

	// Fall through
	// In the case of a match, the captures have already been put into
	//           the current frame.

	case DMATCH_MATCH:
		goto __3139

	// PCRE doesn't allow the effect of (*THEN) to escape beyond an
	//           assertion; it is therefore always treated as NOMATCH.

	case DMATCH_NOMATCH:
		goto __3140
	case -993:
		goto __3141

	// These force no match without checking other branches.

	case -997:
		goto __3142
	case -995:
		goto __3143
	case -996:
		goto __3144

	default:
		goto __3145
	}
	goto __3137

__3138: // Save captures
	libc.Xmemcpy(tls, F+128,
		assert_accept_frame+uintptr(uint64(uintptr(0)+128)),
		(*Theapframe)(unsafe.Pointer(assert_accept_frame)).Foffset_top*uint64(unsafe.Sizeof(uint64(0))))
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = (*Theapframe)(unsafe.Pointer(assert_accept_frame)).Foffset_top

	// Fall through
	// In the case of a match, the captures have already been put into
	//           the current frame.

__3139:
	condition = int32(*(*uint32)(unsafe.Pointer(F + 56))) // TRUE for positive assertion
	goto __3137

	// PCRE doesn't allow the effect of (*THEN) to escape beyond an
	//           assertion; it is therefore always treated as NOMATCH.

__3140:
__3141:
	*(*uintptr)(unsafe.Pointer(F + 8)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8)) + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8)) + 2)))))
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(F + 8))))) == OP_ALT) {
		goto __3146
	}
	goto __3135
__3146:
	;                                                                      // Try next branch
	condition = libc.BoolInt32(!(*(*uint32)(unsafe.Pointer(F + 56)) != 0)) // TRUE for negative assertion
	goto __3137

	// These force no match without checking other branches.

__3142:
__3143:
__3144:
	condition = libc.BoolInt32(!(*(*uint32)(unsafe.Pointer(F + 56)) != 0))
	goto __3137

__3145:
	rrc = rrc
	goto RETURN_SWITCH

__3137:
	;
	goto __3136 // Out of the branch loop
	goto __3135
__3135:
	goto __3134
	goto __3136
__3136:
	;

	// If the condition is true, find the end of the assertion so that
	//       advancing past it gets us to the start of the first branch.

	if !(condition != 0) {
		goto __3147
	}

__3148:
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3149
__3149:
	if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3148
	}
	goto __3150
__3150:
	;
__3147:
	;
	goto __3117 // End of assertion condition
__3117:
	;

	// Choose branch according to the condition.

	*(*uintptr)(unsafe.Pointer(F)) += func() uintptr {
		if condition != 0 {
			return uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
		}
		return uintptr((*Theapframe)(unsafe.Pointer(F)).Flength)
	}()

	// If the opcode is OP_SCOND it means we are at a repeated conditional
	//     group that might match an empty string. We must therefore descend a level
	//     so that the start is remembered for checking. For OP_COND we can just
	//     continue at this level.

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_SCOND) {
		goto __3151
	}

	group_frame_type = DGF_NOCAPTURE | uint32((*Theapframe)(unsafe.Pointer(F)).Fop)
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM35
	goto MATCH_RECURSE
L_RM35:
	;

	rrc = rrc
	goto RETURN_SWITCH

__3151:
	;
	goto __12

	// =========================================================================
	//                  End of start of parenthesis opcodes
	// =========================================================================

	// =====================================================================
	// Move the subject pointer back. This occurs only at the start of each
	//     branch of a lookbehind assertion. If we are too close to the start to move
	//     back, fail. When working with UTF-8 we move back a number of characters,
	//     not bytes.

__135:
	number = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2))))
	if !(utf != 0) {
		goto __3152
	}

__3154:
	if !(libc.PostDecUint32(&number, 1) > uint32(0)) {
		goto __3155
	}

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject) {
		goto __3156
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3156:
	;

	(*Theapframe)(unsafe.Pointer(F)).Feptr--
__3157:
	if !(uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))&0xc0 == 0x80) {
		goto __3158
	}
	(*Theapframe)(unsafe.Pointer(F)).Feptr--
	goto __3157
__3158:
	;
	goto __3154
__3155:
	;
	goto __3153
__3152:

	/* No UTF-8 support, or not in UTF-8 mode: count is code unit count */

	if !(int64(number) > (int64((*Theapframe)(unsafe.Pointer(F)).Feptr)-int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject))/1) {
		goto __3159
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3159:
	;

	*(*uintptr)(unsafe.Pointer(F + 80)) -= uintptr(number)
__3153:
	;

	// Save the earliest consulted character, then skip to next opcode

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __3160
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__3160:
	;
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DLINK_SIZE)
	goto __12

	// =====================================================================
	// An alternation is the end of a branch; scan along to find the end of the
	//     bracketed group.

__136:
__3161:
	*(*uintptr)(unsafe.Pointer(F)) += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __3162
__3162:
	if int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_ALT {
		goto __3161
	}
	goto __3163
__3163:
	;
	goto __12

	// =====================================================================
	// The end of a parenthesized group. For all but OP_BRA and OP_COND, the
	//     starting frame was added to the chained frames in order to remember the
	//     starting subject position for the group.

__137:
__138:
__139:
__140:

	bracode = (*Theapframe)(unsafe.Pointer(F)).Fecode - uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))

	// Point N to the frame at the start of the most recent group.
	//     Remember the subject pointer at the start of the group.

	if !(int32(*(*uint8)(unsafe.Pointer(bracode))) != OP_BRA && int32(*(*uint8)(unsafe.Pointer(bracode))) != OP_COND) {
		goto __3164
	}

	N = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes + uintptr((*Theapframe)(unsafe.Pointer(F)).Flast_group_offset)
	P = N - uintptr(frame_size)
	(*Theapframe)(unsafe.Pointer(F)).Flast_group_offset = (*Theapframe)(unsafe.Pointer(P)).Flast_group_offset

	// If we are at the end of an assertion that is a condition, return a
	//       match, discarding any intermediate backtracking points. Copy back the
	//       mark setting and the captures into the frame before N so that they are
	//       set on return. Doing this for all assertions, both positive and negative,
	//       seems to match what Perl does.

	if !((*Theapframe)(unsafe.Pointer(N)).Fgroup_frame_type&0xffff0000 == DGF_CONDASSERT) {
		goto __3166
	}

	libc.Xmemcpy(tls, P+uintptr(uint64(uintptr(0)+128)), F+128,
		(*Theapframe)(unsafe.Pointer(F)).Foffset_top*uint64(unsafe.Sizeof(uint64(0))))
	(*Theapframe)(unsafe.Pointer(P)).Foffset_top = (*Theapframe)(unsafe.Pointer(F)).Foffset_top
	(*Theapframe)(unsafe.Pointer(P)).Fmark = (*Theapframe)(unsafe.Pointer(F)).Fmark
	(*Theapframe)(unsafe.Pointer(F)).Fback_frame = uint64((int64(F) - int64(P)) / 1)
	rrc = DMATCH_MATCH
	goto RETURN_SWITCH

__3166:
	;
	goto __3165
__3164:
	P = uintptr(0)
__3165:
	; // Indicates starting frame not recorded

	// The group was not a conditional assertion.

	switch int32(*(*uint8)(unsafe.Pointer(bracode))) {
	case OP_BRA:
		goto __3168 // No need to do anything for these
	case OP_COND:
		goto __3169
	case OP_SCOND:
		goto __3170

	// Non-atomic positive assertions are like OP_BRA, except that the
	//       subject pointer must be put back to where it was at the start of the
	//       assertion.

	case OP_ASSERT_NA:
		goto __3171
	case OP_ASSERTBACK_NA:
		goto __3172

	// Atomic positive assertions are like OP_ONCE, except that in addition
	//       the subject pointer must be put back to where it was at the start of the
	//       assertion.

	case OP_ASSERT:
		goto __3173
	case OP_ASSERTBACK:
		goto __3174
	// Fall through

	// For an atomic group, discard internal backtracking points. We must
	//       also ensure that any remaining branches within the top-level of the group
	//       are not tried. Do this by adjusting the code pointer within the backtrack
	//       frame so that it points to the final branch.

	case OP_ONCE:
		goto __3175

	// A matching negative assertion returns MATCH, which is turned into
	//       NOMATCH at the assertion level.

	case OP_ASSERT_NOT:
		goto __3176
	case OP_ASSERTBACK_NOT:
		goto __3177

	// At the end of a script run, apply the script-checking rules. This code
	//       will never by exercised if Unicode support it not compiled, because in
	//       that environment script runs cause an error at compile time.

	case OP_SCRIPT_RUN:
		goto __3178

	// Whole-pattern recursion is coded as a recurse into group 0, so it
	//       won't be picked up here. Instead, we catch it when the OP_END is reached.
	//       Other recursion is handled here.

	case OP_CBRA:
		goto __3179
	case OP_CBRAPOS:
		goto __3180
	case OP_SCBRA:
		goto __3181
	case OP_SCBRAPOS:
		goto __3182
	}
	goto __3167

__3168: // No need to do anything for these
__3169:
__3170:
	goto __3167

	// Non-atomic positive assertions are like OP_BRA, except that the
	//       subject pointer must be put back to where it was at the start of the
	//       assertion.

__3171:
__3172:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __3183
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__3183:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Theapframe)(unsafe.Pointer(P)).Feptr
	goto __3167

	// Atomic positive assertions are like OP_ONCE, except that in addition
	//       the subject pointer must be put back to where it was at the start of the
	//       assertion.

__3173:
__3174:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __3184
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__3184:
	;
	(*Theapframe)(unsafe.Pointer(F)).Feptr = (*Theapframe)(unsafe.Pointer(P)).Feptr
	// Fall through

	// For an atomic group, discard internal backtracking points. We must
	//       also ensure that any remaining branches within the top-level of the group
	//       are not tried. Do this by adjusting the code pointer within the backtrack
	//       frame so that it points to the final branch.

__3175:
	(*Theapframe)(unsafe.Pointer(F)).Fback_frame = uint64((int64(F) - int64(P)) / 1)
__3185:

	y = uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(P)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(P)).Fecode + 2))))
	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(P)).Fecode + uintptr(y)))) != OP_ALT) {
		goto __3188
	}
	goto __3187
__3188:
	;
	*(*uintptr)(unsafe.Pointer(P)) += uintptr(y)
	goto __3186
__3186:
	goto __3185
	goto __3187
__3187:
	;
	goto __3167

	// A matching negative assertion returns MATCH, which is turned into
	//       NOMATCH at the assertion level.

__3176:
__3177:
	rrc = DMATCH_MATCH
	goto RETURN_SWITCH

	// At the end of a script run, apply the script-checking rules. This code
	//       will never by exercised if Unicode support it not compiled, because in
	//       that environment script runs cause an error at compile time.

__3178:
	if !!(X_pcre2_script_run_8(tls, (*Theapframe)(unsafe.Pointer(P)).Feptr, (*Theapframe)(unsafe.Pointer(F)).Feptr, utf) != 0) {
		goto __3189
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3189:
	;

	goto __3167

	// Whole-pattern recursion is coded as a recurse into group 0, so it
	//       won't be picked up here. Instead, we catch it when the OP_END is reached.
	//       Other recursion is handled here.

__3179:
__3180:
__3181:
__3182:
	number = uint32(int32(*(*uint8)(unsafe.Pointer(bracode + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(bracode + 4))))

	// Handle a recursively called group. We reinstate the previous set of
	//       captures and then carry on after the recursion call.

	if !((*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse == number) {
		goto __3190
	}

	P = N - uintptr(frame_size)
	libc.Xmemcpy(tls, F+uintptr(uint64(uintptr(0)+128)), P+128,
		(*Theapframe)(unsafe.Pointer(P)).Foffset_top*uint64(unsafe.Sizeof(uint64(0))))
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = (*Theapframe)(unsafe.Pointer(P)).Foffset_top
	(*Theapframe)(unsafe.Pointer(F)).Fcapture_last = (*Theapframe)(unsafe.Pointer(P)).Fcapture_last
	(*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse = (*Theapframe)(unsafe.Pointer(P)).Fcurrent_recurse
	(*Theapframe)(unsafe.Pointer(F)).Fecode = (*Theapframe)(unsafe.Pointer(P)).Fecode + uintptr(1) + uintptr(DLINK_SIZE)
	goto __10 // With next opcode
__3190:
	;

	// Deal with actual capturing.

	offset = uint64(number<<1 - uint32(2))
	(*Theapframe)(unsafe.Pointer(F)).Fcapture_last = number
	*(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset)*8)) = uint64((int64((*Theapframe)(unsafe.Pointer(P)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	*(*uint64)(unsafe.Pointer(F + 128 + uintptr(offset+uint64(1))*8)) = uint64((int64((*Theapframe)(unsafe.Pointer(F)).Feptr) - int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject)) / 1)
	if !(offset >= (*Theapframe)(unsafe.Pointer(F)).Foffset_top) {
		goto __3191
	}
	(*Theapframe)(unsafe.Pointer(F)).Foffset_top = offset + uint64(2)
__3191:
	;
	goto __3167
__3167:
	; // End actions relating to the starting opcode

	// OP_KETRPOS is a possessive repeating ket. Remember the current position,
	//     and return the MATCH_KETRPOS. This makes it possible to do the repeats one
	//     at a time from the outer level. This must precede the empty string test -
	//     in this case that test is done at the outer level.

	if !(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))) == OP_KETRPOS) {
		goto __3192
	}

	libc.Xmemcpy(tls, P+uintptr(uint64(uintptr(0)+80)),
		F+uintptr(uint64(uintptr(0)+80)),
		frame_copy_size)
	rrc = -998
	goto RETURN_SWITCH

__3192:
	;

	// Handle the different kinds of closing brackets. A non-repeating ket
	//     needs no special action, just continuing at this level. This also happens
	//     for the repeating kets if the group matched no characters, in order to
	//     forcibly break infinite loops. Otherwise, the repeating kets try the rest
	//     of the pattern or restart from the preceding bracket, in the appropriate
	//     order.

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) != OP_KET && (P == uintptr(0) || (*Theapframe)(unsafe.Pointer(F)).Feptr != (*Theapframe)(unsafe.Pointer(P)).Feptr)) {
		goto __3193
	}

	if !(int32((*Theapframe)(unsafe.Pointer(F)).Fop) == OP_KETRMIN) {
		goto __3194
	}

	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(1) + uintptr(DLINK_SIZE)
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM6
	goto MATCH_RECURSE
L_RM6:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3195
	}
	rrc = rrc
	goto RETURN_SWITCH
__3195:
	;

	*(*uintptr)(unsafe.Pointer(F)) -= uintptr(uint32(int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 2)))))
	goto __12 // End of ket processing
__3194:
	;

	/* Repeat the maximum number of times (KETRMAX) */

	start_ecode = bracode
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM7
	goto MATCH_RECURSE
L_RM7:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3196
	}
	rrc = rrc
	goto RETURN_SWITCH
__3196:
	;

__3193:
	;

	// Carry on at this level for a non-repeating ket, or after matching an
	//     empty string, or after repeating for a maximum number of times.

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(1 + DLINK_SIZE)
	goto __12

	// =====================================================================
	// Start and end of line assertions, not multiline mode.

__141: // Start of line, unless PCRE2_NOTBOL is set.
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTBOL != uint32(0)) {
		goto __3197
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3197:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

__142: // Unconditional start of subject
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject) {
		goto __3198
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3198:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// When PCRE2_NOTEOL is unset, assert before the subject end, or a
	//     terminating newline unless PCRE2_DOLLAR_ENDONLY is set.

__143:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEOL != uint32(0)) {
		goto __3199
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3199:
	;

	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_DOLLAR_ENDONLY == uint32(0)) {
		goto __3200
	}
	goto ASSERT_NL_OR_EOS
__3200:
	;

	// Fall through
	// Unconditional end of subject assertion (\z)

__144:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3201
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3201:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0) {
		goto __3202
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3203
	}
	return -2
__3203:
	;
__3202:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// End of subject or ending \n assertion (\Z)

__145:
ASSERT_NL_OR_EOS:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (!(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) || (*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen))) {
		goto __3204
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __3205
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3206
	}
	return -2
__3206:
	;
__3205:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3204:
	;

	// Either at end of string or \n before end.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0) {
		goto __3207
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3208
	}
	return -2
__3208:
	;
__3207:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// =====================================================================
	// Start and end of line assertions, multiline mode.

	// Start of subject unless notbol, or after any newline except for one at
	//     the very end, unless PCRE2_ALT_CIRCUMFLEX is set.

__146:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTBOL != uint32(0) && (*Theapframe)(unsafe.Pointer(F)).Feptr == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject) {
		goto __3209
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3209:
	;

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject && ((*Theapframe)(unsafe.Pointer(F)).Feptr == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_ALT_CIRCUMFLEX == uint32(0) || !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0))) {
		goto __3210
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3210:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// Assert before any newline, or before end of subject unless noteol is
	//     set.

__147:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3211
	}

	if !!(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, (*Theapframe)(unsafe.Pointer(F)).Feptr, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32((*Theapframe)(unsafe.Pointer(F)).Feptr <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __3213
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && (*Theapframe)(unsafe.Pointer(F)).Feptr+uintptr(1) >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_FIXED) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2) && int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr))) == int32(*(*uint8)(unsafe.Pointer(mb + 228)))) {
		goto __3214
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3215
	}
	return -2
__3215:
	;
__3214:
	;
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

__3213:
	;
	goto __3212
__3211:

	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions&DPCRE2_NOTEOL != uint32(0)) {
		goto __3216
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3216:
	;

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __3217
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3218
	}
	return -2
__3218:
	;
__3217:
	;

__3212:
	;
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// =====================================================================
	// Start of match assertion

__148:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr != (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_offset)) {
		goto __3219
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3219:
	;

	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// =====================================================================
	// Reset the start of match point

__149:
	(*Theapframe)(unsafe.Pointer(F)).Fstart_match = (*Theapframe)(unsafe.Pointer(F)).Feptr
	(*Theapframe)(unsafe.Pointer(F)).Fecode++
	goto __12

	// =====================================================================
	// Word boundary assertions. Find out if the previous and current
	//     characters are "word" characters. It takes a bit more work in UTF mode.
	//     Characters > 255 are assumed to be "non-word" characters when PCRE2_UCP is
	//     not set. When it is set, use Unicode properties if available, even when not
	//     in UTF mode. Remember the earliest and latest consulted characters.

__150:
__151:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr == (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject) {
		goto __3220
	}
	prev_is_word = DFALSE
	goto __3221
__3220:

	lastptr = (*Theapframe)(unsafe.Pointer(F)).Feptr - uintptr(1)
	if !(utf != 0) {
		goto __3222
	}

__3224:
	if !(uint32(*(*uint8)(unsafe.Pointer(lastptr)))&0xc0 == 0x80) {
		goto __3225
	}
	lastptr--
	goto __3224
__3225:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer(lastptr)))
	if !(fc >= 0xc0) {
		goto __3226
	}
	if !(fc&0x20 == uint32(0)) {
		goto __3227
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 1)))&0x3f
	goto __3228
__3227:
	if !(fc&0x10 == uint32(0)) {
		goto __3229
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 2)))&0x3f
	goto __3230
__3229:
	if !(fc&0x08 == uint32(0)) {
		goto __3231
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 3)))&0x3f
	goto __3232
__3231:
	if !(fc&0x04 == uint32(0)) {
		goto __3233
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 4)))&0x3f
	goto __3234
__3233:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(lastptr + 5)))&0x3f
__3234:
	;
__3232:
	;
__3230:
	;
__3228:
	;
__3226:
	;

	goto __3223
__3222:
	fc = uint32(*(*uint8)(unsafe.Pointer(lastptr)))
__3223:
	;
	if !(lastptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) {
		goto __3235
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = lastptr
__3235:
	;
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != uint32(0)) {
		goto __3236
	}

	if !(fc == uint32('_')) {
		goto __3238
	}
	prev_is_word = DTRUE
	goto __3239
__3238:

	cat = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	prev_is_word = libc.Bool32(cat == ucp_L || cat == ucp_N)
__3239:
	;
	goto __3237
__3236:
	prev_is_word = libc.Bool32(fc <= 255 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0)
__3237:
	;
__3221:
	;

	// Get status of next character

	if !((*Theapframe)(unsafe.Pointer(F)).Feptr >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __3240
	}

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial != 0)) {
		goto __3242
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DTRUE
	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) > 1) {
		goto __3243
	}
	return -2
__3243:
	;
__3242:
	;

	cur_is_word = DFALSE
	goto __3241
__3240:

	nextptr = (*Theapframe)(unsafe.Pointer(F)).Feptr + uintptr(1)
	if !(utf != 0) {
		goto __3244
	}

__3246:
	if !(nextptr < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && uint32(*(*uint8)(unsafe.Pointer(nextptr)))&0xc0 == 0x80) {
		goto __3247
	}
	nextptr++
	goto __3246
__3247:
	;
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
	if !(fc >= 0xc0) {
		goto __3248
	}
	if !(fc&0x20 == uint32(0)) {
		goto __3249
	}
	fc = fc&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f
	goto __3250
__3249:
	if !(fc&0x10 == uint32(0)) {
		goto __3251
	}
	fc = fc&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f
	goto __3252
__3251:
	if !(fc&0x08 == uint32(0)) {
		goto __3253
	}
	fc = fc&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f
	goto __3254
__3253:
	if !(fc&0x04 == uint32(0)) {
		goto __3255
	}
	fc = fc&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f
	goto __3256
__3255:
	fc = fc&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr + 5)))&0x3f
__3256:
	;
__3254:
	;
__3252:
	;
__3250:
	;
__3248:
	;

	goto __3245
__3244:
	fc = uint32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Feptr)))
__3245:
	;
	if !(nextptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __3257
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = nextptr
__3257:
	;
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions&DPCRE2_UCP != uint32(0)) {
		goto __3258
	}

	if !(fc == uint32('_')) {
		goto __3260
	}
	cur_is_word = DTRUE
	goto __3261
__3260:

	cat1 = int32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(fc)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(fc)%DUCD_BLOCK_SIZE])*12)).Fchartype])
	cur_is_word = libc.Bool32(cat1 == ucp_L || cat1 == ucp_N)
__3261:
	;
	goto __3259
__3258:
	cur_is_word = libc.Bool32(fc <= 255 && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes + uintptr(fc))))&Dctype_word != 0)
__3259:
	;
__3241:
	;

	// Now see if the situation is what we want

	if !(func() int32 {
		if int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&(*Theapframe)(unsafe.Pointer(F)).Fecode, 1)))) == OP_WORD_BOUNDARY {
			return libc.Bool32(cur_is_word == prev_is_word)
		}
		return libc.Bool32(cur_is_word != prev_is_word)
	}() != 0) {
		goto __3262
	}
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH
__3262:
	;

	goto __12

	// =====================================================================
	// Backtracking (*VERB)s, with and without arguments. Note that if the
	//     pattern is successfully matched, we do not come back from RMATCH.

__152:
	(*Theapframe)(unsafe.Pointer(F)).Fmark = libc.AssignPtrUintptr(mb+176, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM12
	goto MATCH_RECURSE
L_RM12:
	;

	// A return of MATCH_SKIP_ARG means that matching failed at SKIP with an
	//     argument, and we must check whether that argument matches this MARK's
	//     argument. It is passed back in mb->verb_skip_ptr. If it does match, we
	//     return MATCH_SKIP with mb->verb_skip_ptr now pointing to the subject
	//     position that corresponds to this mark. Otherwise, pass back the return
	//     code unaltered.

	if !(rrc == -994 && X_pcre2_strcmp_8(tls, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2), (*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr) == 0) {
		goto __3263
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr /* Pass back current position */
	rrc = -995
	goto RETURN_SWITCH

__3263:
	;
	rrc = rrc
	goto RETURN_SWITCH

__153:
	rrc = DMATCH_NOMATCH
	goto RETURN_SWITCH

	// Record the current recursing group number in mb->verb_current_recurse
	//     when a backtracking return such as MATCH_COMMIT is given. This enables the
	//     recurse processing to catch verbs from within the recursion.

__154:
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM13
	goto MATCH_RECURSE
L_RM13:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3264
	}
	rrc = rrc
	goto RETURN_SWITCH
__3264:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -997
	goto RETURN_SWITCH

__155:
	(*Theapframe)(unsafe.Pointer(F)).Fmark = libc.AssignPtrUintptr(mb+176, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM36
	goto MATCH_RECURSE
L_RM36:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3265
	}
	rrc = rrc
	goto RETURN_SWITCH
__3265:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -997
	goto RETURN_SWITCH

__156:
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM14
	goto MATCH_RECURSE
L_RM14:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3266
	}
	rrc = rrc
	goto RETURN_SWITCH
__3266:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -996
	goto RETURN_SWITCH

__157:
	(*Theapframe)(unsafe.Pointer(F)).Fmark = libc.AssignPtrUintptr(mb+176, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM15
	goto MATCH_RECURSE
L_RM15:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3267
	}
	rrc = rrc
	goto RETURN_SWITCH
__3267:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -996
	goto RETURN_SWITCH

__158:
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM16
	goto MATCH_RECURSE
L_RM16:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3268
	}
	rrc = rrc
	goto RETURN_SWITCH
__3268:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr // Pass back current position
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -995
	goto RETURN_SWITCH

	// Note that, for Perl compatibility, SKIP with an argument does NOT set
	//     nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was
	//     not a matching mark, we have to re-run the match, ignoring the SKIP_ARG
	//     that failed and any that precede it (either they also failed, or were not
	//     triggered). To do this, we maintain a count of executed SKIP_ARGs. If a
	//     SKIP_ARG gets to top level, the match is re-run with mb->ignore_skip_arg
	//     set to the count of the one that failed.

__159:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fskip_arg_count++
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fskip_arg_count <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fignore_skip_arg) {
		goto __3269
	}

	*(*uintptr)(unsafe.Pointer(F)) += uintptr(int32(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + int32(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1))))
	goto __12
__3269:
	;
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM17
	goto MATCH_RECURSE
L_RM17:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3270
	}
	rrc = rrc
	goto RETURN_SWITCH
__3270:
	;

	// Pass back the current skip name and return the special MATCH_SKIP_ARG
	//     return code. This will either be caught by a matching MARK, or get to the
	//     top, where it causes a rematch with mb->ignore_skip_arg set to the value of
	//     mb->skip_arg_count.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(2)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -994
	goto RETURN_SWITCH

	// For THEN (and THEN_ARG) we pass back the address of the opcode, so that
	//     the branch in which it occurs can be determined.

__160:
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))])
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM18
	goto MATCH_RECURSE
L_RM18:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3271
	}
	rrc = rrc
	goto RETURN_SWITCH
__3271:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -993
	goto RETURN_SWITCH

__161:
	(*Theapframe)(unsafe.Pointer(F)).Fmark = libc.AssignPtrUintptr(mb+176, (*Theapframe)(unsafe.Pointer(F)).Fecode+uintptr(2))
	start_ecode = (*Theapframe)(unsafe.Pointer(F)).Fecode + uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode))]) + uintptr(*(*uint8)(unsafe.Pointer((*Theapframe)(unsafe.Pointer(F)).Fecode + 1)))
	(*Theapframe)(unsafe.Pointer(F)).Freturn_id = RM19
	goto MATCH_RECURSE
L_RM19:
	;

	if !(rrc != DMATCH_NOMATCH) {
		goto __3272
	}
	rrc = rrc
	goto RETURN_SWITCH
__3272:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_ecode_ptr = (*Theapframe)(unsafe.Pointer(F)).Fecode
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_current_recurse = (*Theapframe)(unsafe.Pointer(F)).Fcurrent_recurse
	rrc = -993
	goto RETURN_SWITCH

	// =====================================================================
	// There's been some horrible disaster. Arrival here can only mean there is
	//     something seriously wrong in the code above or the OP_xxx definitions.

__162:
	return -44
__12:
	;

	// Do not insert any code in here without much thought; it is assumed
	//   that "continue" in the code above comes out to here to repeat the main
	//   loop.

	goto __10
__10:
	goto __9
	goto __11
__11:
	; // End of main loop
	// Control never reaches here

	// =========================================================================
	// The RRETURN() macro jumps here. The number that is saved in Freturn_id
	// indicates which label we actually want to return to. The value in Frdepth is
	// the index number of the frame in the vector. The return value has been placed
	// in rrc.

RETURN_SWITCH:
	if !((*Theapframe)(unsafe.Pointer(F)).Feptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr) {
		goto __3273
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = (*Theapframe)(unsafe.Pointer(F)).Feptr
__3273:
	;
	if !((*Theapframe)(unsafe.Pointer(F)).Frdepth == uint32(0)) {
		goto __3274
	}
	return rrc
__3274:
	;                                                                                                       // Exit from the top level
	F = F - uintptr((*Theapframe)(unsafe.Pointer(F)).Fback_frame)                                           // Backtrack
	*(*uint32)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcb + 104)) |= DPCRE2_CALLOUT_BACKTRACK // Note for callouts

	switch int32((*Theapframe)(unsafe.Pointer(F)).Freturn_id) {
	case 1:
		goto __3276
	case 2:
		goto __3277
	case 3:
		goto __3278
	case 4:
		goto __3279
	case 5:
		goto __3280
	case 6:
		goto __3281
	case 7:
		goto __3282
	case 8:
		goto __3283
	case 9:
		goto __3284
	case 10:
		goto __3285
	case 11:
		goto __3286
	case 12:
		goto __3287
	case 13:
		goto __3288
	case 14:
		goto __3289
	case 15:
		goto __3290
	case 16:
		goto __3291
	case 17:
		goto __3292
	case 18:
		goto __3293
	case 19:
		goto __3294
	case 20:
		goto __3295
	case 21:
		goto __3296
	case 22:
		goto __3297
	case 23:
		goto __3298
	case 24:
		goto __3299
	case 25:
		goto __3300
	case 26:
		goto __3301
	case 27:
		goto __3302
	case 28:
		goto __3303
	case 29:
		goto __3304
	case 30:
		goto __3305
	case 31:
		goto __3306
	case 32:
		goto __3307
	case 33:
		goto __3308
	case 34:
		goto __3309
	case 35:
		goto __3310
	case 36:
		goto __3311

	case 100:
		goto __3312
	case 101:
		goto __3313

	case 200:
		goto __3314
	case 201:
		goto __3315
	case 202:
		goto __3316
	case 203:
		goto __3317
	case 204:
		goto __3318
	case 205:
		goto __3319
	case 206:
		goto __3320
	case 207:
		goto __3321
	case 208:
		goto __3322
	case 209:
		goto __3323
	case 210:
		goto __3324
	case 211:
		goto __3325
	case 212:
		goto __3326
	case 213:
		goto __3327
	case 214:
		goto __3328
	case 215:
		goto __3329
	case 216:
		goto __3330
	case 217:
		goto __3331
	case 218:
		goto __3332
	case 219:
		goto __3333
	case 220:
		goto __3334
	case 221:
		goto __3335
	case 222:
		goto __3336
	case 223:
		goto __3337
	case 224:
		goto __3338
	case 225:
		goto __3339

	default:
		goto __3340
	}
	goto __3275

__3276:
	goto L_RM1
__3277:
	goto L_RM2
__3278:
	goto L_RM3
__3279:
	goto L_RM4
__3280:
	goto L_RM5
__3281:
	goto L_RM6
__3282:
	goto L_RM7
__3283:
	goto L_RM8
__3284:
	goto L_RM9
__3285:
	goto L_RM10
__3286:
	goto L_RM11
__3287:
	goto L_RM12
__3288:
	goto L_RM13
__3289:
	goto L_RM14
__3290:
	goto L_RM15
__3291:
	goto L_RM16
__3292:
	goto L_RM17
__3293:
	goto L_RM18
__3294:
	goto L_RM19
__3295:
	goto L_RM20
__3296:
	goto L_RM21
__3297:
	goto L_RM22
__3298:
	goto L_RM23
__3299:
	goto L_RM24
__3300:
	goto L_RM25
__3301:
	goto L_RM26
__3302:
	goto L_RM27
__3303:
	goto L_RM28
__3304:
	goto L_RM29
__3305:
	goto L_RM30
__3306:
	goto L_RM31
__3307:
	goto L_RM32
__3308:
	goto L_RM33
__3309:
	goto L_RM34
__3310:
	goto L_RM35
__3311:
	goto L_RM36

__3312:
	goto L_RM100
__3313:
	goto L_RM101

__3314:
	goto L_RM200
__3315:
	goto L_RM201
__3316:
	goto L_RM202
__3317:
	goto L_RM203
__3318:
	goto L_RM204
__3319:
	goto L_RM205
__3320:
	goto L_RM206
__3321:
	goto L_RM207
__3322:
	goto L_RM208
__3323:
	goto L_RM209
__3324:
	goto L_RM210
__3325:
	goto L_RM211
__3326:
	goto L_RM212
__3327:
	goto L_RM213
__3328:
	goto L_RM214
__3329:
	goto L_RM215
__3330:
	goto L_RM216
__3331:
	goto L_RM217
__3332:
	goto L_RM218
__3333:
	goto L_RM219
__3334:
	goto L_RM220
__3335:
	goto L_RM221
__3336:
	goto L_RM222
__3337:
	goto L_RM223
__3338:
	goto L_RM224
__3339:
	goto L_RM225

__3340:
	return -44
__3275:
	;
	return int32(0)
}

// ************************************************
//
//           Match a Regular Expression           *
//

// This function applies a compiled pattern to a subject string and picks out
// portions of the string if it matches. Two elements in the vector are set for
// each substring: the offsets to the start and end of the substring.
//
// Arguments:
//   code            points to the compiled expression
//   subject         points to the subject string
//   length          length of subject string (may contain binary zeros)
//   start_offset    where to start in the subject string
//   options         option bits
//   match_data      points to a match_data block
//   mcontext        points a PCRE2 context
//
// Returns:          > 0 => success; value is the number of ovector pairs filled
//                   = 0 => success, but ovector is not big enough
//                   = -1 => failed to match (PCRE2_ERROR_NOMATCH)
//                   = -2 => partial match (PCRE2_ERROR_PARTIAL)
//                   < -2 => some kind of unexpected problem

func Xpcre2_match_8(tls *libc.TLS, code uintptr, subject uintptr, length uint64, start_offset uint64, options uint32, match_data uintptr, mcontext uintptr) int32 { /* pcre2_match.c:6311:1: */
	bp := tls.Alloc(368)
	defer tls.Free(368)

	var rc int32
	var was_zero_terminated int32
	var start_bits uintptr
	var re uintptr
	var anchored int32
	var firstline int32
	var has_first_cu int32
	var has_req_cu int32
	var startline int32
	var memchr_found_first_cu uintptr
	var memchr_found_first_cu2 uintptr
	var first_cu uint8
	var first_cu2 uint8
	var req_cu uint8
	var req_cu2 uint8
	var bumpalong_limit uintptr
	var end_subject uintptr
	var true_end_subject uintptr
	var start_match uintptr
	var req_cu_ptr uintptr
	var start_partial uintptr
	var match_partial uintptr

	// This flag is needed even when Unicode is not supported for convenience
	// (it is used by the IS_NEWLINE macro).

	var utf int32
	var ucp int32
	var allow_invalid int32
	var fragment_options uint32
	var frame_size uint64
	var heapframes_size uint64

	// We need to have mb as a pointer to a match block, because the IS_NEWLINE
	// macro is used below, and it expects NLBLOCK to be defined as a pointer.

	// var cb Tpcre2_callout_block_8 at bp+256, 112

	// var actual_match_block Tmatch_block_8 at bp, 256

	var mb uintptr
	var i uint32
	var skipped_bad_start int32
	var t uintptr
	var c uint8
	var ok int32
	// In 16-bit and 32_bit modes we have to do our own search, so can
	//           look for both cases at once.

	// In 8-bit mode, the use of memchr() gives a big speed up, even
	//           though we have to call it twice in order to find the earliest
	//           occurrence of the code unit in either of its cases. Caching is used
	//           to remember the positions of previously found code units. This can
	//           make a huge difference when the strings are very long and only one
	//           case is actually present.

	var pp1 uintptr
	var pp2 uintptr
	var searchlength uint64
	var c1 uint32
	var pp uintptr
	var check_length uint64
	var p uintptr
	var new_start_match uintptr
	was_zero_terminated = 0
	start_bits = uintptr(0)
	re = code
	has_first_cu = DFALSE
	has_req_cu = DFALSE
	first_cu = uint8(0)
	first_cu2 = uint8(0)
	req_cu = uint8(0)
	req_cu2 = uint8(0)
	utf = DFALSE
	ucp = DFALSE
	fragment_options = uint32(0)
	mb = bp /* &actual_match_block */

	// Recognize NULL, length 0 as an empty string.

	if !(subject == uintptr(0) && length == uint64(0)) {
		goto __1
	}
	subject = ts + 797 /* "" */
__1:
	;

	// Plausibility checks

	if !(options&libc.CplUint32(DPCRE2_ANCHORED|DPCRE2_ENDANCHORED|DPCRE2_NOTBOL|DPCRE2_NOTEOL|DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART|DPCRE2_NO_UTF_CHECK|DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT|DPCRE2_NO_JIT|DPCRE2_COPY_MATCHED_SUBJECT) != uint32(0)) {
		goto __2
	}
	return -34
__2:
	;
	if !(code == uintptr(0) || subject == uintptr(0) || match_data == uintptr(0)) {
		goto __3
	}
	return -51
__3:
	;

	start_match = subject + uintptr(start_offset)
	req_cu_ptr = start_match - uintptr(1)
	if !(length == libc.CplUint64(uint64(0))) {
		goto __4
	}

	length = X_pcre2_strlen_8(tls, subject)
	was_zero_terminated = 1
__4:
	;
	true_end_subject = libc.AssignUintptr(&end_subject, subject+uintptr(length))

	if !(start_offset > length) {
		goto __5
	}
	return -33
__5:
	;

	// Check that the first field in the block is the magic number.

	if !(uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER) {
		goto __6
	}
	return -31
__6:
	;

	// Check the code unit width.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_MODE8|DPCRE2_MODE16|DPCRE2_MODE32) != uint32(DPCRE2_CODE_UNIT_WIDTH/8)) {
		goto __7
	}
	return -32
__7:
	;

	// PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the
	// options variable for this function. Users of PCRE2 who are not calling the
	// function directly would like to have a way of setting these flags, in the same
	// way that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with
	// constructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and
	// (*NOTEMPTY_ATSTART) set bits in the pattern's "flag" function which we now
	// transfer to the options for this function. The bits are guaranteed to be
	// adjacent, but do not have the same values. This bit of Boolean trickery assumes
	// that the match-time bits are not more significant than the flag bits. If by
	// accident this is not the case, a compile-time division by zero error will
	// occur.

	options = options | (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)/(uint32((DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)&(libc.CplInt32(DPCRE2_NOTEMPTY_SET|DPCRE2_NE_ATST_SET)+1))/((DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART)&(libc.CplUint32(DPCRE2_NOTEMPTY|DPCRE2_NOTEMPTY_ATSTART)+uint32(1))))

	// If the pattern was successfully studied with JIT support, we will run the
	// JIT executable instead of the rest of this function. Most options must be set
	// at compile time for the JIT code to be usable.

	// Initialize UTF/UCP parameters.

	utf = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF != uint32(0))
	allow_invalid = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_INVALID_UTF != uint32(0))
	ucp = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UCP != uint32(0))

	// Convert the partial matching flags into an integer.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial = func() uint16 {
		if options&DPCRE2_PARTIAL_HARD != uint32(0) {
			return uint16(2)
		}
		return func() uint16 {
			if options&DPCRE2_PARTIAL_SOFT != uint32(0) {
				return uint16(1)
			}
			return uint16(0)
		}()
	}()

	// Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same
	// time.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) != 0 && ((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options|options)&DPCRE2_ENDANCHORED != uint32(0)) {
		goto __8
	}
	return -34
__8:
	;

	// It is an error to set an offset limit without setting the flag at compile
	// time.

	if !(mcontext != uintptr(0) && (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit != libc.CplUint64(uint64(0)) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_USE_OFFSET_LIMIT == uint32(0)) {
		goto __9
	}
	return -56
__9:
	;

	// If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,
	// free the memory that was obtained. Set the field to NULL for no match cases.

	if !(uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fflags)&DPCRE2_MD_COPIED_SUBJECT != uint32(0)) {
		goto __10
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	*(*uint8)(unsafe.Pointer(match_data + 89)) &= libc.Uint8FromUint32(libc.CplUint32(DPCRE2_MD_COPIED_SUBJECT))
__10:
	;
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = uintptr(0)

	// Zero the error offset in case the first code unit is invalid UTF.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar = uint64(0)

	// ============================= JIT matching ==============================

	// Prepare for JIT matching. Check a UTF string for validity unless no check is
	// requested or invalid UTF can be handled. We check only the portion of the
	// subject that might be be inspected during matching - from the offset minus the
	// maximum lookbehind to the given length. This saves time when a small part of a
	// large subject is being matched by the use of a starting offset. Note that the
	// maximum lookbehind is a number of characters, not code units.

	// ========================= End of JIT matching ==========================

	// Proceed with non-JIT matching. The default is to allow lookbehinds to the
	// start of the subject. A UTF check when there is a non-zero offset may change
	// this.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject = subject

	// If a UTF subject string was not checked for validity in the JIT code above,
	// check it here, and handle support for invalid UTF strings. The check above
	// happens only when invalid UTF is not supported and PCRE2_NO_CHECK_UTF is unset.
	// If we get here in those circumstances, it means the subject string is valid,
	// but for some reason JIT matching was not successful. There is no need to check
	// the subject again.
	//
	// We check only the portion of the subject that might be be inspected during
	// matching - from the offset minus the maximum lookbehind to the given length.
	// This saves time when a small part of a large subject is being matched by the
	// use of a starting offset. Note that the maximum lookbehind is a number of
	// characters, not code units.
	//
	// Note also that support for invalid UTF forces a check, overriding the setting
	// of PCRE2_NO_CHECK_UTF.

	if !(utf != 0 && (options&DPCRE2_NO_UTF_CHECK == uint32(0) || allow_invalid != 0)) {
		goto __11
	}

	skipped_bad_start = DFALSE

	// For 8-bit and 16-bit UTF, check that the first code unit is a valid
	//   character start. If we are handling invalid UTF, just skip over such code
	//   units. Otherwise, give an appropriate error.

	if !(allow_invalid != 0) {
		goto __12
	}

__14:
	if !(start_match < end_subject && uint32(*(*uint8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __15
	}

	start_match++
	skipped_bad_start = DTRUE
	goto __14
__15:
	;
	goto __13
__12:
	if !(start_match < end_subject && uint32(*(*uint8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __16
	}

	if !(start_offset > uint64(0)) {
		goto __17
	}
	return -36
__17:
	;
	return -22 // Isolated 0x80 byte
__16:
	;
__13:
	;

	// The mb->check_subject field points to the start of UTF checking;
	//   lookbehinds can go back no further than this.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject = start_match

	// Move back by the maximum lookbehind, just in case it happens at the very
	//   start of matching, but don't do this if we skipped bad 8-bit or 16-bit code
	//   units above.

	if !!(skipped_bad_start != 0) {
		goto __18
	}

	i = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind)
__19:
	if !(i > uint32(0) && (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject > subject) {
		goto __21
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject--
__22:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject > subject && int32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject)))&0xc0 == 0x80) {
		goto __23
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject--
	goto __22
__23:
	;
	goto __20
__20:
	i--
	goto __19
	goto __21
__21:
	;
__18:
	;

	// Validate the relevant portion of the subject. There's a loop in case we
	//   encounter bad UTF in the characters preceding start_match which we are
	//   scanning because of a lookbehind.

__24:

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = X_pcre2_valid_utf_8(tls, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject,
		length-uint64((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject)-int64(subject))/1), match_data+80)

	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc == 0) {
		goto __27
	}
	goto __26
__27:
	; // Valid UTF string

	// Invalid UTF string. Adjust the offset to be an absolute offset in the
	//     whole string. If we are handling invalid UTF strings, set end_subject to
	//     stop before the bad code unit, and set the options to "not end of line".
	//     Otherwise return the error.

	*(*uint64)(unsafe.Pointer(match_data + 80)) += uint64((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject) - int64(subject)) / 1)
	if !(!(allow_invalid != 0) || (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc > 0) {
		goto __28
	}
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
__28:
	;
	end_subject = subject + uintptr((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar)

	// If the end precedes start_match, it means there is invalid UTF in the
	//     extra code units we reversed over because of a lookbehind. Advance past the
	//     first bad code unit, and then skip invalid character starting code units in
	//     8-bit and 16-bit modes, and try again with the original end point.

	if !(end_subject < start_match) {
		goto __29
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject = end_subject + uintptr(1)
__31:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject < start_match && uint32(*(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject)))&0xc0 == 0x80) {
		goto __32
	}
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject++
	goto __31
__32:
	;
	end_subject = true_end_subject
	goto __30
__29:

	fragment_options = DPCRE2_NOTEOL
	goto __26
__30:
	;
	goto __25
__25:
	goto __24
	goto __26
__26:
	;
__11:
	;

	// A NULL match context means "use a default context", but we take the memory
	// control functions from the pattern.

	if !(mcontext == uintptr(0)) {
		goto __33
	}

	mcontext = uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmemctl
	goto __34
__33:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmemctl = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmemctl
__34:
	;

	anchored = libc.Bool32(((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options|options)&DPCRE2_ANCHORED != uint32(0))
	firstline = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_FIRSTLINE != uint32(0))
	startline = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_STARTLINE) != uint32(0))
	if (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit == libc.CplUint64(uint64(0)) {
		bumpalong_limit = true_end_subject
	} else {
		bumpalong_limit = subject + uintptr((*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Foffset_limit)
	}

	// Initialize and set up the fixed fields in the callout block, with a pointer
	// in the match block.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcb = bp + 256 /* &cb */
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 256 /* &cb */)).Fversion = uint32(2)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 256 /* &cb */)).Fsubject = subject
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 256 /* &cb */)).Fsubject_length = uint64((int64(end_subject) - int64(subject)) / 1)
	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 256 /* &cb */)).Fcallout_flags = uint32(0)

	// Fill in the remaining fields in the match block, except for moptions, which
	// gets set later.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcallout_data = (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fcallout_data

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject = subject
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_offset = start_offset
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject = end_subject
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhasthen = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_HASTHEN) != uint32(0))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fallowemptypartial = libc.Bool32(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind) > 0 || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_MATCH_EMPTY) != uint32(0))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fpoptions = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options // Pattern options
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fignore_skip_arg = uint32(0)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmark = libc.AssignPtrUintptr(mb+176, uintptr(0)) // In case never set

	// The name table is needed for finding all the numbers associated with a
	// given name, for condition testing. The code follows the name table.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_count = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_entry_size = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_code = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fname_table + uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size))

	// Process the \R and newline settings.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fbsr_convention = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fbsr_convention
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype = uint32(DNLTYPE_FIXED)
	switch int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fnewline_convention) {
	case DPCRE2_NEWLINE_CR:
		goto __36

	case DPCRE2_NEWLINE_LF:
		goto __37

	case DPCRE2_NEWLINE_NUL:
		goto __38

	case DPCRE2_NEWLINE_CRLF:
		goto __39

	case DPCRE2_NEWLINE_ANY:
		goto __40

	case DPCRE2_NEWLINE_ANYCRLF:
		goto __41

	default:
		goto __42
	}
	goto __35

__36:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(mb + 228)) = uint8('\015')
	goto __35

__37:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(mb + 228)) = uint8('\012')
	goto __35

__38:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen = uint32(1)
	*(*uint8)(unsafe.Pointer(mb + 228)) = uint8(0)
	goto __35

__39:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen = uint32(2)
	*(*uint8)(unsafe.Pointer(mb + 228)) = uint8('\015')
	*(*uint8)(unsafe.Pointer(mb + 228 + 1)) = uint8('\012')
	goto __35

__40:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype = uint32(DNLTYPE_ANY)
	goto __35

__41:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype = uint32(DNLTYPE_ANYCRLF)
	goto __35

__42:
	return -44
__35:
	;

	// The backtracking frames have fixed data at the front, and a PCRE2_SIZE
	// vector at the end, whose size depends on the number of capturing parentheses in
	// the pattern. It is not used at all if there are no capturing parentheses.
	//
	//   frame_size                   is the total size of each frame
	//   match_data->heapframes       is the pointer to the frames vector
	//   match_data->heapframes_size  is the total size of the vector
	//
	// We must pad the frame_size for alignment to ensure subsequent frames are as
	// aligned as heapframe. Whilst ovector is word-aligned due to being a PCRE2_SIZE
	// array, that does not guarantee it is suitably aligned for pointers, as some
	// architectures have pointers that are larger than a size_t.

	frame_size = (uint64(uintptr(0)+128) + uint64(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket)*2)*uint64(unsafe.Sizeof(uint64(0))) + uint64(uintptr(0)+8) - uint64(1)) & libc.CplUint64(uint64(uintptr(0)+8)-uint64(1))

	// Limits set in the pattern override the match context only if they are
	// smaller.

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit = uint64(func() uint32 {
		if (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fheap_limit < (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap {
			return (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fheap_limit
		}
		return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap
	}() * uint32(1024))

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_limit = func() uint32 {
		if (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmatch_limit < (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match {
			return (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fmatch_limit
		}
		return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match
	}()

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_limit_depth = func() uint32 {
		if (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fdepth_limit < (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth {
			return (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fdepth_limit
		}
		return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth
	}()

	// If a pattern has very many capturing parentheses, the frame size may be very
	// large. Set the initial frame vector size to ensure that there are at least 10
	// available frames, but enforce a minimum of START_FRAMES_SIZE. If this is
	// greater than the heap limit, get as large a vector as possible. Always round
	// the size to a multiple of the frame size.

	heapframes_size = frame_size * uint64(10)
	if !(heapframes_size < uint64(DSTART_FRAMES_SIZE)) {
		goto __43
	}
	heapframes_size = uint64(DSTART_FRAMES_SIZE)
__43:
	;
	if !(heapframes_size > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit) {
		goto __44
	}

	if !(frame_size > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit) {
		goto __45
	}
	return -63
__45:
	;
	heapframes_size = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fheap_limit
__44:
	;

	// If an existing frame vector in the match_data block is large enough, we can
	// use it.Otherwise, free any pre-existing vector and get a new one.

	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes_size < heapframes_size) {
		goto __46
	}

	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmalloc})).f(tls, heapframes_size,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes == uintptr(0)) {
		goto __47
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes_size = uint64(0)
	return -48
__47:
	;
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes_size = heapframes_size
__46:
	;

	// Write to the ovector within the first frame to mark every capture unset and
	// to avoid uninitialized memory read errors when it is copied to a new frame.

	libc.Xmemset(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes+uintptr(uint64(uintptr(0)+128)), 0xff,
		frame_size-uint64(uintptr(0)+128))

	// Pointers to the individual character tables

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flcc = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Dlcc_offset)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Dfcc_offset)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fctypes = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Dcbits_offset+Dcbit_length)

	// Set up the first code unit to match, if available. If there's no first code
	// unit there may be a bitmap of possible first characters.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTSET) != uint32(0)) {
		goto __48
	}

	has_first_cu = DTRUE
	first_cu = libc.AssignUint8(&first_cu2, uint8((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit))
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTCASELESS) != uint32(0)) {
		goto __50
	}

	first_cu2 = *(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(first_cu)))
	if !(int32(first_cu) > 127 && ucp != 0 && !(utf != 0)) {
		goto __51
	}
	first_cu2 = uint8(uint32(int32(first_cu) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(first_cu)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(first_cu)%DUCD_BLOCK_SIZE])*12)).Fother_case))
__51:
	;
__50:
	;
	goto __49
__48:
	if !(!(startline != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTMAPSET) != uint32(0)) {
		goto __52
	}
	start_bits = re + 40 /* &.start_bitmap */
__52:
	;
__49:
	;

	// There may also be a "last known required character" set.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_LASTSET) != uint32(0)) {
		goto __53
	}

	has_req_cu = DTRUE
	req_cu = libc.AssignUint8(&req_cu2, uint8((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit))
	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_LASTCASELESS) != uint32(0)) {
		goto __54
	}

	req_cu2 = *(*uint8)(unsafe.Pointer((*Tmatch_block_8)(unsafe.Pointer(mb)).Ffcc + uintptr(req_cu)))
	if !(int32(req_cu) > 127 && ucp != 0 && !(utf != 0)) {
		goto __55
	}
	req_cu2 = uint8(uint32(int32(req_cu) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(req_cu)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(req_cu)%DUCD_BLOCK_SIZE])*12)).Fother_case))
__55:
	;
__54:
	;
__53:
	;

	// ==========================================================================

	// Loop for handling unanchored repeated matching attempts; for anchored regexs
	// the loop runs just once.

FRAGMENT_RESTART:

	start_partial = libc.AssignUintptr(&match_partial, uintptr(0))
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend = DFALSE

	memchr_found_first_cu = uintptr(0)
	memchr_found_first_cu2 = uintptr(0)

__56:

	// ----------------- Start of match optimizations ----------------

	// There are some optimizations that avoid running the match if a known
	//   starting point is not found, or if a known later code unit is not present.
	//   However, there is an option (settable at compile time) that disables these,
	//   for testing and for ensuring that all callouts do actually occur.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_NO_START_OPTIMIZE == uint32(0)) {
		goto __59
	}

	// If firstline is TRUE, the start of the match is constrained to the first
	//     line of a multiline string. That is, the match must be before or at the
	//     first newline following the start of matching. Temporarily adjust
	//     end_subject so that we stop the scans for a first code unit at a newline.
	//     If the match fails at the newline, later code breaks the loop.

	if !(firstline != 0) {
		goto __60
	}

	t = start_match
	if !(utf != 0) {
		goto __61
	}

__63:
	if !(t < end_subject && !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(t < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, t, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32(t <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(t))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(t + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0)) {
		goto __64
	}

	t++
__65:
	if !(t < end_subject && uint32(*(*uint8)(unsafe.Pointer(t)))&0xc0 == 0x80) {
		goto __66
	}
	t++
	goto __65
__66:
	;
	goto __63
__64:
	;
	goto __62
__61:
__67:
	if !(t < end_subject && !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(t < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, t, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32(t <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(t))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(t + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0)) {
		goto __68
	}
	t++
	goto __67
__68:
	;
__62:
	;
	end_subject = t
__60:
	;

	// Anchored: check the first code unit if one is recorded. This may seem
	//     pointless but it can help in detecting a no match case without scanning for
	//     the required code unit.

	if !(anchored != 0) {
		goto __69
	}

	if !(has_first_cu != 0 || start_bits != uintptr(0)) {
		goto __71
	}

	ok = libc.Bool32(start_match < end_subject)
	if !(ok != 0) {
		goto __72
	}

	c = *(*uint8)(unsafe.Pointer(start_match))
	ok = libc.Bool32(has_first_cu != 0 && (int32(c) == int32(first_cu) || int32(c) == int32(first_cu2)))
	if !(!(ok != 0) && start_bits != uintptr(0)) {
		goto __73
	}

	ok = libc.Bool32(uint32(*(*uint8)(unsafe.Pointer(start_bits + uintptr(int32(c)/8))))&(uint32(1)<<(int32(c)&7)) != uint32(0))
__73:
	;
__72:
	;
	if !!(ok != 0) {
		goto __74
	}

	rc = DMATCH_NOMATCH
	goto __58
__74:
	;
__71:
	;
	goto __70
__69:

	if !(has_first_cu != 0) {
		goto __75
	}

	if !(int32(first_cu) != int32(first_cu2)) {
		goto __77
	} /* Caseless */

	// In 16-bit and 32_bit modes we have to do our own search, so can
	//           look for both cases at once.

	// In 8-bit mode, the use of memchr() gives a big speed up, even
	//           though we have to call it twice in order to find the earliest
	//           occurrence of the code unit in either of its cases. Caching is used
	//           to remember the positions of previously found code units. This can
	//           make a huge difference when the strings are very long and only one
	//           case is actually present.

	pp1 = uintptr(0)
	pp2 = uintptr(0)
	searchlength = uint64((int64(end_subject) - int64(start_match)) / 1)

	// If we haven't got a previously found position for first_cu, or if
	//           the current starting position is later, we need to do a search. If
	//           the code unit is not found, set it to the end.

	if !(memchr_found_first_cu == uintptr(0) || start_match > memchr_found_first_cu) {
		goto __79
	}

	pp1 = libc.Xmemchr(tls, start_match, int32(first_cu), searchlength)
	if pp1 == uintptr(0) {
		memchr_found_first_cu = end_subject
	} else {
		memchr_found_first_cu = pp1
	}
	goto __80
__79:
	if memchr_found_first_cu == end_subject {
		pp1 = uintptr(0)
	} else {
		pp1 = memchr_found_first_cu
	}
__80:
	;

	// Do the same thing for the other case.

	if !(memchr_found_first_cu2 == uintptr(0) || start_match > memchr_found_first_cu2) {
		goto __81
	}

	pp2 = libc.Xmemchr(tls, start_match, int32(first_cu2), searchlength)
	if pp2 == uintptr(0) {
		memchr_found_first_cu2 = end_subject
	} else {
		memchr_found_first_cu2 = pp2
	}
	goto __82
__81:
	if memchr_found_first_cu2 == end_subject {
		pp2 = uintptr(0)
	} else {
		pp2 = memchr_found_first_cu2
	}
__82:
	;

	// Set the start to the end of the subject if neither case was found.
	//           Otherwise, use the earlier found point.

	if !(pp1 == uintptr(0)) {
		goto __83
	}
	if pp2 == uintptr(0) {
		start_match = end_subject
	} else {
		start_match = pp2
	}
	goto __84
__83:
	if pp2 == uintptr(0) || pp1 < pp2 {
		start_match = pp1
	} else {
		start_match = pp2
	}
__84:
	;

	goto __78
__77:

	start_match = libc.Xmemchr(tls, start_match, int32(first_cu), uint64((int64(end_subject)-int64(start_match))/1))
	if !(start_match == uintptr(0)) {
		goto __85
	}
	start_match = end_subject
__85:
	;
__78:
	;

	// If we can't find the required first code unit, having reached the
	//         true end of the subject, break the bumpalong loop, to force a match
	//         failure, except when doing partial matching, when we let the next cycle
	//         run at the end of the subject. To see why, consider the pattern
	//         /(?<=abc)def/, which partially matches "abc", even though the string
	//         does not contain the starting character "d". If we have not reached the
	//         true end of the subject (PCRE2_FIRSTLINE caused end_subject to be
	//         temporarily modified) we also let the cycle run, because the matching
	//         string is legitimately allowed to start with the first code unit of a
	//         newline.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) == 0 && start_match >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __86
	}

	rc = DMATCH_NOMATCH
	goto __58
__86:
	;
	goto __76
__75:
	if !(startline != 0) {
		goto __87
	}

	if !(start_match > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr(start_offset)) {
		goto __89
	}

	if !(utf != 0) {
		goto __90
	}

__92:
	if !(start_match < end_subject && !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(start_match > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, start_match, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+224, utf) != 0)
		}
		return libc.Bool32(start_match >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(start_match - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(start_match - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0)) {
		goto __93
	}

	start_match++
__94:
	if !(start_match < end_subject && uint32(*(*uint8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __95
	}
	start_match++
	goto __94
__95:
	;
	goto __92
__93:
	;
	goto __91
__90:
__96:
	if !(start_match < end_subject && !(func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(start_match > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject && X_pcre2_was_newline_8(tls, start_match, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject, mb+224, utf) != 0)
		}
		return libc.Bool32(start_match >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_subject+uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(start_match - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(start_match - uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0)) {
		goto __97
	}
	start_match++
	goto __96
__97:
	;
__91:
	;

	// If we have just passed a CR and the newline option is ANY or
	//           ANYCRLF, and we are now at a LF, advance the match position by one
	//           more code unit.

	if !(int32(*(*uint8)(unsafe.Pointer(start_match + libc.UintptrFromInt32(-1)))) == '\015' && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_ANY) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_ANYCRLF)) && start_match < end_subject && int32(*(*uint8)(unsafe.Pointer(start_match))) == '\012') {
		goto __98
	}
	start_match++
__98:
	;
__89:
	;
	goto __88
__87:
	if !(start_bits != uintptr(0)) {
		goto __99
	}

__100:
	if !(start_match < end_subject) {
		goto __101
	}

	c1 = uint32(*(*uint8)(unsafe.Pointer(start_match)))
	if !(uint32(*(*uint8)(unsafe.Pointer(start_bits + uintptr(c1/uint32(8)))))&(uint32(1)<<(c1&uint32(7))) != uint32(0)) {
		goto __102
	}
	goto __101
__102:
	;
	start_match++
	goto __100
__101:
	;

	// See comment above in first_cu checking about the next few lines.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) == 0 && start_match >= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject) {
		goto __103
	}

	rc = DMATCH_NOMATCH
	goto __58
__103:
	;
__99:
	;
__88:
	;
__76:
	;
__70:
	; // End first code unit handling

	// Restore fudged end_subject

	end_subject = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject

	// The following two optimizations must be disabled for partial matching.

	if !(int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fpartial) == 0) {
		goto __104
	}

	// The minimum matching length is a lower bound; no string of that length
	//       may actually match the pattern. Although the value is, strictly, in
	//       characters, we treat it as code units to avoid spending too much time in
	//       this optimization.

	if !((int64(end_subject)-int64(start_match))/1 < int64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength)) {
		goto __105
	}

	rc = DMATCH_NOMATCH
	goto __58
__105:
	;

	// If req_cu is set, we know that that code unit must appear in the
	//       subject for the (non-partial) match to succeed. If the first code unit is
	//       set, req_cu must be later in the subject; otherwise the test starts at
	//       the match point. This optimization can save a huge amount of backtracking
	//       in patterns with nested unlimited repeats that aren't going to match.
	//       Writing separate code for caseful/caseless versions makes it go faster,
	//       as does using an autoincrement and backing off on a match. As in the case
	//       of the first code unit, using memchr() in the 8-bit library gives a big
	//       speed up. Unlike the first_cu check above, we do not need to call
	//       memchr() twice in the caseless case because we only need to check for the
	//       presence of the character in either case, not find the first occurrence.
	//
	//       The search can be skipped if the code unit was found later than the
	//       current starting point in a previous iteration of the bumpalong loop.
	//
	//       HOWEVER: when the subject string is very, very long, searching to its end
	//       can take a long time, and give bad performance on quite ordinary
	//       anchored patterns. This showed up when somebody was matching something
	//       like /^\d+C/ on a 32-megabyte string... so we don't do this when the
	//       string is sufficiently long, but it's worth searching a lot more for
	//       unanchored patterns.

	p = start_match + uintptr(func() int32 {
		if has_first_cu != 0 {
			return 1
		}
		return 0
	}())
	if !(has_req_cu != 0 && p > req_cu_ptr) {
		goto __106
	}

	check_length = uint64((int64(end_subject) - int64(start_match)) / 1)

	if !(check_length < uint64(DREQ_CU_MAX) || !(anchored != 0) && check_length < uint64(DREQ_CU_MAX*1000)) {
		goto __107
	}

	if !(int32(req_cu) != int32(req_cu2)) {
		goto __108
	} /* Caseless */

	pp = p
	p = libc.Xmemchr(tls, pp, int32(req_cu), uint64((int64(end_subject)-int64(pp))/1))
	if !(p == uintptr(0)) {
		goto __110
	}

	p = libc.Xmemchr(tls, pp, int32(req_cu2), uint64((int64(end_subject)-int64(pp))/1))
	if !(p == uintptr(0)) {
		goto __111
	}
	p = end_subject
__111:
	;
__110:
	;
	goto __109
__108:

	p = libc.Xmemchr(tls, p, int32(req_cu), uint64((int64(end_subject)-int64(p))/1))
	if !(p == uintptr(0)) {
		goto __112
	}
	p = end_subject
__112:
	;
__109:
	;

	// If we can't find the required code unit, break the bumpalong loop,
	//           forcing a match failure.

	if !(p >= end_subject) {
		goto __113
	}

	rc = DMATCH_NOMATCH
	goto __58
__113:
	;

	// If we have found the required code unit, save the point where we
	//           found it, so that we don't search again next time round the bumpalong
	//           loop if the start hasn't yet passed this code unit.

	req_cu_ptr = p
__107:
	;
__106:
	;
__104:
	;
__59:
	;

	// ------------ End of start of match optimizations ------------

	// Give no match if we have passed the bumpalong limit.

	if !(start_match > bumpalong_limit) {
		goto __114
	}

	rc = DMATCH_NOMATCH
	goto __58
__114:
	;

	// OK, we can now run the match. If "hitend" is set afterwards, remember the
	//   first starting point for which a partial match was found.

	(*Tpcre2_callout_block_8)(unsafe.Pointer(bp + 256 /* &cb */)).Fstart_match = uint64((int64(start_match) - int64(subject)) / 1)
	*(*uint32)(unsafe.Pointer(bp + 256 + 104)) |= DPCRE2_CALLOUT_STARTMATCH

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr = start_match
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr = start_match
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmoptions = options | fragment_options
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmatch_call_count = uint32(0)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_offset_top = uint64(0)
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fskip_arg_count = uint32(0)

	rc = match(tls, start_match, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_code, (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket, frame_size,
		match_data, mb)

	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fhitend != 0 && start_partial == uintptr(0)) {
		goto __115
	}

	start_partial = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr
	match_partial = start_match
__115:
	;

	switch rc {
	// If MATCH_SKIP_ARG reaches this level it means that a MARK that matched
	//     the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP
	//     entirely. The only way we can do that is to re-do the match at the same
	//     point, with a flag to force SKIP with an argument to be ignored. Just
	//     treating this case as NOMATCH does not work because it does not check other
	//     alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC.

	case -994:
		goto __117

	// SKIP passes back the next starting point explicitly, but if it is no
	//     greater than the match we have just done, treat it as NOMATCH.

	case -995:
		goto __118
	// Fall through

	// NOMATCH and PRUNE advance by one character. THEN at this level acts
	//     exactly like PRUNE. Unset ignore SKIP-with-argument.

	case DMATCH_NOMATCH:
		goto __119
	case -996:
		goto __120
	case -993:
		goto __121

	// COMMIT disables the bumpalong, but otherwise behaves as NOMATCH.

	case -997:
		goto __122

	// Any other return is either a match, or some kind of error.

	default:
		goto __123
	}
	goto __116

	// If MATCH_SKIP_ARG reaches this level it means that a MARK that matched
	//     the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP
	//     entirely. The only way we can do that is to re-do the match at the same
	//     point, with a flag to force SKIP with an argument to be ignored. Just
	//     treating this case as NOMATCH does not work because it does not check other
	//     alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC.

__117:
	new_start_match = start_match
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fignore_skip_arg = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fskip_arg_count
	goto __116

	// SKIP passes back the next starting point explicitly, but if it is no
	//     greater than the match we have just done, treat it as NOMATCH.

__118:
	if !((*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr > start_match) {
		goto __124
	}

	new_start_match = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fverb_skip_ptr
	goto __116
__124:
	;
	// Fall through

	// NOMATCH and PRUNE advance by one character. THEN at this level acts
	//     exactly like PRUNE. Unset ignore SKIP-with-argument.

__119:
__120:
__121:
	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fignore_skip_arg = uint32(0)
	new_start_match = start_match + uintptr(1)
	if !(utf != 0) {
		goto __125
	}
__126:
	if !(new_start_match < end_subject && uint32(*(*uint8)(unsafe.Pointer(new_start_match)))&0xc0 == 0x80) {
		goto __127
	}
	new_start_match++
	goto __126
__127:
	;
__125:
	;
	goto __116

	// COMMIT disables the bumpalong, but otherwise behaves as NOMATCH.

__122:
	rc = DMATCH_NOMATCH
	goto ENDLOOP

	// Any other return is either a match, or some kind of error.

__123:
	goto ENDLOOP
__116:
	;

	// Control reaches here for the various types of "no match at this point"
	//   result. Reset the code to MATCH_NOMATCH for subsequent checking.

	rc = DMATCH_NOMATCH

	// If PCRE2_FIRSTLINE is set, the match must happen before or at the first
	//   newline in the subject (though it may continue over the newline). Therefore,
	//   if we have just failed to match, starting at a newline, do not continue.

	if !(firstline != 0 && func() int32 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype != uint32(DNLTYPE_FIXED) {
			return libc.Bool32(start_match < (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject && X_pcre2_is_newline_8(tls, start_match, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype, (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject, mb+224, utf) != 0)
		}
		return libc.Bool32(start_match <= (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject-uintptr((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen) && int32(*(*uint8)(unsafe.Pointer(start_match))) == int32(*(*uint8)(unsafe.Pointer(mb + 228))) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(1) || int32(*(*uint8)(unsafe.Pointer(start_match + uintptr(1)))) == int32(*(*uint8)(unsafe.Pointer(mb + 228 + 1)))))
	}() != 0) {
		goto __128
	}
	goto __58
__128:
	;

	// Advance to new matching position

	start_match = new_start_match

	// Break the loop if the pattern is anchored or if we have passed the end of
	//   the subject.

	if !(anchored != 0 || start_match > end_subject) {
		goto __129
	}
	goto __58
__129:
	;

	// If we have just passed a CR and we are now at a LF, and the pattern does
	//   not contain any explicit matches for \r or \n, and the newline option is CRLF
	//   or ANY or ANYCRLF, advance the match position by one more code unit. In
	//   normal matching start_match will aways be greater than the first position at
	//   this stage, but a failed *SKIP can cause a return at the same point, which is
	//   why the first test exists.

	if !(start_match > subject+uintptr(start_offset) && int32(*(*uint8)(unsafe.Pointer(start_match + libc.UintptrFromInt32(-1)))) == '\015' && start_match < end_subject && int32(*(*uint8)(unsafe.Pointer(start_match))) == '\012' && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_HASCRORLF) == uint32(0) && ((*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_ANY) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnltype == uint32(DNLTYPE_ANYCRLF) || (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnllen == uint32(2))) {
		goto __130
	}
	start_match++
__130:
	;

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fmark = uintptr(0) // Reset for start of next match attempt
	goto __57
__57:
	goto __56
	goto __58
__58:
	; // End of for(;;) "bumpalong" loop

	// ==========================================================================

	// When we reach here, one of the following stopping conditions is true:
	//
	// (1) The match succeeded, either completely, or partially;
	//
	// (2) The pattern is anchored or the match was failed after (*COMMIT);
	//
	// (3) We are past the end of the subject or the bumpalong limit;
	//
	// (4) PCRE2_FIRSTLINE is set and we have failed to match at a newline, because
	//     this option requests that a match occur at or before the first newline in
	//     the subject.
	//
	// (5) Some kind of error occurred.
	//

ENDLOOP:

	// If end_subject != true_end_subject, it means we are handling invalid UTF,
	// and have just processed a non-terminal fragment. If this resulted in no match
	// or a partial match we must carry on to the next fragment (a partial match is
	// returned to the caller only at the very end of the subject). A loop is used to
	// avoid trying to match against empty fragments; if the pattern can match an
	// empty string it would have done so already.

	if !(utf != 0 && end_subject != true_end_subject && (rc == DMATCH_NOMATCH || rc == -2)) {
		goto __131
	}

__132:

	// Advance past the first bad code unit, and then skip invalid character
	//     starting code units in 8-bit and 16-bit modes.

	start_match = end_subject + uintptr(1)

__135:
	if !(start_match < true_end_subject && uint32(*(*uint8)(unsafe.Pointer(start_match)))&0xc0 == 0x80) {
		goto __136
	}
	start_match++
	goto __135
__136:
	;

	// If we have hit the end of the subject, there isn't another non-empty
	//     fragment, so give up.

	if !(start_match >= true_end_subject) {
		goto __137
	}

	rc = DMATCH_NOMATCH // In case it was partial
	goto __134
__137:
	;

	// Check the rest of the subject

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fcheck_subject = start_match
	rc = X_pcre2_valid_utf_8(tls, start_match, length-uint64((int64(start_match)-int64(subject))/1),
		match_data+80)

	// The rest of the subject is valid UTF.

	if !(rc == 0) {
		goto __138
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject = libc.AssignUintptr(&end_subject, true_end_subject)
	fragment_options = DPCRE2_NOTBOL
	goto FRAGMENT_RESTART
	goto __139
__138:
	if !(rc < 0) {
		goto __140
	}

	(*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_subject = libc.AssignUintptr(&end_subject, start_match+uintptr((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar))
	if !(end_subject > start_match) {
		goto __141
	}

	fragment_options = DPCRE2_NOTBOL | DPCRE2_NOTEOL
	goto FRAGMENT_RESTART
__141:
	;
__140:
	;
__139:
	;
	goto __133
__133:
	goto __132
	goto __134
__134:
	;
__131:
	;

	// Fill in fields that are always returned in the match data.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode = re
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmark = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fmark
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby = PCRE2_MATCHEDBY_INTERPRETER

	// Handle a fully successful match. Set the return code to the number of
	// captured strings, or 0 if there were too many to fit into the ovector, and then
	// set the remaining returned values before returning. Make a copy of the subject
	// string if requested.

	if !(rc == DMATCH_MATCH) {
		goto __142
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = func() int32 {
		if int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_offset_top) >= 2*int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			return 0
		}
		return int32((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_offset_top)/2 + 1
	}()
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar = uint64((int64(start_match) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = uint64((int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fstart_used_ptr) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frightchar = uint64((func() int64 {
		if (*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr > (*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_match_ptr {
			return int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Flast_used_ptr)
		}
		return int64((*Tmatch_block_8)(unsafe.Pointer(mb)).Fend_match_ptr)
	}() - int64(subject)) / 1)
	if !(options&DPCRE2_COPY_MATCHED_SUBJECT != uint32(0)) {
		goto __143
	}

	length = (length + uint64(was_zero_terminated)) * uint64(DPCRE2_CODE_UNIT_WIDTH/8)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmalloc})).f(tls, length,
		(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	if !((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject == uintptr(0)) {
		goto __145
	}
	return -48
__145:
	;
	libc.Xmemcpy(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject, subject, length)
	*(*uint8)(unsafe.Pointer(match_data + 89)) |= uint8(DPCRE2_MD_COPIED_SUBJECT)
	goto __144
__143:
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = subject
__144:
	;
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
__142:
	;

	// Control gets here if there has been a partial match, an error, or if the
	// overall match attempt has failed at all permitted starting positions. Any mark
	// data is in the nomatch_mark field.

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmark = (*Tmatch_block_8)(unsafe.Pointer(mb)).Fnomatch_mark

	// For anything other than nomatch or partial match, just return the code.

	if !(rc != DMATCH_NOMATCH && rc != -2) {
		goto __146
	}
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = rc
	goto __147
__146:
	if !(match_partial != uintptr(0)) {
		goto __148
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject = subject
	*(*uint64)(unsafe.Pointer(match_data + 96)) = uint64((int64(match_partial) - int64(subject)) / 1)
	*(*uint64)(unsafe.Pointer(match_data + 96 + 1*8)) = uint64((int64(end_subject) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar = uint64((int64(match_partial) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = uint64((int64(start_partial) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frightchar = uint64((int64(end_subject) - int64(subject)) / 1)
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = -2
	goto __149
__148:
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = -1
__149:
	;
__147:
	;

	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
}

// These #undefs are here to enable unity builds with CMake.

// End of pcre2_match.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//  Create a match data block given ovector size  *
//

// A minimum of 1 is imposed on the number of ovector pairs. A maximum is also
// imposed because the oveccount field in a match data block is uintt6_t.

func Xpcre2_match_data_create_8(tls *libc.TLS, oveccount uint32, gcontext uintptr) uintptr { /* pcre2_match_data.c:57:33: */
	var yield uintptr
	if oveccount < uint32(1) {
		oveccount = uint32(1)
	}
	if oveccount > uint32(65535) {
		oveccount = uint32(65535)
	}
	yield = X_pcre2_memctl_malloc_8(tls,
		uint64(uintptr(0)+96)+uint64(uint32(2)*oveccount)*uint64(unsafe.Sizeof(uint64(0))),
		gcontext)
	if yield == uintptr(0) {
		return uintptr(0)
	}
	(*Tpcre2_match_data_8)(unsafe.Pointer(yield)).Foveccount = uint16(oveccount)
	(*Tpcre2_match_data_8)(unsafe.Pointer(yield)).Fflags = uint8(0)
	(*Tpcre2_match_data_8)(unsafe.Pointer(yield)).Fheapframes = uintptr(0)
	(*Tpcre2_match_data_8)(unsafe.Pointer(yield)).Fheapframes_size = uint64(0)
	return yield
}

// ************************************************
//
//  Create a match data block using pattern data  *
//

// If no context is supplied, use the memory allocator from the code.

func Xpcre2_match_data_create_from_pattern_8(tls *libc.TLS, code uintptr, gcontext uintptr) uintptr { /* pcre2_match_data.c:82:33: */
	if gcontext == uintptr(0) {
		gcontext = code
	}
	return Xpcre2_match_data_create_8(tls, uint32(int32((*Tpcre2_real_code_8)(unsafe.Pointer(code)).Ftop_bracket)+1),
		gcontext)
}

// ************************************************
//
//            Free a match data block             *
//

func Xpcre2_match_data_free_8(tls *libc.TLS, match_data uintptr) { /* pcre2_match_data.c:98:1: */
	if match_data != uintptr(0) {
		if (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes != uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fheapframes,
				(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
		}
		if uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fflags)&DPCRE2_MD_COPIED_SUBJECT != uint32(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject,
				(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Ffree})).f(tls, match_data, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmemctl.Fmemory_data)
	}
}

// ************************************************
//
//         Get last mark in match                 *
//

func Xpcre2_get_mark_8(tls *libc.TLS, match_data uintptr) uintptr { /* pcre2_match_data.c:119:1: */
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmark
}

// ************************************************
//
//          Get pointer to ovector                *
//

func Xpcre2_get_ovector_pointer_8(tls *libc.TLS, match_data uintptr) uintptr { /* pcre2_match_data.c:130:27: */
	return match_data + 96 /* &.ovector */
}

// ************************************************
//
//          Get number of ovector slots           *
//

func Xpcre2_get_ovector_count_8(tls *libc.TLS, match_data uintptr) uint32 { /* pcre2_match_data.c:143:1: */
	return uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)
}

// ************************************************
//
//         Get starting code unit in match        *
//

func Xpcre2_get_startchar_8(tls *libc.TLS, match_data uintptr) uint64 { /* pcre2_match_data.c:155:1: */
	return (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fstartchar
}

// ************************************************
//
//         Get size of match data block           *
//

func Xpcre2_get_match_data_size_8(tls *libc.TLS, match_data uintptr) uint64 { /* pcre2_match_data.c:167:1: */
	return uint64(uintptr(0)+96) + uint64(2*int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount))*uint64(unsafe.Sizeof(uint64(0)))
}

// End of pcre2_match_data.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//      Check for newline at given position       *
//

// This function is called only via the IS_NEWLINE macro, which does so only
// when the newline type is NLTYPE_ANY or NLTYPE_ANYCRLF. The case of a fixed
// newline (NLTYPE_FIXED) is handled inline. It is guaranteed that the code unit
// pointed to by ptr is less than the end of the string.
//
// Arguments:
//   ptr          pointer to possible newline
//   type         the newline type
//   endptr       pointer to the end of the string
//   lenptr       where to return the length
//   utf          TRUE if in utf mode
//
// Returns:       TRUE or FALSE

func X_pcre2_is_newline_8(tls *libc.TLS, ptr uintptr, type1 uint32, endptr uintptr, lenptr uintptr, utf int32) int32 { /* pcre2_newline.c:79:1: */
	var c uint32

	if utf != 0 {
		c = uint32(*(*uint8)(unsafe.Pointer(ptr)))
		if c >= 0xc0 {
			if c&0x20 == uint32(0) {
				c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f
			} else if c&0x10 == uint32(0) {
				c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f
			} else if c&0x08 == uint32(0) {
				c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f
			} else if c&0x04 == uint32(0) {
				c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f
			} else {
				c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 5)))&0x3f
			}
		}

	} else {
		c = uint32(*(*uint8)(unsafe.Pointer(ptr)))
	}

	if type1 == uint32(DNLTYPE_ANYCRLF) {
		switch c {
		case uint32('\012'):
			*(*uint32)(unsafe.Pointer(lenptr)) = uint32(1)
			return DTRUE
			fallthrough

		case uint32('\015'):
			*(*uint32)(unsafe.Pointer(lenptr)) = func() uint32 {
				if ptr < endptr-uintptr(1) && int32(*(*uint8)(unsafe.Pointer(ptr + 1))) == '\012' {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		default:
			return DFALSE
		}
	} else {
		switch c {
		case uint32('\012'):
			fallthrough
		case uint32('\013'):
			fallthrough
		case uint32('\014'):
			*(*uint32)(unsafe.Pointer(lenptr)) = uint32(1)
			return DTRUE
			fallthrough

		case uint32('\015'):
			*(*uint32)(unsafe.Pointer(lenptr)) = func() uint32 {
				if ptr < endptr-uintptr(1) && int32(*(*uint8)(unsafe.Pointer(ptr + 1))) == '\012' {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
			*(*uint32)(unsafe.Pointer(lenptr)) = func() uint32 {
				if utf != 0 {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case uint32(0x2028):
			fallthrough // LS
		case uint32(0x2029): // PS
			*(*uint32)(unsafe.Pointer(lenptr)) = uint32(3)
			return DTRUE
			fallthrough

		default:
			return DFALSE
		}
	}
	return int32(0)
}

// ************************************************
//
//     Check for newline at previous position     *
//

// This function is called only via the WAS_NEWLINE macro, which does so only
// when the newline type is NLTYPE_ANY or NLTYPE_ANYCRLF. The case of a fixed
// newline (NLTYPE_FIXED) is handled inline. It is guaranteed that the initial
// value of ptr is greater than the start of the string that is being processed.
//
// Arguments:
//   ptr          pointer to possible newline
//   type         the newline type
//   startptr     pointer to the start of the string
//   lenptr       where to return the length
//   utf          TRUE if in utf mode
//
// Returns:       TRUE or FALSE

func X_pcre2_was_newline_8(tls *libc.TLS, ptr uintptr, type1 uint32, startptr uintptr, lenptr uintptr, utf int32) int32 { /* pcre2_newline.c:169:1: */
	var c uint32
	ptr--

	if utf != 0 {
		for uint32(*(*uint8)(unsafe.Pointer(ptr)))&0xc0 == 0x80 {
			ptr--
		}
		c = uint32(*(*uint8)(unsafe.Pointer(ptr)))
		if c >= 0xc0 {
			if c&0x20 == uint32(0) {
				c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f
			} else if c&0x10 == uint32(0) {
				c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f
			} else if c&0x08 == uint32(0) {
				c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f
			} else if c&0x04 == uint32(0) {
				c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f
			} else {
				c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 5)))&0x3f
			}
		}

	} else {
		c = uint32(*(*uint8)(unsafe.Pointer(ptr)))
	}

	if type1 == uint32(DNLTYPE_ANYCRLF) {
		switch c {
		case uint32('\012'):
			*(*uint32)(unsafe.Pointer(lenptr)) = func() uint32 {
				if ptr > startptr && int32(*(*uint8)(unsafe.Pointer(ptr + libc.UintptrFromInt32(-1)))) == '\015' {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case uint32('\015'):
			*(*uint32)(unsafe.Pointer(lenptr)) = uint32(1)
			return DTRUE
			fallthrough

		default:
			return DFALSE
		}
	} else {
		switch c {
		case uint32('\012'):
			*(*uint32)(unsafe.Pointer(lenptr)) = func() uint32 {
				if ptr > startptr && int32(*(*uint8)(unsafe.Pointer(ptr + libc.UintptrFromInt32(-1)))) == '\015' {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case uint32('\013'):
			fallthrough
		case uint32('\014'):
			fallthrough
		case uint32('\015'):
			*(*uint32)(unsafe.Pointer(lenptr)) = uint32(1)
			return DTRUE
			fallthrough

		case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
			*(*uint32)(unsafe.Pointer(lenptr)) = func() uint32 {
				if utf != 0 {
					return uint32(2)
				}
				return uint32(1)
			}()
			return DTRUE
			fallthrough

		case uint32(0x2028):
			fallthrough // LS
		case uint32(0x2029): // PS
			*(*uint32)(unsafe.Pointer(lenptr)) = uint32(3)
			return DTRUE
			fallthrough

		default:
			return DFALSE
		}
	}
	return int32(0)
}

// End of pcre2_newline.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// If SUPPORT_UNICODE is not defined, this function will never be called.
// Supply a dummy function because some compilers do not like empty source
// modules.

// ************************************************
//
//          Convert code point to UTF             *
//

//
// Arguments:
//   cvalue     the character value
//   buffer     pointer to buffer for result
//
// Returns:     number of code units placed in the buffer

func X_pcre2_ord2utf_8(tls *libc.TLS, cvalue uint32, buffer uintptr) uint32 { /* pcre2_ord2utf.c:81:1: */
	// Convert to UTF-8

	var i int32
	var j int32
	for i = 0; i < X_pcre2_utf8_table1_size; i++ {
		if int32(cvalue) <= X_pcre2_utf8_table1[i] {
			break
		}
	}
	buffer += uintptr(i)
	for j = i; j > 0; j-- {
		*(*uint8)(unsafe.Pointer(libc.PostDecUintptr(&buffer, 1))) = uint8(uint32(0x80) | cvalue&uint32(0x3f))
		cvalue >>= 6
	}
	*(*uint8)(unsafe.Pointer(buffer)) = uint8(uint32(X_pcre2_utf8_table2[i]) | cvalue)
	return uint32(i + 1)

	// Convert to UTF-16

}

// End of pcre_ord2utf.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//        Return info about compiled pattern      *
//

//
// Arguments:
//   code          points to compiled code
//   what          what information is required
//   where         where to put the information; if NULL, return length
//
// Returns:        0 when data returned
//                 > 0 when length requested
//                 < 0 on error or unset value

func Xpcre2_pattern_info_8(tls *libc.TLS, code uintptr, what uint32, where uintptr) int32 { /* pcre2_pattern_info.c:65:1: */
	var re uintptr = code

	if where == uintptr(0) {
		switch what {
		case uint32(DPCRE2_INFO_ALLOPTIONS):
			fallthrough
		case uint32(DPCRE2_INFO_ARGOPTIONS):
			fallthrough
		case uint32(DPCRE2_INFO_BACKREFMAX):
			fallthrough
		case uint32(DPCRE2_INFO_BSR):
			fallthrough
		case uint32(DPCRE2_INFO_CAPTURECOUNT):
			fallthrough
		case uint32(DPCRE2_INFO_DEPTHLIMIT):
			fallthrough
		case uint32(DPCRE2_INFO_EXTRAOPTIONS):
			fallthrough
		case uint32(DPCRE2_INFO_FIRSTCODETYPE):
			fallthrough
		case uint32(DPCRE2_INFO_FIRSTCODEUNIT):
			fallthrough
		case uint32(DPCRE2_INFO_HASBACKSLASHC):
			fallthrough
		case uint32(DPCRE2_INFO_HASCRORLF):
			fallthrough
		case uint32(DPCRE2_INFO_HEAPLIMIT):
			fallthrough
		case uint32(DPCRE2_INFO_JCHANGED):
			fallthrough
		case uint32(DPCRE2_INFO_LASTCODETYPE):
			fallthrough
		case uint32(DPCRE2_INFO_LASTCODEUNIT):
			fallthrough
		case uint32(DPCRE2_INFO_MATCHEMPTY):
			fallthrough
		case uint32(DPCRE2_INFO_MATCHLIMIT):
			fallthrough
		case uint32(DPCRE2_INFO_MAXLOOKBEHIND):
			fallthrough
		case uint32(DPCRE2_INFO_MINLENGTH):
			fallthrough
		case uint32(DPCRE2_INFO_NAMEENTRYSIZE):
			fallthrough
		case uint32(DPCRE2_INFO_NAMECOUNT):
			fallthrough
		case uint32(DPCRE2_INFO_NEWLINE):
			return int32(unsafe.Sizeof(uint32(0)))
			fallthrough

		case uint32(DPCRE2_INFO_FIRSTBITMAP):
			return int32(unsafe.Sizeof(uintptr(0)))
			fallthrough

		case uint32(DPCRE2_INFO_JITSIZE):
			fallthrough
		case uint32(DPCRE2_INFO_SIZE):
			fallthrough
		case uint32(DPCRE2_INFO_FRAMESIZE):
			return int32(unsafe.Sizeof(uint64(0)))
			fallthrough

		case uint32(DPCRE2_INFO_NAMETABLE):
			return int32(unsafe.Sizeof(uintptr(0)))
		}
	}

	if re == uintptr(0) {
		return -51
	}

	// Check that the first field in the block is the magic number. If it is not,
	// return with PCRE2_ERROR_BADMAGIC.

	if uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER {
		return -31
	}

	// Check that this pattern was compiled in the correct bit mode

	if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_CODE_UNIT_WIDTH/8) == uint32(0) {
		return -32
	}

	switch what {
	case uint32(DPCRE2_INFO_ALLOPTIONS):
		*(*uint32)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options
		break

	case uint32(DPCRE2_INFO_ARGOPTIONS):
		*(*uint32)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fcompile_options
		break

	case uint32(DPCRE2_INFO_BACKREFMAX):
		*(*uint32)(unsafe.Pointer(where)) = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_backref)
		break

	case uint32(DPCRE2_INFO_BSR):
		*(*uint32)(unsafe.Pointer(where)) = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fbsr_convention)
		break

	case uint32(DPCRE2_INFO_CAPTURECOUNT):
		*(*uint32)(unsafe.Pointer(where)) = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket)
		break

	case uint32(DPCRE2_INFO_DEPTHLIMIT):
		*(*uint32)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth
		if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_depth == 4294967295 {
			return -55
		}
		break

	case uint32(DPCRE2_INFO_EXTRAOPTIONS):
		*(*uint32)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fextra_options
		break

	case uint32(DPCRE2_INFO_FIRSTCODETYPE):
		*(*uint32)(unsafe.Pointer(where)) = func() uint32 {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTSET) != uint32(0) {
				return uint32(1)
			}
			return func() uint32 {
				if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_STARTLINE) != uint32(0) {
					return uint32(2)
				}
				return uint32(0)
			}()
		}()
		break

	case uint32(DPCRE2_INFO_FIRSTCODEUNIT):
		*(*uint32)(unsafe.Pointer(where)) = func() uint32 {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTSET) != uint32(0) {
				return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit
			}
			return uint32(0)
		}()
		break

	case uint32(DPCRE2_INFO_FIRSTBITMAP):
		*(*uintptr)(unsafe.Pointer(where)) = func() uintptr {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTMAPSET) != uint32(0) {
				return re + 40
			}
			return uintptr(0)
		}()
		break

	case uint32(DPCRE2_INFO_FRAMESIZE):
		*(*uint64)(unsafe.Pointer(where)) = uint64(uintptr(0)+128) + uint64(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_bracket)*2)*uint64(unsafe.Sizeof(uint64(0)))
		break

	case uint32(DPCRE2_INFO_HASBACKSLASHC):
		*(*uint32)(unsafe.Pointer(where)) = uint32(libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_HASBKC) != uint32(0)))
		break

	case uint32(DPCRE2_INFO_HASCRORLF):
		*(*uint32)(unsafe.Pointer(where)) = uint32(libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_HASCRORLF) != uint32(0)))
		break

	case uint32(DPCRE2_INFO_HEAPLIMIT):
		*(*uint32)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap
		if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_heap == 4294967295 {
			return -55
		}
		break

	case uint32(DPCRE2_INFO_JCHANGED):
		*(*uint32)(unsafe.Pointer(where)) = uint32(libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_JCHANGED) != uint32(0)))
		break

	case uint32(DPCRE2_INFO_JITSIZE):
		*(*uint64)(unsafe.Pointer(where)) = uint64(0)
		break

	case uint32(DPCRE2_INFO_LASTCODETYPE):
		*(*uint32)(unsafe.Pointer(where)) = func() uint32 {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_LASTSET) != uint32(0) {
				return uint32(1)
			}
			return uint32(0)
		}()
		break

	case uint32(DPCRE2_INFO_LASTCODEUNIT):
		*(*uint32)(unsafe.Pointer(where)) = func() uint32 {
			if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_LASTSET) != uint32(0) {
				return (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit
			}
			return uint32(0)
		}()
		break

	case uint32(DPCRE2_INFO_MATCHEMPTY):
		*(*uint32)(unsafe.Pointer(where)) = uint32(libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_MATCH_EMPTY) != uint32(0)))
		break

	case uint32(DPCRE2_INFO_MATCHLIMIT):
		*(*uint32)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match
		if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flimit_match == 4294967295 {
			return -55
		}
		break

	case uint32(DPCRE2_INFO_MAXLOOKBEHIND):
		*(*uint32)(unsafe.Pointer(where)) = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmax_lookbehind)
		break

	case uint32(DPCRE2_INFO_MINLENGTH):
		*(*uint32)(unsafe.Pointer(where)) = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength)
		break

	case uint32(DPCRE2_INFO_NAMEENTRYSIZE):
		*(*uint32)(unsafe.Pointer(where)) = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size)
		break

	case uint32(DPCRE2_INFO_NAMECOUNT):
		*(*uint32)(unsafe.Pointer(where)) = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count)
		break

	case uint32(DPCRE2_INFO_NAMETABLE):
		*(*uintptr)(unsafe.Pointer(where)) = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))
		break

	case uint32(DPCRE2_INFO_NEWLINE):
		*(*uint32)(unsafe.Pointer(where)) = uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fnewline_convention)
		break

	case uint32(DPCRE2_INFO_SIZE):
		*(*uint64)(unsafe.Pointer(where)) = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize
		break

	default:
		return -34
	}

	return 0
}

// ************************************************
//
//              Callout enumerator                *
//

//
// Arguments:
//   code          points to compiled code
//   callback      function called for each callout block
//   callout_data  user data passed to the callback
//
// Returns:        0 when successfully completed
//                 < 0 on local error
//                != 0 for callback error

func Xpcre2_callout_enumerate_8(tls *libc.TLS, code uintptr, callback uintptr, callout_data uintptr) int32 { /* pcre2_pattern_info.c:268:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var re uintptr = code
	// var cb Tpcre2_callout_enumerate_block_8 at bp, 56

	var cc uintptr
	var utf int32

	if re == uintptr(0) {
		return -51
	}

	utf = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF != uint32(0))

	// Check that the first field in the block is the magic number. If it is not,
	// return with PCRE2_ERROR_BADMAGIC.

	if uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER {
		return -31
	}

	// Check that this pattern was compiled in the correct bit mode

	if (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_CODE_UNIT_WIDTH/8) == uint32(0) {
		return -32
	}

	(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fversion = uint32(0)
	cc = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) +
		uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size))

	for 1 != 0 {
		var rc int32
		switch int32(*(*uint8)(unsafe.Pointer(cc))) {
		case OP_END:
			return 0

		case OP_CHAR:
			fallthrough
		case OP_CHARI:
			fallthrough
		case OP_NOT:
			fallthrough
		case OP_NOTI:
			fallthrough
		case OP_STAR:
			fallthrough
		case OP_MINSTAR:
			fallthrough
		case OP_PLUS:
			fallthrough
		case OP_MINPLUS:
			fallthrough
		case OP_QUERY:
			fallthrough
		case OP_MINQUERY:
			fallthrough
		case OP_UPTO:
			fallthrough
		case OP_MINUPTO:
			fallthrough
		case OP_EXACT:
			fallthrough
		case OP_POSSTAR:
			fallthrough
		case OP_POSPLUS:
			fallthrough
		case OP_POSQUERY:
			fallthrough
		case OP_POSUPTO:
			fallthrough
		case OP_STARI:
			fallthrough
		case OP_MINSTARI:
			fallthrough
		case OP_PLUSI:
			fallthrough
		case OP_MINPLUSI:
			fallthrough
		case OP_QUERYI:
			fallthrough
		case OP_MINQUERYI:
			fallthrough
		case OP_UPTOI:
			fallthrough
		case OP_MINUPTOI:
			fallthrough
		case OP_EXACTI:
			fallthrough
		case OP_POSSTARI:
			fallthrough
		case OP_POSPLUSI:
			fallthrough
		case OP_POSQUERYI:
			fallthrough
		case OP_POSUPTOI:
			fallthrough
		case OP_NOTSTAR:
			fallthrough
		case OP_NOTMINSTAR:
			fallthrough
		case OP_NOTPLUS:
			fallthrough
		case OP_NOTMINPLUS:
			fallthrough
		case OP_NOTQUERY:
			fallthrough
		case OP_NOTMINQUERY:
			fallthrough
		case OP_NOTUPTO:
			fallthrough
		case OP_NOTMINUPTO:
			fallthrough
		case OP_NOTEXACT:
			fallthrough
		case OP_NOTPOSSTAR:
			fallthrough
		case OP_NOTPOSPLUS:
			fallthrough
		case OP_NOTPOSQUERY:
			fallthrough
		case OP_NOTPOSUPTO:
			fallthrough
		case OP_NOTSTARI:
			fallthrough
		case OP_NOTMINSTARI:
			fallthrough
		case OP_NOTPLUSI:
			fallthrough
		case OP_NOTMINPLUSI:
			fallthrough
		case OP_NOTQUERYI:
			fallthrough
		case OP_NOTMINQUERYI:
			fallthrough
		case OP_NOTUPTOI:
			fallthrough
		case OP_NOTMINUPTOI:
			fallthrough
		case OP_NOTEXACTI:
			fallthrough
		case OP_NOTPOSSTARI:
			fallthrough
		case OP_NOTPOSPLUSI:
			fallthrough
		case OP_NOTPOSQUERYI:
			fallthrough
		case OP_NOTPOSUPTOI:
			cc += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(cc))])
			if utf != 0 && int32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) >= 0xc0 {
				cc += uintptr(X_pcre2_utf8_table4[uint32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1))))&0x3f])
			}
			break

		case OP_TYPESTAR:
			fallthrough
		case OP_TYPEMINSTAR:
			fallthrough
		case OP_TYPEPLUS:
			fallthrough
		case OP_TYPEMINPLUS:
			fallthrough
		case OP_TYPEQUERY:
			fallthrough
		case OP_TYPEMINQUERY:
			fallthrough
		case OP_TYPEUPTO:
			fallthrough
		case OP_TYPEMINUPTO:
			fallthrough
		case OP_TYPEEXACT:
			fallthrough
		case OP_TYPEPOSSTAR:
			fallthrough
		case OP_TYPEPOSPLUS:
			fallthrough
		case OP_TYPEPOSQUERY:
			fallthrough
		case OP_TYPEPOSUPTO:
			cc += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(cc))])
			if int32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) == OP_NOTPROP {
				cc += uintptr(2)
			}
			break

		case OP_XCLASS:
			cc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
			break

		case OP_MARK:
			fallthrough
		case OP_COMMIT_ARG:
			fallthrough
		case OP_PRUNE_ARG:
			fallthrough
		case OP_SKIP_ARG:
			fallthrough
		case OP_THEN_ARG:
			cc += uintptr(int32(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(cc))]) + int32(*(*uint8)(unsafe.Pointer(cc + 1))))
			break

		case OP_CALLOUT:
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fpattern_position = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fnext_item_length = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 4)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_number = uint32(*(*uint8)(unsafe.Pointer(cc + 5)))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string_offset = uint64(0)
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string_length = uint64(0)
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string = uintptr(0)
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{callback})).f(tls, bp /* &cb */, callout_data)
			if rc != 0 {
				return rc
			}
			cc += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(cc))])
			break

		case OP_CALLOUT_STR:
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fpattern_position = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fnext_item_length = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 4)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_number = uint32(0)
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string_offset = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 7)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 8)))))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string_length = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 5)))<<8|int32(*(*uint8)(unsafe.Pointer(cc + 6)))) - uint32(1+4*DLINK_SIZE) - uint32(2))
			(*Tpcre2_callout_enumerate_block_8)(unsafe.Pointer(bp /* &cb */)).Fcallout_string = cc + uintptr(1+4*DLINK_SIZE) + uintptr(1)
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{callback})).f(tls, bp /* &cb */, callout_data)
			if rc != 0 {
				return rc
			}
			cc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 6)))))
			break

		default:
			cc += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(cc))])
			break
		}
	}
	return int32(0)
}

// End of pcre2_pattern_info.c

func X_pcre2_script_run_8(tls *libc.TLS, ptr uintptr, endptr uintptr, utf int32) int32 { /* pcre2_script_run.c:85:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var require_state uint32 = SCRIPT_UNSET
	// var require_map [6]uint32 at bp, 24

	// var map1 [6]uint32 at bp+24, 24

	var require_digitset uint32 = uint32(0)
	var c uint32

	// Any string containing fewer than 2 characters is a valid script run.

	if ptr >= endptr {
		return DTRUE
	}
	c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))))
	if utf != 0 && c >= 0xc0 {
		if c&0x20 == uint32(0) {
			c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))))&0x3f
		} else if c&0x10 == uint32(0) {
			c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f
			ptr += uintptr(2)
		} else if c&0x08 == uint32(0) {
			c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f
			ptr += uintptr(3)
		} else if c&0x04 == uint32(0) {
			c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f
			ptr += uintptr(4)
		} else {
			c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(ptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f
			ptr += uintptr(5)
		}
	}

	if ptr >= endptr {
		return DTRUE
	}

	// Initialize the require map. This is a full-size bitmap that has a bit for
	// every script, as opposed to the maps in ucd_script_sets, which only have bits
	// for scripts less than ucp_Unknown - those that appear in script extension
	// lists.

	{
		var i int32 = 0
		for ; i < ucp_Script_Count/32+1; i++ {
			*(*uint32)(unsafe.Pointer(bp + uintptr(i)*4)) = uint32(0)
		}
	}

	// Scan strings of two or more characters, checking the Unicode characteristics
	// of each code point. There is special code for scripts that can be combined with
	// characters from the Han Chinese script. This may be used in conjunction with
	// four other scripts in these combinations:
	//
	// . Han with Hiragana and Katakana is allowed (for Japanese).
	// . Han with Bopomofo is allowed (for Taiwanese Mandarin).
	// . Han with Hangul is allowed (for Korean).
	//
	// If the first significant character's script is one of the four, the required
	// script type is immediately known. However, if the first significant
	// character's script is Han, we have to keep checking for a non-Han character.
	// Hence the SCRIPT_HANPENDING state.

	for {
		var ucd uintptr = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
		var script uint32 = uint32((*Tucd_record)(unsafe.Pointer(ucd)).Fscript)

		// If the script is Unknown, the string is not a valid script run. Such
		//   characters can only form script runs of length one (see test above).

		if script == ucp_Unknown {
			return DFALSE
		}

		// A character without any script extensions whose script is Inherited or
		//   Common is always accepted with any script. If there are extensions, the
		//   following processing happens for all scripts.

		if int32((*Tucd_record)(unsafe.Pointer(ucd)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK != 0 || script != ucp_Inherited && script != ucp_Common {
			var OK int32

			// Set up a full-sized map for this character that can include bits for all
			//     scripts. Copy the scriptx map for this character (which covers those
			//     scripts that appear in script extension lists), set the remaining values to
			//     zero, and then, except for Common or Inherited, add this script's bit to
			//     the map.

			libc.Xmemcpy(tls, bp+24, uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8))+uintptr(int32((*Tucd_record)(unsafe.Pointer(ucd)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4, uint64(ucp_Unknown/32+1)*uint64(unsafe.Sizeof(uint32(0))))
			libc.Xmemset(tls, bp+24+uintptr(ucp_Unknown/32+1)*4, 0, uint64(ucp_Script_Count/32+1-(ucp_Unknown/32+1))*uint64(unsafe.Sizeof(uint32(0))))
			if script != ucp_Common && script != ucp_Inherited {
				*(*uint32)(unsafe.Pointer(bp + 24 + uintptr(script/uint32(32))*4)) |= uint32(1) << (script % uint32(32))
			}

			// Handle the different checking states

			{
				var i int32
				switch require_state {
				// First significant character - it might follow Common or Inherited
				//       characters that do not have any script extensions.

				case SCRIPT_UNSET:
					switch script {
					case ucp_Han:
						require_state = SCRIPT_HANPENDING
						break
						fallthrough

					case ucp_Hiragana:
						fallthrough
					case ucp_Katakana:
						require_state = SCRIPT_HANHIRAKATA
						break
						fallthrough

					case ucp_Bopomofo:
						require_state = SCRIPT_HANBOPOMOFO
						break
						fallthrough

					case ucp_Hangul:
						require_state = SCRIPT_HANHANGUL
						break
						fallthrough

					default:
						libc.Xmemcpy(tls, bp, bp+24, uint64(ucp_Script_Count/32+1)*uint64(unsafe.Sizeof(uint32(0))))
						require_state = SCRIPT_MAP
						break
					}
					break
					fallthrough

				// The first significant character was Han. An inspection of the Unicode
				//       11.0.0 files shows that there are the following types of Script Extension
				//       list that involve the Han, Bopomofo, Hiragana, Katakana, and Hangul
				//       scripts:
				//
				//       . Bopomofo + Han
				//       . Han + Hiragana + Katakana
				//       . Hiragana + Katakana
				//       . Bopopmofo + Hangul + Han + Hiragana + Katakana
				//
				//       The following code tries to make sense of this.

				case SCRIPT_HANPENDING:
					if script != ucp_Han {
						var chspecial uint32 = uint32(0)

						if *(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Bopomofo%32)) != uint32(0) {
							chspecial = chspecial | uint32(DFOUND_BOPOMOFO)
						}
						if *(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Hiragana%32)) != uint32(0) {
							chspecial = chspecial | uint32(DFOUND_HIRAGANA)
						}
						if *(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Katakana%32)) != uint32(0) {
							chspecial = chspecial | uint32(DFOUND_KATAKANA)
						}
						if *(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Hangul%32)) != uint32(0) {
							chspecial = chspecial | uint32(DFOUND_HANGUL)
						}

						if chspecial == uint32(0) {
							return DFALSE
						} // Not allowed with Han

						if chspecial == uint32(DFOUND_BOPOMOFO) {
							require_state = SCRIPT_HANBOPOMOFO
						} else if chspecial == uint32(DFOUND_HIRAGANA|DFOUND_KATAKANA) {
							require_state = SCRIPT_HANHIRAKATA
						}

						// Otherwise this character must be allowed with all of them, so remain
						//         in the pending state.
					}
					break
					fallthrough

				// Previously encountered one of the "with Han" scripts. Check that
				//       this character is appropriate.

				case SCRIPT_HANHIRAKATA:
					if *(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Han%32))+*(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Hiragana%32))+*(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Katakana%32)) == uint32(0) {
						return DFALSE
					}
					break
					fallthrough

				case SCRIPT_HANBOPOMOFO:
					if *(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Han%32))+*(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Bopomofo%32)) == uint32(0) {
						return DFALSE
					}
					break
					fallthrough

				case SCRIPT_HANHANGUL:
					if *(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Han%32))+*(*uint32)(unsafe.Pointer(bp + 24))&(uint32(1)<<(ucp_Hangul%32)) == uint32(0) {
						return DFALSE
					}
					break
					fallthrough

				// Previously encountered one or more characters that are allowed with a
				//       list of scripts.

				case SCRIPT_MAP:
					OK = DFALSE

					{
						i = 0
						for ; i < ucp_Script_Count/32+1; i++ {

							if *(*uint32)(unsafe.Pointer(bp + uintptr(i)*4))&*(*uint32)(unsafe.Pointer(bp + 24 + uintptr(i)*4)) != uint32(0) {
								OK = DTRUE
								break
							}
						}
					}

					if !(OK != 0) {
						return DFALSE
					}

					// The rest of the string must be in this script, but we have to
					//       allow for the Han complications.

					{
						var i int32
						switch script {
						case ucp_Han:
							require_state = SCRIPT_HANPENDING
							break
							fallthrough

						case ucp_Hiragana:
							fallthrough
						case ucp_Katakana:
							require_state = SCRIPT_HANHIRAKATA
							break
							fallthrough

						case ucp_Bopomofo:
							require_state = SCRIPT_HANBOPOMOFO
							break
							fallthrough

						case ucp_Hangul:
							require_state = SCRIPT_HANHANGUL
							break
							fallthrough

						// Compute the intersection of the required list of scripts and the
						//         allowed scripts for this character.

						default:
							{
								i = 0
								for ; i < ucp_Script_Count/32+1; i++ {
									*(*uint32)(unsafe.Pointer(bp + uintptr(i)*4)) &= *(*uint32)(unsafe.Pointer(bp + 24 + uintptr(i)*4))
								}
							}
							break
						}
					}

					break
				}
			}
		} // End checking character's script and extensions.

		// The character is in an acceptable script. We must now ensure that all
		//   decimal digits in the string come from the same set. Some scripts (e.g.
		//   Common, Arabic) have more than one set of decimal digits. This code does
		//   not allow mixing sets, even within the same script. The vector called
		//   PRIV(ucd_digit_sets)[] contains, in its first element, the number of
		//   following elements, and then, in ascending order, the code points of the
		//   '9' characters in every set of 10 digits. Each set is identified by the
		//   offset in the vector of its '9' character. An initial check of the first
		//   value picks up ASCII digits quickly. Otherwise, a binary chop is used.

		if int32((*Tucd_record)(unsafe.Pointer(ucd)).Fchartype) == ucp_Nd {
			var digitset uint32

			if c <= X_pcre2_ucd_digit_sets_8[1] {
				digitset = uint32(1)
			} else {
				var mid int32
				var bot int32 = 1
				var top int32 = int32(X_pcre2_ucd_digit_sets_8[0])
				for {
					if top <= bot+1 {
						digitset = uint32(top)
						break
					}
					mid = (top + bot) / 2
					if c <= X_pcre2_ucd_digit_sets_8[mid] {
						top = mid
					} else {
						bot = mid
					}
				}
			}

			// A required value of 0 means "unset".

			if require_digitset == uint32(0) {
				require_digitset = digitset
			} else if digitset != require_digitset {
				return DFALSE
			}
		} // End digit handling

		// If we haven't yet got to the end, pick up the next character.

		if ptr >= endptr {
			return DTRUE
		}
		c = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))))
		if utf != 0 && c >= 0xc0 {
			if c&0x20 == uint32(0) {
				c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1))))&0x3f
			} else if c&0x10 == uint32(0) {
				c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f
				ptr += uintptr(2)
			} else if c&0x08 == uint32(0) {
				c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f
				ptr += uintptr(3)
			} else if c&0x04 == uint32(0) {
				c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f
				ptr += uintptr(4)
			} else {
				c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(ptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(ptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(ptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(ptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(ptr + 4)))&0x3f
				ptr += uintptr(5)
			}
		}

	}
	return int32(0) // End checking loop

}

// End of pcre2_script_run.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Magic number to provide a small check against being handed junk.

// Deserialization is limited to the current PCRE version and
// character width.

// ************************************************
//
//           Serialize compiled patterns          *
//

func Xpcre2_serialize_encode_8(tls *libc.TLS, codes uintptr, number_of_codes int32, serialized_bytes uintptr, serialized_size uintptr, gcontext uintptr) int32 { /* pcre2_serialize.c:72:1: */
	var bytes uintptr
	var dst_bytes uintptr
	var i int32
	var total_size uint64
	var re uintptr
	var tables uintptr
	var data uintptr

	var memctl uintptr
	if gcontext != uintptr(0) {
		memctl = gcontext
	} else {
		memctl = uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8))
	}

	if codes == uintptr(0) || serialized_bytes == uintptr(0) || serialized_size == uintptr(0) {
		return -51
	}

	if number_of_codes <= 0 {
		return -29
	}

	// Compute total size.
	total_size = uint64(unsafe.Sizeof(Tpcre2_serialized_data{})) + uint64(Dcbits_offset+Dcbit_length+256)
	tables = uintptr(0)

	for i = 0; i < number_of_codes; i++ {
		if *(*uintptr)(unsafe.Pointer(codes + uintptr(i)*8)) == uintptr(0) {
			return -51
		}
		re = *(*uintptr)(unsafe.Pointer(codes + uintptr(i)*8))
		if uint64((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fmagic_number) != DMAGIC_NUMBER {
			return -31
		}
		if tables == uintptr(0) {
			tables = (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables
		} else if tables != (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables {
			return -30
		}
		total_size = total_size + (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize
	}

	// Initialize the byte stream.
	bytes = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmalloc})).f(tls, total_size+uint64(unsafe.Sizeof(Tpcre2_memctl{})), (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	if bytes == uintptr(0) {
		return -48
	}

	// The controller is stored as a hidden parameter.
	libc.Xmemcpy(tls, bytes, memctl, uint64(unsafe.Sizeof(Tpcre2_memctl{})))
	bytes += uintptr(unsafe.Sizeof(Tpcre2_memctl{}))

	data = bytes
	(*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fmagic = DSERIALIZED_DATA_MAGIC
	(*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fversion = uint32(DPCRE2_MAJOR | int32(DPCRE2_MINOR)<<16)
	(*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fconfig = uint32(uint64(unsafe.Sizeof(uint8(0))) | uint64(uint64(unsafe.Sizeof(uintptr(0))))<<8 | uint64(uint64(unsafe.Sizeof(uint64(0))))<<16)
	(*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes = number_of_codes

	// Copy all compiled code data.
	dst_bytes = bytes + uintptr(uint64(unsafe.Sizeof(Tpcre2_serialized_data{})))
	libc.Xmemcpy(tls, dst_bytes, tables, uint64(Dcbits_offset+Dcbit_length+256))
	dst_bytes += uintptr(Dcbits_offset + Dcbit_length + 256)

	for i = 0; i < number_of_codes; i++ {
		re = *(*uintptr)(unsafe.Pointer(codes + uintptr(i)*8))
		libc.Xmemcpy(tls, dst_bytes, re, (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize)

		// Certain fields in the compiled code block are re-set during
		//   deserialization. In order to ensure that the serialized data stream is always
		//   the same for the same pattern, set them to zero here. We can't assume the
		//   copy of the pattern is correctly aligned for accessing the fields as part of
		//   a structure. Note the use of sizeof(void *) in the second of these, to
		//   specify the size of a pointer. If sizeof(uint8_t *) is used (tables is a
		//   pointer to uint8_t), gcc gives a warning because the first argument is also a
		//   pointer to uint8_t. Casting the first argument to (void *) can stop this, but
		//   it didn't stop Coverity giving the same complaint.

		libc.Xmemset(tls, dst_bytes+uintptr(uint64(uintptr(0))), 0,
			uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		libc.Xmemset(tls, dst_bytes+uintptr(uint64(uintptr(0)+24)), 0,
			uint64(unsafe.Sizeof(uintptr(0))))
		libc.Xmemset(tls, dst_bytes+uintptr(uint64(uintptr(0)+32)), 0,
			uint64(unsafe.Sizeof(uintptr(0))))

		dst_bytes += uintptr((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fblocksize)
	}

	*(*uintptr)(unsafe.Pointer(serialized_bytes)) = bytes
	*(*uint64)(unsafe.Pointer(serialized_size)) = total_size
	return number_of_codes
}

// ************************************************
//
//          Deserialize compiled patterns         *
//

func Xpcre2_serialize_decode_8(tls *libc.TLS, codes uintptr, number_of_codes int32, bytes uintptr, gcontext uintptr) int32 { /* pcre2_serialize.c:163:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var data uintptr = bytes
	var memctl uintptr
	if gcontext != uintptr(0) {
		memctl = gcontext
	} else {
		memctl = uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8))
	}
	var src_bytes uintptr
	var dst_re uintptr
	var tables uintptr
	var i int32
	var j int32

	// Sanity checks.

	if data == uintptr(0) || codes == uintptr(0) {
		return -51
	}
	if number_of_codes <= 0 {
		return -29
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes <= 0 {
		return -62
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fmagic != DSERIALIZED_DATA_MAGIC {
		return -31
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fversion != uint32(DPCRE2_MAJOR|int32(DPCRE2_MINOR)<<16) {
		return -32
	}
	if uint64((*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fconfig) != uint64(unsafe.Sizeof(uint8(0)))|uint64(uint64(unsafe.Sizeof(uintptr(0))))<<8|uint64(uint64(unsafe.Sizeof(uint64(0))))<<16 {
		return -32
	}

	if number_of_codes > (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes {
		number_of_codes = (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes
	}

	src_bytes = bytes + uintptr(uint64(unsafe.Sizeof(Tpcre2_serialized_data{})))

	// Decode tables. The reference count for the tables is stored immediately
	// following them.

	tables = (*struct {
		f func(*libc.TLS, uint64, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmalloc})).f(tls, uint64(Dcbits_offset+Dcbit_length+256)+uint64(unsafe.Sizeof(uint64(0))), (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	if tables == uintptr(0) {
		return -48
	}

	libc.Xmemcpy(tls, tables, src_bytes, uint64(Dcbits_offset+Dcbit_length+256))
	*(*uint64)(unsafe.Pointer(tables + uintptr(Dcbits_offset+Dcbit_length+256))) = uint64(number_of_codes)
	src_bytes += uintptr(Dcbits_offset + Dcbit_length + 256)

	// Decode the byte stream. We must not try to read the size from the compiled
	// code block in the stream, because it might be unaligned, which causes errors on
	// hardware such as Sparc-64 that doesn't like unaligned memory accesses. The type
	// of the blocksize field is given its own name to ensure that it is the same here
	// as in the block.

	for i = 0; i < number_of_codes; i++ {
		// var blocksize uint64 at bp, 8

		libc.Xmemcpy(tls, bp, src_bytes+uintptr(uint64(uintptr(0)+72)),
			uint64(unsafe.Sizeof(uint64(0))))
		if *(*uint64)(unsafe.Pointer(bp)) <= uint64(unsafe.Sizeof(Tpcre2_real_code_8{})) {
			return -62
		}

		// The allocator provided by gcontext replaces the original one.

		dst_re = X_pcre2_memctl_malloc_8(tls, *(*uint64)(unsafe.Pointer(bp /* blocksize */)),
			gcontext)
		if dst_re == uintptr(0) {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, tables, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
			for j = 0; j < i; j++ {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, *(*uintptr)(unsafe.Pointer(codes + uintptr(j)*8)), (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
				*(*uintptr)(unsafe.Pointer(codes + uintptr(j)*8)) = uintptr(0)
			}
			return -48
		}

		// The new allocator must be preserved.

		libc.Xmemcpy(tls, dst_re+uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{}))),
			src_bytes+uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{}))), *(*uint64)(unsafe.Pointer(bp))-uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		if uint64((*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Fmagic_number) != DMAGIC_NUMBER || int32((*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Fname_entry_size) > DMAX_NAME_SIZE+DIMM2_SIZE+1 || int32((*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Fname_count) > DMAX_NAME_COUNT {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, dst_re, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
			return -62
		}

		// At the moment only one table is supported.

		(*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Ftables = tables
		(*Tpcre2_real_code_8)(unsafe.Pointer(dst_re)).Fexecutable_jit = uintptr(0)
		*(*uint32)(unsafe.Pointer(dst_re + 96)) |= uint32(DPCRE2_DEREF_TABLES)

		*(*uintptr)(unsafe.Pointer(codes + uintptr(i)*8)) = dst_re
		src_bytes += uintptr(*(*uint64)(unsafe.Pointer(bp /* blocksize */)))
	}

	return number_of_codes
}

// ************************************************
//
//    Get the number of serialized patterns       *
//

func Xpcre2_serialize_get_number_of_codes_8(tls *libc.TLS, bytes uintptr) int32 { /* pcre2_serialize.c:259:1: */
	var data uintptr = bytes

	if data == uintptr(0) {
		return -51
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fmagic != DSERIALIZED_DATA_MAGIC {
		return -31
	}
	if (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fversion != uint32(DPCRE2_MAJOR|int32(DPCRE2_MINOR)<<16) {
		return -32
	}
	if uint64((*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fconfig) != uint64(unsafe.Sizeof(uint8(0)))|uint64(uint64(unsafe.Sizeof(uintptr(0))))<<8|uint64(uint64(unsafe.Sizeof(uint64(0))))<<16 {
		return -32
	}

	return (*Tpcre2_serialized_data)(unsafe.Pointer(data)).Fnumber_of_codes
}

// ************************************************
//
//            Free the allocated stream           *
//

func Xpcre2_serialize_free_8(tls *libc.TLS, bytes uintptr) { /* pcre2_serialize.c:277:1: */
	if bytes != uintptr(0) {
		var memctl uintptr = bytes - uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, memctl, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
}

// End of pcre2_serialize.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//    Emulated memmove() for systems without it   *
//

// This function can make use of bcopy() if it is available. Otherwise do it by
// steam, as there some non-Unix environments that lack both memmove() and
// bcopy().

// ************************************************
//
//    Compare two zero-terminated PCRE2 strings   *
//

//
// Arguments:
//   str1        first string
//   str2        second string
//
// Returns:      0, 1, or -1

func X_pcre2_strcmp_8(tls *libc.TLS, str1 uintptr, str2 uintptr) int32 { /* pcre2_string_utils.c:102:1: */
	var c1 uint8
	var c2 uint8
	for int32(*(*uint8)(unsafe.Pointer(str1))) != 0 || int32(*(*uint8)(unsafe.Pointer(str2))) != 0 {
		c1 = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str1, 1)))
		c2 = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1)))
		if int32(c1) != int32(c2) {
			return libc.Bool32(int32(c1) > int32(c2))<<1 - 1
		}
	}
	return 0
}

// ************************************************
//
//  Compare zero-terminated PCRE2 & 8-bit strings *
//

// As the 8-bit string is almost always a literal, its type is specified as
// const char *.
//
// Arguments:
//   str1        first string
//   str2        second string
//
// Returns:      0, 1, or -1

func X_pcre2_strcmp_c8_8(tls *libc.TLS, str1 uintptr, str2 uintptr) int32 { /* pcre2_string_utils.c:130:1: */
	var c1 uint8
	var c2 uint8
	for int32(*(*uint8)(unsafe.Pointer(str1))) != 0 || int32(*(*int8)(unsafe.Pointer(str2))) != 0 {
		c1 = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str1, 1)))
		c2 = uint8(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1))))
		if int32(c1) != int32(c2) {
			return libc.Bool32(int32(c1) > int32(c2))<<1 - 1
		}
	}
	return 0
}

// ************************************************
//
//    Compare two PCRE2 strings, given a length   *
//

//
// Arguments:
//   str1        first string
//   str2        second string
//   len         the length
//
// Returns:      0, 1, or -1

func X_pcre2_strncmp_8(tls *libc.TLS, str1 uintptr, str2 uintptr, len uint64) int32 { /* pcre2_string_utils.c:157:1: */
	var c1 uint8
	var c2 uint8
	for ; len > uint64(0); len-- {
		c1 = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str1, 1)))
		c2 = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1)))
		if int32(c1) != int32(c2) {
			return libc.Bool32(int32(c1) > int32(c2))<<1 - 1
		}
	}
	return 0
}

// ************************************************
//
// Compare PCRE2 string to 8-bit string by length *
//

// As the 8-bit string is almost always a literal, its type is specified as
// const char *.
//
// Arguments:
//   str1        first string
//   str2        second string
//   len         the length
//
// Returns:      0, 1, or -1

func X_pcre2_strncmp_c8_8(tls *libc.TLS, str1 uintptr, str2 uintptr, len uint64) int32 { /* pcre2_string_utils.c:186:1: */
	var c1 uint8
	var c2 uint8
	for ; len > uint64(0); len-- {
		c1 = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str1, 1)))
		c2 = uint8(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1))))
		if int32(c1) != int32(c2) {
			return libc.Bool32(int32(c1) > int32(c2))<<1 - 1
		}
	}
	return 0
}

// ************************************************
//
//        Find the length of a PCRE2 string       *
//

//
// Argument:    the string
// Returns:     the length

func X_pcre2_strlen_8(tls *libc.TLS, str uintptr) uint64 { /* pcre2_string_utils.c:209:1: */
	var c uint64 = uint64(0)
	for int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&str, 1)))) != 0 {
		c++
	}
	return c
}

// ************************************************
//
// Copy 8-bit 0-terminated string to PCRE2 string *
//

// Arguments:
//   str1     buffer to receive the string
//   str2     8-bit string to be copied
//
// Returns:   the number of code units used (excluding trailing zero)

func X_pcre2_strcpy_c8_8(tls *libc.TLS, str1 uintptr, str2 uintptr) uint64 { /* pcre2_string_utils.c:229:1: */
	var t uintptr = str1
	for int32(*(*int8)(unsafe.Pointer(str2))) != 0 {
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&t, 1))) = uint8(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&str2, 1))))
	}
	*(*uint8)(unsafe.Pointer(t)) = uint8(0)
	return uint64((int64(t) - int64(str1)) / 1)
}

// End of pcre2_string_utils.c

// ************************************************
//
//   Find the minimum subject length for a group  *
//

// Scan a parenthesized group and compute the minimum length of subject that
// is needed to match it. This is a lower bound; it does not mean there is a
// string of that length that matches. In UTF mode, the result is in characters
// rather than code units. The field in a compiled pattern for storing the minimum
// length is 16-bits long (on the grounds that anything longer than that is
// pathological), so we give up when we reach that amount. This also means that
// integer overflow for really crazy patterns cannot happen.
//
// Backreference minimum lengths are cached to speed up multiple references. This
// function is called only when the highest back reference in the pattern is less
// than or equal to MAX_CACHE_BACKREF, which is one less than the size of the
// caching vector. The zeroth element contains the number of the highest set
// value.
//
// Arguments:
//   re              compiled pattern block
//   code            pointer to start of group (the bracket)
//   startcode       pointer to start of the whole pattern's code
//   utf             UTF flag
//   recurses        chain of recurse_check to catch mutual recursion
//   countptr        pointer to call count (to catch over complexity)
//   backref_cache   vector for caching back references.
//
// This function is no longer called when the pattern contains (*ACCEPT); however,
// the old code for returning -1 is retained, just in case.
//
// Returns:   the minimum length
//            -1 \C in UTF-8 mode
//               or (*ACCEPT)
//               or pattern too complicated
//            -2 internal error (missing capturing bracket)
//            -3 internal error (opcode not listed)

func find_minlength(tls *libc.TLS, re uintptr, code uintptr, startcode uintptr, utf int32, recurses uintptr, countptr uintptr, backref_cache uintptr) int32 { /* pcre2_study.c:103:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var length int32
	var branchlength int32
	var prev_cap_recno int32
	var prev_cap_d int32
	var prev_recurse_recno int32
	var prev_recurse_d int32
	var once_fudge uint32
	var had_recurse int32
	var dupcapused int32
	var nextbranch uintptr
	var cc uintptr
	// var this_recurse Trecurse_check at bp, 16

	var r uintptr
	var dd int32
	var i int32
	var count int32
	var slot uintptr
	var r1 uintptr
	var i1 int32
	var r2 uintptr
	var d int32
	var min int32
	var recno int32
	var op uint8
	var cs uintptr
	var ce uintptr
	length = -1
	branchlength = 0
	prev_cap_recno = -1
	prev_cap_d = 0
	prev_recurse_recno = -1
	prev_recurse_d = 0
	once_fudge = uint32(0)
	had_recurse = DFALSE
	dupcapused = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_DUPCAPUSED) != uint32(0))
	nextbranch = code + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(code + 2)))))
	cc = code + uintptr(1) + uintptr(DLINK_SIZE)

	// If this is a "could be empty" group, its minimum length is 0.

	if !(int32(*(*uint8)(unsafe.Pointer(code))) >= OP_SBRA && int32(*(*uint8)(unsafe.Pointer(code))) <= OP_SCOND) {
		goto __1
	}
	return 0
__1:
	;

	// Skip over capturing bracket number

	if !(int32(*(*uint8)(unsafe.Pointer(code))) == OP_CBRA || int32(*(*uint8)(unsafe.Pointer(code))) == OP_CBRAPOS) {
		goto __2
	}
	cc += uintptr(DIMM2_SIZE)
__2:
	;

	// A large and/or complex regex can take too long to process.

	if !(libc.PostIncInt32(&*(*int32)(unsafe.Pointer(countptr)), 1) > 1000) {
		goto __3
	}
	return -1
__3:
	;

	// Scan along the opcodes for this branch. If we get to the end of the branch,
	// check the length against that of the other branches. If the accumulated length
	// passes 16-bits, reset to that value and skip the rest of the branch.

__4:

	if !(branchlength >= 65535) {
		goto __7
	}

	branchlength = 65535
	cc = nextbranch
__7:
	;

	op = *(*uint8)(unsafe.Pointer(cc))
	switch int32(op) {
	case OP_COND:
		goto __9
	case OP_SCOND:
		goto __10

	case OP_BRA:
		goto __11
	// Fall through

	case OP_ONCE:
		goto __12
	case OP_SCRIPT_RUN:
		goto __13
	case OP_SBRA:
		goto __14
	case OP_BRAPOS:
		goto __15
	case OP_SBRAPOS:
		goto __16

	// To save time for repeated capturing subpatterns, we remember the
	//     length of the previous one. Unfortunately we can't do the same for
	//     the unnumbered ones above. Nor can we do this if (?| is present in the
	//     pattern because captures with the same number are not then identical.

	case OP_CBRA:
		goto __17
	case OP_SCBRA:
		goto __18
	case OP_CBRAPOS:
		goto __19
	case OP_SCBRAPOS:
		goto __20

	// ACCEPT makes things far too complicated; we have to give up. In fact,
	//     from 10.34 onwards, if a pattern contains (*ACCEPT), this function is not
	//     used. However, leave the code in place, just in case.

	case OP_ACCEPT:
		goto __21
	case OP_ASSERT_ACCEPT:
		goto __22

	// Reached end of a branch; if it's a ket it is the end of a nested
	//     call. If it's ALT it is an alternation in a nested call. If it is END it's
	//     the end of the outer call. All can be handled by the same code. If the
	//     length of any branch is zero, there is no need to scan any subsequent
	//     branches.

	case OP_ALT:
		goto __23
	case OP_KET:
		goto __24
	case OP_KETRMAX:
		goto __25
	case OP_KETRMIN:
		goto __26
	case OP_KETRPOS:
		goto __27
	case OP_END:
		goto __28

	// Skip over assertive subpatterns

	case OP_ASSERT:
		goto __29
	case OP_ASSERT_NOT:
		goto __30
	case OP_ASSERTBACK:
		goto __31
	case OP_ASSERTBACK_NOT:
		goto __32
	case OP_ASSERT_NA:
		goto __33
	case OP_ASSERTBACK_NA:
		goto __34
	// Fall through

	// Skip over things that don't match chars

	case OP_REVERSE:
		goto __35
	case OP_CREF:
		goto __36
	case OP_DNCREF:
		goto __37
	case OP_RREF:
		goto __38
	case OP_DNRREF:
		goto __39
	case OP_FALSE:
		goto __40
	case OP_TRUE:
		goto __41
	case OP_CALLOUT:
		goto __42
	case OP_SOD:
		goto __43
	case OP_SOM:
		goto __44
	case OP_EOD:
		goto __45
	case OP_EODN:
		goto __46
	case OP_CIRC:
		goto __47
	case OP_CIRCM:
		goto __48
	case OP_DOLL:
		goto __49
	case OP_DOLLM:
		goto __50
	case OP_NOT_WORD_BOUNDARY:
		goto __51
	case OP_WORD_BOUNDARY:
		goto __52

	case OP_CALLOUT_STR:
		goto __53

	// Skip over a subpattern that has a {0} or {0,x} quantifier

	case OP_BRAZERO:
		goto __54
	case OP_BRAMINZERO:
		goto __55
	case OP_BRAPOSZERO:
		goto __56
	case OP_SKIPZERO:
		goto __57

	// Handle literal characters and + repetitions

	case OP_CHAR:
		goto __58
	case OP_CHARI:
		goto __59
	case OP_NOT:
		goto __60
	case OP_NOTI:
		goto __61
	case OP_PLUS:
		goto __62
	case OP_PLUSI:
		goto __63
	case OP_MINPLUS:
		goto __64
	case OP_MINPLUSI:
		goto __65
	case OP_POSPLUS:
		goto __66
	case OP_POSPLUSI:
		goto __67
	case OP_NOTPLUS:
		goto __68
	case OP_NOTPLUSI:
		goto __69
	case OP_NOTMINPLUS:
		goto __70
	case OP_NOTMINPLUSI:
		goto __71
	case OP_NOTPOSPLUS:
		goto __72
	case OP_NOTPOSPLUSI:
		goto __73

	case OP_TYPEPLUS:
		goto __74
	case OP_TYPEMINPLUS:
		goto __75
	case OP_TYPEPOSPLUS:
		goto __76

	// Handle exact repetitions. The count is already in characters, but we
	//     may need to skip over a multibyte character in UTF mode.

	case OP_EXACT:
		goto __77
	case OP_EXACTI:
		goto __78
	case OP_NOTEXACT:
		goto __79
	case OP_NOTEXACTI:
		goto __80

	case OP_TYPEEXACT:
		goto __81

	// Handle single-char non-literal matchers

	case OP_PROP:
		goto __82
	case OP_NOTPROP:
		goto __83
	// Fall through

	case OP_NOT_DIGIT:
		goto __84
	case OP_DIGIT:
		goto __85
	case OP_NOT_WHITESPACE:
		goto __86
	case OP_WHITESPACE:
		goto __87
	case OP_NOT_WORDCHAR:
		goto __88
	case OP_WORDCHAR:
		goto __89
	case OP_ANY:
		goto __90
	case OP_ALLANY:
		goto __91
	case OP_EXTUNI:
		goto __92
	case OP_HSPACE:
		goto __93
	case OP_NOT_HSPACE:
		goto __94
	case OP_VSPACE:
		goto __95
	case OP_NOT_VSPACE:
		goto __96

	// "Any newline" might match two characters, but it also might match just
	//     one.

	case OP_ANYNL:
		goto __97

	// The single-byte matcher means we can't proceed in UTF mode. (In
	//     non-UTF mode \C will actually be turned into OP_ALLANY, so won't ever
	//     appear, but leave the code, just in case.)

	case OP_ANYBYTE:
		goto __98

	// For repeated character types, we have to test for \p and \P, which have
	//     an extra two bytes of parameters.

	case OP_TYPESTAR:
		goto __99
	case OP_TYPEMINSTAR:
		goto __100
	case OP_TYPEQUERY:
		goto __101
	case OP_TYPEMINQUERY:
		goto __102
	case OP_TYPEPOSSTAR:
		goto __103
	case OP_TYPEPOSQUERY:
		goto __104

	case OP_TYPEUPTO:
		goto __105
	case OP_TYPEMINUPTO:
		goto __106
	case OP_TYPEPOSUPTO:
		goto __107

	// Check a class for variable quantification

	case OP_CLASS:
		goto __108
	case OP_NCLASS:
		goto __109
	case OP_XCLASS:
		goto __110

	// Backreferences and subroutine calls (OP_RECURSE) are treated in the same
	//     way: we find the minimum length for the subpattern. A recursion
	//     (backreference or subroutine) causes an a flag to be set that causes the
	//     length of this branch to be ignored. The logic is that a recursion can only
	//     make sense if there is another alternative that stops the recursing. That
	//     will provide the minimum length (when no recursion happens).
	//
	//     If PCRE2_MATCH_UNSET_BACKREF is set, a backreference to an unset bracket
	//     matches an empty string (by default it causes a matching failure), so in
	//     that case we must set the minimum length to zero.
	//
	//     For backreferenes, if duplicate numbers are present in the pattern we check
	//     for a reference to a duplicate. If it is, we don't know which version will
	//     be referenced, so we have to set the minimum length to zero.

	// Duplicate named pattern back reference.

	case OP_DNREF:
		goto __111
	case OP_DNREFI:
		goto __112

	// Single back reference by number. References by name are converted to by
	//     number when there is no duplication.

	case OP_REF:
		goto __113
	case OP_REFI:
		goto __114

	// Recursion always refers to the first occurrence of a subpattern with a
	//     given number. Therefore, we can always make use of caching, even when the
	//     pattern contains multiple subpatterns with the same number.

	case OP_RECURSE:
		goto __115

	// Anything else does not or need not match a character. We can get the
	//     item's length from the table, but for those that can match zero occurrences
	//     of a character, we must take special action for UTF-8 characters. As it
	//     happens, the "NOT" versions of these opcodes are used at present only for
	//     ASCII characters, so they could be omitted from this list. However, in
	//     future that may change, so we include them here so as not to leave a
	//     gotcha for a future maintainer.

	case OP_UPTO:
		goto __116
	case OP_UPTOI:
		goto __117
	case OP_NOTUPTO:
		goto __118
	case OP_NOTUPTOI:
		goto __119
	case OP_MINUPTO:
		goto __120
	case OP_MINUPTOI:
		goto __121
	case OP_NOTMINUPTO:
		goto __122
	case OP_NOTMINUPTOI:
		goto __123
	case OP_POSUPTO:
		goto __124
	case OP_POSUPTOI:
		goto __125
	case OP_NOTPOSUPTO:
		goto __126
	case OP_NOTPOSUPTOI:
		goto __127

	case OP_STAR:
		goto __128
	case OP_STARI:
		goto __129
	case OP_NOTSTAR:
		goto __130
	case OP_NOTSTARI:
		goto __131
	case OP_MINSTAR:
		goto __132
	case OP_MINSTARI:
		goto __133
	case OP_NOTMINSTAR:
		goto __134
	case OP_NOTMINSTARI:
		goto __135
	case OP_POSSTAR:
		goto __136
	case OP_POSSTARI:
		goto __137
	case OP_NOTPOSSTAR:
		goto __138
	case OP_NOTPOSSTARI:
		goto __139

	case OP_QUERY:
		goto __140
	case OP_QUERYI:
		goto __141
	case OP_NOTQUERY:
		goto __142
	case OP_NOTQUERYI:
		goto __143
	case OP_MINQUERY:
		goto __144
	case OP_MINQUERYI:
		goto __145
	case OP_NOTMINQUERY:
		goto __146
	case OP_NOTMINQUERYI:
		goto __147
	case OP_POSQUERY:
		goto __148
	case OP_POSQUERYI:
		goto __149
	case OP_NOTPOSQUERY:
		goto __150
	case OP_NOTPOSQUERYI:
		goto __151

	// Skip these, but we need to add in the name length.

	case OP_MARK:
		goto __152
	case OP_COMMIT_ARG:
		goto __153
	case OP_PRUNE_ARG:
		goto __154
	case OP_SKIP_ARG:
		goto __155
	case OP_THEN_ARG:
		goto __156

	// The remaining opcodes are just skipped over.

	case OP_CLOSE:
		goto __157
	case OP_COMMIT:
		goto __158
	case OP_FAIL:
		goto __159
	case OP_PRUNE:
		goto __160
	case OP_SET_SOM:
		goto __161
	case OP_SKIP:
		goto __162
	case OP_THEN:
		goto __163

	// This should not occur: we list all opcodes explicitly so that when
	//     new ones get added they are properly considered.

	default:
		goto __164
	}
	goto __8

__9:
__10:

	// If there is only one branch in a condition, the implied branch has zero
	//     length, so we don't add anything. This covers the DEFINE "condition"
	//     automatically. If there are two branches we can treat it the same as any
	//     other non-capturing subpattern.

	cs = cc + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	if !(int32(*(*uint8)(unsafe.Pointer(cs))) != OP_ALT) {
		goto __165
	}

	cc = cs + uintptr(1) + uintptr(DLINK_SIZE)
	goto __8
__165:
	;
	goto PROCESS_NON_CAPTURE

__11:
	// There's a special case of OP_BRA, when it is wrapped round a repeated
	//     OP_RECURSE. We'd like to process the latter at this level so that
	//     remembering the value works for repeated cases. So we do nothing, but
	//     set a fudge value to skip over the OP_KET after the recurse.

	if !(int32(*(*uint8)(unsafe.Pointer(cc + 3))) == OP_RECURSE && int32(*(*uint8)(unsafe.Pointer(cc + 6))) == OP_KET) {
		goto __166
	}

	once_fudge = uint32(1 + DLINK_SIZE)
	cc += uintptr(1 + DLINK_SIZE)
	goto __8
__166:
	;
	// Fall through

__12:
__13:
__14:
__15:
__16:
PROCESS_NON_CAPTURE:
	d = find_minlength(tls, re, cc, startcode, utf, recurses, countptr,
		backref_cache)
	if !(d < 0) {
		goto __167
	}
	return d
__167:
	;
	branchlength = branchlength + d
__168:
	cc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	goto __169
__169:
	if int32(*(*uint8)(unsafe.Pointer(cc))) == OP_ALT {
		goto __168
	}
	goto __170
__170:
	;
	cc += uintptr(1 + DLINK_SIZE)
	goto __8

	// To save time for repeated capturing subpatterns, we remember the
	//     length of the previous one. Unfortunately we can't do the same for
	//     the unnumbered ones above. Nor can we do this if (?| is present in the
	//     pattern because captures with the same number are not then identical.

__17:
__18:
__19:
__20:
	recno = int32(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 4)))))
	if !(dupcapused != 0 || recno != prev_cap_recno) {
		goto __171
	}

	prev_cap_recno = recno
	prev_cap_d = find_minlength(tls, re, cc, startcode, utf, recurses, countptr,
		backref_cache)
	if !(prev_cap_d < 0) {
		goto __172
	}
	return prev_cap_d
__172:
	;
__171:
	;
	branchlength = branchlength + prev_cap_d
__173:
	cc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	goto __174
__174:
	if int32(*(*uint8)(unsafe.Pointer(cc))) == OP_ALT {
		goto __173
	}
	goto __175
__175:
	;
	cc += uintptr(1 + DLINK_SIZE)
	goto __8

	// ACCEPT makes things far too complicated; we have to give up. In fact,
	//     from 10.34 onwards, if a pattern contains (*ACCEPT), this function is not
	//     used. However, leave the code in place, just in case.

__21:
__22:
	return -1

	// Reached end of a branch; if it's a ket it is the end of a nested
	//     call. If it's ALT it is an alternation in a nested call. If it is END it's
	//     the end of the outer call. All can be handled by the same code. If the
	//     length of any branch is zero, there is no need to scan any subsequent
	//     branches.

__23:
__24:
__25:
__26:
__27:
__28:
	if !(length < 0 || !(had_recurse != 0) && branchlength < length) {
		goto __176
	}
	length = branchlength
__176:
	;
	if !(int32(op) != OP_ALT || length == 0) {
		goto __177
	}
	return length
__177:
	;
	nextbranch = cc + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(1 + DLINK_SIZE)
	branchlength = 0
	had_recurse = DFALSE
	goto __8

	// Skip over assertive subpatterns

__29:
__30:
__31:
__32:
__33:
__34:
__178:
	cc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	goto __179
__179:
	if int32(*(*uint8)(unsafe.Pointer(cc))) == OP_ALT {
		goto __178
	}
	goto __180
__180:
	;
	// Fall through

	// Skip over things that don't match chars

__35:
__36:
__37:
__38:
__39:
__40:
__41:
__42:
__43:
__44:
__45:
__46:
__47:
__48:
__49:
__50:
__51:
__52:
	cc += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(cc))])
	goto __8

__53:
	cc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 6)))))
	goto __8

	// Skip over a subpattern that has a {0} or {0,x} quantifier

__54:
__55:
__56:
__57:
	cc += uintptr(X_pcre2_OP_lengths_8[*(*uint8)(unsafe.Pointer(cc))])
__181:
	cc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	goto __182
__182:
	if int32(*(*uint8)(unsafe.Pointer(cc))) == OP_ALT {
		goto __181
	}
	goto __183
__183:
	;
	cc += uintptr(1 + DLINK_SIZE)
	goto __8

	// Handle literal characters and + repetitions

__58:
__59:
__60:
__61:
__62:
__63:
__64:
__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
	branchlength++
	cc += uintptr(2)
	if !(utf != 0 && int32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) >= 0xc0) {
		goto __184
	}
	cc += uintptr(X_pcre2_utf8_table4[uint32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1))))&0x3f])
__184:
	;
	goto __8

__74:
__75:
__76:
	branchlength++
	cc += func() uintptr {
		if int32(*(*uint8)(unsafe.Pointer(cc + 1))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(cc + 1))) == OP_NOTPROP {
			return uintptr(4)
		}
		return uintptr(2)
	}()
	goto __8

	// Handle exact repetitions. The count is already in characters, but we
	//     may need to skip over a multibyte character in UTF mode.

__77:
__78:
__79:
__80:
	branchlength = int32(uint32(branchlength) + uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(2 + DIMM2_SIZE)
	if !(utf != 0 && int32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) >= 0xc0) {
		goto __185
	}
	cc += uintptr(X_pcre2_utf8_table4[uint32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1))))&0x3f])
__185:
	;
	goto __8

__81:
	branchlength = int32(uint32(branchlength) + uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(2 + DIMM2_SIZE + func() int32 {
		if int32(*(*uint8)(unsafe.Pointer(cc + 3))) == OP_PROP ||
			int32(*(*uint8)(unsafe.Pointer(cc + 3))) == OP_NOTPROP {
			return 2
		}
		return 0
	}())
	goto __8

	// Handle single-char non-literal matchers

__82:
__83:
	cc += uintptr(2)
	// Fall through

__84:
__85:
__86:
__87:
__88:
__89:
__90:
__91:
__92:
__93:
__94:
__95:
__96:
	branchlength++
	cc++
	goto __8

	// "Any newline" might match two characters, but it also might match just
	//     one.

__97:
	branchlength = branchlength + 1
	cc++
	goto __8

	// The single-byte matcher means we can't proceed in UTF mode. (In
	//     non-UTF mode \C will actually be turned into OP_ALLANY, so won't ever
	//     appear, but leave the code, just in case.)

__98:
	if !(utf != 0) {
		goto __186
	}
	return -1
__186:
	;
	branchlength++
	cc++
	goto __8

	// For repeated character types, we have to test for \p and \P, which have
	//     an extra two bytes of parameters.

__99:
__100:
__101:
__102:
__103:
__104:
	if !(int32(*(*uint8)(unsafe.Pointer(cc + 1))) == OP_PROP || int32(*(*uint8)(unsafe.Pointer(cc + 1))) == OP_NOTPROP) {
		goto __187
	}
	cc += uintptr(2)
__187:
	;
	cc += uintptr(X_pcre2_OP_lengths_8[op])
	goto __8

__105:
__106:
__107:
	if !(int32(*(*uint8)(unsafe.Pointer(cc + 3))) == OP_PROP ||
		int32(*(*uint8)(unsafe.Pointer(cc + 3))) == OP_NOTPROP) {
		goto __188
	}
	cc += uintptr(2)
__188:
	;
	cc += uintptr(X_pcre2_OP_lengths_8[op])
	goto __8

	// Check a class for variable quantification

__108:
__109:
__110:
	// The original code caused an unsigned overflow in 64 bit systems,
	//     so now we use a conditional statement.
	if !(int32(op) == OP_XCLASS) {
		goto __189
	}
	cc += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	goto __190
__189:
	cc += uintptr(X_pcre2_OP_lengths_8[OP_CLASS])
__190:
	;

	switch int32(*(*uint8)(unsafe.Pointer(cc))) {
	case OP_CRPLUS:
		goto __192
	case OP_CRMINPLUS:
		goto __193
	case OP_CRPOSPLUS:
		goto __194
	// Fall through

	case OP_CRSTAR:
		goto __195
	case OP_CRMINSTAR:
		goto __196
	case OP_CRQUERY:
		goto __197
	case OP_CRMINQUERY:
		goto __198
	case OP_CRPOSSTAR:
		goto __199
	case OP_CRPOSQUERY:
		goto __200

	case OP_CRRANGE:
		goto __201
	case OP_CRMINRANGE:
		goto __202
	case OP_CRPOSRANGE:
		goto __203

	default:
		goto __204
	}
	goto __191

__192:
__193:
__194:
	branchlength++
	// Fall through

__195:
__196:
__197:
__198:
__199:
__200:
	cc++
	goto __191

__201:
__202:
__203:
	branchlength = int32(uint32(branchlength) + uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(1 + 2*DIMM2_SIZE)
	goto __191

__204:
	branchlength++
	goto __191
__191:
	;
	goto __8

	// Backreferences and subroutine calls (OP_RECURSE) are treated in the same
	//     way: we find the minimum length for the subpattern. A recursion
	//     (backreference or subroutine) causes an a flag to be set that causes the
	//     length of this branch to be ignored. The logic is that a recursion can only
	//     make sense if there is another alternative that stops the recursing. That
	//     will provide the minimum length (when no recursion happens).
	//
	//     If PCRE2_MATCH_UNSET_BACKREF is set, a backreference to an unset bracket
	//     matches an empty string (by default it causes a matching failure), so in
	//     that case we must set the minimum length to zero.
	//
	//     For backreferenes, if duplicate numbers are present in the pattern we check
	//     for a reference to a duplicate. If it is, we don't know which version will
	//     be referenced, so we have to set the minimum length to zero.

	// Duplicate named pattern back reference.

__111:
__112:
	if !(!(dupcapused != 0) && (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_UNSET_BACKREF == uint32(0)) {
		goto __205
	}

	count = int32(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 4)))))
	slot =
		re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) + uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(cc + 2))))*uint32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size))

	d = 0x7fffffff

	// Scan all groups with the same name; find the shortest.

__207:
	if !(libc.PostDecInt32(&count, 1) > 0) {
		goto __208
	}

	recno = int32(uint32(int32(*(*uint8)(unsafe.Pointer(slot)))<<8 | int32(*(*uint8)(unsafe.Pointer(slot + 1)))))

	if !(recno <= *(*int32)(unsafe.Pointer(backref_cache)) && *(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4)) >= 0) {
		goto __209
	}
	dd = *(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4))
	goto __210
__209:

	ce = libc.AssignUintptr(&cs, X_pcre2_find_bracket_8(tls, startcode, utf, recno))
	if !(cs == uintptr(0)) {
		goto __211
	}
	return -2
__211:
	;
__212:
	ce += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(ce + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(ce + 2)))))
	goto __213
__213:
	if int32(*(*uint8)(unsafe.Pointer(ce))) == OP_ALT {
		goto __212
	}
	goto __214
__214:
	;

	dd = 0
	if !(!(dupcapused != 0) || X_pcre2_find_bracket_8(tls, ce, utf, recno) == uintptr(0)) {
		goto __215
	}

	if !(cc > cs && cc < ce) {
		goto __216
	} /* Simple recursion */

	had_recurse = DTRUE
	goto __217
__216:

	r = recurses
	r = recurses
__218:
	if !(r != uintptr(0)) {
		goto __220
	}
	if !((*Trecurse_check)(unsafe.Pointer(r)).Fgroup == cs) {
		goto __221
	}
	goto __220
__221:
	;
	goto __219
__219:
	r = (*Trecurse_check)(unsafe.Pointer(r)).Fprev
	goto __218
	goto __220
__220:
	;
	if !(r != uintptr(0)) {
		goto __222
	} /* Mutual recursion */

	had_recurse = DTRUE
	goto __223
__222:

	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fprev = recurses // No recursion
	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fgroup = cs
	dd = find_minlength(tls, re, cs, startcode, utf, bp,
		countptr, backref_cache)
	if !(dd < 0) {
		goto __224
	}
	return dd
__224:
	;
__223:
	;
__217:
	;
__215:
	;

	*(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4)) = dd
	i = *(*int32)(unsafe.Pointer(backref_cache)) + 1
__225:
	if !(i < recno) {
		goto __227
	}
	*(*int32)(unsafe.Pointer(backref_cache + uintptr(i)*4)) = -1
	goto __226
__226:
	i++
	goto __225
	goto __227
__227:
	;
	*(*int32)(unsafe.Pointer(backref_cache)) = recno
__210:
	;

	if !(dd < d) {
		goto __228
	}
	d = dd
__228:
	;
	if !(d <= 0) {
		goto __229
	}
	goto __208
__229:
	; // No point looking at any more
	slot += uintptr((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size)
	goto __207
__208:
	;
	goto __206
__205:
	d = 0
__206:
	;
	cc += uintptr(1 + 2*DIMM2_SIZE)
	goto REPEAT_BACK_REFERENCE

	// Single back reference by number. References by name are converted to by
	//     number when there is no duplication.

__113:
__114:
	recno = int32(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	if !(recno <= *(*int32)(unsafe.Pointer(backref_cache)) && *(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4)) >= 0) {
		goto __230
	}
	d = *(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4))
	goto __231
__230:

	d = 0

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_MATCH_UNSET_BACKREF == uint32(0)) {
		goto __232
	}

	ce = libc.AssignUintptr(&cs, X_pcre2_find_bracket_8(tls, startcode, utf, recno))
	if !(cs == uintptr(0)) {
		goto __233
	}
	return -2
__233:
	;
__234:
	ce += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(ce + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(ce + 2)))))
	goto __235
__235:
	if int32(*(*uint8)(unsafe.Pointer(ce))) == OP_ALT {
		goto __234
	}
	goto __236
__236:
	;

	if !(!(dupcapused != 0) || X_pcre2_find_bracket_8(tls, ce, utf, recno) == uintptr(0)) {
		goto __237
	}

	if !(cc > cs && cc < ce) {
		goto __238
	} /* Simple recursion */

	had_recurse = DTRUE
	goto __239
__238:

	r1 = recurses
	r1 = recurses
__240:
	if !(r1 != uintptr(0)) {
		goto __242
	}
	if !((*Trecurse_check)(unsafe.Pointer(r1)).Fgroup == cs) {
		goto __243
	}
	goto __242
__243:
	;
	goto __241
__241:
	r1 = (*Trecurse_check)(unsafe.Pointer(r1)).Fprev
	goto __240
	goto __242
__242:
	;
	if !(r1 != uintptr(0)) {
		goto __244
	} /* Mutual recursion */

	had_recurse = DTRUE
	goto __245
__244: /* No recursion */

	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fprev = recurses
	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fgroup = cs
	d = find_minlength(tls, re, cs, startcode, utf, bp, countptr,
		backref_cache)
	if !(d < 0) {
		goto __246
	}
	return d
__246:
	;
__245:
	;
__239:
	;
__237:
	;
__232:
	;

	*(*int32)(unsafe.Pointer(backref_cache + uintptr(recno)*4)) = d
	i1 = *(*int32)(unsafe.Pointer(backref_cache)) + 1
__247:
	if !(i1 < recno) {
		goto __249
	}
	*(*int32)(unsafe.Pointer(backref_cache + uintptr(i1)*4)) = -1
	goto __248
__248:
	i1++
	goto __247
	goto __249
__249:
	;
	*(*int32)(unsafe.Pointer(backref_cache)) = recno
__231:
	;

	cc += uintptr(1 + DIMM2_SIZE)

	// Handle repeated back references

REPEAT_BACK_REFERENCE:
	switch int32(*(*uint8)(unsafe.Pointer(cc))) {
	case OP_CRSTAR:
		goto __251
	case OP_CRMINSTAR:
		goto __252
	case OP_CRQUERY:
		goto __253
	case OP_CRMINQUERY:
		goto __254
	case OP_CRPOSSTAR:
		goto __255
	case OP_CRPOSQUERY:
		goto __256

	case OP_CRPLUS:
		goto __257
	case OP_CRMINPLUS:
		goto __258
	case OP_CRPOSPLUS:
		goto __259

	case OP_CRRANGE:
		goto __260
	case OP_CRMINRANGE:
		goto __261
	case OP_CRPOSRANGE:
		goto __262

	default:
		goto __263
	}
	goto __250

__251:
__252:
__253:
__254:
__255:
__256:
	min = 0
	cc++
	goto __250

__257:
__258:
__259:
	min = 1
	cc++
	goto __250

__260:
__261:
__262:
	min = int32(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(cc + 2)))))
	cc += uintptr(1 + 2*DIMM2_SIZE)
	goto __250

__263:
	min = 1
	goto __250
__250:
	;

	// Take care not to overflow: (1) min and d are ints, so check that their
	//      product is not greater than INT_MAX. (2) branchlength is limited to
	//      UINT16_MAX (checked at the top of the loop).

	if !(d > 0 && 0x7fffffff/d < min || 65535-branchlength < min*d) {
		goto __264
	}
	branchlength = 65535
	goto __265
__264:
	branchlength = branchlength + min*d
__265:
	;
	goto __8

	// Recursion always refers to the first occurrence of a subpattern with a
	//     given number. Therefore, we can always make use of caching, even when the
	//     pattern contains multiple subpatterns with the same number.

__115:
	cs = libc.AssignUintptr(&ce, startcode+uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(cc + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(cc + 2))))))
	recno = int32(uint32(int32(*(*uint8)(unsafe.Pointer(cs + 3)))<<8 | int32(*(*uint8)(unsafe.Pointer(cs + 4)))))
	if !(recno == prev_recurse_recno) {
		goto __266
	}

	branchlength = branchlength + prev_recurse_d
	goto __267
__266:

__268:
	ce += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(ce + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(ce + 2)))))
	goto __269
__269:
	if int32(*(*uint8)(unsafe.Pointer(ce))) == OP_ALT {
		goto __268
	}
	goto __270
__270:
	;
	if !(cc > cs && cc < ce) {
		goto __271
	} // Simple recursion
	had_recurse = DTRUE
	goto __272
__271:

	r2 = recurses
	r2 = recurses
__273:
	if !(r2 != uintptr(0)) {
		goto __275
	}
	if !((*Trecurse_check)(unsafe.Pointer(r2)).Fgroup == cs) {
		goto __276
	}
	goto __275
__276:
	;
	goto __274
__274:
	r2 = (*Trecurse_check)(unsafe.Pointer(r2)).Fprev
	goto __273
	goto __275
__275:
	;
	if !(r2 != uintptr(0)) {
		goto __277
	} // Mutual recursion
	had_recurse = DTRUE
	goto __278
__277:

	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fprev = recurses
	(*Trecurse_check)(unsafe.Pointer(bp /* &this_recurse */)).Fgroup = cs
	prev_recurse_d = find_minlength(tls, re, cs, startcode, utf, bp,
		countptr, backref_cache)
	if !(prev_recurse_d < 0) {
		goto __279
	}
	return prev_recurse_d
__279:
	;
	prev_recurse_recno = recno
	branchlength = branchlength + prev_recurse_d
__278:
	;
__272:
	;
__267:
	;
	cc += uintptr(uint32(1+DLINK_SIZE) + once_fudge)
	once_fudge = uint32(0)
	goto __8

	// Anything else does not or need not match a character. We can get the
	//     item's length from the table, but for those that can match zero occurrences
	//     of a character, we must take special action for UTF-8 characters. As it
	//     happens, the "NOT" versions of these opcodes are used at present only for
	//     ASCII characters, so they could be omitted from this list. However, in
	//     future that may change, so we include them here so as not to leave a
	//     gotcha for a future maintainer.

__116:
__117:
__118:
__119:
__120:
__121:
__122:
__123:
__124:
__125:
__126:
__127:

__128:
__129:
__130:
__131:
__132:
__133:
__134:
__135:
__136:
__137:
__138:
__139:

__140:
__141:
__142:
__143:
__144:
__145:
__146:
__147:
__148:
__149:
__150:
__151:

	cc += uintptr(X_pcre2_OP_lengths_8[op])
	if !(utf != 0 && int32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1)))) >= 0xc0) {
		goto __280
	}
	cc += uintptr(X_pcre2_utf8_table4[uint32(*(*uint8)(unsafe.Pointer(cc + libc.UintptrFromInt32(-1))))&0x3f])
__280:
	;
	goto __8

	// Skip these, but we need to add in the name length.

__152:
__153:
__154:
__155:
__156:
	cc += uintptr(int32(X_pcre2_OP_lengths_8[op]) + int32(*(*uint8)(unsafe.Pointer(cc + 1))))
	goto __8

	// The remaining opcodes are just skipped over.

__157:
__158:
__159:
__160:
__161:
__162:
__163:
	cc += uintptr(X_pcre2_OP_lengths_8[op])
	goto __8

	// This should not occur: we list all opcodes explicitly so that when
	//     new ones get added they are properly considered.

__164:
	return -3
__8:
	;
	goto __5
__5:
	goto __4
	goto __6
__6:
	;
	return int32(0)
	// Control never gets here
}

// ************************************************
//
//      Set a bit and maybe its alternate case    *
//

// Given a character, set its first code unit's bit in the table, and also the
// corresponding bit for the other version of a letter if we are caseless.
//
// Arguments:
//   re            points to the regex block
//   p             points to the first code unit of the character
//   caseless      TRUE if caseless
//   utf           TRUE for UTF mode
//   ucp           TRUE for UCP mode
//
// Returns:        pointer after the character

func set_table_bit(tls *libc.TLS, re uintptr, p uintptr, caseless int32, utf int32, ucp int32) uintptr { /* pcre2_study.c:781:1: */
	bp := tls.Alloc(6)
	defer tls.Free(6)

	var c uint32 = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1)))) // First code unit

	_ = utf // Stop compiler warnings when UTF not supported
	_ = ucp

	// In 16-bit and 32-bit modes, code units greater than 0xff set the bit for
	// 0xff.

	*(*uint8)(unsafe.Pointer(re + 40 + uintptr(c/uint32(8)))) |= uint8(uint32(1) << (c & uint32(7)))

	// In UTF-8 or UTF-16 mode, pick up the remaining code units in order to find
	// the end of the character, even when caseless.

	if utf != 0 {
		if c >= uint32(0xc0) {
			if c&0x20 == uint32(0) {
				c = c&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))))&0x3f
			} else if c&0x10 == uint32(0) {
				c = c&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(p)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(p + 1)))&0x3f
				p += uintptr(2)
			} else if c&0x08 == uint32(0) {
				c = c&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(p)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(p + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(p + 2)))&0x3f
				p += uintptr(3)
			} else if c&0x04 == uint32(0) {
				c = c&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(p)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(p + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(p + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(p + 3)))&0x3f
				p += uintptr(4)
			} else {
				c = c&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(p)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(p + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(p + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(p + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(p + 4)))&0x3f
				p += uintptr(5)
			}
		}

	}

	// If caseless, handle the other case of the character.

	if caseless != 0 {
		if utf != 0 || ucp != 0 {
			c = uint32(int32(c) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12)).Fother_case)
			if utf != 0 {
				// var buff [6]uint8 at bp, 6

				X_pcre2_ord2utf_8(tls, c, bp)
				*(*uint8)(unsafe.Pointer(re + 40 + uintptr(int32(*(*uint8)(unsafe.Pointer(bp)))/8))) |= uint8(uint32(1) << (int32(*(*uint8)(unsafe.Pointer(bp))) & 7))
			} else if c < uint32(256) {
				*(*uint8)(unsafe.Pointer(re + 40 + uintptr(c/uint32(8)))) |= uint8(uint32(1) << (c & uint32(7)))
			}
		} else

		// Not UTF or UCP

		if 1 != 0 {
			*(*uint8)(unsafe.Pointer(re + 40 + uintptr(int32(*(*uint8)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(uint32(Dfcc_offset)+c))))/8))) |= uint8(uint32(1) << (int32(*(*uint8)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(uint32(Dfcc_offset)+c)))) & 7))
		}
	}

	return p
}

// ************************************************
//
//     Set bits for a positive character type     *
//

// This function sets starting bits for a character type. In UTF-8 mode, we can
// only do a direct setting for bytes less than 128, as otherwise there can be
// confusion with bytes in the middle of UTF-8 characters. In a "traditional"
// environment, the tables will only recognize ASCII characters anyway, but in at
// least one Windows environment, some higher bytes bits were set in the tables.
// So we deal with that case by considering the UTF-8 encoding.
//
// Arguments:
//   re             the regex block
//   cbit type      the type of character wanted
//   table_limit    32 for non-UTF-8; 16 for UTF-8
//
// Returns:         nothing

func set_type_bits(tls *libc.TLS, re uintptr, cbit_type int32, table_limit uint32) { /* pcre2_study.c:866:1: */
	bp := tls.Alloc(6)
	defer tls.Free(6)

	var c uint32
	for c = uint32(0); c < table_limit; c++ {
		*(*uint8)(unsafe.Pointer(re + 40 + uintptr(c))) |= uint8(int32(*(*uint8)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(c+uint32(Dcbits_offset)+uint32(cbit_type))))))
	}
	if table_limit == uint32(32) {
		return
	}
	for c = uint32(128); c < uint32(256); c++ {
		if uint32(*(*uint8)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(uint32(Dcbits_offset)+c/uint32(8)))))&(uint32(1)<<(c&uint32(7))) != uint32(0) {
			// var buff [6]uint8 at bp, 6

			X_pcre2_ord2utf_8(tls, c, bp)
			*(*uint8)(unsafe.Pointer(re + 40 + uintptr(int32(*(*uint8)(unsafe.Pointer(bp)))/8))) |= uint8(uint32(1) << (int32(*(*uint8)(unsafe.Pointer(bp))) & 7))
		}
	}
}

// ************************************************
//
//     Set bits for a negative character type     *
//

// This function sets starting bits for a negative character type such as \D.
// In UTF-8 mode, we can only do a direct setting for bytes less than 128, as
// otherwise there can be confusion with bytes in the middle of UTF-8 characters.
// Unlike in the positive case, where we can set appropriate starting bits for
// specific high-valued UTF-8 characters, in this case we have to set the bits for
// all high-valued characters. The lowest is 0xc2, but we overkill by starting at
// 0xc0 (192) for simplicity.
//
// Arguments:
//   re             the regex block
//   cbit type      the type of character wanted
//   table_limit    32 for non-UTF-8; 16 for UTF-8
//
// Returns:         nothing

func set_nottype_bits(tls *libc.TLS, re uintptr, cbit_type int32, table_limit uint32) { /* pcre2_study.c:907:1: */
	var c uint32
	for c = uint32(0); c < table_limit; c++ {
		*(*uint8)(unsafe.Pointer(re + 40 + uintptr(c))) |= uint8(int32(uint8(^int32(*(*uint8)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(c+uint32(Dcbits_offset)+uint32(cbit_type))))))))
	}
	if table_limit != uint32(32) {
		for c = uint32(24); c < uint32(32); c++ {
			*(*uint8)(unsafe.Pointer(re + 40 + uintptr(c))) = uint8(0xff)
		}
	}
}

// ************************************************
//
//      Create bitmap of starting code units      *
//

// This function scans a compiled unanchored expression recursively and
// attempts to build a bitmap of the set of possible starting code units whose
// values are less than 256. In 16-bit and 32-bit mode, values above 255 all cause
// the 255 bit to be set. When calling set[_not]_type_bits() in UTF-8 (sic) mode
// we pass a value of 16 rather than 32 as the final argument. (See comments in
// those functions for the reason.)
//
// The SSB_CONTINUE return is useful for parenthesized groups in patterns such as
// (a*)b where the group provides some optional starting code units but scanning
// must continue at the outer level to find at least one mandatory code unit. At
// the outermost level, this function fails unless the result is SSB_DONE.
//
// We restrict recursion (for nested groups) to 1000 to avoid stack overflow
// issues.
//
// Arguments:
//   re           points to the compiled regex block
//   code         points to an expression
//   utf          TRUE if in UTF mode
//   ucp          TRUE if in UCP mode
//   depthptr     pointer to recurse depth
//
// Returns:       SSB_FAIL     => Failed to find any starting code units
//                SSB_DONE     => Found mandatory starting code units
//                SSB_CONTINUE => Found optional starting code units
//                SSB_UNKNOWN  => Hit an unrecognized opcode
//                SSB_TOODEEP  => Recursion is too deep

func set_start_bits(tls *libc.TLS, re uintptr, code uintptr, utf int32, ucp int32, depthptr uintptr) int32 { /* pcre2_study.c:953:1: */
	bp := tls.Alloc(6)
	defer tls.Free(6)

	var c uint32
	var yield int32
	var table_limit int32
	// var buff [6]uint8 at bp, 6

	var p uintptr
	var b uint8
	var e uint8
	var p1 uintptr
	var d int32
	var rc int32
	var classmap uintptr
	var xclassflags uint8
	var try_next int32
	var tcode uintptr
	yield = SSB_DONE
	if utf != 0 {
		table_limit = 16
	} else {
		table_limit = 32
	}

	*(*int32)(unsafe.Pointer(depthptr)) += 1
	if !(*(*int32)(unsafe.Pointer(depthptr)) > 1000) {
		goto __1
	}
	return SSB_TOODEEP
__1:
	;

__2:
	try_next = DTRUE
	tcode = code + uintptr(1) + uintptr(DLINK_SIZE)

	if !(int32(*(*uint8)(unsafe.Pointer(code))) == OP_CBRA || int32(*(*uint8)(unsafe.Pointer(code))) == OP_SCBRA || int32(*(*uint8)(unsafe.Pointer(code))) == OP_CBRAPOS || int32(*(*uint8)(unsafe.Pointer(code))) == OP_SCBRAPOS) {
		goto __5
	}
	tcode += uintptr(DIMM2_SIZE)
__5:
	;

__6:
	if !(try_next != 0) {
		goto __7
	} /* Loop for items in this branch */
	classmap = uintptr(0)

	switch int32(*(*uint8)(unsafe.Pointer(tcode))) {
	// If we reach something we don't understand, it means a new opcode has
	//       been created that hasn't been added to this function. Hopefully this
	//       problem will be discovered during testing.

	default:
		goto __9

	// Fail for a valid opcode that implies no starting bits.

	case OP_ACCEPT:
		goto __10
	case OP_ASSERT_ACCEPT:
		goto __11
	case OP_ALLANY:
		goto __12
	case OP_ANY:
		goto __13
	case OP_ANYBYTE:
		goto __14
	case OP_CIRCM:
		goto __15
	case OP_CLOSE:
		goto __16
	case OP_COMMIT:
		goto __17
	case OP_COMMIT_ARG:
		goto __18
	case OP_COND:
		goto __19
	case OP_CREF:
		goto __20
	case OP_FALSE:
		goto __21
	case OP_TRUE:
		goto __22
	case OP_DNCREF:
		goto __23
	case OP_DNREF:
		goto __24
	case OP_DNREFI:
		goto __25
	case OP_DNRREF:
		goto __26
	case OP_DOLL:
		goto __27
	case OP_DOLLM:
		goto __28
	case OP_END:
		goto __29
	case OP_EOD:
		goto __30
	case OP_EODN:
		goto __31
	case OP_EXTUNI:
		goto __32
	case OP_FAIL:
		goto __33
	case OP_MARK:
		goto __34
	case OP_NOT:
		goto __35
	case OP_NOTEXACT:
		goto __36
	case OP_NOTEXACTI:
		goto __37
	case OP_NOTI:
		goto __38
	case OP_NOTMINPLUS:
		goto __39
	case OP_NOTMINPLUSI:
		goto __40
	case OP_NOTMINQUERY:
		goto __41
	case OP_NOTMINQUERYI:
		goto __42
	case OP_NOTMINSTAR:
		goto __43
	case OP_NOTMINSTARI:
		goto __44
	case OP_NOTMINUPTO:
		goto __45
	case OP_NOTMINUPTOI:
		goto __46
	case OP_NOTPLUS:
		goto __47
	case OP_NOTPLUSI:
		goto __48
	case OP_NOTPOSPLUS:
		goto __49
	case OP_NOTPOSPLUSI:
		goto __50
	case OP_NOTPOSQUERY:
		goto __51
	case OP_NOTPOSQUERYI:
		goto __52
	case OP_NOTPOSSTAR:
		goto __53
	case OP_NOTPOSSTARI:
		goto __54
	case OP_NOTPOSUPTO:
		goto __55
	case OP_NOTPOSUPTOI:
		goto __56
	case OP_NOTPROP:
		goto __57
	case OP_NOTQUERY:
		goto __58
	case OP_NOTQUERYI:
		goto __59
	case OP_NOTSTAR:
		goto __60
	case OP_NOTSTARI:
		goto __61
	case OP_NOTUPTO:
		goto __62
	case OP_NOTUPTOI:
		goto __63
	case OP_NOT_HSPACE:
		goto __64
	case OP_NOT_VSPACE:
		goto __65
	case OP_PRUNE:
		goto __66
	case OP_PRUNE_ARG:
		goto __67
	case OP_RECURSE:
		goto __68
	case OP_REF:
		goto __69
	case OP_REFI:
		goto __70
	case OP_REVERSE:
		goto __71
	case OP_RREF:
		goto __72
	case OP_SCOND:
		goto __73
	case OP_SET_SOM:
		goto __74
	case OP_SKIP:
		goto __75
	case OP_SKIP_ARG:
		goto __76
	case OP_SOD:
		goto __77
	case OP_SOM:
		goto __78
	case OP_THEN:
		goto __79
	case OP_THEN_ARG:
		goto __80

	// OP_CIRC happens only at the start of an anchored branch (multiline ^
	//       uses OP_CIRCM). Skip over it.

	case OP_CIRC:
		goto __81

	// A "real" property test implies no starting bits, but the fake property
	//       PT_CLIST identifies a list of characters. These lists are short, as they
	//       are used for characters with more than one "other case", so there is no
	//       point in recognizing them for OP_NOTPROP.

	case OP_PROP:
		goto __82

	// We can ignore word boundary tests.

	case OP_WORD_BOUNDARY:
		goto __83
	case OP_NOT_WORD_BOUNDARY:
		goto __84

	// If we hit a bracket or a positive lookahead assertion, recurse to set
	//       bits from within the subpattern. If it can't find anything, we have to
	//       give up. If it finds some mandatory character(s), we are done for this
	//       branch. Otherwise, carry on scanning after the subpattern.

	case OP_BRA:
		goto __85
	case OP_SBRA:
		goto __86
	case OP_CBRA:
		goto __87
	case OP_SCBRA:
		goto __88
	case OP_BRAPOS:
		goto __89
	case OP_SBRAPOS:
		goto __90
	case OP_CBRAPOS:
		goto __91
	case OP_SCBRAPOS:
		goto __92
	case OP_ONCE:
		goto __93
	case OP_SCRIPT_RUN:
		goto __94
	case OP_ASSERT:
		goto __95
	case OP_ASSERT_NA:
		goto __96

	// If we hit ALT or KET, it means we haven't found anything mandatory in
	//       this branch, though we might have found something optional. For ALT, we
	//       continue with the next alternative, but we have to arrange that the final
	//       result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,
	//       return SSB_CONTINUE: if this is the top level, that indicates failure,
	//       but after a nested subpattern, it causes scanning to continue.

	case OP_ALT:
		goto __97

	case OP_KET:
		goto __98
	case OP_KETRMAX:
		goto __99
	case OP_KETRMIN:
		goto __100
	case OP_KETRPOS:
		goto __101

	// Skip over callout

	case OP_CALLOUT:
		goto __102

	case OP_CALLOUT_STR:
		goto __103

	// Skip over lookbehind and negative lookahead assertions

	case OP_ASSERT_NOT:
		goto __104
	case OP_ASSERTBACK:
		goto __105
	case OP_ASSERTBACK_NOT:
		goto __106
	case OP_ASSERTBACK_NA:
		goto __107

	// BRAZERO does the bracket, but carries on.

	case OP_BRAZERO:
		goto __108
	case OP_BRAMINZERO:
		goto __109
	case OP_BRAPOSZERO:
		goto __110

	// SKIPZERO skips the bracket.

	case OP_SKIPZERO:
		goto __111

	// Single-char * or ? sets the bit and tries the next item

	case OP_STAR:
		goto __112
	case OP_MINSTAR:
		goto __113
	case OP_POSSTAR:
		goto __114
	case OP_QUERY:
		goto __115
	case OP_MINQUERY:
		goto __116
	case OP_POSQUERY:
		goto __117

	case OP_STARI:
		goto __118
	case OP_MINSTARI:
		goto __119
	case OP_POSSTARI:
		goto __120
	case OP_QUERYI:
		goto __121
	case OP_MINQUERYI:
		goto __122
	case OP_POSQUERYI:
		goto __123

	// Single-char upto sets the bit and tries the next

	case OP_UPTO:
		goto __124
	case OP_MINUPTO:
		goto __125
	case OP_POSUPTO:
		goto __126

	case OP_UPTOI:
		goto __127
	case OP_MINUPTOI:
		goto __128
	case OP_POSUPTOI:
		goto __129

	// At least one single char sets the bit and stops

	case OP_EXACT:
		goto __130
	// Fall through
	case OP_CHAR:
		goto __131
	case OP_PLUS:
		goto __132
	case OP_MINPLUS:
		goto __133
	case OP_POSPLUS:
		goto __134

	case OP_EXACTI:
		goto __135
	// Fall through
	case OP_CHARI:
		goto __136
	case OP_PLUSI:
		goto __137
	case OP_MINPLUSI:
		goto __138
	case OP_POSPLUSI:
		goto __139

	// Special spacing and line-terminating items. These recognize specific
	//       lists of characters. The difference between VSPACE and ANYNL is that the
	//       latter can match the two-character CRLF sequence, but that is not
	//       relevant for finding the first character, so their code here is
	//       identical.

	case OP_HSPACE:
		goto __140

	case OP_ANYNL:
		goto __141
	case OP_VSPACE:
		goto __142

	// Single character types set the bits and stop. Note that if PCRE2_UCP
	//       is set, we do not see these opcodes because \d etc are converted to
	//       properties. Therefore, these apply in the case when only characters less
	//       than 256 are recognized to match the types.

	case OP_NOT_DIGIT:
		goto __143

	case OP_DIGIT:
		goto __144

	case OP_NOT_WHITESPACE:
		goto __145

	case OP_WHITESPACE:
		goto __146

	case OP_NOT_WORDCHAR:
		goto __147

	case OP_WORDCHAR:
		goto __148

	// One or more character type fudges the pointer and restarts, knowing
	//       it will hit a single character type and stop there.

	case OP_TYPEPLUS:
		goto __149
	case OP_TYPEMINPLUS:
		goto __150
	case OP_TYPEPOSPLUS:
		goto __151

	case OP_TYPEEXACT:
		goto __152

	// Zero or more repeats of character types set the bits and then
	//       try again.

	case OP_TYPEUPTO:
		goto __153
	case OP_TYPEMINUPTO:
		goto __154
	case OP_TYPEPOSUPTO:
		goto __155 // Fall through

	case OP_TYPESTAR:
		goto __156
	case OP_TYPEMINSTAR:
		goto __157
	case OP_TYPEPOSSTAR:
		goto __158
	case OP_TYPEQUERY:
		goto __159
	case OP_TYPEMINQUERY:
		goto __160
	case OP_TYPEPOSQUERY:
		goto __161

	// Extended class: if there are any property checks, or if this is a
	//       negative XCLASS without a map, give up. If there are no property checks,
	//       there must be wide characters on the XCLASS list, because otherwise an
	//       XCLASS would not have been created. This means that code points >= 255
	//       are potential starters. In the UTF-8 case we can scan them and set bits
	//       for the relevant leading bytes.

	case OP_XCLASS:
		goto __162

	// It seems that the fall through comment must be outside the #ifdef if
	//       it is to avoid the gcc compiler warning.

	// Fall through

	// Enter here for a negative non-XCLASS. In the 8-bit library, if we are
	//       in UTF mode, any byte with a value >= 0xc4 is a potentially valid starter
	//       because it starts a character with a value > 255. In 8-bit non-UTF mode,
	//       there is no difference between CLASS and NCLASS. In all other wide
	//       character modes, set the 0xFF bit to indicate code units >= 255.

	case OP_NCLASS:
		goto __163
	// Fall through

	// Enter here for a positive non-XCLASS. If we have fallen through from
	//       an XCLASS, classmap will already be set; just advance the code pointer.
	//       Otherwise, set up classmap for a a non-XCLASS and advance past it.

	case OP_CLASS:
		goto __164
	}
	goto __8

	// If we reach something we don't understand, it means a new opcode has
	//       been created that hasn't been added to this function. Hopefully this
	//       problem will be discovered during testing.

__9:
	return SSB_UNKNOWN

	// Fail for a valid opcode that implies no starting bits.

__10:
__11:
__12:
__13:
__14:
__15:
__16:
__17:
__18:
__19:
__20:
__21:
__22:
__23:
__24:
__25:
__26:
__27:
__28:
__29:
__30:
__31:
__32:
__33:
__34:
__35:
__36:
__37:
__38:
__39:
__40:
__41:
__42:
__43:
__44:
__45:
__46:
__47:
__48:
__49:
__50:
__51:
__52:
__53:
__54:
__55:
__56:
__57:
__58:
__59:
__60:
__61:
__62:
__63:
__64:
__65:
__66:
__67:
__68:
__69:
__70:
__71:
__72:
__73:
__74:
__75:
__76:
__77:
__78:
__79:
__80:
	return SSB_FAIL

	// OP_CIRC happens only at the start of an anchored branch (multiline ^
	//       uses OP_CIRCM). Skip over it.

__81:
	tcode += uintptr(X_pcre2_OP_lengths_8[OP_CIRC])
	goto __8

	// A "real" property test implies no starting bits, but the fake property
	//       PT_CLIST identifies a list of characters. These lists are short, as they
	//       are used for characters with more than one "other case", so there is no
	//       point in recognizing them for OP_NOTPROP.

__82:
	if !(int32(*(*uint8)(unsafe.Pointer(tcode + 1))) != DPT_CLIST) {
		goto __165
	}
	return SSB_FAIL
__165:
	;

	p = uintptr(unsafe.Pointer(&X_pcre2_ucd_caseless_sets_8)) + uintptr(*(*uint8)(unsafe.Pointer(tcode + 2)))*4
__166:
	if !(libc.AssignUint32(&c, *(*uint32)(unsafe.Pointer(libc.PostIncUintptr(&p, 4)))) < DNOTACHAR) {
		goto __167
	}

	if !(utf != 0) {
		goto __168
	}

	X_pcre2_ord2utf_8(tls, c, bp)
	c = uint32(*(*uint8)(unsafe.Pointer(bp)))
__168:
	;
	if !(c > uint32(0xff)) {
		goto __169
	}
	*(*uint8)(unsafe.Pointer(re + 40 + 31)) |= uint8(uint32(1) << (0xff & 7))
	goto __170
__169:
	*(*uint8)(unsafe.Pointer(re + 40 + uintptr(c/uint32(8)))) |= uint8(uint32(1) << (c & uint32(7)))
__170:
	;
	goto __166
__167:
	;

	try_next = DFALSE
	goto __8

	// We can ignore word boundary tests.

__83:
__84:
	tcode++
	goto __8

	// If we hit a bracket or a positive lookahead assertion, recurse to set
	//       bits from within the subpattern. If it can't find anything, we have to
	//       give up. If it finds some mandatory character(s), we are done for this
	//       branch. Otherwise, carry on scanning after the subpattern.

__85:
__86:
__87:
__88:
__89:
__90:
__91:
__92:
__93:
__94:
__95:
__96:
	rc = set_start_bits(tls, re, tcode, utf, ucp, depthptr)
	if !(rc == SSB_DONE) {
		goto __171
	}

	try_next = DFALSE
	goto __172
__171:
	if !(rc == SSB_CONTINUE) {
		goto __173
	}

__175:
	tcode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(tcode + 2)))))
	goto __176
__176:
	if int32(*(*uint8)(unsafe.Pointer(tcode))) == OP_ALT {
		goto __175
	}
	goto __177
__177:
	;
	tcode += uintptr(1 + DLINK_SIZE)
	goto __174
__173:
	return rc
__174:
	;
__172:
	; // FAIL, UNKNOWN, or TOODEEP
	goto __8

	// If we hit ALT or KET, it means we haven't found anything mandatory in
	//       this branch, though we might have found something optional. For ALT, we
	//       continue with the next alternative, but we have to arrange that the final
	//       result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,
	//       return SSB_CONTINUE: if this is the top level, that indicates failure,
	//       but after a nested subpattern, it causes scanning to continue.

__97:
	yield = SSB_CONTINUE
	try_next = DFALSE
	goto __8

__98:
__99:
__100:
__101:
	return SSB_CONTINUE

	// Skip over callout

__102:
	tcode += uintptr(X_pcre2_OP_lengths_8[OP_CALLOUT])
	goto __8

__103:
	tcode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(tcode + 5)))<<8 | int32(*(*uint8)(unsafe.Pointer(tcode + 6)))))
	goto __8

	// Skip over lookbehind and negative lookahead assertions

__104:
__105:
__106:
__107:
__178:
	tcode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(tcode + 2)))))
	goto __179
__179:
	if int32(*(*uint8)(unsafe.Pointer(tcode))) == OP_ALT {
		goto __178
	}
	goto __180
__180:
	;
	tcode += uintptr(1 + DLINK_SIZE)
	goto __8

	// BRAZERO does the bracket, but carries on.

__108:
__109:
__110:
	rc = set_start_bits(tls, re, libc.PreIncUintptr(&tcode, 1), utf, ucp, depthptr)
	if !(rc == SSB_FAIL || rc == SSB_UNKNOWN || rc == SSB_TOODEEP) {
		goto __181
	}
	return rc
__181:
	;
__182:
	tcode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(tcode + 2)))))
	goto __183
__183:
	if int32(*(*uint8)(unsafe.Pointer(tcode))) == OP_ALT {
		goto __182
	}
	goto __184
__184:
	;
	tcode += uintptr(1 + DLINK_SIZE)
	goto __8

	// SKIPZERO skips the bracket.

__111:
	tcode++
__185:
	tcode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(tcode + 2)))))
	goto __186
__186:
	if int32(*(*uint8)(unsafe.Pointer(tcode))) == OP_ALT {
		goto __185
	}
	goto __187
__187:
	;
	tcode += uintptr(1 + DLINK_SIZE)
	goto __8

	// Single-char * or ? sets the bit and tries the next item

__112:
__113:
__114:
__115:
__116:
__117:
	tcode = set_table_bit(tls, re, tcode+uintptr(1), DFALSE, utf, ucp)
	goto __8

__118:
__119:
__120:
__121:
__122:
__123:
	tcode = set_table_bit(tls, re, tcode+uintptr(1), DTRUE, utf, ucp)
	goto __8

	// Single-char upto sets the bit and tries the next

__124:
__125:
__126:
	tcode = set_table_bit(tls, re, tcode+uintptr(1)+uintptr(DIMM2_SIZE), DFALSE, utf, ucp)
	goto __8

__127:
__128:
__129:
	tcode = set_table_bit(tls, re, tcode+uintptr(1)+uintptr(DIMM2_SIZE), DTRUE, utf, ucp)
	goto __8

	// At least one single char sets the bit and stops

__130:
	tcode += uintptr(DIMM2_SIZE)
	// Fall through
__131:
__132:
__133:
__134:
	set_table_bit(tls, re, tcode+uintptr(1), DFALSE, utf, ucp)
	try_next = DFALSE
	goto __8

__135:
	tcode += uintptr(DIMM2_SIZE)
	// Fall through
__136:
__137:
__138:
__139:
	set_table_bit(tls, re, tcode+uintptr(1), DTRUE, utf, ucp)
	try_next = DFALSE
	goto __8

	// Special spacing and line-terminating items. These recognize specific
	//       lists of characters. The difference between VSPACE and ANYNL is that the
	//       latter can match the two-character CRLF sequence, but that is not
	//       relevant for finding the first character, so their code here is
	//       identical.

__140:
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\011' & 7))
	*(*uint8)(unsafe.Pointer(re + 40 + 4)) |= uint8(uint32(1) << ('\040' & 7))

	// For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
	//       the bits for 0xA0 and for code units >= 255, independently of UTF.

	// For the 8-bit library in UTF-8 mode, set the bits for the first code
	//       units of horizontal space characters.

	if !(utf != 0) {
		goto __188
	}

	*(*uint8)(unsafe.Pointer(re + 40 + 24)) |= uint8(uint32(1) << (0xC2 & 7)) // For U+00A0
	*(*uint8)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE1 & 7)) // For U+1680, U+180E
	*(*uint8)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE2 & 7)) // For U+2000 - U+200A, U+202F, U+205F
	*(*uint8)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE3 & 7)) // For U+3000
	goto __189
__188:
	/* For the 8-bit library not in UTF-8 mode, set the bit for 0xA0, unless
	   the code is EBCDIC. */

	*(*uint8)(unsafe.Pointer(re + 40 + 20)) |= uint8(uint32(1) << (0xA0 & 7))
__189:
	;

	try_next = DFALSE
	goto __8

__141:
__142:
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\012' & 7))
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\013' & 7))
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\014' & 7))
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\015' & 7))

	// For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
	//       the bits for NEL and for code units >= 255, independently of UTF.

	// For the 8-bit library in UTF-8 mode, set the bits for the first code
	//       units of vertical space characters.

	if !(utf != 0) {
		goto __190
	}

	*(*uint8)(unsafe.Pointer(re + 40 + 24)) |= uint8(uint32(1) << (0xC2 & 7)) // For U+0085 (NEL)
	*(*uint8)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE2 & 7)) // For U+2028, U+2029
	goto __191
__190:
	/* For the 8-bit library not in UTF-8 mode, set the bit for NEL. */

	*(*uint8)(unsafe.Pointer(re + 40 + 16)) |= uint8(uint32(1) << (int32(libc.Uint8FromInt32(133)) & 7))
__191:
	;

	try_next = DFALSE
	goto __8

	// Single character types set the bits and stop. Note that if PCRE2_UCP
	//       is set, we do not see these opcodes because \d etc are converted to
	//       properties. Therefore, these apply in the case when only characters less
	//       than 256 are recognized to match the types.

__143:
	set_nottype_bits(tls, re, Dcbit_digit, uint32(table_limit))
	try_next = DFALSE
	goto __8

__144:
	set_type_bits(tls, re, Dcbit_digit, uint32(table_limit))
	try_next = DFALSE
	goto __8

__145:
	set_nottype_bits(tls, re, Dcbit_space, uint32(table_limit))
	try_next = DFALSE
	goto __8

__146:
	set_type_bits(tls, re, Dcbit_space, uint32(table_limit))
	try_next = DFALSE
	goto __8

__147:
	set_nottype_bits(tls, re, Dcbit_word, uint32(table_limit))
	try_next = DFALSE
	goto __8

__148:
	set_type_bits(tls, re, Dcbit_word, uint32(table_limit))
	try_next = DFALSE
	goto __8

	// One or more character type fudges the pointer and restarts, knowing
	//       it will hit a single character type and stop there.

__149:
__150:
__151:
	tcode++
	goto __8

__152:
	tcode += uintptr(1 + DIMM2_SIZE)
	goto __8

	// Zero or more repeats of character types set the bits and then
	//       try again.

__153:
__154:
__155:
	tcode += uintptr(DIMM2_SIZE) // Fall through

__156:
__157:
__158:
__159:
__160:
__161:
	switch int32(*(*uint8)(unsafe.Pointer(tcode + 1))) {
	default:
		goto __193
	case OP_ANY:
		goto __194
	case OP_ALLANY:
		goto __195

	case OP_HSPACE:
		goto __196

	case OP_ANYNL:
		goto __197
	case OP_VSPACE:
		goto __198

	case OP_NOT_DIGIT:
		goto __199

	case OP_DIGIT:
		goto __200

	case OP_NOT_WHITESPACE:
		goto __201

	case OP_WHITESPACE:
		goto __202

	case OP_NOT_WORDCHAR:
		goto __203

	case OP_WORDCHAR:
		goto __204
	}
	goto __192

__193:
__194:
__195:
	return SSB_FAIL

__196:
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\011' & 7))
	*(*uint8)(unsafe.Pointer(re + 40 + 4)) |= uint8(uint32(1) << ('\040' & 7))

	// For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
	//         the bits for 0xA0 and for code units >= 255, independently of UTF.

	// For the 8-bit library in UTF-8 mode, set the bits for the first code
	//         units of horizontal space characters.

	if !(utf != 0) {
		goto __205
	}

	*(*uint8)(unsafe.Pointer(re + 40 + 24)) |= uint8(uint32(1) << (0xC2 & 7)) // For U+00A0
	*(*uint8)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE1 & 7)) // For U+1680, U+180E
	*(*uint8)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE2 & 7)) // For U+2000 - U+200A, U+202F, U+205F
	*(*uint8)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE3 & 7)) // For U+3000
	goto __206
__205:
	/* For the 8-bit library not in UTF-8 mode, set the bit for 0xA0, unless
	   the code is EBCDIC. */

	*(*uint8)(unsafe.Pointer(re + 40 + 20)) |= uint8(uint32(1) << (0xA0 & 7))
__206:
	;
	goto __192

__197:
__198:
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\012' & 7))
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\013' & 7))
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\014' & 7))
	*(*uint8)(unsafe.Pointer(re + 40 + 1)) |= uint8(uint32(1) << ('\015' & 7))

	// For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
	//         the bits for NEL and for code units >= 255, independently of UTF.

	// For the 8-bit library in UTF-8 mode, set the bits for the first code
	//         units of vertical space characters.

	if !(utf != 0) {
		goto __207
	}

	*(*uint8)(unsafe.Pointer(re + 40 + 24)) |= uint8(uint32(1) << (0xC2 & 7)) // For U+0085 (NEL)
	*(*uint8)(unsafe.Pointer(re + 40 + 28)) |= uint8(uint32(1) << (0xE2 & 7)) // For U+2028, U+2029
	goto __208
__207:
	/* For the 8-bit library not in UTF-8 mode, set the bit for NEL. */

	*(*uint8)(unsafe.Pointer(re + 40 + 16)) |= uint8(uint32(1) << (int32(libc.Uint8FromInt32(133)) & 7))
__208:
	;
	goto __192

__199:
	set_nottype_bits(tls, re, Dcbit_digit, uint32(table_limit))
	goto __192

__200:
	set_type_bits(tls, re, Dcbit_digit, uint32(table_limit))
	goto __192

__201:
	set_nottype_bits(tls, re, Dcbit_space, uint32(table_limit))
	goto __192

__202:
	set_type_bits(tls, re, Dcbit_space, uint32(table_limit))
	goto __192

__203:
	set_nottype_bits(tls, re, Dcbit_word, uint32(table_limit))
	goto __192

__204:
	set_type_bits(tls, re, Dcbit_word, uint32(table_limit))
	goto __192
__192:
	;

	tcode += uintptr(2)
	goto __8

	// Extended class: if there are any property checks, or if this is a
	//       negative XCLASS without a map, give up. If there are no property checks,
	//       there must be wide characters on the XCLASS list, because otherwise an
	//       XCLASS would not have been created. This means that code points >= 255
	//       are potential starters. In the UTF-8 case we can scan them and set bits
	//       for the relevant leading bytes.

__162:
	xclassflags = *(*uint8)(unsafe.Pointer(tcode + 3))
	if !(int32(xclassflags)&DXCL_HASPROP != 0 || int32(xclassflags)&(DXCL_MAP|DXCL_NOT) == DXCL_NOT) {
		goto __209
	}
	return SSB_FAIL
__209:
	;

	// We have a positive XCLASS or a negative one without a map. Set up the
	//       map pointer if there is one, and fall through.

	if int32(xclassflags)&DXCL_MAP == 0 {
		classmap = uintptr(0)
	} else {
		classmap = tcode + uintptr(1) + uintptr(DLINK_SIZE) + uintptr(1)
	}

	// In UTF-8 mode, scan the character list and set bits for leading bytes,
	//       then jump to handle the map.

	if !(utf != 0 && int32(xclassflags)&DXCL_NOT == 0) {
		goto __210
	}

	p1 = tcode + uintptr(1) + uintptr(DLINK_SIZE) + uintptr(1) + uintptr(func() int32 {
		if classmap == uintptr(0) {
			return 0
		}
		return 32
	}())
	tcode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(tcode + 2)))))

__211:
	switch int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1)))) {
	case DXCL_SINGLE:
		goto __215

	case DXCL_RANGE:
		goto __216

	case DXCL_END:
		goto __217

	default:
		goto __218
	}
	goto __214

__215:
	b = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1)))
__219:
	if !(int32(*(*uint8)(unsafe.Pointer(p1)))&0xc0 == 0x80) {
		goto __220
	}
	p1++
	goto __219
__220:
	;
	*(*uint8)(unsafe.Pointer(re + 40 + uintptr(int32(b)/8))) |= uint8(uint32(1) << (int32(b) & 7))
	goto __214

__216:
	b = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1)))
__221:
	if !(int32(*(*uint8)(unsafe.Pointer(p1)))&0xc0 == 0x80) {
		goto __222
	}
	p1++
	goto __221
__222:
	;
	e = *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p1, 1)))
__223:
	if !(int32(*(*uint8)(unsafe.Pointer(p1)))&0xc0 == 0x80) {
		goto __224
	}
	p1++
	goto __223
__224:
	;
__225:
	if !(int32(b) <= int32(e)) {
		goto __227
	}
	*(*uint8)(unsafe.Pointer(re + 40 + uintptr(int32(b)/8))) |= uint8(uint32(1) << (int32(b) & 7))
	goto __226
__226:
	b++
	goto __225
	goto __227
__227:
	;
	goto __214

__217:
	goto HANDLE_CLASSMAP

__218:
	return SSB_UNKNOWN // Internal error, should not occur
__214:
	;
	goto __212
__212:
	goto __211
	goto __213
__213:
	;
__210:
	;

	// It seems that the fall through comment must be outside the #ifdef if
	//       it is to avoid the gcc compiler warning.

	// Fall through

	// Enter here for a negative non-XCLASS. In the 8-bit library, if we are
	//       in UTF mode, any byte with a value >= 0xc4 is a potentially valid starter
	//       because it starts a character with a value > 255. In 8-bit non-UTF mode,
	//       there is no difference between CLASS and NCLASS. In all other wide
	//       character modes, set the 0xFF bit to indicate code units >= 255.

__163:
	if !(utf != 0) {
		goto __228
	}

	*(*uint8)(unsafe.Pointer(re + 40 + 24)) |= uint8(0xf0) // Bits for 0xc4 - 0xc8
	libc.Xmemset(tls, re+40+uintptr(25), 0xff, uint64(7))  // Bits for 0xc9 - 0xff
__228:
	;
	// Fall through

	// Enter here for a positive non-XCLASS. If we have fallen through from
	//       an XCLASS, classmap will already be set; just advance the code pointer.
	//       Otherwise, set up classmap for a a non-XCLASS and advance past it.

__164:
	if !(int32(*(*uint8)(unsafe.Pointer(tcode))) == OP_XCLASS) {
		goto __229
	}
	tcode += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(tcode + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(tcode + 2)))))
	goto __230
__229:

	classmap = libc.PreIncUintptr(&tcode, 1)
	tcode += uintptr(uint64(32) / uint64(unsafe.Sizeof(uint8(0))))
__230:
	;

	// When wide characters are supported, classmap may be NULL. In UTF-8
	//       (sic) mode, the bits in a class bit map correspond to character values,
	//       not to byte values. However, the bit map we are constructing is for byte
	//       values. So we have to do a conversion for characters whose code point is
	//       greater than 127. In fact, there are only two possible starting bytes for
	//       characters in the range 128 - 255.

HANDLE_CLASSMAP:
	if !(classmap != uintptr(0)) {
		goto __231
	}

	if !(utf != 0) {
		goto __232
	}

	c = uint32(0)
__234:
	if !(c < uint32(16)) {
		goto __236
	}
	*(*uint8)(unsafe.Pointer(re + 40 + uintptr(c))) |= uint8(int32(*(*uint8)(unsafe.Pointer(classmap + uintptr(c)))))
	goto __235
__235:
	c++
	goto __234
	goto __236
__236:
	;
	c = uint32(128)
__237:
	if !(c < uint32(256)) {
		goto __239
	}

	if !(uint32(*(*uint8)(unsafe.Pointer(classmap + uintptr(c/uint32(8)))))&(uint32(1)<<(c&uint32(7))) != uint32(0)) {
		goto __240
	}

	d = int32(c>>6 | uint32(0xc0))                                                   // Set bit for this starter
	*(*uint8)(unsafe.Pointer(re + 40 + uintptr(d/8))) |= uint8(uint32(1) << (d & 7)) // and then skip on to the
	c = c&uint32(0xc0) + uint32(0x40) - uint32(1)                                    // next relevant character.
__240:
	;
	goto __238
__238:
	c++
	goto __237
	goto __239
__239:
	;
	goto __233
__232:
	/* In all modes except UTF-8, the two bit maps are compatible. */

	c = uint32(0)
__241:
	if !(c < uint32(32)) {
		goto __243
	}
	*(*uint8)(unsafe.Pointer(re + 40 + uintptr(c))) |= uint8(int32(*(*uint8)(unsafe.Pointer(classmap + uintptr(c)))))
	goto __242
__242:
	c++
	goto __241
	goto __243
__243:
	;
__233:
	;
__231:
	;

	// Act on what follows the class. For a zero minimum repeat, continue;
	//       otherwise stop processing.

	switch int32(*(*uint8)(unsafe.Pointer(tcode))) {
	case OP_CRSTAR:
		goto __245
	case OP_CRMINSTAR:
		goto __246
	case OP_CRQUERY:
		goto __247
	case OP_CRMINQUERY:
		goto __248
	case OP_CRPOSSTAR:
		goto __249
	case OP_CRPOSQUERY:
		goto __250

	case OP_CRRANGE:
		goto __251
	case OP_CRMINRANGE:
		goto __252
	case OP_CRPOSRANGE:
		goto __253

	default:
		goto __254
	}
	goto __244

__245:
__246:
__247:
__248:
__249:
__250:
	tcode++
	goto __244

__251:
__252:
__253:
	if !(uint32(int32(*(*uint8)(unsafe.Pointer(tcode + 1)))<<8|int32(*(*uint8)(unsafe.Pointer(tcode + 2)))) == uint32(0)) {
		goto __255
	}
	tcode += uintptr(1 + 2*DIMM2_SIZE)
	goto __256
__255:
	try_next = DFALSE
__256:
	;
	goto __244

__254:
	try_next = DFALSE
	goto __244
__244:
	;
	goto __8 // End of class handling case
__8:
	; // End of switch for opcodes
	goto __6
__7:
	; // End of try_next loop

	code += uintptr(uint32(int32(*(*uint8)(unsafe.Pointer(code + 1)))<<8 | int32(*(*uint8)(unsafe.Pointer(code + 2))))) // Advance to next branch
	goto __3
__3:
	if int32(*(*uint8)(unsafe.Pointer(code))) == OP_ALT {
		goto __2
	}
	goto __4
__4:
	;

	return yield
}

// ************************************************
//
//          Study a compiled expression           *
//

// This function is handed a compiled expression that it must study to produce
// information that will speed up the matching.
//
// Argument:
//   re       points to the compiled expression
//
// Returns:   0 normally; non-zero should never normally occur
//            1 unknown opcode in set_start_bits
//            2 missing capturing bracket
//            3 unknown opcode in find_minlength

func X_pcre2_study_8(tls *libc.TLS, re uintptr) int32 { /* pcre2_study.c:1672:1: */
	bp := tls.Alloc(524)
	defer tls.Free(524)

	// var count int32 at bp+520, 4

	var code uintptr
	var utf int32
	var ucp int32
	var d int32
	var c int32
	var y uint8
	var x uint8
	var i int32
	var a int32
	var b int32
	var p uintptr
	var flags uint32
	// var depth int32 at bp, 4

	var rc int32
	var min int32
	// var backref_cache [129]int32 at bp+4, 516
	*(*int32)(unsafe.Pointer(bp + 520 /* count */)) = 0
	utf = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UTF != uint32(0))
	ucp = libc.Bool32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Foverall_options&DPCRE2_UCP != uint32(0))

	// Find start of compiled code

	code = re + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{}))) + uintptr(int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_entry_size)*int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fname_count))

	// For a pattern that has a first code unit, or a multiline pattern that
	// matches only at "line start", there is no point in seeking a list of starting
	// code units.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_FIRSTSET|DPCRE2_STARTLINE) == uint32(0)) {
		goto __1
	}
	*(*int32)(unsafe.Pointer(bp /* depth */)) = 0
	rc = set_start_bits(tls, re, code, utf, ucp, bp)
	if !(rc == SSB_UNKNOWN) {
		goto __2
	}
	return 1
__2:
	;

	// If a list of starting code units was set up, scan the list to see if only
	//   one or two were listed. Having only one listed is rare because usually a
	//   single starting code unit will have been recognized and PCRE2_FIRSTSET set.
	//   If two are listed, see if they are caseless versions of the same character;
	//   if so we can replace the list with a caseless first code unit. This gives
	//   better performance and is plausibly worth doing for patterns such as [Ww]ord
	//   or (word|WORD).

	if !(rc == SSB_DONE) {
		goto __3
	}
	a = -1
	b = -1
	p = re + 40 /* &.start_bitmap */
	flags = uint32(DPCRE2_FIRSTMAPSET)

	i = 0
__4:
	if !(i < 256) {
		goto __6
	}

	x = *(*uint8)(unsafe.Pointer(p))
	if !(int32(x) != 0) {
		goto __7
	}

	y = uint8(int32(x) & (^int32(x) + 1)) // Least significant bit
	if !(int32(y) != int32(x)) {
		goto __8
	}
	goto DONE
__8:
	; // More than one bit set

	// In the 16-bit and 32-bit libraries, the bit for 0xff means "0xff and
	//         all wide characters", so we cannot use it here.

	// Compute the character value

	c = i
	switch int32(x) {
	case 1:
		goto __10
	case 2:
		goto __11
	case 4:
		goto __12
	case 8:
		goto __13
	case 16:
		goto __14
	case 32:
		goto __15
	case 64:
		goto __16
	case 128:
		goto __17
	}
	goto __9

__10:
	goto __9
__11:
	c = c + 1
	goto __9
__12:
	c = c + 2
	goto __9
__13:
	c = c + 3
	goto __9
__14:
	c = c + 4
	goto __9
__15:
	c = c + 5
	goto __9
__16:
	c = c + 6
	goto __9
__17:
	c = c + 7
	goto __9
__9:
	;

	// c contains the code unit value, in the range 0-255. In 8-bit UTF
	//         mode, only values < 128 can be used. In all the other cases, c is a
	//         character value.

	if !(utf != 0 && c > 127) {
		goto __18
	}
	goto DONE
__18:
	;
	if !(a < 0) {
		goto __19
	}
	a = c
	goto __20
__19:
	if !(b < 0) {
		goto __21
	} /* Second one found */

	d = int32(*(*uint8)(unsafe.Pointer((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftables + uintptr(Dfcc_offset) + uintptr(uint32(c)))))

	if !(utf != 0 || ucp != 0) {
		goto __23
	}

	if !(int32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[c/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+c%DUCD_BLOCK_SIZE])*12)).Fcaseset) != 0) {
		goto __24
	}
	goto DONE
__24:
	; // Multiple case set
	if !(c > 127) {
		goto __25
	}
	d = int32(uint32(c + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[c/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+c%DUCD_BLOCK_SIZE])*12)).Fother_case))
__25:
	;
__23:
	;

	if !(d != a) {
		goto __26
	}
	goto DONE
__26:
	;     // Not the other case of a
	b = c // Save second in b
	goto __22
__21:
	goto DONE
__22:
	;
__20:
	; // More than two characters found
__7:
	;
	goto __5
__5:
	p++
	i = i + 8
	goto __4
	goto __6
__6:
	;

	// Replace the start code unit bits with a first code unit, but only if it
	//     is not the same as a required later code unit. This is because a search for
	//     a required code unit starts after an explicit first code unit, but at a
	//     code unit found from the bitmap. Patterns such as /a*a/ don't work
	//     if both the start unit and required unit are the same.

	if !(a >= 0 && ((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_LASTSET) == uint32(0) || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit != uint32(a) && (b < 0 || (*Tpcre2_real_code_8)(unsafe.Pointer(re)).Flast_codeunit != uint32(b)))) {
		goto __27
	}

	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ffirst_codeunit = uint32(a)
	flags = uint32(DPCRE2_FIRSTSET)
	if !(b >= 0) {
		goto __28
	}
	flags = flags | uint32(DPCRE2_FIRSTCASELESS)
__28:
	;
__27:
	;

DONE:
	*(*uint32)(unsafe.Pointer(re + 96)) |= flags
__3:
	;
__1:
	;

	// Find the minimum length of subject string. If the pattern can match an empty
	// string, the minimum length is already known. If the pattern contains (*ACCEPT)
	// all bets are off, and we don't even try to find a minimum length. If there are
	// more back references than the size of the vector we are going to cache them in,
	// do nothing. A pattern that complicated will probably take a long time to
	// analyze and may in any case turn out to be too complicated. Note that back
	// reference minima are held as 16-bit numbers.

	if !((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fflags&uint32(DPCRE2_MATCH_EMPTY|DPCRE2_HASACCEPT) == uint32(0) && int32((*Tpcre2_real_code_8)(unsafe.Pointer(re)).Ftop_backref) <= DMAX_CACHE_BACKREF) {
		goto __29
	}

	*(*int32)(unsafe.Pointer(bp + 4)) = 0 // Highest one that is set
	min = find_minlength(tls, re, code, code, utf, uintptr(0), bp+520, bp+4)
	switch min {
	case -1:
		goto __31 // Leave minlength unchanged (will be zero)

	case -2:
		goto __32 // missing capturing bracket

	case -3:
		goto __33 // unrecognized opcode

	default:
		goto __34
	}
	goto __30

__31: // \C in UTF mode or over-complex regex
	goto __30 // Leave minlength unchanged (will be zero)

__32:
	return 2 // missing capturing bracket

__33:
	return 3 // unrecognized opcode

__34:
	(*Tpcre2_real_code_8)(unsafe.Pointer(re)).Fminlength = func() uint16 {
		if min > 65535 {
			return uint16(65535)
		}
		return uint16(min)
	}()
	goto __30
__30:
	;
__29:
	;

	return 0
}

// End of pcre2_study.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//           Find end of substitute text          *
//

// In extended mode, we recognize ${name:+set text:unset text} and similar
// constructions. This requires the identification of unescaped : and }
// characters. This function scans for such. It must deal with nested ${
// constructions. The pointer to the text is updated, either to the required end
// character, or to where an error was detected.
//
// Arguments:
//   code      points to the compiled expression (for options)
//   ptrptr    points to the pointer to the start of the text (updated)
//   ptrend    end of the whole string
//   last      TRUE if the last expected string (only } recognized)
//
// Returns:    0 on success
//             negative error code on failure

func find_text_end(tls *libc.TLS, code uintptr, ptrptr uintptr, ptrend uintptr, last int32) int32 { /* pcre2_substitute.c:79:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	var nestlevel uint32
	var literal int32
	// var ptr uintptr at bp, 8

	var erc int32
	// var errorcode int32 at bp+12, 4

	// var ch uint32 at bp+8, 4
	rc = 0
	nestlevel = uint32(0)
	literal = DFALSE
	*(*uintptr)(unsafe.Pointer(bp /* ptr */)) = *(*uintptr)(unsafe.Pointer(ptrptr))

__1:
	if !(*(*uintptr)(unsafe.Pointer(bp)) < ptrend) {
		goto __3
	}

	if !(literal != 0) {
		goto __4
	}

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\134' && *(*uintptr)(unsafe.Pointer(bp)) < ptrend-uintptr(1) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1))) == '\105') {
		goto __6
	}

	literal = DFALSE
	*(*uintptr)(unsafe.Pointer(bp /* ptr */)) += uintptr(1)
__6:
	;
	goto __5
__4:
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\175') {
		goto __7
	}

	if !(nestlevel == uint32(0)) {
		goto __9
	}
	goto EXIT
__9:
	;
	nestlevel--
	goto __8
__7:
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\072' && !(last != 0) && nestlevel == uint32(0)) {
		goto __10
	}
	goto EXIT
	goto __11
__10:
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\044') {
		goto __12
	}

	if !(*(*uintptr)(unsafe.Pointer(bp)) < ptrend-uintptr(1) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1))) == '\173') {
		goto __14
	}

	nestlevel++
	*(*uintptr)(unsafe.Pointer(bp /* ptr */)) += uintptr(1)
__14:
	;
	goto __13
__12:
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\134') {
		goto __15
	}

	if !(*(*uintptr)(unsafe.Pointer(bp)) < ptrend-uintptr(1)) {
		goto __16
	}
	switch int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* ptr */)) + 1))) {
	case '\114':
		goto __18
	case '\154':
		goto __19
	case '\125':
		goto __20
	case '\165':
		goto __21
	}
	goto __17

__18:
__19:
__20:
__21:
	*(*uintptr)(unsafe.Pointer(bp /* ptr */)) += uintptr(1)
	goto __2
__17:
	;
__16:
	;

	*(*uintptr)(unsafe.Pointer(bp /* ptr */)) += uintptr(1) // Must point after \
	erc = X_pcre2_check_escape_8(tls, bp, ptrend, bp+8, bp+12,
		(*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fextra_options, DFALSE, uintptr(0))
	*(*uintptr)(unsafe.Pointer(bp /* ptr */)) -= uintptr(1) // Back to last code unit of escape
	if !(*(*int32)(unsafe.Pointer(bp + 12)) != 0) {
		goto __22
	}

	rc = *(*int32)(unsafe.Pointer(bp + 12 /* errorcode */))
	goto EXIT
__22:
	;

	switch erc {
	case 0:
		goto __24 // Data character
	case ESC_E:
		goto __25

	case ESC_Q:
		goto __26

	default:
		goto __27
	}
	goto __23

__24: // Data character
__25: // Isolated \E is ignored
	goto __23

__26:
	literal = DTRUE
	goto __23

__27:
	rc = -57
	goto EXIT
__23:
	;
__15:
	;
__13:
	;
__11:
	;
__8:
	;
__5:
	;
	goto __2
__2:
	*(*uintptr)(unsafe.Pointer(bp /* ptr */))++
	goto __1
	goto __3
__3:
	;

	rc = -58 // Terminator not found

EXIT:
	*(*uintptr)(unsafe.Pointer(ptrptr)) = *(*uintptr)(unsafe.Pointer(bp /* ptr */))
	return rc
}

// ************************************************
//
//              Match and substitute              *
//

// This function applies a compiled re to a subject string and creates a new
// string with substitutions. The first 7 arguments are the same as for
// pcre2_match(). Either string length may be PCRE2_ZERO_TERMINATED.
//
// Arguments:
//   code            points to the compiled expression
//   subject         points to the subject string
//   length          length of subject string (may contain binary zeros)
//   start_offset    where to start in the subject string
//   options         option bits
//   match_data      points to a match_data block, or is NULL
//   context         points a PCRE2 context
//   replacement     points to the replacement string
//   rlength         length of replacement string
//   buffer          where to put the substituted string
//   blength         points to length of buffer; updated to length of string
//
// Returns:          >= 0 number of substitutions made
//                   < 0 an error code
//                   PCRE2_ERROR_BADREPLACEMENT means invalid use of $

// This macro checks for space in the buffer before copying into it. On
// overflow, either give an error immediately, or keep on, accumulating the
// length.

// Here's the function

func Xpcre2_substitute_8(tls *libc.TLS, code uintptr, subject uintptr, length uint64, start_offset uint64, options uint32, match_data uintptr, mcontext uintptr, replacement uintptr, rlength uint64, buffer uintptr, blength uintptr) int32 { /* pcre2_substitute.c:220:1: */
	bp := tls.Alloc(328)
	defer tls.Free(328)

	var rc int32
	var subs int32
	var forcecase int32
	var forcecasereset int32
	var ovector_count uint32
	var goptions uint32
	var suboptions uint32
	var internal_match_data uintptr
	var escaped_literal int32
	var overflowed int32
	var use_existing_match int32
	var replacement_only int32
	var utf int32
	var ucp int32
	// var temp [6]uint8 at bp+312, 6

	// var ptr uintptr at bp+280, 8

	var repend uintptr
	var extra_needed uint64
	var buff_offset uint64
	var buff_length uint64
	var lengthleft uint64
	var fraglength uint64
	var ovector uintptr
	// var ovecsave [3]uint64 at bp, 24

	// var scb Tpcre2_substitute_callout_block_8 at bp+24, 56

	var gcontext uintptr
	var gcontext1 uintptr
	var pairs int32
	var save_start uint64
	var ctypes uintptr
	var mark_start uintptr
	var mark uintptr
	var ng uint32
	// var first uintptr at bp+288, 8

	// var last uintptr at bp+296, 8

	var entry uintptr
	var type1 uint32
	var subptr uintptr
	var subptrend uintptr
	var group int32
	var n int32
	var special uint32
	var inparens int32
	var star int32
	// var sublength uint64 at bp+304, 8

	var text1_start uintptr
	var text1_end uintptr
	var text2_start uintptr
	var text2_end uintptr
	var next uint8
	// var name [33]uint8 at bp+240, 33

	// var errorcode int32 at bp+324, 4

	var type2 uint32
	// var ch uint32 at bp+320, 4

	var chlen uint32
	var newlength uint64
	var oldlength uint64
	// var ptrstack [20]uintptr at bp+80, 160

	var ptrstackptr uint32
	forcecase = 0
	forcecasereset = 0
	goptions = uint32(0)
	internal_match_data = uintptr(0)
	escaped_literal = DFALSE
	overflowed = DFALSE
	utf = libc.Bool32((*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options&DPCRE2_UTF != uint32(0))
	ucp = libc.Bool32((*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options&DPCRE2_UCP != uint32(0))
	extra_needed = uint64(0)

	// General initialization

	buff_offset = uint64(0)
	lengthleft = libc.AssignUint64(&buff_length, *(*uint64)(unsafe.Pointer(blength)))
	*(*uint64)(unsafe.Pointer(blength)) = libc.CplUint64(uint64(0))
	*(*uint64)(unsafe.Pointer(bp)) = libc.AssignPtrUint64(bp+1*8, libc.AssignPtrUint64(bp+2*8, libc.CplUint64(uint64(0))))

	// Partial matching is not valid. This must come after setting *blength to
	// PCRE2_UNSET, so as not to imply an offset in the replacement.

	if !(options&(DPCRE2_PARTIAL_HARD|DPCRE2_PARTIAL_SOFT) != uint32(0)) {
		goto __1
	}
	return -34
__1:
	;

	// Validate length and find the end of the replacement. A NULL replacement of
	// zero length is interpreted as an empty string.

	if !(replacement == uintptr(0)) {
		goto __2
	}

	if !(rlength != uint64(0)) {
		goto __3
	}
	return -51
__3:
	;
	replacement = ts + 797 /* "" */
__2:
	;

	if !(rlength == libc.CplUint64(uint64(0))) {
		goto __4
	}
	rlength = X_pcre2_strlen_8(tls, replacement)
__4:
	;
	repend = replacement + uintptr(rlength)

	// Check for using a match that has already happened. Note that the subject
	// pointer in the match data may be NULL after a no-match.

	use_existing_match = libc.Bool32(options&DPCRE2_SUBSTITUTE_MATCHED != uint32(0))
	replacement_only = libc.Bool32(options&DPCRE2_SUBSTITUTE_REPLACEMENT_ONLY != uint32(0))

	// If starting from an existing match, there must be an externally provided
	// match data block. We create an internal match_data block in two cases: (a) an
	// external one is not supplied (and we are not starting from an existing match);
	// (b) an existing match is to be used for the first substitution. In the latter
	// case, we copy the existing match into the internal block, except for any cached
	// heap frame size and pointer. This ensures that no changes are made to the
	// external match data block.

	if !(match_data == uintptr(0)) {
		goto __5
	}

	if !(use_existing_match != 0) {
		goto __7
	}
	return -51
__7:
	;
	if mcontext == uintptr(0) {
		gcontext = code
	} else {
		gcontext = mcontext
	}
	match_data = libc.AssignUintptr(&internal_match_data, Xpcre2_match_data_create_from_pattern_8(tls, code, gcontext))
	if !(internal_match_data == uintptr(0)) {
		goto __8
	}
	return -48
__8:
	;
	goto __6
__5:
	if !(use_existing_match != 0) {
		goto __9
	}

	if mcontext == uintptr(0) {
		gcontext1 = code
	} else {
		gcontext1 = mcontext
	}
	if int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftop_bracket)+1 < int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
		pairs = int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftop_bracket) + 1
	} else {
		pairs = int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)
	}
	internal_match_data = Xpcre2_match_data_create_8(tls, uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount),
		gcontext1)
	if !(internal_match_data == uintptr(0)) {
		goto __10
	}
	return -48
__10:
	;
	libc.Xmemcpy(tls, internal_match_data, match_data, uint64(uintptr(0)+96)+
		uint64(2*pairs)*uint64(unsafe.Sizeof(uint64(0))))
	(*Tpcre2_match_data_8)(unsafe.Pointer(internal_match_data)).Fheapframes = uintptr(0)
	(*Tpcre2_match_data_8)(unsafe.Pointer(internal_match_data)).Fheapframes_size = uint64(0)
	match_data = internal_match_data
__9:
	;
__6:
	;

	// Remember ovector details

	ovector = Xpcre2_get_ovector_pointer_8(tls, match_data)
	ovector_count = Xpcre2_get_ovector_count_8(tls, match_data)

	// Fixed things in the callout block

	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Fversion = uint32(0)
	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Finput = subject
	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Foutput = buffer
	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Fovector = ovector

	// A NULL subject of zero length is treated as an empty string.

	if !(subject == uintptr(0)) {
		goto __11
	}

	if !(length != uint64(0)) {
		goto __12
	}
	return -51
__12:
	;
	subject = ts + 797 /* "" */
__11:
	;

	// Find length of zero-terminated subject

	if !(length == libc.CplUint64(uint64(0))) {
		goto __13
	}
	if subject != 0 {
		length = X_pcre2_strlen_8(tls, subject)
	} else {
		length = uint64(0)
	}
__13:
	;

	// Check UTF replacement string if necessary.

	if !(utf != 0 && options&DPCRE2_NO_UTF_CHECK == uint32(0)) {
		goto __14
	}

	rc = X_pcre2_valid_utf_8(tls, replacement, rlength, match_data+80)
	if !(rc != 0) {
		goto __15
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = uint64(0)
	goto EXIT
__15:
	;
__14:
	;

	// Save the substitute options and remove them from the match options.

	suboptions = options & (DPCRE2_SUBSTITUTE_EXTENDED | DPCRE2_SUBSTITUTE_GLOBAL | DPCRE2_SUBSTITUTE_LITERAL | DPCRE2_SUBSTITUTE_MATCHED | DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH | DPCRE2_SUBSTITUTE_REPLACEMENT_ONLY | DPCRE2_SUBSTITUTE_UNKNOWN_UNSET | DPCRE2_SUBSTITUTE_UNSET_EMPTY)
	options = options & libc.CplUint32(DPCRE2_SUBSTITUTE_EXTENDED|DPCRE2_SUBSTITUTE_GLOBAL|DPCRE2_SUBSTITUTE_LITERAL|DPCRE2_SUBSTITUTE_MATCHED|DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH|DPCRE2_SUBSTITUTE_REPLACEMENT_ONLY|DPCRE2_SUBSTITUTE_UNKNOWN_UNSET|DPCRE2_SUBSTITUTE_UNSET_EMPTY)

	// Error if the start match offset is greater than the length of the subject.

	if !(start_offset > length) {
		goto __16
	}

	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fleftchar = uint64(0)
	rc = -33
	goto EXIT
__16:
	;

	// Copy up to the start offset, unless only the replacement is required.

	if !!(replacement_only != 0) {
		goto __17
	}
	if !(!(overflowed != 0) && lengthleft < start_offset) {
		goto __18
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __20
	}
	goto NOROOM
__20:
	;
	overflowed = DTRUE
	extra_needed = start_offset - lengthleft
	goto __19
__18:
	if !(overflowed != 0) {
		goto __21
	}
	extra_needed = extra_needed + start_offset
	goto __22
__21:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject, start_offset*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + start_offset
	lengthleft = lengthleft - start_offset
__22:
	;
__19:
	;
__17:
	;

	// Loop for global substituting. If PCRE2_SUBSTITUTE_MATCHED is set, the first
	// match is taken from the match_data that was passed in.

	subs = 0
__23:
	ptrstackptr = uint32(0)

	if !(use_existing_match != 0) {
		goto __26
	}

	rc = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
	use_existing_match = DFALSE
	goto __27
__26:
	rc = Xpcre2_match_8(tls, code, subject, length, start_offset, options|goptions,
		match_data, mcontext)
__27:
	;

	if !(utf != 0) {
		goto __28
	}
	options = options | DPCRE2_NO_UTF_CHECK
__28:
	; // Only need to check once

	// Any error other than no match returns the error code. No match when not
	//   doing the special after-empty-match global rematch, or when at the end of the
	//   subject, breaks the global loop. Otherwise, advance the starting point by one
	//   character, copying it to the output, and try again.

	if !(rc < 0) {
		goto __29
	}

	if !(rc != -1) {
		goto __30
	}
	goto EXIT
__30:
	;
	if !(goptions == uint32(0) || start_offset >= length) {
		goto __31
	}
	goto __25
__31:
	;

	// Advance by one code point. Then, if CRLF is a valid newline sequence and
	//     we have advanced into the middle of it, advance one more code point. In
	//     other words, do not start in the middle of CRLF, even if CR and LF on their
	//     own are valid newlines.

	save_start = libc.PostIncUint64(&start_offset, 1)
	if !(int32(*(*uint8)(unsafe.Pointer(subject + uintptr(start_offset-uint64(1))))) == '\015' && int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Fnewline_convention) != DPCRE2_NEWLINE_CR && int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Fnewline_convention) != DPCRE2_NEWLINE_LF && start_offset < length && int32(*(*uint8)(unsafe.Pointer(subject + uintptr(start_offset)))) == '\012') {
		goto __32
	}
	start_offset++
	goto __33
__32:
	if !((*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options&DPCRE2_UTF != uint32(0)) {
		goto __34
	}

__35:
	if !(start_offset < length && int32(*(*uint8)(unsafe.Pointer(subject + uintptr(start_offset))))&0xc0 == 0x80) {
		goto __36
	}
	start_offset++
	goto __35
__36:
	;
__34:
	;
__33:
	;

	// Copy what we have advanced past (unless not required), reset the special
	//     global options, and continue to the next match.

	fraglength = start_offset - save_start
	if !!(replacement_only != 0) {
		goto __37
	}
	if !(!(overflowed != 0) && lengthleft < fraglength) {
		goto __38
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __40
	}
	goto NOROOM
__40:
	;
	overflowed = DTRUE
	extra_needed = fraglength - lengthleft
	goto __39
__38:
	if !(overflowed != 0) {
		goto __41
	}
	extra_needed = extra_needed + fraglength
	goto __42
__41:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject+uintptr(save_start), fraglength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + fraglength
	lengthleft = lengthleft - fraglength
__42:
	;
__39:
	;
__37:
	;

	goptions = uint32(0)
	goto __24
__29:
	;

	// Handle a successful match. Matches that use \K to end before they start
	//   or start before the current point in the subject are not supported.

	if !(*(*uint64)(unsafe.Pointer(ovector + 1*8)) < *(*uint64)(unsafe.Pointer(ovector)) || *(*uint64)(unsafe.Pointer(ovector)) < start_offset) {
		goto __43
	}

	rc = -60
	goto EXIT
__43:
	;

	// Check for the same match as previous. This is legitimate after matching an
	//   empty string that starts after the initial match offset. We have tried again
	//   at the match point in case the pattern is one like /(?<=\G.)/ which can never
	//   match at its starting point, so running the match achieves the bumpalong. If
	//   we do get the same (null) match at the original match point, it isn't such a
	//   pattern, so we now do the empty string magic. In all other cases, a repeat
	//   match should never occur.

	if !(*(*uint64)(unsafe.Pointer(bp)) == *(*uint64)(unsafe.Pointer(ovector)) && *(*uint64)(unsafe.Pointer(bp + 1*8)) == *(*uint64)(unsafe.Pointer(ovector + 1*8))) {
		goto __44
	}

	if !(*(*uint64)(unsafe.Pointer(ovector)) == *(*uint64)(unsafe.Pointer(ovector + 1*8)) && *(*uint64)(unsafe.Pointer(bp + 2*8)) != start_offset) {
		goto __45
	}

	goptions = DPCRE2_NOTEMPTY_ATSTART | DPCRE2_ANCHORED
	*(*uint64)(unsafe.Pointer(bp + 2*8)) = start_offset
	goto __24 // Back to the top of the loop
__45:
	;
	rc = -65
	goto EXIT
__44:
	;

	// Count substitutions with a paranoid check for integer overflow; surely no
	//   real call to this function would ever hit this!

	if !(subs == 0x7fffffff) {
		goto __46
	}

	rc = -61
	goto EXIT
__46:
	;
	subs++

	// Copy the text leading up to the match (unless not required), and remember
	//   where the insert begins and how many ovector pairs are set.

	if !(rc == 0) {
		goto __47
	}
	rc = int32(ovector_count)
__47:
	;
	fraglength = *(*uint64)(unsafe.Pointer(ovector)) - start_offset
	if !!(replacement_only != 0) {
		goto __48
	}
	if !(!(overflowed != 0) && lengthleft < fraglength) {
		goto __49
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __51
	}
	goto NOROOM
__51:
	;
	overflowed = DTRUE
	extra_needed = fraglength - lengthleft
	goto __50
__49:
	if !(overflowed != 0) {
		goto __52
	}
	extra_needed = extra_needed + fraglength
	goto __53
__52:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject+uintptr(start_offset), fraglength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + fraglength
	lengthleft = lengthleft - fraglength
__53:
	;
__50:
	;
__48:
	;

	*(*uint64)(unsafe.Pointer(bp + 24 + 24)) = buff_offset
	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Foveccount = uint32(rc)

	// Process the replacement string. If the entire replacement is literal, just
	//   copy it with length check.

	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) = replacement
	if !(suboptions&DPCRE2_SUBSTITUTE_LITERAL != uint32(0)) {
		goto __54
	}

	if !(!(overflowed != 0) && lengthleft < rlength) {
		goto __56
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __58
	}
	goto NOROOM
__58:
	;
	overflowed = DTRUE
	extra_needed = rlength - lengthleft
	goto __57
__56:
	if !(overflowed != 0) {
		goto __59
	}
	extra_needed = extra_needed + rlength
	goto __60
__59:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), *(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)), rlength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + rlength
	lengthleft = lengthleft - rlength
__60:
	;
__57:
	;

	goto __55
__54:
__61:

	// If at the end of a nested substring, pop the stack.

	if !(*(*uintptr)(unsafe.Pointer(bp + 280)) >= repend) {
		goto __64
	}

	if !(ptrstackptr == uint32(0)) {
		goto __65
	}
	goto __63
__65:
	; // End of replacement string
	repend = *(*uintptr)(unsafe.Pointer(bp + 80 + uintptr(libc.PreDecUint32(&ptrstackptr, 1))*8))
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) = *(*uintptr)(unsafe.Pointer(bp + 80 + uintptr(libc.PreDecUint32(&ptrstackptr, 1))*8))
	goto __62
__64:
	;

	// Handle the next character

	if !(escaped_literal != 0) {
		goto __66
	}

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280))))) == '\134' && *(*uintptr)(unsafe.Pointer(bp + 280)) < repend-uintptr(1) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 1))) == '\105') {
		goto __67
	}

	escaped_literal = DFALSE
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62
__67:
	;
	goto LOADLITERAL
__66:
	;

	// Not in literal mode.

	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280))))) == '\044') {
		goto __68
	}
	special = uint32(0)
	text1_start = uintptr(0)
	text1_end = uintptr(0)
	text2_start = uintptr(0)
	text2_end = uintptr(0)

	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280)), 1) >= repend) {
		goto __70
	}
	goto BAD
__70:
	;
	if !(int32(libc.AssignUint8(&next, *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))))) == '\044') {
		goto __71
	}
	goto LOADLITERAL
__71:
	;

	group = -1
	n = 0
	inparens = DFALSE
	star = DFALSE

	if !(int32(next) == '\173') {
		goto __72
	}

	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280)), 1) >= repend) {
		goto __73
	}
	goto BAD
__73:
	;
	next = *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))))
	inparens = DTRUE
__72:
	;

	if !(int32(next) == '\052') {
		goto __74
	}

	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280)), 1) >= repend) {
		goto __75
	}
	goto BAD
__75:
	;
	next = *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))))
	star = DTRUE
__74:
	;

	if !(!(star != 0) && int32(next) >= '\060' && int32(next) <= '\071') {
		goto __76
	}

	group = int32(next) - '\060'
__78:
	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280)), 1) < repend) {
		goto __79
	}

	next = *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))))
	if !(int32(next) < '\060' || int32(next) > '\071') {
		goto __80
	}
	goto __79
__80:
	;
	group = group*10 + int32(next) - '\060'

	// A check for a number greater than the hightest captured group
	//           is sufficient here; no need for a separate overflow check. If unknown
	//           groups are to be treated as unset, just skip over any remaining
	//           digits and carry on.

	if !(group > int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftop_bracket)) {
		goto __81
	}

	if !(suboptions&DPCRE2_SUBSTITUTE_UNKNOWN_UNSET != uint32(0)) {
		goto __82
	}

__84:
	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280)), 1) < repend && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280))))) >= '\060' && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280))))) <= '\071') {
		goto __85
	}
	goto __84
__85:
	;
	goto __79
	goto __83
__82:

	rc = -49
	goto PTREXIT
__83:
	;
__81:
	;
	goto __78
__79:
	;
	goto __77
__76:

	ctypes = (*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset+Dcbit_length)
__86:
	if !(1 != 0 && int32(*(*uint8)(unsafe.Pointer(ctypes + uintptr(next))))&Dctype_word != 0) {
		goto __87
	}

	*(*uint8)(unsafe.Pointer(bp + 240 + uintptr(libc.PostIncInt32(&n, 1)))) = next
	if !(n > 32) {
		goto __88
	}
	goto BAD
__88:
	;
	if !(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280)), 1) >= repend) {
		goto __89
	}
	goto __87
__89:
	;
	next = *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))))
	goto __86
__87:
	;
	if !(n == 0) {
		goto __90
	}
	goto BAD
__90:
	;
	*(*uint8)(unsafe.Pointer(bp + 240 + uintptr(n))) = uint8(0)
__77:
	;

	// In extended mode we recognize ${name:+set text:unset text} and
	//       ${name:-default text}.

	if !(inparens != 0) {
		goto __91
	}

	if !(suboptions&DPCRE2_SUBSTITUTE_EXTENDED != uint32(0) && !(star != 0) && *(*uintptr)(unsafe.Pointer(bp + 280)) < repend-uintptr(2) && int32(next) == '\072') {
		goto __92
	}

	special = uint32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280)), 1))))
	if !(special != uint32('\053') && special != uint32('\055')) {
		goto __94
	}

	rc = -59
	goto PTREXIT
__94:
	;

	text1_start = libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)), 1)
	rc = find_text_end(tls, code, bp+280, repend, libc.Bool32(special == uint32('\055')))
	if !(rc != 0) {
		goto __95
	}
	goto PTREXIT
__95:
	;
	text1_end = *(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))

	if !(special == uint32('\053') && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280))))) == '\072') {
		goto __96
	}

	text2_start = libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)), 1)
	rc = find_text_end(tls, code, bp+280, repend, DTRUE)
	if !(rc != 0) {
		goto __97
	}
	goto PTREXIT
__97:
	;
	text2_end = *(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))
__96:
	;
	goto __93
__92:

	if !(*(*uintptr)(unsafe.Pointer(bp + 280)) >= repend || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280))))) != '\175') {
		goto __98
	}

	rc = -58
	goto PTREXIT
__98:
	;
__93:
	;

	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))++
__91:
	;

	// Have found a syntactically correct group number or name, or *name.
	//       Only *MARK is currently recognized.

	if !(star != 0) {
		goto __99
	}

	if !(X_pcre2_strcmp_c8_8(tls, bp+240, ts+7678) == 0) {
		goto __101
	}

	mark = Xpcre2_get_mark_8(tls, match_data)
	if !(mark != uintptr(0)) {
		goto __103
	}

	mark_start = mark
__104:
	if !(int32(*(*uint8)(unsafe.Pointer(mark))) != 0) {
		goto __105
	}
	mark++
	goto __104
__105:
	;
	fraglength = uint64((int64(mark) - int64(mark_start)) / 1)
	if !(!(overflowed != 0) && lengthleft < fraglength) {
		goto __106
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __108
	}
	goto NOROOM
__108:
	;
	overflowed = DTRUE
	extra_needed = fraglength - lengthleft
	goto __107
__106:
	if !(overflowed != 0) {
		goto __109
	}
	extra_needed = extra_needed + fraglength
	goto __110
__109:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), mark_start, fraglength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + fraglength
	lengthleft = lengthleft - fraglength
__110:
	;
__107:
	;

__103:
	;
	goto __102
__101:
	goto BAD
__102:
	;
	goto __100
__99:

	// Find a number for a named group. In case there are duplicate names,
	//         search for the first one that is set. If the name is not found when
	//         PCRE2_SUBSTITUTE_UNKNOWN_EMPTY is set, set the group number to a
	//         non-existent group.

	if !(group < 0) {
		goto __111
	}

	rc = Xpcre2_substring_nametable_scan_8(tls, code, bp+240, bp+288, bp+296)
	if !(rc == -49 && suboptions&DPCRE2_SUBSTITUTE_UNKNOWN_UNSET != uint32(0)) {
		goto __112
	}

	group = int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftop_bracket) + 1
	goto __113
__112:

	if !(rc < 0) {
		goto __114
	}
	goto PTREXIT
__114:
	;
	entry = *(*uintptr)(unsafe.Pointer(bp + 288 /* first */))
__115:
	if !(entry <= *(*uintptr)(unsafe.Pointer(bp + 296))) {
		goto __117
	}

	ng = uint32(int32(*(*uint8)(unsafe.Pointer(entry)))<<8 | int32(*(*uint8)(unsafe.Pointer(entry + 1))))
	if !(ng < ovector_count) {
		goto __118
	}

	if !(group < 0) {
		goto __119
	}
	group = int32(ng)
__119:
	; // First in ovector
	if !(*(*uint64)(unsafe.Pointer(ovector + uintptr(ng*uint32(2))*8)) != libc.CplUint64(uint64(0))) {
		goto __120
	}

	group = int32(ng) // First that is set
	goto __117
__120:
	;
__118:
	;
	goto __116
__116:
	entry += uintptr(rc)
	goto __115
	goto __117
__117:
	;

	// If group is still negative, it means we did not find a group
	//             that is in the ovector. Just set the first group.

	if !(group < 0) {
		goto __121
	}
	group = int32(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288)))))<<8 | int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288)) + 1)))))
__121:
	;
__113:
	;
__111:
	;

	// We now have a group that is identified by number. Find the length of
	//         the captured string. If a group in a non-special substitution is unset
	//         when PCRE2_SUBSTITUTE_UNSET_EMPTY is set, substitute nothing.

	rc = Xpcre2_substring_length_bynumber_8(tls, match_data, uint32(group), bp+304)
	if !(rc < 0) {
		goto __122
	}

	if !(rc == -49 && suboptions&DPCRE2_SUBSTITUTE_UNKNOWN_UNSET != uint32(0)) {
		goto __123
	}

	rc = -55
__123:
	;
	if !(rc != -55) {
		goto __124
	}
	goto PTREXIT
__124:
	; // Non-unset errors
	if !(special == uint32(0)) {
		goto __125
	} /* Plain substitution */

	if !(suboptions&DPCRE2_SUBSTITUTE_UNSET_EMPTY != uint32(0)) {
		goto __126
	}
	goto __62
__126:
	;
	goto PTREXIT // Else error
__125:
	;
__122:
	;

	// If special is '+' we have a 'set' and possibly an 'unset' text,
	//         both of which are reprocessed when used. If special is '-' we have a
	//         default text for when the group is unset; it must be reprocessed.

	if !(special != uint32(0)) {
		goto __127
	}

	if !(special == uint32('\055')) {
		goto __128
	}

	if !(rc == 0) {
		goto __129
	}
	goto LITERAL_SUBSTITUTE
__129:
	;
	text2_start = text1_start
	text2_end = text1_end
__128:
	;

	if !(ptrstackptr >= uint32(DPTR_STACK_SIZE)) {
		goto __130
	}
	goto BAD
__130:
	;
	*(*uintptr)(unsafe.Pointer(bp + 80 + uintptr(libc.PostIncUint32(&ptrstackptr, 1))*8)) = *(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))
	*(*uintptr)(unsafe.Pointer(bp + 80 + uintptr(libc.PostIncUint32(&ptrstackptr, 1))*8)) = repend

	if !(rc == 0) {
		goto __131
	}

	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) = text1_start
	repend = text1_end
	goto __132
__131:

	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) = text2_start
	repend = text2_end
__132:
	;
	goto __62
__127:
	;

	// Otherwise we have a literal substitution of a group's contents.

LITERAL_SUBSTITUTE:
	subptr = subject + uintptr(*(*uint64)(unsafe.Pointer(ovector + uintptr(group*2)*8)))
	subptrend = subject + uintptr(*(*uint64)(unsafe.Pointer(ovector + uintptr(group*2+1)*8)))

	// Substitute a literal string, possibly forcing alphabetic case.

__133:
	if !(subptr < subptrend) {
		goto __134
	}

	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&subptr, 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(bp + 320)) >= 0xc0) {
		goto __135
	}
	if !(*(*uint32)(unsafe.Pointer(bp + 320))&0x20 == uint32(0)) {
		goto __136
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&subptr, 1))))&0x3f
	goto __137
__136:
	if !(*(*uint32)(unsafe.Pointer(bp + 320))&0x10 == uint32(0)) {
		goto __138
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(subptr)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(subptr + 1)))&0x3f
	subptr += uintptr(2)
	goto __139
__138:
	if !(*(*uint32)(unsafe.Pointer(bp + 320))&0x08 == uint32(0)) {
		goto __140
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(subptr)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(subptr + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(subptr + 2)))&0x3f
	subptr += uintptr(3)
	goto __141
__140:
	if !(*(*uint32)(unsafe.Pointer(bp + 320))&0x04 == uint32(0)) {
		goto __142
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(subptr)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(subptr + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(subptr + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(subptr + 3)))&0x3f
	subptr += uintptr(4)
	goto __143
__142:
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(subptr)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(subptr + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(subptr + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(subptr + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(subptr + 4)))&0x3f
	subptr += uintptr(5)
__143:
	;
__141:
	;
__139:
	;
__137:
	;
__135:
	;

	if !(forcecase != 0) {
		goto __144
	}

	if !(utf != 0 || ucp != 0) {
		goto __145
	}

	type1 = uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*uint32)(unsafe.Pointer(bp + 320)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*uint32)(unsafe.Pointer(bp + 320)))%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(X_pcre2_ucp_gentype_8[type1] == ucp_L && type1 != func() uint32 {
		if forcecase > 0 {
			return ucp_Lu
		}
		return ucp_Ll
	}()) {
		goto __147
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = uint32(int32(*(*uint32)(unsafe.Pointer(bp + 320))) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*uint32)(unsafe.Pointer(bp + 320)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*uint32)(unsafe.Pointer(bp + 320)))%DUCD_BLOCK_SIZE])*12)).Fother_case)
__147:
	;
	goto __146
__145:

	if !(uint32(*(*uint8)(unsafe.Pointer((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset) + uintptr(func() int32 {
		if forcecase > 0 {
			return Dcbit_upper
		}
		return Dcbit_lower
	}()) + uintptr(*(*uint32)(unsafe.Pointer(bp + 320))/uint32(8)))))&(uint32(1)<<(*(*uint32)(unsafe.Pointer(bp + 320))%uint32(8))) == uint32(0)) {
		goto __148
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = uint32(*(*uint8)(unsafe.Pointer((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dfcc_offset) + uintptr(*(*uint32)(unsafe.Pointer(bp + 320 /* ch */))))))
__148:
	;
__146:
	;
	forcecase = forcecasereset
__144:
	;

	if !(utf != 0) {
		goto __149
	}
	chlen = X_pcre2_ord2utf_8(tls, *(*uint32)(unsafe.Pointer(bp + 320 /* ch */)), bp+312)
	goto __150
__149:

	*(*uint8)(unsafe.Pointer(bp + 312)) = uint8(*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)))
	chlen = uint32(1)
__150:
	;
	if !(!(overflowed != 0) && lengthleft < uint64(chlen)) {
		goto __151
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __153
	}
	goto NOROOM
__153:
	;
	overflowed = DTRUE
	extra_needed = uint64(chlen) - lengthleft
	goto __152
__151:
	if !(overflowed != 0) {
		goto __154
	}
	extra_needed = extra_needed + uint64(chlen)
	goto __155
__154:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), bp+312, uint64(chlen*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
	buff_offset = buff_offset + uint64(chlen)
	lengthleft = lengthleft - uint64(chlen)
__155:
	;
__152:
	;

	goto __133
__134:
	;
__100:
	;
	goto __69
__68:
	if !(suboptions&DPCRE2_SUBSTITUTE_EXTENDED != uint32(0) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280))))) == '\134') {
		goto __156
	}

	if !(*(*uintptr)(unsafe.Pointer(bp + 280)) < repend-uintptr(1)) {
		goto __158
	}
	switch int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) + 1))) {
	case '\114':
		goto __160

	case '\154':
		goto __161

	case '\125':
		goto __162

	case '\165':
		goto __163

	default:
		goto __164
	}
	goto __159

__160:
	forcecase = libc.AssignInt32(&forcecasereset, -1)
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62

__161:
	forcecase = -1
	forcecasereset = 0
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62

__162:
	forcecase = libc.AssignInt32(&forcecasereset, 1)
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62

__163:
	forcecase = 1
	forcecasereset = 0
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __62

__164:
	goto __159
__159:
	;
__158:
	;

	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */))++ // Point after \
	rc = X_pcre2_check_escape_8(tls, bp+280, repend, bp+320, bp+324,
		(*Tpcre2_code_8)(unsafe.Pointer(code)).Foverall_options, (*Tpcre2_code_8)(unsafe.Pointer(code)).Fextra_options, DFALSE, uintptr(0))
	if !(*(*int32)(unsafe.Pointer(bp + 324)) != 0) {
		goto __165
	}
	goto BADESCAPE
__165:
	;

	switch rc {
	case ESC_E:
		goto __167

	case ESC_Q:
		goto __168

	case 0:
		goto __169

	default:
		goto __170
	}
	goto __166

__167:
	forcecase = libc.AssignInt32(&forcecasereset, 0)
	goto __62

__168:
	escaped_literal = DTRUE
	goto __62

__169: // Data character
	goto LITERAL

__170:
	goto BADESCAPE
__166:
	;
	goto __157
__156:

LOADLITERAL:
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)), 1))))
	if !(utf != 0 && *(*uint32)(unsafe.Pointer(bp + 320)) >= 0xc0) {
		goto __171
	}
	if !(*(*uint32)(unsafe.Pointer(bp + 320))&0x20 == uint32(0)) {
		goto __172
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 280)), 1))))&0x3f
	goto __173
__172:
	if !(*(*uint32)(unsafe.Pointer(bp + 320))&0x10 == uint32(0)) {
		goto __174
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 1)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(2)
	goto __175
__174:
	if !(*(*uint32)(unsafe.Pointer(bp + 320))&0x08 == uint32(0)) {
		goto __176
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 2)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(3)
	goto __177
__176:
	if !(*(*uint32)(unsafe.Pointer(bp + 320))&0x04 == uint32(0)) {
		goto __178
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 3)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(4)
	goto __179
__178:
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = *(*uint32)(unsafe.Pointer(bp + 320))&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)))))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 280)) + 4)))&0x3f
	*(*uintptr)(unsafe.Pointer(bp + 280 /* ptr */)) += uintptr(5)
__179:
	;
__177:
	;
__175:
	;
__173:
	;
__171:
	;

	// Get character value, increment pointer

LITERAL:
	if !(forcecase != 0) {
		goto __180
	}

	if !(utf != 0 || ucp != 0) {
		goto __181
	}

	type2 = uint32((*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*uint32)(unsafe.Pointer(bp + 320)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*uint32)(unsafe.Pointer(bp + 320)))%DUCD_BLOCK_SIZE])*12)).Fchartype)
	if !(X_pcre2_ucp_gentype_8[type2] == ucp_L && type2 != func() uint32 {
		if forcecase > 0 {
			return ucp_Lu
		}
		return ucp_Ll
	}()) {
		goto __183
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = uint32(int32(*(*uint32)(unsafe.Pointer(bp + 320))) + (*Tucd_record)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8))+uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(*(*uint32)(unsafe.Pointer(bp + 320)))/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(*(*uint32)(unsafe.Pointer(bp + 320)))%DUCD_BLOCK_SIZE])*12)).Fother_case)
__183:
	;
	goto __182
__181:

	if !(uint32(*(*uint8)(unsafe.Pointer((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dcbits_offset) + uintptr(func() int32 {
		if forcecase > 0 {
			return Dcbit_upper
		}
		return Dcbit_lower
	}()) + uintptr(*(*uint32)(unsafe.Pointer(bp + 320))/uint32(8)))))&(uint32(1)<<(*(*uint32)(unsafe.Pointer(bp + 320))%uint32(8))) == uint32(0)) {
		goto __184
	}
	*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)) = uint32(*(*uint8)(unsafe.Pointer((*Tpcre2_code_8)(unsafe.Pointer(code)).Ftables + uintptr(Dfcc_offset) + uintptr(*(*uint32)(unsafe.Pointer(bp + 320 /* ch */))))))
__184:
	;
__182:
	;
	forcecase = forcecasereset
__180:
	;

	if !(utf != 0) {
		goto __185
	}
	chlen = X_pcre2_ord2utf_8(tls, *(*uint32)(unsafe.Pointer(bp + 320 /* ch */)), bp+312)
	goto __186
__185:

	*(*uint8)(unsafe.Pointer(bp + 312)) = uint8(*(*uint32)(unsafe.Pointer(bp + 320 /* ch */)))
	chlen = uint32(1)
__186:
	;
	if !(!(overflowed != 0) && lengthleft < uint64(chlen)) {
		goto __187
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __189
	}
	goto NOROOM
__189:
	;
	overflowed = DTRUE
	extra_needed = uint64(chlen) - lengthleft
	goto __188
__187:
	if !(overflowed != 0) {
		goto __190
	}
	extra_needed = extra_needed + uint64(chlen)
	goto __191
__190:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), bp+312, uint64(chlen*uint32(DPCRE2_CODE_UNIT_WIDTH/8)))
	buff_offset = buff_offset + uint64(chlen)
	lengthleft = lengthleft - uint64(chlen)
__191:
	;
__188:
	;

__157:
	;
__69:
	; // End handling a literal code unit
	goto __62
__62:
	goto __61
	goto __63
__63:
	;
__55:
	; // End of loop for scanning the replacement.

	// The replacement has been copied to the output, or its size has been
	//   remembered. Do the callout if there is one and we have done an actual
	//   replacement.

	if !(!(overflowed != 0) && mcontext != uintptr(0) && (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout != uintptr(0)) {
		goto __192
	}

	(*Tpcre2_substitute_callout_block_8)(unsafe.Pointer(bp + 24 /* &scb */)).Fsubscount = uint32(subs)
	*(*uint64)(unsafe.Pointer(bp + 24 + 24 + 1*8)) = buff_offset
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout})).f(tls, bp+24 /* &scb */, (*Tpcre2_match_context_8)(unsafe.Pointer(mcontext)).Fsubstitute_callout_data)

	// A non-zero return means cancel this substitution. Instead, copy the
	//     matched string fragment.

	if !(rc != 0) {
		goto __193
	}

	newlength = *(*uint64)(unsafe.Pointer(bp + 24 + 24 + 1*8)) - *(*uint64)(unsafe.Pointer(bp + 24 + 24))
	oldlength = *(*uint64)(unsafe.Pointer(ovector + 1*8)) - *(*uint64)(unsafe.Pointer(ovector))

	buff_offset = buff_offset - newlength
	lengthleft = lengthleft + newlength
	if !!(replacement_only != 0) {
		goto __194
	}
	if !(!(overflowed != 0) && lengthleft < oldlength) {
		goto __195
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __197
	}
	goto NOROOM
__197:
	;
	overflowed = DTRUE
	extra_needed = oldlength - lengthleft
	goto __196
__195:
	if !(overflowed != 0) {
		goto __198
	}
	extra_needed = extra_needed + oldlength
	goto __199
__198:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject+uintptr(*(*uint64)(unsafe.Pointer(ovector))), oldlength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + oldlength
	lengthleft = lengthleft - oldlength
__199:
	;
__196:
	;
__194:
	;

	// A negative return means do not do any more.

	if !(rc < 0) {
		goto __200
	}
	suboptions = suboptions & libc.CplUint32(DPCRE2_SUBSTITUTE_GLOBAL)
__200:
	;
__193:
	;
__192:
	;

	// Save the details of this match. See above for how this data is used. If we
	//   matched an empty string, do the magic for global matches. Update the start
	//   offset to point to the rest of the subject string. If we re-used an existing
	//   match for the first match, switch to the internal match data block.

	*(*uint64)(unsafe.Pointer(bp)) = *(*uint64)(unsafe.Pointer(ovector))
	*(*uint64)(unsafe.Pointer(bp + 1*8)) = *(*uint64)(unsafe.Pointer(ovector + 1*8))
	*(*uint64)(unsafe.Pointer(bp + 2*8)) = start_offset

	if *(*uint64)(unsafe.Pointer(ovector)) != *(*uint64)(unsafe.Pointer(ovector + 1*8)) || *(*uint64)(unsafe.Pointer(ovector)) > start_offset {
		goptions = uint32(0)
	} else {
		goptions = DPCRE2_ANCHORED | DPCRE2_NOTEMPTY_ATSTART
	}
	start_offset = *(*uint64)(unsafe.Pointer(ovector + 1*8))
	goto __24
__24:
	if suboptions&DPCRE2_SUBSTITUTE_GLOBAL != uint32(0) {
		goto __23
	}
	goto __25
__25:
	; // Repeat "do" loop

	// Copy the rest of the subject unless not required, and terminate the output
	// with a binary zero.

	if !!(replacement_only != 0) {
		goto __201
	}

	fraglength = length - start_offset
	if !(!(overflowed != 0) && lengthleft < fraglength) {
		goto __202
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __204
	}
	goto NOROOM
__204:
	;
	overflowed = DTRUE
	extra_needed = fraglength - lengthleft
	goto __203
__202:
	if !(overflowed != 0) {
		goto __205
	}
	extra_needed = extra_needed + fraglength
	goto __206
__205:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), subject+uintptr(start_offset), fraglength*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	buff_offset = buff_offset + fraglength
	lengthleft = lengthleft - fraglength
__206:
	;
__203:
	;

__201:
	;

	*(*uint8)(unsafe.Pointer(bp + 312)) = uint8(0)
	if !(!(overflowed != 0) && lengthleft < uint64(1)) {
		goto __207
	}
	if !(suboptions&DPCRE2_SUBSTITUTE_OVERFLOW_LENGTH == uint32(0)) {
		goto __209
	}
	goto NOROOM
__209:
	;
	overflowed = DTRUE
	extra_needed = uint64(1) - lengthleft
	goto __208
__207:
	if !(overflowed != 0) {
		goto __210
	}
	extra_needed = extra_needed + uint64(1)
	goto __211
__210:
	libc.Xmemcpy(tls, buffer+uintptr(buff_offset), bp+312, uint64(1*(DPCRE2_CODE_UNIT_WIDTH/8)))
	buff_offset = buff_offset + uint64(1)
	lengthleft = lengthleft - uint64(1)
__211:
	;
__208:
	;

	// If overflowed is set it means the PCRE2_SUBSTITUTE_OVERFLOW_LENGTH is set,
	// and matching has carried on after a full buffer, in order to compute the length
	// needed. Otherwise, an overflow generates an immediate error return.

	if !(overflowed != 0) {
		goto __212
	}

	rc = -48
	*(*uint64)(unsafe.Pointer(blength)) = buff_length + extra_needed
	goto __213
__212:

	rc = subs
	*(*uint64)(unsafe.Pointer(blength)) = buff_offset - uint64(1)
__213:
	;

EXIT:
	if !(internal_match_data != uintptr(0)) {
		goto __214
	}
	Xpcre2_match_data_free_8(tls, internal_match_data)
	goto __215
__214:
	(*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc = rc
__215:
	;
	return rc

NOROOM:
	rc = -48
	goto EXIT

BAD:
	rc = -35
	goto PTREXIT

BADESCAPE:
	rc = -57

PTREXIT:
	*(*uint64)(unsafe.Pointer(blength)) = uint64((int64(*(*uintptr)(unsafe.Pointer(bp + 280))) - int64(replacement)) / 1)
	goto EXIT
	return int32(0)
}

// End of pcre2_substitute.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//   Copy named captured string to given buffer   *
//

// This function copies a single captured substring into a given buffer,
// identifying it by name. If the regex permits duplicate names, the first
// substring that is set is chosen.
//
// Arguments:
//   match_data     points to the match data
//   stringname     the name of the required substring
//   buffer         where to put the substring
//   sizeptr        the size of the buffer, updated to the size of the substring
//
// Returns:         if successful: zero
//                  if not successful, a negative error code:
//                    (1) an error from nametable_scan()
//                    (2) an error from copy_bynumber()
//                    (3) PCRE2_ERROR_UNAVAILABLE: no group is in ovector
//                    (4) PCRE2_ERROR_UNSET: all named groups in ovector are unset

func Xpcre2_substring_copy_byname_8(tls *libc.TLS, match_data uintptr, stringname uintptr, buffer uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:73:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var first uintptr at bp, 8

	// var last uintptr at bp+8, 8

	var entry uintptr
	var failrc int32
	var entrysize int32
	if int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby) == PCRE2_MATCHEDBY_DFA_INTERPRETER {
		return -41
	}
	entrysize = Xpcre2_substring_nametable_scan_8(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode, stringname,
		bp, bp+8)
	if entrysize < 0 {
		return entrysize
	}
	failrc = -54
	for entry = *(*uintptr)(unsafe.Pointer(bp /* first */)); entry <= *(*uintptr)(unsafe.Pointer(bp + 8 /* last */)); entry += uintptr(entrysize) {
		var n uint32 = uint32(int32(*(*uint8)(unsafe.Pointer(entry)))<<8 | int32(*(*uint8)(unsafe.Pointer(entry + 1))))
		if n < uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			if *(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(n*uint32(2))*8)) != libc.CplUint64(uint64(0)) {
				return Xpcre2_substring_copy_bynumber_8(tls, match_data, n, buffer, sizeptr)
			}
			failrc = -55
		}
	}
	return failrc
}

// ************************************************
//
//  Copy numbered captured string to given buffer *
//

// This function copies a single captured substring into a given buffer,
// identifying it by number.
//
// Arguments:
//   match_data     points to the match data
//   stringnumber   the number of the required substring
//   buffer         where to put the substring
//   sizeptr        the size of the buffer, updated to the size of the substring
//
// Returns:         if successful: 0
//                  if not successful, a negative error code:
//                    PCRE2_ERROR_NOMEMORY: buffer too small
//                    PCRE2_ERROR_NOSUBSTRING: no such substring
//                    PCRE2_ERROR_UNAVAILABLE: ovector too small
//                    PCRE2_ERROR_UNSET: substring is not set

func Xpcre2_substring_copy_bynumber_8(tls *libc.TLS, match_data uintptr, stringnumber uint32, buffer uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:121:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var size uint64 at bp, 8

	rc = Xpcre2_substring_length_bynumber_8(tls, match_data, stringnumber, bp)
	if rc < 0 {
		return rc
	}
	if *(*uint64)(unsafe.Pointer(bp))+uint64(1) > *(*uint64)(unsafe.Pointer(sizeptr)) {
		return -48
	}
	libc.Xmemcpy(tls, buffer, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject+uintptr(*(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(stringnumber*uint32(2))*8))),
		*(*uint64)(unsafe.Pointer(bp))*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	*(*uint8)(unsafe.Pointer(buffer + uintptr(*(*uint64)(unsafe.Pointer(bp /* size */))))) = uint8(0)
	*(*uint64)(unsafe.Pointer(sizeptr)) = *(*uint64)(unsafe.Pointer(bp /* size */))
	return 0
}

// ************************************************
//
//          Extract named captured string         *
//

// This function copies a single captured substring, identified by name, into
// new memory. If the regex permits duplicate names, the first substring that is
// set is chosen.
//
// Arguments:
//   match_data     pointer to match_data
//   stringname     the name of the required substring
//   stringptr      where to put the pointer to the new memory
//   sizeptr        where to put the length of the substring
//
// Returns:         if successful: zero
//                  if not successful, a negative value:
//                    (1) an error from nametable_scan()
//                    (2) an error from get_bynumber()
//                    (3) PCRE2_ERROR_UNAVAILABLE: no group is in ovector
//                    (4) PCRE2_ERROR_UNSET: all named groups in ovector are unset

func Xpcre2_substring_get_byname_8(tls *libc.TLS, match_data uintptr, stringname uintptr, stringptr uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:161:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var first uintptr at bp, 8

	// var last uintptr at bp+8, 8

	var entry uintptr
	var failrc int32
	var entrysize int32
	if int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby) == PCRE2_MATCHEDBY_DFA_INTERPRETER {
		return -41
	}
	entrysize = Xpcre2_substring_nametable_scan_8(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode, stringname,
		bp, bp+8)
	if entrysize < 0 {
		return entrysize
	}
	failrc = -54
	for entry = *(*uintptr)(unsafe.Pointer(bp /* first */)); entry <= *(*uintptr)(unsafe.Pointer(bp + 8 /* last */)); entry += uintptr(entrysize) {
		var n uint32 = uint32(int32(*(*uint8)(unsafe.Pointer(entry)))<<8 | int32(*(*uint8)(unsafe.Pointer(entry + 1))))
		if n < uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			if *(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(n*uint32(2))*8)) != libc.CplUint64(uint64(0)) {
				return Xpcre2_substring_get_bynumber_8(tls, match_data, n, stringptr, sizeptr)
			}
			failrc = -55
		}
	}
	return failrc
}

// ************************************************
//
//      Extract captured string to new memory     *
//

// This function copies a single captured substring into a piece of new
// memory.
//
// Arguments:
//   match_data     points to match data
//   stringnumber   the number of the required substring
//   stringptr      where to put a pointer to the new memory
//   sizeptr        where to put the size of the substring
//
// Returns:         if successful: 0
//                  if not successful, a negative error code:
//                    PCRE2_ERROR_NOMEMORY: failed to get memory
//                    PCRE2_ERROR_NOSUBSTRING: no such substring
//                    PCRE2_ERROR_UNAVAILABLE: ovector too small
//                    PCRE2_ERROR_UNSET: substring is not set

func Xpcre2_substring_get_bynumber_8(tls *libc.TLS, match_data uintptr, stringnumber uint32, stringptr uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:209:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var size uint64 at bp, 8

	var yield uintptr
	rc = Xpcre2_substring_length_bynumber_8(tls, match_data, stringnumber, bp)
	if rc < 0 {
		return rc
	}
	yield = X_pcre2_memctl_malloc_8(tls, uint64(unsafe.Sizeof(Tpcre2_memctl{}))+(*(*uint64)(unsafe.Pointer(bp))+uint64(1))*uint64(DPCRE2_CODE_UNIT_WIDTH), match_data)
	if yield == uintptr(0) {
		return -48
	}
	yield = yield + uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
	libc.Xmemcpy(tls, yield, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject+uintptr(*(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(stringnumber*uint32(2))*8))),
		*(*uint64)(unsafe.Pointer(bp))*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
	*(*uint8)(unsafe.Pointer(yield + uintptr(*(*uint64)(unsafe.Pointer(bp /* size */))))) = uint8(0)
	*(*uintptr)(unsafe.Pointer(stringptr)) = yield
	*(*uint64)(unsafe.Pointer(sizeptr)) = *(*uint64)(unsafe.Pointer(bp /* size */))
	return 0
}

// ************************************************
//
//       Free memory obtained by get_substring    *
//

//
// Argument:     the result of a previous pcre2_substring_get_byxxx()
// Returns:      nothing

func Xpcre2_substring_free_8(tls *libc.TLS, string uintptr) { /* pcre2_substring.c:241:1: */
	if string != uintptr(0) {
		var memctl uintptr = string - uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, memctl, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
}

// ************************************************
//
//         Get length of a named substring        *
//

// This function returns the length of a named captured substring. If the regex
// permits duplicate names, the first substring that is set is chosen.
//
// Arguments:
//   match_data      pointer to match data
//   stringname      the name of the required substring
//   sizeptr         where to put the length
//
// Returns:          0 if successful, else a negative error number

func Xpcre2_substring_length_byname_8(tls *libc.TLS, match_data uintptr, stringname uintptr, sizeptr uintptr) int32 { /* pcre2_substring.c:268:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var first uintptr at bp, 8

	// var last uintptr at bp+8, 8

	var entry uintptr
	var failrc int32
	var entrysize int32
	if int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby) == PCRE2_MATCHEDBY_DFA_INTERPRETER {
		return -41
	}
	entrysize = Xpcre2_substring_nametable_scan_8(tls, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode, stringname,
		bp, bp+8)
	if entrysize < 0 {
		return entrysize
	}
	failrc = -54
	for entry = *(*uintptr)(unsafe.Pointer(bp /* first */)); entry <= *(*uintptr)(unsafe.Pointer(bp + 8 /* last */)); entry += uintptr(entrysize) {
		var n uint32 = uint32(int32(*(*uint8)(unsafe.Pointer(entry)))<<8 | int32(*(*uint8)(unsafe.Pointer(entry + 1))))
		if n < uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			if *(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(n*uint32(2))*8)) != libc.CplUint64(uint64(0)) {
				return Xpcre2_substring_length_bynumber_8(tls, match_data, n, sizeptr)
			}
			failrc = -55
		}
	}
	return failrc
}

// ************************************************
//
//        Get length of a numbered substring      *
//

// This function returns the length of a captured substring. If the start is
// beyond the end (which can happen when \K is used in an assertion), it sets the
// length to zero.
//
// Arguments:
//   match_data      pointer to match data
//   stringnumber    the number of the required substring
//   sizeptr         where to put the length, if not NULL
//
// Returns:         if successful: 0
//                  if not successful, a negative error code:
//                    PCRE2_ERROR_NOSUBSTRING: no such substring
//                    PCRE2_ERROR_UNAVAILABLE: ovector is too small
//                    PCRE2_ERROR_UNSET: substring is not set

func Xpcre2_substring_length_bynumber_8(tls *libc.TLS, match_data uintptr, stringnumber uint32, sizeptr uintptr) int32 { /* pcre2_substring.c:315:1: */
	var left uint64
	var right uint64
	var count int32 = (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc
	if count == -2 {
		if stringnumber > uint32(0) {
			return -2
		}
		count = 0
	} else if count < 0 {
		return count
	} // Match failed

	if int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fmatchedby) != PCRE2_MATCHEDBY_DFA_INTERPRETER {
		if stringnumber > uint32((*Tpcre2_real_code_8)(unsafe.Pointer((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fcode)).Ftop_bracket) {
			return -49
		}
		if stringnumber >= uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			return -54
		}
		if *(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(stringnumber*uint32(2))*8)) == libc.CplUint64(uint64(0)) {
			return -55
		}
	} else {
		if stringnumber >= uint32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount) {
			return -54
		}
		if count != 0 && stringnumber >= uint32(count) {
			return -55
		}
	}

	left = *(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(stringnumber*uint32(2))*8))
	right = *(*uint64)(unsafe.Pointer(match_data + 96 + uintptr(stringnumber*uint32(2)+uint32(1))*8))
	if sizeptr != uintptr(0) {
		*(*uint64)(unsafe.Pointer(sizeptr)) = func() uint64 {
			if left > right {
				return uint64(0)
			}
			return right - left
		}()
	}
	return 0
}

// ************************************************
//
//    Extract all captured strings to new memory  *
//

// This function gets one chunk of memory and builds a list of pointers and all
// the captured substrings in it. A NULL pointer is put on the end of the list.
// The substrings are zero-terminated, but also, if the final argument is
// non-NULL, a list of lengths is also returned. This allows binary data to be
// handled.
//
// Arguments:
//   match_data     points to the match data
//   listptr        set to point to the list of pointers
//   lengthsptr     set to point to the list of lengths (may be NULL)
//
// Returns:         if successful: 0
//                  if not successful, a negative error code:
//                    PCRE2_ERROR_NOMEMORY: failed to get memory,
//                    or a match failure code

func Xpcre2_substring_list_get_8(tls *libc.TLS, match_data uintptr, listptr uintptr, lengthsptr uintptr) int32 { /* pcre2_substring.c:372:1: */
	var i int32
	var count int32
	var count2 int32
	var size uint64
	var lensp uintptr
	var memp uintptr
	var listp uintptr
	var sp uintptr
	var ovector uintptr

	if libc.AssignInt32(&count, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Frc) < 0 {
		return count
	} // Match failed
	if count == 0 {
		count = int32((*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Foveccount)
	} // Ovector too small

	count2 = 2 * count
	ovector = match_data + 96                                                         /* &.ovector */
	size = uint64(unsafe.Sizeof(Tpcre2_memctl{})) + uint64(unsafe.Sizeof(uintptr(0))) // For final NULL
	if lengthsptr != uintptr(0) {
		size = size + uint64(unsafe.Sizeof(uint64(0)))*uint64(count)
	} // For lengths

	for i = 0; i < count2; i = i + 2 {
		size = size + (uint64(unsafe.Sizeof(uintptr(0))) + uint64(1*(DPCRE2_CODE_UNIT_WIDTH/8)))
		if *(*uint64)(unsafe.Pointer(ovector + uintptr(i+1)*8)) > *(*uint64)(unsafe.Pointer(ovector + uintptr(i)*8)) {
			size = size + (*(*uint64)(unsafe.Pointer(ovector + uintptr(i+1)*8))-*(*uint64)(unsafe.Pointer(ovector + uintptr(i)*8)))*uint64(DPCRE2_CODE_UNIT_WIDTH/8)
		}
	}

	memp = X_pcre2_memctl_malloc_8(tls, size, match_data)
	if memp == uintptr(0) {
		return -48
	}

	*(*uintptr)(unsafe.Pointer(listptr)) = libc.AssignUintptr(&listp, memp+uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{}))))
	lensp = listp + uintptr(uint64(unsafe.Sizeof(uintptr(0)))*uint64(count+1))

	if lengthsptr == uintptr(0) {
		sp = lensp
		lensp = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(lengthsptr)) = lensp
		sp = lensp + uintptr(uint64(unsafe.Sizeof(uint64(0)))*uint64(count))
	}

	for i = 0; i < count2; i = i + 2 {
		if *(*uint64)(unsafe.Pointer(ovector + uintptr(i+1)*8)) > *(*uint64)(unsafe.Pointer(ovector + uintptr(i)*8)) {
			size = *(*uint64)(unsafe.Pointer(ovector + uintptr(i+1)*8)) - *(*uint64)(unsafe.Pointer(ovector + uintptr(i)*8))
		} else {
			size = uint64(0)
		}

		// Size == 0 includes the case when the capture is unset. Avoid adding
		//   PCRE2_UNSET to match_data->subject because it overflows, even though with
		//   zero size calling memcpy() is harmless.

		if size != uint64(0) {
			libc.Xmemcpy(tls, sp, (*Tpcre2_match_data_8)(unsafe.Pointer(match_data)).Fsubject+uintptr(*(*uint64)(unsafe.Pointer(ovector + uintptr(i)*8))), size*uint64(DPCRE2_CODE_UNIT_WIDTH/8))
		}
		*(*uintptr)(unsafe.Pointer(libc.PostIncUintptr(&listp, 8))) = sp
		if lensp != uintptr(0) {
			*(*uint64)(unsafe.Pointer(libc.PostIncUintptr(&lensp, 8))) = size
		}
		sp += uintptr(size)
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&sp, 1))) = uint8(0)
	}

	*(*uintptr)(unsafe.Pointer(listp)) = uintptr(0)
	return 0
}

// ************************************************
//
//   Free memory obtained by substring_list_get   *
//

//
// Argument:     the result of a previous pcre2_substring_list_get()
// Returns:      nothing

func Xpcre2_substring_list_free_8(tls *libc.TLS, list uintptr) { /* pcre2_substring.c:445:1: */
	if list != uintptr(0) {
		var memctl uintptr = list - uintptr(uint64(unsafe.Sizeof(Tpcre2_memctl{})))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Tpcre2_memctl)(unsafe.Pointer(memctl)).Ffree})).f(tls, memctl, (*Tpcre2_memctl)(unsafe.Pointer(memctl)).Fmemory_data)
	}
}

// ************************************************
//
//     Find (multiple) entries for named string   *
//

// This function scans the nametable for a given name, using binary chop. It
// returns either two pointers to the entries in the table, or, if no pointers are
// given, the number of a unique group with the given name. If duplicate names are
// permitted, and the name is not unique, an error is generated.
//
// Arguments:
//   code        the compiled regex
//   stringname  the name whose entries required
//   firstptr    where to put the pointer to the first entry
//   lastptr     where to put the pointer to the last entry
//
// Returns:      PCRE2_ERROR_NOSUBSTRING if the name is not found
//               otherwise, if firstptr and lastptr are NULL:
//                 a group number for a unique substring
//                 else PCRE2_ERROR_NOUNIQUESUBSTRING
//               otherwise:
//                 the length of each entry, having set firstptr and lastptr

func Xpcre2_substring_nametable_scan_8(tls *libc.TLS, code uintptr, stringname uintptr, firstptr uintptr, lastptr uintptr) int32 { /* pcre2_substring.c:480:1: */
	var bot uint16 = uint16(0)
	var top uint16 = (*Tpcre2_code_8)(unsafe.Pointer(code)).Fname_count
	var entrysize uint16 = (*Tpcre2_code_8)(unsafe.Pointer(code)).Fname_entry_size
	var nametable uintptr = code + uintptr(uint64(unsafe.Sizeof(Tpcre2_real_code_8{})))

	for int32(top) > int32(bot) {
		var mid uint16 = uint16((int32(top) + int32(bot)) / 2)
		var entry uintptr = nametable + uintptr(int32(entrysize)*int32(mid))
		var c int32 = X_pcre2_strcmp_8(tls, stringname, entry+uintptr(DIMM2_SIZE))
		if c == 0 {
			var first uintptr
			var last uintptr
			var lastentry uintptr
			lastentry = nametable + uintptr(int32(entrysize)*(int32((*Tpcre2_code_8)(unsafe.Pointer(code)).Fname_count)-1))
			first = libc.AssignUintptr(&last, entry)
			for first > nametable {
				if X_pcre2_strcmp_8(tls, stringname, first-uintptr(entrysize)+uintptr(DIMM2_SIZE)) != 0 {
					break
				}
				first -= uintptr(entrysize)
			}
			for last < lastentry {
				if X_pcre2_strcmp_8(tls, stringname, last+uintptr(entrysize)+uintptr(DIMM2_SIZE)) != 0 {
					break
				}
				last += uintptr(entrysize)
			}
			if firstptr == uintptr(0) {
				if first == last {
					return int32(uint32(int32(*(*uint8)(unsafe.Pointer(entry)))<<8 | int32(*(*uint8)(unsafe.Pointer(entry + 1)))))
				}
				return -50
			}
			*(*uintptr)(unsafe.Pointer(firstptr)) = first
			*(*uintptr)(unsafe.Pointer(lastptr)) = last
			return int32(entrysize)
		}
		if c > 0 {
			bot = uint16(int32(mid) + 1)
		} else {
			top = mid
		}
	}

	return -49
}

// ************************************************
//
//           Find number for named string         *
//

// This function is a convenience wrapper for pcre2_substring_nametable_scan()
// when it is known that names are unique. If there are duplicate names, it is not
// defined which number is returned.
//
// Arguments:
//   code        the compiled regex
//   stringname  the name whose number is required
//
// Returns:      the number of the named parenthesis, or a negative number
//                 PCRE2_ERROR_NOSUBSTRING if not found
//                 PCRE2_ERROR_NOUNIQUESUBSTRING if not unique

func Xpcre2_substring_number_from_name_8(tls *libc.TLS, code uintptr, stringname uintptr) int32 { /* pcre2_substring.c:541:1: */
	return Xpcre2_substring_nametable_scan_8(tls, code, stringname, uintptr(0), uintptr(0))
}

// End of pcre2_substring.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// Table of sizes for the fixed-length opcodes. It's defined in a macro so that
// the definition is next to the definition of the opcodes in pcre2_internal.h.
// This is mode-dependent, so it is skipped when this file is included by
// pcre2test.

var X_pcre2_OP_lengths_8 = [168]uint8{uint8(1) /* End                                    */, uint8(1), uint8(1), uint8(1), uint8(1), uint8(1) /* \A, \G, \K, \B, \b                     */, uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1) /* \D, \d, \S, \s, \W, \w                 */, uint8(1), uint8(1), uint8(1) /* Any, AllAny, Anybyte                   */, uint8(3), uint8(3) /* \P, \p                                 */, uint8(1), uint8(1), uint8(1), uint8(1), uint8(1) /* \R, \H, \h, \V, \v                     */, uint8(1) /* \X                                     */, uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1) /* \Z, \z, $, $M ^, ^M                    */, uint8(2) /* Char  - the minimum length             */, uint8(2) /* Chari  - the minimum length            */, uint8(2) /* not                                    */, uint8(2) /* noti                                   */ /* Positive single-char repeats                             ** These are */, uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2) /* *, *?, +, +?, ?, ??       ** minima in */, uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2) /* *I, *?I, +I, +?I, ?I, ??I ** UTF-8     */, uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2) /* NOT *, *?, +, +?, ?, ??                */, uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2) /* NOT *I, *?I, +I, +?I, ?I, ??I          */, uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2) /* Type *, *?, +, +?, ?, ??               */, uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2 + DIMM2_SIZE), uint8(2), uint8(2), uint8(2), uint8(2 + DIMM2_SIZE), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1) /* *, *?, +, +?, ?, ??                    */, uint8(1 + 2*DIMM2_SIZE), uint8(1 + 2*DIMM2_SIZE), uint8(1), uint8(1), uint8(1), uint8(1 + 2*DIMM2_SIZE), uint8(uint64(1) + uint64(32)/uint64(unsafe.Sizeof(uint8(0)))), uint8(uint64(1) + uint64(32)/uint64(unsafe.Sizeof(uint8(0)))), uint8(0) /* XCLASS - variable length               */, uint8(1 + DIMM2_SIZE), uint8(1 + DIMM2_SIZE), uint8(1 + 2*DIMM2_SIZE), uint8(1 + 2*DIMM2_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + 2*DLINK_SIZE + 1), uint8(0) /* CALLOUT_STR - variable length          */, uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE + DIMM2_SIZE), uint8(1 + DLINK_SIZE + DIMM2_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DLINK_SIZE + DIMM2_SIZE), uint8(1 + DLINK_SIZE + DIMM2_SIZE), uint8(1 + DLINK_SIZE), uint8(1 + DIMM2_SIZE), uint8(1 + 2*DIMM2_SIZE), uint8(1 + DIMM2_SIZE), uint8(1 + 2*DIMM2_SIZE), uint8(1), uint8(1) /* FALSE, TRUE                            */, uint8(1), uint8(1), uint8(1) /* BRAZERO, BRAMINZERO, BRAPOSZERO        */, uint8(3), uint8(1), uint8(3) /* MARK, PRUNE, PRUNE_ARG                 */, uint8(1), uint8(3) /* SKIP, SKIP_ARG                         */, uint8(1), uint8(3) /* THEN, THEN_ARG                         */, uint8(1), uint8(3) /* COMMIT, COMMIT_ARG                     */, uint8(1), uint8(1), uint8(1) /* FAIL, ACCEPT, ASSERT_ACCEPT            */, uint8(1 + DIMM2_SIZE), uint8(1) /* CLOSE, SKIPZERO                        */, uint8(1)} /* pcre2_tables.c:60:15 */

// Tables of horizontal and vertical whitespace characters, suitable for
// adding to classes.

var X_pcre2_hspace_list_8 = [20]uint32{uint32('\011'), uint32('\040'), libc.Uint32FromUint8(libc.Uint8FromInt32(160)), uint32(0x1680), uint32(0x180e), uint32(0x2000), uint32(0x2001), uint32(0x2002), uint32(0x2003), uint32(0x2004), uint32(0x2005), uint32(0x2006), uint32(0x2007), uint32(0x2008), uint32(0x2009), uint32(0x200A), uint32(0x202f), uint32(0x205f), uint32(0x3000), DNOTACHAR} /* pcre2_tables.c:66:16 */
var X_pcre2_vspace_list_8 = [8]uint32{uint32('\012'), uint32('\013'), uint32('\014'), uint32('\015'), libc.Uint32FromUint8(libc.Uint8FromInt32(133)), uint32(0x2028), uint32(0x2029), DNOTACHAR}                                                                                                                                                                                                  /* pcre2_tables.c:67:16 */

// These tables are the pairs of delimiters that are valid for callout string
// arguments. For each starting delimiter there must be a matching ending
// delimiter, which in fact is different only for bracket-like delimiters.

var X_pcre2_callout_start_delims_8 = [9]uint32{
	uint32('\140'), uint32('\047'), uint32('\042'),
	uint32('\136'), uint32('\045'), uint32('\043'),
	uint32('\044'), uint32('\173'), uint32(0)} /* pcre2_tables.c:73:16 */

var X_pcre2_callout_end_delims_8 = [9]uint32{
	uint32('\140'), uint32('\047'), uint32('\042'),
	uint32('\136'), uint32('\045'), uint32('\043'),
	uint32('\044'), uint32('\175'), uint32(0)} /* pcre2_tables.c:78:16 */

// ************************************************
//
//           Tables for UTF-8 support             *
//

// These tables are required by pcre2test in 16- or 32-bit mode, as well
// as for the library in 8-bit mode, because pcre2test uses UTF-8 internally for
// handling wide characters.

// These are the breakpoints for different numbers of bytes in a UTF-8
// character.

var X_pcre2_utf8_table1 = [6]int32{0x7f, 0x7ff, 0xffff, 0x1fffff, 0x3ffffff, 0x7fffffff} /* pcre2_tables.c:100:11 */

var X_pcre2_utf8_table1_size int32 = int32(uint64(unsafe.Sizeof(X_pcre2_utf8_table1)) / uint64(unsafe.Sizeof(int32(0)))) /* pcre2_tables.c:103:11 */

// These are the indicator bits and the mask for the data bits to set in the
// first byte of a character, indexed by the number of additional bytes.

var X_pcre2_utf8_table2 = [6]int32{0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc}    /* pcre2_tables.c:108:11 */
var X_pcre2_utf8_table3 = [6]int32{0xff, 0x1f, 0x0f, 0x07, 0x03, 0x01} /* pcre2_tables.c:109:11 */

// Table of the number of extra bytes, indexed by the first byte masked with
// 0x3f. The highest number for a valid UTF-8 first byte is in fact 0x3d.

var X_pcre2_utf8_table4 = [64]uint8{
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(4), uint8(4), uint8(4), uint8(4), uint8(5), uint8(5), uint8(5), uint8(5)} /* pcre2_tables.c:114:15 */

// Tables concerned with Unicode properties are relevant only when Unicode
// support is enabled. See also the pcre2_ucptables.c file, which is generated by
// a Python script from Unicode data files.

// Table to translate from particular type value to the general value.

var X_pcre2_ucp_gentype_8 = [30]uint32{
	ucp_C, ucp_C, ucp_C, ucp_C, ucp_C, // Cc, Cf, Cn, Co, Cs
	ucp_L, ucp_L, ucp_L, ucp_L, ucp_L, // Ll, Lu, Lm, Lo, Lt
	ucp_M, ucp_M, ucp_M, // Mc, Me, Mn
	ucp_N, ucp_N, ucp_N, // Nd, Nl, No
	ucp_P, ucp_P, ucp_P, ucp_P, ucp_P, // Pc, Pd, Pe, Pf, Pi
	ucp_P, ucp_P, // Ps, Po
	ucp_S, ucp_S, ucp_S, ucp_S, // Sc, Sk, Sm, So
	ucp_Z, ucp_Z, ucp_Z, // Zl, Zp, Zs
} /* pcre2_tables.c:130:16 */

// This table encodes the rules for finding the end of an extended grapheme
// cluster. Every code point has a grapheme break property which is one of the
// ucp_gbXX values defined in pcre2_ucp.h. These changed between Unicode versions
// 10 and 11. The 2-dimensional table is indexed by the properties of two adjacent
// code points. The left property selects a word from the table, and the right
// property selects a bit from that word like this:
//
//   PRIV(ucp_gbtable)[left-property] & (1u << right-property)
//
// The value is non-zero if a grapheme break is NOT permitted between the relevant
// two code points. The breaking rules are as follows:
//
// 1. Break at the start and end of text (pretty obviously).
//
// 2. Do not break between a CR and LF; otherwise, break before and after
//    controls.
//
// 3. Do not break Hangul syllable sequences, the rules for which are:
//
//     L may be followed by L, V, LV or LVT
//     LV or V may be followed by V or T
//     LVT or T may be followed by T
//
// 4. Do not break before extending characters or zero-width-joiner (ZWJ).
//
// The following rules are only for extended grapheme clusters (but that's what we
// are implementing).
//
// 5. Do not break before SpacingMarks.
//
// 6. Do not break after Prepend characters.
//
// 7. Do not break within emoji modifier sequences or emoji zwj sequences. That
//    is, do not break between characters with the Extended_Pictographic property.
//    Extend and ZWJ characters are allowed between the characters; this cannot be
//    represented in this table, the code has to deal with it.
//
// 8. Do not break within emoji flag sequences. That is, do not break between
//    regional indicator (RI) symbols if there are an odd number of RI characters
//    before the break point. This table encodes "join RI characters"; the code
//    has to deal with checking for previous adjoining RIs.
//
// 9. Otherwise, break everywhere.

var X_pcre2_ucp_gbtable_8 = [15]uint32{
	uint32(1) << ucp_gbLF,
	uint32(0), //  1 LF
	uint32(0), //  2 Control
	uint32(int32(1)<<ucp_gbExtend | int32(1)<<ucp_gbSpacingMark | int32(1)<<ucp_gbZWJ),
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbPrepend | uint32(1)<<ucp_gbL | uint32(1)<<ucp_gbV | uint32(1)<<ucp_gbT | uint32(1)<<ucp_gbLV | uint32(1)<<ucp_gbLVT | uint32(1)<<ucp_gbOther | uint32(1)<<ucp_gbRegional_Indicator,
	uint32(int32(1)<<ucp_gbExtend | int32(1)<<ucp_gbSpacingMark | int32(1)<<ucp_gbZWJ),
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbL | uint32(1)<<ucp_gbV | uint32(1)<<ucp_gbLV | uint32(1)<<ucp_gbLVT,
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbV | uint32(1)<<ucp_gbT,
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbT,
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbV | uint32(1)<<ucp_gbT,
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbT,
	uint32(1) << ucp_gbRegional_Indicator,
	uint32(int32(1)<<ucp_gbExtend | int32(1)<<ucp_gbSpacingMark | int32(1)<<ucp_gbZWJ),
	uint32(int32(1)<<ucp_gbExtend | int32(1)<<ucp_gbSpacingMark | int32(1)<<ucp_gbZWJ),
	uint32(int32(1)<<ucp_gbExtend|int32(1)<<ucp_gbSpacingMark|int32(1)<<ucp_gbZWJ) | uint32(1)<<ucp_gbExtended_Pictographic,
} /* pcre2_tables.c:188:16 */

// Finally, include the tables that are auto-generated from the Unicode data
// files.

// ************************************************
//
//      Perl-Compatible Regular Expressions       *
//

// PCRE is a library of functions to support regular expressions whose syntax
// and semantics are as close as possible to those of the Perl 5 language.
//
//                        Written by Philip Hazel
//      Original API code Copyright (c) 1997-2012 University of Cambridge
//           New API code Copyright (c) 2016-2022 University of Cambridge
//
// This module is auto-generated from Unicode data files. DO NOT EDIT MANUALLY!
// Instead, modify the maint/GenerateUcpTables.py script and run it to generate
// a new version of this code.
//
// -----------------------------------------------------------------------------
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the name of the University of Cambridge nor the names of its
//       contributors may be used to endorse or promote products derived from
//       this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// -----------------------------------------------------------------------------

// The PRIV(utt)[] table below translates Unicode property names into type and
// code values. It is searched by binary chop, so must be in collating sequence of
// name. Originally, the table contained pointers to the name strings in the first
// field of each entry. However, that leads to a large number of relocations when
// a shared library is dynamically loaded. A significant reduction is made by
// putting all the names into a single, large string and using offsets instead.
// All letters are lower cased, and underscores are removed, in accordance with
// the "loose matching" rules that Unicode advises and Perl uses.

var X_pcre2_utt_names_8 = *(*[3569]int8)(unsafe.Pointer(ts + 7683)) /* pcre2_ucptables.c:543:12 */

var X_pcre2_utt_8 = [486]Tucp_type_table{
	{Ftype: uint16(DPT_SCX), Fvalue: ucp_Adlam},
	{Fname_offset: uint16(6), Ftype: uint16(DPT_SCX), Fvalue: ucp_Adlam},
	{Fname_offset: uint16(11), Ftype: uint16(DPT_SC), Fvalue: ucp_Caucasian_Albanian},
	{Fname_offset: uint16(16), Ftype: uint16(DPT_BOOL), Fvalue: ucp_ASCII_Hex_Digit},
	{Fname_offset: uint16(21), Ftype: uint16(DPT_SC), Fvalue: ucp_Ahom},
	{Fname_offset: uint16(26), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Alphabetic},
	{Fname_offset: uint16(32), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Alphabetic},
	{Fname_offset: uint16(43), Ftype: uint16(DPT_SC), Fvalue: ucp_Anatolian_Hieroglyphs},
	{Fname_offset: uint16(64)},
	{Fname_offset: uint16(68), Ftype: uint16(DPT_SCX), Fvalue: ucp_Arabic},
	{Fname_offset: uint16(73), Ftype: uint16(DPT_SCX), Fvalue: ucp_Arabic},
	{Fname_offset: uint16(80), Ftype: uint16(DPT_SC), Fvalue: ucp_Armenian},
	{Fname_offset: uint16(89), Ftype: uint16(DPT_SC), Fvalue: ucp_Imperial_Aramaic},
	{Fname_offset: uint16(94), Ftype: uint16(DPT_SC), Fvalue: ucp_Armenian},
	{Fname_offset: uint16(99), Ftype: uint16(DPT_BOOL)},
	{Fname_offset: uint16(105), Ftype: uint16(DPT_BOOL), Fvalue: ucp_ASCII_Hex_Digit},
	{Fname_offset: uint16(119), Ftype: uint16(DPT_SC), Fvalue: ucp_Avestan},
	{Fname_offset: uint16(127), Ftype: uint16(DPT_SC), Fvalue: ucp_Avestan},
	{Fname_offset: uint16(132), Ftype: uint16(DPT_SC), Fvalue: ucp_Balinese},
	{Fname_offset: uint16(137), Ftype: uint16(DPT_SC), Fvalue: ucp_Balinese},
	{Fname_offset: uint16(146), Ftype: uint16(DPT_SC), Fvalue: ucp_Bamum},
	{Fname_offset: uint16(151), Ftype: uint16(DPT_SC), Fvalue: ucp_Bamum},
	{Fname_offset: uint16(157), Ftype: uint16(DPT_SC), Fvalue: ucp_Bassa_Vah},
	{Fname_offset: uint16(162), Ftype: uint16(DPT_SC), Fvalue: ucp_Bassa_Vah},
	{Fname_offset: uint16(171), Ftype: uint16(DPT_SC), Fvalue: ucp_Batak},
	{Fname_offset: uint16(177), Ftype: uint16(DPT_SC), Fvalue: ucp_Batak},
	{Fname_offset: uint16(182), Ftype: uint16(DPT_SCX), Fvalue: ucp_Bengali},
	{Fname_offset: uint16(187), Ftype: uint16(DPT_SCX), Fvalue: ucp_Bengali},
	{Fname_offset: uint16(195), Ftype: uint16(DPT_SC), Fvalue: ucp_Bhaiksuki},
	{Fname_offset: uint16(205), Ftype: uint16(DPT_SC), Fvalue: ucp_Bhaiksuki},
	{Fname_offset: uint16(210), Ftype: uint16(DPT_BIDICL)},
	{Fname_offset: uint16(217), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiAN},
	{Fname_offset: uint16(224), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiB},
	{Fname_offset: uint16(230), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiBN},
	{Fname_offset: uint16(237), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Bidi_Control},
	{Fname_offset: uint16(243), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Bidi_Control},
	{Fname_offset: uint16(255), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiCS},
	{Fname_offset: uint16(262), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiEN},
	{Fname_offset: uint16(269), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiES},
	{Fname_offset: uint16(276), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiET},
	{Fname_offset: uint16(283), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiFSI},
	{Fname_offset: uint16(291), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiL},
	{Fname_offset: uint16(297), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiLRE},
	{Fname_offset: uint16(305), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiLRI},
	{Fname_offset: uint16(313), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiLRO},
	{Fname_offset: uint16(321), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Bidi_Mirrored},
	{Fname_offset: uint16(327), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Bidi_Mirrored},
	{Fname_offset: uint16(340), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiNSM},
	{Fname_offset: uint16(348), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiON},
	{Fname_offset: uint16(355), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiPDF},
	{Fname_offset: uint16(363), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiPDI},
	{Fname_offset: uint16(371), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiR},
	{Fname_offset: uint16(377), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiRLE},
	{Fname_offset: uint16(385), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiRLI},
	{Fname_offset: uint16(393), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiRLO},
	{Fname_offset: uint16(401), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiS},
	{Fname_offset: uint16(407), Ftype: uint16(DPT_BIDICL), Fvalue: ucp_bidiWS},
	{Fname_offset: uint16(414), Ftype: uint16(DPT_SCX), Fvalue: ucp_Bopomofo},
	{Fname_offset: uint16(419), Ftype: uint16(DPT_SCX), Fvalue: ucp_Bopomofo},
	{Fname_offset: uint16(428), Ftype: uint16(DPT_SC), Fvalue: ucp_Brahmi},
	{Fname_offset: uint16(433), Ftype: uint16(DPT_SC), Fvalue: ucp_Brahmi},
	{Fname_offset: uint16(440), Ftype: uint16(DPT_SC), Fvalue: ucp_Braille},
	{Fname_offset: uint16(445), Ftype: uint16(DPT_SC), Fvalue: ucp_Braille},
	{Fname_offset: uint16(453), Ftype: uint16(DPT_SCX), Fvalue: ucp_Buginese},
	{Fname_offset: uint16(458), Ftype: uint16(DPT_SCX), Fvalue: ucp_Buginese},
	{Fname_offset: uint16(467), Ftype: uint16(DPT_SCX), Fvalue: ucp_Buhid},
	{Fname_offset: uint16(472), Ftype: uint16(DPT_SCX), Fvalue: ucp_Buhid},
	{Fname_offset: uint16(478), Ftype: uint16(DPT_GC)},
	{Fname_offset: uint16(480), Ftype: uint16(DPT_SCX), Fvalue: ucp_Chakma},
	{Fname_offset: uint16(485), Ftype: uint16(DPT_SC), Fvalue: ucp_Canadian_Aboriginal},
	{Fname_offset: uint16(504), Ftype: uint16(DPT_SC), Fvalue: ucp_Canadian_Aboriginal},
	{Fname_offset: uint16(509), Ftype: uint16(DPT_SC), Fvalue: ucp_Carian},
	{Fname_offset: uint16(514), Ftype: uint16(DPT_SC), Fvalue: ucp_Carian},
	{Fname_offset: uint16(521), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Cased},
	{Fname_offset: uint16(527), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Case_Ignorable},
	{Fname_offset: uint16(541), Ftype: uint16(DPT_SC), Fvalue: ucp_Caucasian_Albanian},
	{Fname_offset: uint16(559), Ftype: uint16(DPT_PC)},
	{Fname_offset: uint16(562), Ftype: uint16(DPT_PC), Fvalue: ucp_Cf},
	{Fname_offset: uint16(565), Ftype: uint16(DPT_SCX), Fvalue: ucp_Chakma},
	{Fname_offset: uint16(572), Ftype: uint16(DPT_SC), Fvalue: ucp_Cham},
	{Fname_offset: uint16(577), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Casefolded},
	{Fname_offset: uint16(599), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Casemapped},
	{Fname_offset: uint16(621), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Lowercased},
	{Fname_offset: uint16(643), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Titlecased},
	{Fname_offset: uint16(665), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Uppercased},
	{Fname_offset: uint16(687), Ftype: uint16(DPT_SC), Fvalue: ucp_Cherokee},
	{Fname_offset: uint16(692), Ftype: uint16(DPT_SC), Fvalue: ucp_Cherokee},
	{Fname_offset: uint16(701), Ftype: uint16(DPT_SC), Fvalue: ucp_Chorasmian},
	{Fname_offset: uint16(712), Ftype: uint16(DPT_SC), Fvalue: ucp_Chorasmian},
	{Fname_offset: uint16(717), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Case_Ignorable},
	{Fname_offset: uint16(720), Ftype: uint16(DPT_PC), Fvalue: ucp_Cn},
	{Fname_offset: uint16(723), Ftype: uint16(DPT_PC), Fvalue: ucp_Co},
	{Fname_offset: uint16(726), Ftype: uint16(DPT_SC), Fvalue: ucp_Common},
	{Fname_offset: uint16(733), Ftype: uint16(DPT_SCX), Fvalue: ucp_Coptic},
	{Fname_offset: uint16(738), Ftype: uint16(DPT_SCX), Fvalue: ucp_Coptic},
	{Fname_offset: uint16(745), Ftype: uint16(DPT_SCX), Fvalue: ucp_Cypro_Minoan},
	{Fname_offset: uint16(750), Ftype: uint16(DPT_SCX), Fvalue: ucp_Cypriot},
	{Fname_offset: uint16(755), Ftype: uint16(DPT_PC), Fvalue: ucp_Cs},
	{Fname_offset: uint16(758), Ftype: uint16(DPT_SC), Fvalue: ucp_Cuneiform},
	{Fname_offset: uint16(768), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Casefolded},
	{Fname_offset: uint16(773), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Casemapped},
	{Fname_offset: uint16(778), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Lowercased},
	{Fname_offset: uint16(782), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Titlecased},
	{Fname_offset: uint16(786), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Changes_When_Uppercased},
	{Fname_offset: uint16(790), Ftype: uint16(DPT_SCX), Fvalue: ucp_Cypriot},
	{Fname_offset: uint16(798), Ftype: uint16(DPT_SCX), Fvalue: ucp_Cypro_Minoan},
	{Fname_offset: uint16(810), Ftype: uint16(DPT_SCX), Fvalue: ucp_Cyrillic},
	{Fname_offset: uint16(819), Ftype: uint16(DPT_SCX), Fvalue: ucp_Cyrillic},
	{Fname_offset: uint16(824), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Dash},
	{Fname_offset: uint16(829), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Default_Ignorable_Code_Point},
	{Fname_offset: uint16(855), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Deprecated},
	{Fname_offset: uint16(859), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Deprecated},
	{Fname_offset: uint16(870), Ftype: uint16(DPT_SC), Fvalue: ucp_Deseret},
	{Fname_offset: uint16(878), Ftype: uint16(DPT_SCX), Fvalue: ucp_Devanagari},
	{Fname_offset: uint16(883), Ftype: uint16(DPT_SCX), Fvalue: ucp_Devanagari},
	{Fname_offset: uint16(894), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Default_Ignorable_Code_Point},
	{Fname_offset: uint16(897), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Diacritic},
	{Fname_offset: uint16(901), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Diacritic},
	{Fname_offset: uint16(911), Ftype: uint16(DPT_SC), Fvalue: ucp_Dives_Akuru},
	{Fname_offset: uint16(916), Ftype: uint16(DPT_SC), Fvalue: ucp_Dives_Akuru},
	{Fname_offset: uint16(927), Ftype: uint16(DPT_SCX), Fvalue: ucp_Dogra},
	{Fname_offset: uint16(932), Ftype: uint16(DPT_SCX), Fvalue: ucp_Dogra},
	{Fname_offset: uint16(938), Ftype: uint16(DPT_SC), Fvalue: ucp_Deseret},
	{Fname_offset: uint16(943), Ftype: uint16(DPT_SCX), Fvalue: ucp_Duployan},
	{Fname_offset: uint16(948), Ftype: uint16(DPT_SCX), Fvalue: ucp_Duployan},
	{Fname_offset: uint16(957), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji_Modifier_Base},
	{Fname_offset: uint16(963), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji_Component},
	{Fname_offset: uint16(969), Ftype: uint16(DPT_SC), Fvalue: ucp_Egyptian_Hieroglyphs},
	{Fname_offset: uint16(974), Ftype: uint16(DPT_SC), Fvalue: ucp_Egyptian_Hieroglyphs},
	{Fname_offset: uint16(994), Ftype: uint16(DPT_SC), Fvalue: ucp_Elbasan},
	{Fname_offset: uint16(999), Ftype: uint16(DPT_SC), Fvalue: ucp_Elbasan},
	{Fname_offset: uint16(1007), Ftype: uint16(DPT_SC), Fvalue: ucp_Elymaic},
	{Fname_offset: uint16(1012), Ftype: uint16(DPT_SC), Fvalue: ucp_Elymaic},
	{Fname_offset: uint16(1020), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji_Modifier},
	{Fname_offset: uint16(1025), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji},
	{Fname_offset: uint16(1031), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji_Component},
	{Fname_offset: uint16(1046), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji_Modifier},
	{Fname_offset: uint16(1060), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji_Modifier_Base},
	{Fname_offset: uint16(1078), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji_Presentation},
	{Fname_offset: uint16(1096), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Emoji_Presentation},
	{Fname_offset: uint16(1102), Ftype: uint16(DPT_SC), Fvalue: ucp_Ethiopic},
	{Fname_offset: uint16(1107), Ftype: uint16(DPT_SC), Fvalue: ucp_Ethiopic},
	{Fname_offset: uint16(1116), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Extender},
	{Fname_offset: uint16(1120), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Extended_Pictographic},
	{Fname_offset: uint16(1141), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Extender},
	{Fname_offset: uint16(1150), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Extended_Pictographic},
	{Fname_offset: uint16(1158), Ftype: uint16(DPT_SCX), Fvalue: ucp_Georgian},
	{Fname_offset: uint16(1163), Ftype: uint16(DPT_SCX), Fvalue: ucp_Georgian},
	{Fname_offset: uint16(1172), Ftype: uint16(DPT_SCX), Fvalue: ucp_Glagolitic},
	{Fname_offset: uint16(1177), Ftype: uint16(DPT_SCX), Fvalue: ucp_Glagolitic},
	{Fname_offset: uint16(1188), Ftype: uint16(DPT_SCX), Fvalue: ucp_Gunjala_Gondi},
	{Fname_offset: uint16(1193), Ftype: uint16(DPT_SCX), Fvalue: ucp_Masaram_Gondi},
	{Fname_offset: uint16(1198), Ftype: uint16(DPT_SC), Fvalue: ucp_Gothic},
	{Fname_offset: uint16(1203), Ftype: uint16(DPT_SC), Fvalue: ucp_Gothic},
	{Fname_offset: uint16(1210), Ftype: uint16(DPT_SCX), Fvalue: ucp_Grantha},
	{Fname_offset: uint16(1215), Ftype: uint16(DPT_SCX), Fvalue: ucp_Grantha},
	{Fname_offset: uint16(1223), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Grapheme_Base},
	{Fname_offset: uint16(1236), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Grapheme_Extend},
	{Fname_offset: uint16(1251), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Grapheme_Link},
	{Fname_offset: uint16(1264), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Grapheme_Base},
	{Fname_offset: uint16(1271), Ftype: uint16(DPT_SCX), Fvalue: ucp_Greek},
	{Fname_offset: uint16(1277), Ftype: uint16(DPT_SCX), Fvalue: ucp_Greek},
	{Fname_offset: uint16(1282), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Grapheme_Extend},
	{Fname_offset: uint16(1288), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Grapheme_Link},
	{Fname_offset: uint16(1295), Ftype: uint16(DPT_SCX), Fvalue: ucp_Gujarati},
	{Fname_offset: uint16(1304), Ftype: uint16(DPT_SCX), Fvalue: ucp_Gujarati},
	{Fname_offset: uint16(1309), Ftype: uint16(DPT_SCX), Fvalue: ucp_Gunjala_Gondi},
	{Fname_offset: uint16(1322), Ftype: uint16(DPT_SCX), Fvalue: ucp_Gurmukhi},
	{Fname_offset: uint16(1331), Ftype: uint16(DPT_SCX), Fvalue: ucp_Gurmukhi},
	{Fname_offset: uint16(1336), Ftype: uint16(DPT_SCX), Fvalue: ucp_Han},
	{Fname_offset: uint16(1340), Ftype: uint16(DPT_SCX), Fvalue: ucp_Hangul},
	{Fname_offset: uint16(1345), Ftype: uint16(DPT_SCX), Fvalue: ucp_Hangul},
	{Fname_offset: uint16(1352), Ftype: uint16(DPT_SCX), Fvalue: ucp_Han},
	{Fname_offset: uint16(1357), Ftype: uint16(DPT_SCX), Fvalue: ucp_Hanifi_Rohingya},
	{Fname_offset: uint16(1372), Ftype: uint16(DPT_SCX), Fvalue: ucp_Hanunoo},
	{Fname_offset: uint16(1377), Ftype: uint16(DPT_SCX), Fvalue: ucp_Hanunoo},
	{Fname_offset: uint16(1385), Ftype: uint16(DPT_SC), Fvalue: ucp_Hatran},
	{Fname_offset: uint16(1390), Ftype: uint16(DPT_SC), Fvalue: ucp_Hatran},
	{Fname_offset: uint16(1397), Ftype: uint16(DPT_SC), Fvalue: ucp_Hebrew},
	{Fname_offset: uint16(1402), Ftype: uint16(DPT_SC), Fvalue: ucp_Hebrew},
	{Fname_offset: uint16(1409), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Hex_Digit},
	{Fname_offset: uint16(1413), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Hex_Digit},
	{Fname_offset: uint16(1422), Ftype: uint16(DPT_SCX), Fvalue: ucp_Hiragana},
	{Fname_offset: uint16(1427), Ftype: uint16(DPT_SCX), Fvalue: ucp_Hiragana},
	{Fname_offset: uint16(1436), Ftype: uint16(DPT_SC), Fvalue: ucp_Anatolian_Hieroglyphs},
	{Fname_offset: uint16(1441), Ftype: uint16(DPT_SC), Fvalue: ucp_Pahawh_Hmong},
	{Fname_offset: uint16(1446), Ftype: uint16(DPT_SC), Fvalue: ucp_Nyiakeng_Puachue_Hmong},
	{Fname_offset: uint16(1451), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Hungarian},
	{Fname_offset: uint16(1456), Ftype: uint16(DPT_BOOL), Fvalue: ucp_ID_Continue},
	{Fname_offset: uint16(1460), Ftype: uint16(DPT_BOOL), Fvalue: ucp_ID_Continue},
	{Fname_offset: uint16(1471), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Ideographic},
	{Fname_offset: uint16(1476), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Ideographic},
	{Fname_offset: uint16(1488), Ftype: uint16(DPT_BOOL), Fvalue: ucp_ID_Start},
	{Fname_offset: uint16(1492), Ftype: uint16(DPT_BOOL), Fvalue: ucp_IDS_Binary_Operator},
	{Fname_offset: uint16(1497), Ftype: uint16(DPT_BOOL), Fvalue: ucp_IDS_Binary_Operator},
	{Fname_offset: uint16(1515), Ftype: uint16(DPT_BOOL), Fvalue: ucp_IDS_Trinary_Operator},
	{Fname_offset: uint16(1520), Ftype: uint16(DPT_BOOL), Fvalue: ucp_ID_Start},
	{Fname_offset: uint16(1528), Ftype: uint16(DPT_BOOL), Fvalue: ucp_IDS_Trinary_Operator},
	{Fname_offset: uint16(1547), Ftype: uint16(DPT_SC), Fvalue: ucp_Imperial_Aramaic},
	{Fname_offset: uint16(1563), Ftype: uint16(DPT_SC), Fvalue: ucp_Inherited},
	{Fname_offset: uint16(1573), Ftype: uint16(DPT_SC), Fvalue: ucp_Inscriptional_Pahlavi},
	{Fname_offset: uint16(1594), Ftype: uint16(DPT_SC), Fvalue: ucp_Inscriptional_Parthian},
	{Fname_offset: uint16(1616), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Italic},
	{Fname_offset: uint16(1621), Ftype: uint16(DPT_SCX), Fvalue: ucp_Javanese},
	{Fname_offset: uint16(1626), Ftype: uint16(DPT_SCX), Fvalue: ucp_Javanese},
	{Fname_offset: uint16(1635), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Join_Control},
	{Fname_offset: uint16(1641), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Join_Control},
	{Fname_offset: uint16(1653), Ftype: uint16(DPT_SCX), Fvalue: ucp_Kaithi},
	{Fname_offset: uint16(1660), Ftype: uint16(DPT_SCX), Fvalue: ucp_Kayah_Li},
	{Fname_offset: uint16(1665), Ftype: uint16(DPT_SCX), Fvalue: ucp_Katakana},
	{Fname_offset: uint16(1670), Ftype: uint16(DPT_SCX), Fvalue: ucp_Kannada},
	{Fname_offset: uint16(1678), Ftype: uint16(DPT_SCX), Fvalue: ucp_Katakana},
	{Fname_offset: uint16(1687), Ftype: uint16(DPT_SCX), Fvalue: ucp_Kayah_Li},
	{Fname_offset: uint16(1695), Ftype: uint16(DPT_SC), Fvalue: ucp_Kharoshthi},
	{Fname_offset: uint16(1700), Ftype: uint16(DPT_SC), Fvalue: ucp_Kharoshthi},
	{Fname_offset: uint16(1711), Ftype: uint16(DPT_SC), Fvalue: ucp_Khitan_Small_Script},
	{Fname_offset: uint16(1729), Ftype: uint16(DPT_SC), Fvalue: ucp_Khmer},
	{Fname_offset: uint16(1735), Ftype: uint16(DPT_SC), Fvalue: ucp_Khmer},
	{Fname_offset: uint16(1740), Ftype: uint16(DPT_SCX), Fvalue: ucp_Khojki},
	{Fname_offset: uint16(1745), Ftype: uint16(DPT_SCX), Fvalue: ucp_Khojki},
	{Fname_offset: uint16(1752), Ftype: uint16(DPT_SCX), Fvalue: ucp_Khudawadi},
	{Fname_offset: uint16(1762), Ftype: uint16(DPT_SC), Fvalue: ucp_Khitan_Small_Script},
	{Fname_offset: uint16(1767), Ftype: uint16(DPT_SCX), Fvalue: ucp_Kannada},
	{Fname_offset: uint16(1772), Ftype: uint16(DPT_SCX), Fvalue: ucp_Kaithi},
	{Fname_offset: uint16(1777), Ftype: uint16(DPT_GC), Fvalue: ucp_L},
	{Fname_offset: uint16(1779), Ftype: uint16(DPT_LAMP)},
	{Fname_offset: uint16(1782), Ftype: uint16(DPT_SC), Fvalue: ucp_Tai_Tham},
	{Fname_offset: uint16(1787), Ftype: uint16(DPT_SC), Fvalue: ucp_Lao},
	{Fname_offset: uint16(1791), Ftype: uint16(DPT_SC), Fvalue: ucp_Lao},
	{Fname_offset: uint16(1796), Ftype: uint16(DPT_SCX)},
	{Fname_offset: uint16(1802), Ftype: uint16(DPT_SCX)},
	{Fname_offset: uint16(1807), Ftype: uint16(DPT_LAMP)},
	{Fname_offset: uint16(1810), Ftype: uint16(DPT_SC), Fvalue: ucp_Lepcha},
	{Fname_offset: uint16(1815), Ftype: uint16(DPT_SC), Fvalue: ucp_Lepcha},
	{Fname_offset: uint16(1822), Ftype: uint16(DPT_SCX), Fvalue: ucp_Limbu},
	{Fname_offset: uint16(1827), Ftype: uint16(DPT_SCX), Fvalue: ucp_Limbu},
	{Fname_offset: uint16(1833), Ftype: uint16(DPT_SCX), Fvalue: ucp_Linear_A},
	{Fname_offset: uint16(1838), Ftype: uint16(DPT_SCX), Fvalue: ucp_Linear_B},
	{Fname_offset: uint16(1843), Ftype: uint16(DPT_SCX), Fvalue: ucp_Linear_A},
	{Fname_offset: uint16(1851), Ftype: uint16(DPT_SCX), Fvalue: ucp_Linear_B},
	{Fname_offset: uint16(1859), Ftype: uint16(DPT_SC), Fvalue: ucp_Lisu},
	{Fname_offset: uint16(1864), Ftype: uint16(DPT_PC), Fvalue: ucp_Ll},
	{Fname_offset: uint16(1867), Ftype: uint16(DPT_PC), Fvalue: ucp_Lm},
	{Fname_offset: uint16(1870), Ftype: uint16(DPT_PC), Fvalue: ucp_Lo},
	{Fname_offset: uint16(1873), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Logical_Order_Exception},
	{Fname_offset: uint16(1877), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Logical_Order_Exception},
	{Fname_offset: uint16(1899), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Lowercase},
	{Fname_offset: uint16(1905), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Lowercase},
	{Fname_offset: uint16(1915), Ftype: uint16(DPT_PC), Fvalue: ucp_Lt},
	{Fname_offset: uint16(1918), Ftype: uint16(DPT_PC), Fvalue: ucp_Lu},
	{Fname_offset: uint16(1921), Ftype: uint16(DPT_SC), Fvalue: ucp_Lycian},
	{Fname_offset: uint16(1926), Ftype: uint16(DPT_SC), Fvalue: ucp_Lycian},
	{Fname_offset: uint16(1933), Ftype: uint16(DPT_SC), Fvalue: ucp_Lydian},
	{Fname_offset: uint16(1938), Ftype: uint16(DPT_SC), Fvalue: ucp_Lydian},
	{Fname_offset: uint16(1945), Ftype: uint16(DPT_GC), Fvalue: ucp_M},
	{Fname_offset: uint16(1947), Ftype: uint16(DPT_SCX), Fvalue: ucp_Mahajani},
	{Fname_offset: uint16(1956), Ftype: uint16(DPT_SCX), Fvalue: ucp_Mahajani},
	{Fname_offset: uint16(1961), Ftype: uint16(DPT_SC), Fvalue: ucp_Makasar},
	{Fname_offset: uint16(1966), Ftype: uint16(DPT_SC), Fvalue: ucp_Makasar},
	{Fname_offset: uint16(1974), Ftype: uint16(DPT_SCX), Fvalue: ucp_Malayalam},
	{Fname_offset: uint16(1984), Ftype: uint16(DPT_SCX), Fvalue: ucp_Mandaic},
	{Fname_offset: uint16(1989), Ftype: uint16(DPT_SCX), Fvalue: ucp_Mandaic},
	{Fname_offset: uint16(1997), Ftype: uint16(DPT_SCX), Fvalue: ucp_Manichaean},
	{Fname_offset: uint16(2002), Ftype: uint16(DPT_SCX), Fvalue: ucp_Manichaean},
	{Fname_offset: uint16(2013), Ftype: uint16(DPT_SC), Fvalue: ucp_Marchen},
	{Fname_offset: uint16(2018), Ftype: uint16(DPT_SC), Fvalue: ucp_Marchen},
	{Fname_offset: uint16(2026), Ftype: uint16(DPT_SCX), Fvalue: ucp_Masaram_Gondi},
	{Fname_offset: uint16(2039), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Math},
	{Fname_offset: uint16(2044), Ftype: uint16(DPT_PC), Fvalue: ucp_Mc},
	{Fname_offset: uint16(2047), Ftype: uint16(DPT_PC), Fvalue: ucp_Me},
	{Fname_offset: uint16(2050), Ftype: uint16(DPT_SC), Fvalue: ucp_Medefaidrin},
	{Fname_offset: uint16(2062), Ftype: uint16(DPT_SC), Fvalue: ucp_Medefaidrin},
	{Fname_offset: uint16(2067), Ftype: uint16(DPT_SC), Fvalue: ucp_Meetei_Mayek},
	{Fname_offset: uint16(2079), Ftype: uint16(DPT_SC), Fvalue: ucp_Mende_Kikakui},
	{Fname_offset: uint16(2084), Ftype: uint16(DPT_SC), Fvalue: ucp_Mende_Kikakui},
	{Fname_offset: uint16(2097), Ftype: uint16(DPT_SC), Fvalue: ucp_Meroitic_Cursive},
	{Fname_offset: uint16(2102), Ftype: uint16(DPT_SC), Fvalue: ucp_Meroitic_Hieroglyphs},
	{Fname_offset: uint16(2107), Ftype: uint16(DPT_SC), Fvalue: ucp_Meroitic_Cursive},
	{Fname_offset: uint16(2123), Ftype: uint16(DPT_SC), Fvalue: ucp_Meroitic_Hieroglyphs},
	{Fname_offset: uint16(2143), Ftype: uint16(DPT_SC), Fvalue: ucp_Miao},
	{Fname_offset: uint16(2148), Ftype: uint16(DPT_SCX), Fvalue: ucp_Malayalam},
	{Fname_offset: uint16(2153), Ftype: uint16(DPT_PC), Fvalue: ucp_Mn},
	{Fname_offset: uint16(2156), Ftype: uint16(DPT_SCX), Fvalue: ucp_Modi},
	{Fname_offset: uint16(2161), Ftype: uint16(DPT_SCX), Fvalue: ucp_Mongolian},
	{Fname_offset: uint16(2166), Ftype: uint16(DPT_SCX), Fvalue: ucp_Mongolian},
	{Fname_offset: uint16(2176), Ftype: uint16(DPT_SC), Fvalue: ucp_Mro},
	{Fname_offset: uint16(2180), Ftype: uint16(DPT_SC), Fvalue: ucp_Mro},
	{Fname_offset: uint16(2185), Ftype: uint16(DPT_SC), Fvalue: ucp_Meetei_Mayek},
	{Fname_offset: uint16(2190), Ftype: uint16(DPT_SCX), Fvalue: ucp_Multani},
	{Fname_offset: uint16(2195), Ftype: uint16(DPT_SCX), Fvalue: ucp_Multani},
	{Fname_offset: uint16(2203), Ftype: uint16(DPT_SCX), Fvalue: ucp_Myanmar},
	{Fname_offset: uint16(2211), Ftype: uint16(DPT_SCX), Fvalue: ucp_Myanmar},
	{Fname_offset: uint16(2216), Ftype: uint16(DPT_GC), Fvalue: ucp_N},
	{Fname_offset: uint16(2218), Ftype: uint16(DPT_SC), Fvalue: ucp_Nabataean},
	{Fname_offset: uint16(2228), Ftype: uint16(DPT_SCX), Fvalue: ucp_Nandinagari},
	{Fname_offset: uint16(2233), Ftype: uint16(DPT_SCX), Fvalue: ucp_Nandinagari},
	{Fname_offset: uint16(2245), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_North_Arabian},
	{Fname_offset: uint16(2250), Ftype: uint16(DPT_SC), Fvalue: ucp_Nabataean},
	{Fname_offset: uint16(2255), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Noncharacter_Code_Point},
	{Fname_offset: uint16(2261), Ftype: uint16(DPT_PC), Fvalue: ucp_Nd},
	{Fname_offset: uint16(2264), Ftype: uint16(DPT_SC), Fvalue: ucp_Newa},
	{Fname_offset: uint16(2269), Ftype: uint16(DPT_SC), Fvalue: ucp_New_Tai_Lue},
	{Fname_offset: uint16(2279), Ftype: uint16(DPT_SCX), Fvalue: ucp_Nko},
	{Fname_offset: uint16(2283), Ftype: uint16(DPT_SCX), Fvalue: ucp_Nko},
	{Fname_offset: uint16(2288), Ftype: uint16(DPT_PC), Fvalue: ucp_Nl},
	{Fname_offset: uint16(2291), Ftype: uint16(DPT_PC), Fvalue: ucp_No},
	{Fname_offset: uint16(2294), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Noncharacter_Code_Point},
	{Fname_offset: uint16(2316), Ftype: uint16(DPT_SC), Fvalue: ucp_Nushu},
	{Fname_offset: uint16(2321), Ftype: uint16(DPT_SC), Fvalue: ucp_Nushu},
	{Fname_offset: uint16(2327), Ftype: uint16(DPT_SC), Fvalue: ucp_Nyiakeng_Puachue_Hmong},
	{Fname_offset: uint16(2348), Ftype: uint16(DPT_SC), Fvalue: ucp_Ogham},
	{Fname_offset: uint16(2353), Ftype: uint16(DPT_SC), Fvalue: ucp_Ogham},
	{Fname_offset: uint16(2359), Ftype: uint16(DPT_SC), Fvalue: ucp_Ol_Chiki},
	{Fname_offset: uint16(2367), Ftype: uint16(DPT_SC), Fvalue: ucp_Ol_Chiki},
	{Fname_offset: uint16(2372), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Hungarian},
	{Fname_offset: uint16(2385), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Italic},
	{Fname_offset: uint16(2395), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_North_Arabian},
	{Fname_offset: uint16(2411), Ftype: uint16(DPT_SCX), Fvalue: ucp_Old_Permic},
	{Fname_offset: uint16(2421), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Persian},
	{Fname_offset: uint16(2432), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Sogdian},
	{Fname_offset: uint16(2443), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_South_Arabian},
	{Fname_offset: uint16(2459), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Turkic},
	{Fname_offset: uint16(2469), Ftype: uint16(DPT_SCX), Fvalue: ucp_Old_Uyghur},
	{Fname_offset: uint16(2479), Ftype: uint16(DPT_SCX), Fvalue: ucp_Oriya},
	{Fname_offset: uint16(2485), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Turkic},
	{Fname_offset: uint16(2490), Ftype: uint16(DPT_SCX), Fvalue: ucp_Oriya},
	{Fname_offset: uint16(2495), Ftype: uint16(DPT_SC), Fvalue: ucp_Osage},
	{Fname_offset: uint16(2501), Ftype: uint16(DPT_SC), Fvalue: ucp_Osage},
	{Fname_offset: uint16(2506), Ftype: uint16(DPT_SC), Fvalue: ucp_Osmanya},
	{Fname_offset: uint16(2511), Ftype: uint16(DPT_SC), Fvalue: ucp_Osmanya},
	{Fname_offset: uint16(2519), Ftype: uint16(DPT_SCX), Fvalue: ucp_Old_Uyghur},
	{Fname_offset: uint16(2524), Ftype: uint16(DPT_GC), Fvalue: ucp_P},
	{Fname_offset: uint16(2526), Ftype: uint16(DPT_SC), Fvalue: ucp_Pahawh_Hmong},
	{Fname_offset: uint16(2538), Ftype: uint16(DPT_SC), Fvalue: ucp_Palmyrene},
	{Fname_offset: uint16(2543), Ftype: uint16(DPT_SC), Fvalue: ucp_Palmyrene},
	{Fname_offset: uint16(2553), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Pattern_Syntax},
	{Fname_offset: uint16(2560), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Pattern_Syntax},
	{Fname_offset: uint16(2574), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Pattern_White_Space},
	{Fname_offset: uint16(2592), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Pattern_White_Space},
	{Fname_offset: uint16(2598), Ftype: uint16(DPT_SC), Fvalue: ucp_Pau_Cin_Hau},
	{Fname_offset: uint16(2603), Ftype: uint16(DPT_SC), Fvalue: ucp_Pau_Cin_Hau},
	{Fname_offset: uint16(2613), Ftype: uint16(DPT_PC), Fvalue: ucp_Pc},
	{Fname_offset: uint16(2616), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Prepended_Concatenation_Mark},
	{Fname_offset: uint16(2620), Ftype: uint16(DPT_PC), Fvalue: ucp_Pd},
	{Fname_offset: uint16(2623), Ftype: uint16(DPT_PC), Fvalue: ucp_Pe},
	{Fname_offset: uint16(2626), Ftype: uint16(DPT_SCX), Fvalue: ucp_Old_Permic},
	{Fname_offset: uint16(2631), Ftype: uint16(DPT_PC), Fvalue: ucp_Pf},
	{Fname_offset: uint16(2634), Ftype: uint16(DPT_SCX), Fvalue: ucp_Phags_Pa},
	{Fname_offset: uint16(2639), Ftype: uint16(DPT_SCX), Fvalue: ucp_Phags_Pa},
	{Fname_offset: uint16(2647), Ftype: uint16(DPT_SC), Fvalue: ucp_Inscriptional_Pahlavi},
	{Fname_offset: uint16(2652), Ftype: uint16(DPT_SCX), Fvalue: ucp_Psalter_Pahlavi},
	{Fname_offset: uint16(2657), Ftype: uint16(DPT_SC), Fvalue: ucp_Phoenician},
	{Fname_offset: uint16(2662), Ftype: uint16(DPT_SC), Fvalue: ucp_Phoenician},
	{Fname_offset: uint16(2673), Ftype: uint16(DPT_PC), Fvalue: ucp_Pi},
	{Fname_offset: uint16(2676), Ftype: uint16(DPT_SC), Fvalue: ucp_Miao},
	{Fname_offset: uint16(2681), Ftype: uint16(DPT_PC), Fvalue: ucp_Po},
	{Fname_offset: uint16(2684), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Prepended_Concatenation_Mark},
	{Fname_offset: uint16(2711), Ftype: uint16(DPT_SC), Fvalue: ucp_Inscriptional_Parthian},
	{Fname_offset: uint16(2716), Ftype: uint16(DPT_PC), Fvalue: ucp_Ps},
	{Fname_offset: uint16(2719), Ftype: uint16(DPT_SCX), Fvalue: ucp_Psalter_Pahlavi},
	{Fname_offset: uint16(2734), Ftype: uint16(DPT_SCX), Fvalue: ucp_Coptic},
	{Fname_offset: uint16(2739), Ftype: uint16(DPT_SC), Fvalue: ucp_Inherited},
	{Fname_offset: uint16(2744), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Quotation_Mark},
	{Fname_offset: uint16(2750), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Quotation_Mark},
	{Fname_offset: uint16(2764), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Radical},
	{Fname_offset: uint16(2772), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Regional_Indicator},
	{Fname_offset: uint16(2790), Ftype: uint16(DPT_SC), Fvalue: ucp_Rejang},
	{Fname_offset: uint16(2797), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Regional_Indicator},
	{Fname_offset: uint16(2800), Ftype: uint16(DPT_SC), Fvalue: ucp_Rejang},
	{Fname_offset: uint16(2805), Ftype: uint16(DPT_SCX), Fvalue: ucp_Hanifi_Rohingya},
	{Fname_offset: uint16(2810), Ftype: uint16(DPT_SC), Fvalue: ucp_Runic},
	{Fname_offset: uint16(2816), Ftype: uint16(DPT_SC), Fvalue: ucp_Runic},
	{Fname_offset: uint16(2821), Ftype: uint16(DPT_GC), Fvalue: ucp_S},
	{Fname_offset: uint16(2823), Ftype: uint16(DPT_SC), Fvalue: ucp_Samaritan},
	{Fname_offset: uint16(2833), Ftype: uint16(DPT_SC), Fvalue: ucp_Samaritan},
	{Fname_offset: uint16(2838), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_South_Arabian},
	{Fname_offset: uint16(2843), Ftype: uint16(DPT_SC), Fvalue: ucp_Saurashtra},
	{Fname_offset: uint16(2848), Ftype: uint16(DPT_SC), Fvalue: ucp_Saurashtra},
	{Fname_offset: uint16(2859), Ftype: uint16(DPT_PC), Fvalue: ucp_Sc},
	{Fname_offset: uint16(2862), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Soft_Dotted},
	{Fname_offset: uint16(2865), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Sentence_Terminal},
	{Fname_offset: uint16(2882), Ftype: uint16(DPT_SC), Fvalue: ucp_SignWriting},
	{Fname_offset: uint16(2887), Ftype: uint16(DPT_SCX), Fvalue: ucp_Sharada},
	{Fname_offset: uint16(2895), Ftype: uint16(DPT_SC), Fvalue: ucp_Shavian},
	{Fname_offset: uint16(2903), Ftype: uint16(DPT_SC), Fvalue: ucp_Shavian},
	{Fname_offset: uint16(2908), Ftype: uint16(DPT_SCX), Fvalue: ucp_Sharada},
	{Fname_offset: uint16(2913), Ftype: uint16(DPT_SC), Fvalue: ucp_Siddham},
	{Fname_offset: uint16(2918), Ftype: uint16(DPT_SC), Fvalue: ucp_Siddham},
	{Fname_offset: uint16(2926), Ftype: uint16(DPT_SC), Fvalue: ucp_SignWriting},
	{Fname_offset: uint16(2938), Ftype: uint16(DPT_SCX), Fvalue: ucp_Khudawadi},
	{Fname_offset: uint16(2943), Ftype: uint16(DPT_SCX), Fvalue: ucp_Sinhala},
	{Fname_offset: uint16(2948), Ftype: uint16(DPT_SCX), Fvalue: ucp_Sinhala},
	{Fname_offset: uint16(2956), Ftype: uint16(DPT_PC), Fvalue: ucp_Sk},
	{Fname_offset: uint16(2959), Ftype: uint16(DPT_PC), Fvalue: ucp_Sm},
	{Fname_offset: uint16(2962), Ftype: uint16(DPT_PC), Fvalue: ucp_So},
	{Fname_offset: uint16(2965), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Soft_Dotted},
	{Fname_offset: uint16(2976), Ftype: uint16(DPT_SCX), Fvalue: ucp_Sogdian},
	{Fname_offset: uint16(2981), Ftype: uint16(DPT_SCX), Fvalue: ucp_Sogdian},
	{Fname_offset: uint16(2989), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Sogdian},
	{Fname_offset: uint16(2994), Ftype: uint16(DPT_SC), Fvalue: ucp_Sora_Sompeng},
	{Fname_offset: uint16(2999), Ftype: uint16(DPT_SC), Fvalue: ucp_Sora_Sompeng},
	{Fname_offset: uint16(3011), Ftype: uint16(DPT_SC), Fvalue: ucp_Soyombo},
	{Fname_offset: uint16(3016), Ftype: uint16(DPT_SC), Fvalue: ucp_Soyombo},
	{Fname_offset: uint16(3024), Ftype: uint16(DPT_BOOL), Fvalue: ucp_White_Space},
	{Fname_offset: uint16(3030), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Sentence_Terminal},
	{Fname_offset: uint16(3036), Ftype: uint16(DPT_SC), Fvalue: ucp_Sundanese},
	{Fname_offset: uint16(3041), Ftype: uint16(DPT_SC), Fvalue: ucp_Sundanese},
	{Fname_offset: uint16(3051), Ftype: uint16(DPT_SCX), Fvalue: ucp_Syloti_Nagri},
	{Fname_offset: uint16(3056), Ftype: uint16(DPT_SCX), Fvalue: ucp_Syloti_Nagri},
	{Fname_offset: uint16(3068), Ftype: uint16(DPT_SCX), Fvalue: ucp_Syriac},
	{Fname_offset: uint16(3073), Ftype: uint16(DPT_SCX), Fvalue: ucp_Syriac},
	{Fname_offset: uint16(3080), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tagalog},
	{Fname_offset: uint16(3088), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tagbanwa},
	{Fname_offset: uint16(3093), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tagbanwa},
	{Fname_offset: uint16(3102), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tai_Le},
	{Fname_offset: uint16(3108), Ftype: uint16(DPT_SC), Fvalue: ucp_Tai_Tham},
	{Fname_offset: uint16(3116), Ftype: uint16(DPT_SC), Fvalue: ucp_Tai_Viet},
	{Fname_offset: uint16(3124), Ftype: uint16(DPT_SCX), Fvalue: ucp_Takri},
	{Fname_offset: uint16(3129), Ftype: uint16(DPT_SCX), Fvalue: ucp_Takri},
	{Fname_offset: uint16(3135), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tai_Le},
	{Fname_offset: uint16(3140), Ftype: uint16(DPT_SC), Fvalue: ucp_New_Tai_Lue},
	{Fname_offset: uint16(3145), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tamil},
	{Fname_offset: uint16(3151), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tamil},
	{Fname_offset: uint16(3156), Ftype: uint16(DPT_SC), Fvalue: ucp_Tangut},
	{Fname_offset: uint16(3161), Ftype: uint16(DPT_SC), Fvalue: ucp_Tangsa},
	{Fname_offset: uint16(3168), Ftype: uint16(DPT_SC), Fvalue: ucp_Tangut},
	{Fname_offset: uint16(3175), Ftype: uint16(DPT_SC), Fvalue: ucp_Tai_Viet},
	{Fname_offset: uint16(3180), Ftype: uint16(DPT_SCX), Fvalue: ucp_Telugu},
	{Fname_offset: uint16(3185), Ftype: uint16(DPT_SCX), Fvalue: ucp_Telugu},
	{Fname_offset: uint16(3192), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Terminal_Punctuation},
	{Fname_offset: uint16(3197), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Terminal_Punctuation},
	{Fname_offset: uint16(3217), Ftype: uint16(DPT_SC), Fvalue: ucp_Tifinagh},
	{Fname_offset: uint16(3222), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tagalog},
	{Fname_offset: uint16(3227), Ftype: uint16(DPT_SCX), Fvalue: ucp_Thaana},
	{Fname_offset: uint16(3232), Ftype: uint16(DPT_SCX), Fvalue: ucp_Thaana},
	{Fname_offset: uint16(3239), Ftype: uint16(DPT_SC), Fvalue: ucp_Thai},
	{Fname_offset: uint16(3244), Ftype: uint16(DPT_SC), Fvalue: ucp_Tibetan},
	{Fname_offset: uint16(3252), Ftype: uint16(DPT_SC), Fvalue: ucp_Tibetan},
	{Fname_offset: uint16(3257), Ftype: uint16(DPT_SC), Fvalue: ucp_Tifinagh},
	{Fname_offset: uint16(3266), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tirhuta},
	{Fname_offset: uint16(3271), Ftype: uint16(DPT_SCX), Fvalue: ucp_Tirhuta},
	{Fname_offset: uint16(3279), Ftype: uint16(DPT_SC), Fvalue: ucp_Tangsa},
	{Fname_offset: uint16(3284), Ftype: uint16(DPT_SC), Fvalue: ucp_Toto},
	{Fname_offset: uint16(3289), Ftype: uint16(DPT_SC), Fvalue: ucp_Ugaritic},
	{Fname_offset: uint16(3294), Ftype: uint16(DPT_SC), Fvalue: ucp_Ugaritic},
	{Fname_offset: uint16(3303), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Unified_Ideograph},
	{Fname_offset: uint16(3309), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Unified_Ideograph},
	{Fname_offset: uint16(3326), Ftype: uint16(DPT_SC), Fvalue: ucp_Unknown},
	{Fname_offset: uint16(3334), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Uppercase},
	{Fname_offset: uint16(3340), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Uppercase},
	{Fname_offset: uint16(3350), Ftype: uint16(DPT_SC), Fvalue: ucp_Vai},
	{Fname_offset: uint16(3354), Ftype: uint16(DPT_SC), Fvalue: ucp_Vai},
	{Fname_offset: uint16(3359), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Variation_Selector},
	{Fname_offset: uint16(3377), Ftype: uint16(DPT_SC), Fvalue: ucp_Vithkuqi},
	{Fname_offset: uint16(3382), Ftype: uint16(DPT_SC), Fvalue: ucp_Vithkuqi},
	{Fname_offset: uint16(3391), Ftype: uint16(DPT_BOOL), Fvalue: ucp_Variation_Selector},
	{Fname_offset: uint16(3394), Ftype: uint16(DPT_SC), Fvalue: ucp_Wancho},
	{Fname_offset: uint16(3401), Ftype: uint16(DPT_SC), Fvalue: ucp_Warang_Citi},
	{Fname_offset: uint16(3406), Ftype: uint16(DPT_SC), Fvalue: ucp_Warang_Citi},
	{Fname_offset: uint16(3417), Ftype: uint16(DPT_SC), Fvalue: ucp_Wancho},
	{Fname_offset: uint16(3422), Ftype: uint16(DPT_BOOL), Fvalue: ucp_White_Space},
	{Fname_offset: uint16(3433), Ftype: uint16(DPT_BOOL), Fvalue: ucp_White_Space},
	{Fname_offset: uint16(3440), Ftype: uint16(DPT_ALNUM)},
	{Fname_offset: uint16(3444), Ftype: uint16(DPT_BOOL), Fvalue: ucp_XID_Continue},
	{Fname_offset: uint16(3449), Ftype: uint16(DPT_BOOL), Fvalue: ucp_XID_Continue},
	{Fname_offset: uint16(3461), Ftype: uint16(DPT_BOOL), Fvalue: ucp_XID_Start},
	{Fname_offset: uint16(3466), Ftype: uint16(DPT_BOOL), Fvalue: ucp_XID_Start},
	{Fname_offset: uint16(3475), Ftype: uint16(DPT_SC), Fvalue: ucp_Old_Persian},
	{Fname_offset: uint16(3480), Ftype: uint16(DPT_PXSPACE)},
	{Fname_offset: uint16(3484), Ftype: uint16(DPT_SPACE)},
	{Fname_offset: uint16(3488), Ftype: uint16(DPT_SC), Fvalue: ucp_Cuneiform},
	{Fname_offset: uint16(3493), Ftype: uint16(DPT_UCNC)},
	{Fname_offset: uint16(3497), Ftype: uint16(DPT_WORD)},
	{Fname_offset: uint16(3501), Ftype: uint16(DPT_SCX), Fvalue: ucp_Yezidi},
	{Fname_offset: uint16(3506), Ftype: uint16(DPT_SCX), Fvalue: ucp_Yezidi},
	{Fname_offset: uint16(3513), Ftype: uint16(DPT_SCX), Fvalue: ucp_Yi},
	{Fname_offset: uint16(3516), Ftype: uint16(DPT_SCX), Fvalue: ucp_Yi},
	{Fname_offset: uint16(3521), Ftype: uint16(DPT_GC), Fvalue: ucp_Z},
	{Fname_offset: uint16(3523), Ftype: uint16(DPT_SC), Fvalue: ucp_Zanabazar_Square},
	{Fname_offset: uint16(3539), Ftype: uint16(DPT_SC), Fvalue: ucp_Zanabazar_Square},
	{Fname_offset: uint16(3544), Ftype: uint16(DPT_SC), Fvalue: ucp_Inherited},
	{Fname_offset: uint16(3549), Ftype: uint16(DPT_PC), Fvalue: ucp_Zl},
	{Fname_offset: uint16(3552), Ftype: uint16(DPT_PC), Fvalue: ucp_Zp},
	{Fname_offset: uint16(3555), Ftype: uint16(DPT_PC), Fvalue: ucp_Zs},
	{Fname_offset: uint16(3558), Ftype: uint16(DPT_SC), Fvalue: ucp_Common},
	{Fname_offset: uint16(3563), Ftype: uint16(DPT_SC), Fvalue: ucp_Unknown},
} /* pcre2_ucptables.c:1031:22 */

var X_pcre2_utt_size_8 uint64 = uint64(unsafe.Sizeof(X_pcre2_utt_8)) / uint64(unsafe.Sizeof(Tucp_type_table{})) /* pcre2_ucptables.c:1520:14 */

// End of pcre2_ucptables.c

// End of pcre2_tables.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// The tables herein are needed only when UCP support is built, and in PCRE2
// that happens automatically with UTF support. This module should not be
// referenced otherwise, so it should not matter whether it is compiled or not.
// However a comment was received about space saving - maybe the guy linked all
// the modules rather than using a library - so we include a condition to cut out
// the tables when not needed. But don't leave a totally empty module because some
// compilers barf at that. Instead, just supply some small dummy tables.

// Total size: 111116 bytes, block size: 128.

var X_pcre2_unicode_version_8 uintptr = ts + 11252 /* "14.0.0" */ /* pcre2_ucd.c:79:12 */

// When recompiling tables with a new Unicode version, please check the types
// in this structure definition with those in pcre2_internal.h (the actual field
// names will be different).
//
// typedef struct {
// uint8_t property_0;
// uint8_t property_1;
// uint8_t property_2;
// uint8_t property_3;
// int32_t property_4;
// uint16_t property_5;
// uint16_t property_6;
// } ucd_record;

// If the 32-bit library is run in non-32-bit mode, character values greater
// than 0x10ffff may be encountered. For these we set up a special record.

// This table contains lists of characters that are caseless sets of
// more than one character. Each list is terminated by NOTACHAR.

var X_pcre2_ucd_caseless_sets_8 = [112]uint32{
	DNOTACHAR,
	uint32(0x0053), uint32(0x0073), uint32(0x017f), DNOTACHAR,
	uint32(0x01c4), uint32(0x01c5), uint32(0x01c6), DNOTACHAR,
	uint32(0x01c7), uint32(0x01c8), uint32(0x01c9), DNOTACHAR,
	uint32(0x01ca), uint32(0x01cb), uint32(0x01cc), DNOTACHAR,
	uint32(0x01f1), uint32(0x01f2), uint32(0x01f3), DNOTACHAR,
	uint32(0x0345), uint32(0x0399), uint32(0x03b9), uint32(0x1fbe), DNOTACHAR,
	uint32(0x00b5), uint32(0x039c), uint32(0x03bc), DNOTACHAR,
	uint32(0x03a3), uint32(0x03c2), uint32(0x03c3), DNOTACHAR,
	uint32(0x0392), uint32(0x03b2), uint32(0x03d0), DNOTACHAR,
	uint32(0x0398), uint32(0x03b8), uint32(0x03d1), uint32(0x03f4), DNOTACHAR,
	uint32(0x03a6), uint32(0x03c6), uint32(0x03d5), DNOTACHAR,
	uint32(0x03a0), uint32(0x03c0), uint32(0x03d6), DNOTACHAR,
	uint32(0x039a), uint32(0x03ba), uint32(0x03f0), DNOTACHAR,
	uint32(0x03a1), uint32(0x03c1), uint32(0x03f1), DNOTACHAR,
	uint32(0x0395), uint32(0x03b5), uint32(0x03f5), DNOTACHAR,
	uint32(0x0412), uint32(0x0432), uint32(0x1c80), DNOTACHAR,
	uint32(0x0414), uint32(0x0434), uint32(0x1c81), DNOTACHAR,
	uint32(0x041e), uint32(0x043e), uint32(0x1c82), DNOTACHAR,
	uint32(0x0421), uint32(0x0441), uint32(0x1c83), DNOTACHAR,
	uint32(0x0422), uint32(0x0442), uint32(0x1c84), uint32(0x1c85), DNOTACHAR,
	uint32(0x042a), uint32(0x044a), uint32(0x1c86), DNOTACHAR,
	uint32(0x0462), uint32(0x0463), uint32(0x1c87), DNOTACHAR,
	uint32(0x1e60), uint32(0x1e61), uint32(0x1e9b), DNOTACHAR,
	uint32(0x03a9), uint32(0x03c9), uint32(0x2126), DNOTACHAR,
	uint32(0x004b), uint32(0x006b), uint32(0x212a), DNOTACHAR,
	uint32(0x00c5), uint32(0x00e5), uint32(0x212b), DNOTACHAR,
	uint32(0x1c88), uint32(0xa64a), uint32(0xa64b), DNOTACHAR,
} /* pcre2_ucd.c:114:16 */

// When #included in pcre2test, we don't need the table of digit sets, nor the
// the large main UCD tables.

// This table lists the code points for the '9' characters in each set of
// decimal digits. It is used to ensure that all the digits in a script run come
// from the same set.

var X_pcre2_ucd_digit_sets_8 = [67]uint32{
	uint32(66), // Number of subsequent values
	uint32(0x00039), uint32(0x00669), uint32(0x006f9), uint32(0x007c9), uint32(0x0096f), uint32(0x009ef), uint32(0x00a6f), uint32(0x00aef),
	uint32(0x00b6f), uint32(0x00bef), uint32(0x00c6f), uint32(0x00cef), uint32(0x00d6f), uint32(0x00def), uint32(0x00e59), uint32(0x00ed9),
	uint32(0x00f29), uint32(0x01049), uint32(0x01099), uint32(0x017e9), uint32(0x01819), uint32(0x0194f), uint32(0x019d9), uint32(0x01a89),
	uint32(0x01a99), uint32(0x01b59), uint32(0x01bb9), uint32(0x01c49), uint32(0x01c59), uint32(0x0a629), uint32(0x0a8d9), uint32(0x0a909),
	uint32(0x0a9d9), uint32(0x0a9f9), uint32(0x0aa59), uint32(0x0abf9), uint32(0x0ff19), uint32(0x104a9), uint32(0x10d39), uint32(0x1106f),
	uint32(0x110f9), uint32(0x1113f), uint32(0x111d9), uint32(0x112f9), uint32(0x11459), uint32(0x114d9), uint32(0x11659), uint32(0x116c9),
	uint32(0x11739), uint32(0x118e9), uint32(0x11959), uint32(0x11c59), uint32(0x11d59), uint32(0x11da9), uint32(0x16a69), uint32(0x16ac9),
	uint32(0x16b59), uint32(0x1d7d7), uint32(0x1d7e1), uint32(0x1d7eb), uint32(0x1d7f5), uint32(0x1d7ff), uint32(0x1e149), uint32(0x1e2f9),
	uint32(0x1e959), uint32(0x1fbf9),
} /* pcre2_ucd.c:154:16 */

// This vector is a list of script bitsets for the Script Extension property.
// The number of 32-bit words in each bitset is #defined in pcre2_ucp.h as
// ucd_script_sets_item_size.

var X_pcre2_ucd_script_sets_8 = [189]uint32{
	0x00000000, 0x00000000, 0x00000000,
	0x00000080, 0x00000000, 0x00000000,
	0x00000040, 0x00000000, 0x00000000,
	0x00000000, 0x00004000, 0x00000000,
	0x00000002, 0x00000000, 0x00000000,
	0x00800000, 0x00000000, 0x00000000,
	0x00000001, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000001,
	0x00000010, 0x00000000, 0x00000000,
	0x00000008, 0x00000004, 0x00000000,
	0x00000008, 0x40000000, 0x00000000,
	0x00000008, 0x00000040, 0x00000000,
	0x00000018, 0x00000000, 0x00000000,
	0x00000028, 0x00000000, 0x00000000,
	0x000000c0, 0x00000000, 0x00000000,
	0x00c00000, 0x00000000, 0x00000000,
	0x00000000, 0x00000102, 0x00000000,
	0x80000000, 0x00000001, 0x00000000,
	0x00000004, 0x00000008, 0x00000000,
	0x00000005, 0x00000000, 0x00000000,
	0x00000004, 0x00200000, 0x00000000,
	0x00000014, 0x00000000, 0x00000000,
	0x00000040, 0x00008000, 0x00000000,
	0x00000040, 0x00000000, 0x00000001,
	0x00000040, 0x00001000, 0x00000000,
	0x00000840, 0x00000000, 0x00000000,
	0x00020001, 0x00000000, 0x00000000,
	0x00000800, 0x00008000, 0x00000000,
	0x00000200, 0x00010000, 0x00000000,
	0x00000100, 0x02000000, 0x00000000,
	0x00800001, 0x00000000, 0x00000000,
	0x00300000, 0x00000000, 0x00000000,
	0x00002000, 0x00000000, 0x00000001,
	0x00080001, 0x00000000, 0x00000000,
	0x00000000, 0x00080000, 0x00000008,
	0x00080000, 0x00000020, 0x00000000,
	0x00000038, 0x00000000, 0x00000000,
	0x00000028, 0x00000000, 0x00000002,
	0x00000080, 0x00000810, 0x00000000,
	0x40010000, 0x00000800, 0x00000000,
	0x80000000, 0x00000001, 0x00000004,
	0x80000000, 0x00020001, 0x00000000,
	0x00002040, 0x00008000, 0x00000000,
	0x00000041, 0x00008000, 0x00000000,
	0x00b00000, 0x00000000, 0x00000000,
	0x00010001, 0x00000080, 0x00000000,
	0x000020c0, 0x00008000, 0x00000000,
	0x1e000000, 0x00000000, 0x00000000,
	0x00000040, 0x10040200, 0x00000000,
	0x00f40000, 0x00000000, 0x00000000,
	0x00000038, 0x40000040, 0x00000002,
	0x01f40000, 0x00000000, 0x00000000,
	0x00007c40, 0x00000000, 0x00000000,
	0x00000038, 0x44000040, 0x00000002,
	0x000034c0, 0x01008000, 0x00000001,
	0x00000018, 0xc4480400, 0x00000008,
	0x00000340, 0x11952200, 0x00000000,
	0x00007fc1, 0x01008000, 0x00000000,
	0x00007fc1, 0x01009000, 0x00000000,
	0x00002340, 0x11952200, 0x00000001,
	0x00006340, 0x11952200, 0x00000001,
	0x0000ffc0, 0x3984a010, 0x00000001,
	0x2000ffc0, 0x3984a010, 0x00000001,
} /* pcre2_ucd.c:171:16 */

// This vector is a list of bitsets for Boolean properties. The number of
// 32_bit words in each bitset is #defined as ucd_boolprop_sets_item_size in
// pcre2_ucp.h.

var X_pcre2_ucd_boolprop_sets_8 = [354]uint32{
	0x00000000, 0x00000000,
	0x00000001, 0x00000000,
	0x00000001, 0x00020040,
	0x00800001, 0x00020040,
	0x00800001, 0x00002820,
	0x00800001, 0x00000120,
	0x00830001, 0x00000020,
	0x00800001, 0x00000020,
	0x00800021, 0x00000120,
	0x00800011, 0x00000020,
	0x00800001, 0x00000028,
	0x00800001, 0x00002020,
	0x00801001, 0x00000020,
	0x00800021, 0x00002820,
	0x24830003, 0x00040000,
	0x00800021, 0x00002020,
	0x00800011, 0x00000028,
	0x648003c7, 0x000c8000,
	0x608003c5, 0x000c8000,
	0x00808021, 0x00000028,
	0x20800001, 0x00040000,
	0x00808021, 0x00000020,
	0x64800d47, 0x000c0004,
	0x60800d45, 0x000c0004,
	0x60800d45, 0x000c1004,
	0x00000000, 0x00020040,
	0x00800000, 0x00020000,
	0x00800000, 0x00000020,
	0x00808020, 0x00000000,
	0x00a10000, 0x00000020,
	0x60800044, 0x000c0004,
	0x00800010, 0x00000120,
	0x00800000, 0x00000028,
	0x00002020, 0x00000000,
	0x00800000, 0x00000000,
	0x60800dc4, 0x000c0004,
	0x20c08020, 0x00040000,
	0x608003c4, 0x000c8000,
	0x60800d44, 0x000c0004,
	0x60800d44, 0x000c1004,
	0x60804dc4, 0x000c0004,
	0x60800004, 0x000c0000,
	0x608007c4, 0x000c8000,
	0x60800bc4, 0x000c0000,
	0x60808064, 0x000c0004,
	0x60808064, 0x000c1004,
	0x60808024, 0x000c0000,
	0x60c08024, 0x000c0000,
	0x21008020, 0x00040000,
	0x21008de4, 0x00040004,
	0x21002020, 0x00040000,
	0x21000020, 0x00040000,
	0x60808064, 0x00000004,
	0x00800000, 0x00002000,
	0x20800020, 0x00042000,
	0x60800dc4, 0x000c000c,
	0x60800044, 0x000c8008,
	0x60800044, 0x000c8000,
	0x608003c4, 0x000c8008,
	0x00800000, 0x00000008,
	0x01000020, 0x00000000,
	0x00800020, 0x00000000,
	0x00800000, 0x00002800,
	0x00801000, 0x00000000,
	0x21008024, 0x00040000,
	0x21000024, 0x00040000,
	0x00000020, 0x00000080,
	0x00002028, 0x00000000,
	0x60c00024, 0x000c0000,
	0x20800000, 0x00040000,
	0x60804004, 0x000c0000,
	0x60800024, 0x000c0000,
	0x20800004, 0x00040000,
	0x23008020, 0x00040000,
	0x21000004, 0x00040000,
	0x21408020, 0x00040000,
	0x60800004, 0x00040000,
	0x23000024, 0x00040000,
	0x60800004, 0x000c0002,
	0x00800010, 0x00000000,
	0x20808000, 0x00040000,
	0x21004024, 0x00040000,
	0x20808004, 0x00040000,
	0x60800944, 0x000c0004,
	0x60802004, 0x000c0000,
	0x60800344, 0x000c8000,
	0x22808000, 0x00040000,
	0x22800000, 0x00040000,
	0x00c00000, 0x00000000,
	0x21002020, 0x00050000,
	0x61000024, 0x000c0000,
	0x23000020, 0x00040000,
	0x01008020, 0x00000000,
	0x21408024, 0x00040000,
	0x00808000, 0x00000000,
	0x60800064, 0x000c0004,
	0x60800044, 0x000c1004,
	0x60800064, 0x000c1004,
	0x01002020, 0x00000001,
	0x00022020, 0x00000001,
	0x00002028, 0x00000040,
	0x00801000, 0x00000020,
	0x00800020, 0x00000120,
	0x00800000, 0x00000120,
	0x00800020, 0x00000020,
	0x00a10000, 0x00002820,
	0x00800000, 0x00002820,
	0x20800000, 0x00040008,
	0x00800010, 0x00000020,
	0x00002020, 0x00000008,
	0x00002000, 0x00000000,
	0x00006020, 0x00000000,
	0x00801000, 0x00000008,
	0x00800010, 0x00000008,
	0x21000020, 0x00040008,
	0x01020020, 0x00000000,
	0x60800044, 0x000c000c,
	0x60800000, 0x000c0008,
	0x00a10000, 0x00000000,
	0x60800000, 0x000c0000,
	0x60800004, 0x000c0008,
	0x60a10044, 0x000c0004,
	0x60800044, 0x000c100c,
	0x00a10000, 0x00000028,
	0x00800010, 0x00000028,
	0x00801000, 0x00000028,
	0x00b10000, 0x00000020,
	0x00804010, 0x00000020,
	0x00a00000, 0x00000020,
	0x00000000, 0x00000020,
	0x008003c4, 0x00008000,
	0x00a103c4, 0x00008000,
	0x00800d44, 0x00000004,
	0x00b10000, 0x00000028,
	0x00a00000, 0x00000028,
	0x00a90000, 0x00000020,
	0x00b90000, 0x00000020,
	0x00808024, 0x00000020,
	0x00800000, 0x00002020,
	0x00800000, 0x00000200,
	0x08800000, 0x00000000,
	0x10800000, 0x00000000,
	0xe0800004, 0x000c0000,
	0x21008000, 0x00040000,
	0x00a11000, 0x00000020,
	0x60808020, 0x00000000,
	0xe0800004, 0x000c4000,
	0x60808004, 0x000c0000,
	0x60800004, 0x00000000,
	0x00000000, 0x00000010,
	0x21022020, 0x00050000,
	0x00800000, 0x00000100,
	0x00800020, 0x00002800,
	0x00800020, 0x00002000,
	0x00800020, 0x00000100,
	0x24800000, 0x00040000,
	0x648003c4, 0x000c8000,
	0x00808020, 0x00000008,
	0x64800d44, 0x000c0004,
	0x00800010, 0x00000100,
	0x61008024, 0x00040000,
	0x00000020, 0x00000000,
	0x60c00004, 0x000c0000,
	0x21400020, 0x00040000,
	0xa1000020, 0x00040000,
	0x21000000, 0x00040000,
	0x00a00000, 0x00000000,
	0x00b10000, 0x00000000,
	0x00200000, 0x00000000,
	0x00800044, 0x00008000,
	0x00a10044, 0x00008000,
	0x00930000, 0x00000400,
	0x00b90000, 0x00000000,
	0x00a90000, 0x00000000,
	0x00970020, 0x00000000,
	0x00b30000, 0x00000000,
	0x01022020, 0x00000000,
} /* pcre2_ucd.c:241:16 */

// These are the main two-stage UCD tables. The fields in each record are:
// script (8 bits), character type (8 bits), grapheme break property (8 bits),
// offset to multichar other cases or zero (8 bits), offset to other case or zero
// (32 bits, signed), bidi class (5 bits) and script extension (11 bits) packed
// into a 16-bit field, and offset in binary properties table (16 bits).

var X_pcre2_ucd_records_8 = [1409]Tucd_record{ // 16908 bytes, record size 12
	{Fscript: uint8(69), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(2)},                                                                   //   0
	{Fscript: uint8(69), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(43008), Fbprops: uint16(4)},                                                                  //   1
	{Fscript: uint8(69), Fgbprop: uint8(1), Fscriptx_bidiclass: uint16(4096), Fbprops: uint16(4)},                                                                   //   2
	{Fscript: uint8(69), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(45056), Fbprops: uint16(4)},                                                                  //   3
	{Fscript: uint8(69), Fscriptx_bidiclass: uint16(4096), Fbprops: uint16(4)},                                                                                      //   4
	{Fscript: uint8(69), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(4096), Fbprops: uint16(2)},                                                                   //   5
	{Fscript: uint8(69), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(43008), Fbprops: uint16(2)},                                                                  //   6
	{Fscript: uint8(69), Fchartype: uint8(29), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(45056), Fbprops: uint16(6)},                                           //   7
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(8)},                                           //   8
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(10)},                                          //   9
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(12)},                                          //  10
	{Fscript: uint8(69), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(14)},                                          //  11
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(14)},                                          //  12
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(14)},                                          //  13
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(16)},                                          //  14
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(18)},                                          //  15
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(18)},                                          //  16
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(12)},                                          //  17
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(12288), Fbprops: uint16(20)},                                          //  18
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(22)},                                           //  19
	{Fscript: uint8(69), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(12288), Fbprops: uint16(24)},                                          //  20
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(26)},                                           //  21
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(14)},                                           //  22
	{Fscript: uint8(69), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(10240), Fbprops: uint16(28)},                                          //  23
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(30)},                                           //  24
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(22)},                                          //  25
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(32)},                                          //  26
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(20)},                                          //  27
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(34)},                                              //  28
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(36)},                                              //  29
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(100), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(36)},                        //  30
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(1), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(36)},                          //  31
	{Fscript: uint8(69), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(38)},                                          //  32
	{Fscript: uint8(69), Fchartype: uint8(16), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(40)},                                          //  33
	{Fscript: uint8(69), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(42)},                                          //  34
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(44)},                                             //  35
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(46)},                                             //  36
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(48)},                                             //  37
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(100), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(46)},                       //  38
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(1), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(46)},                         //  39
	{Fscript: uint8(69), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(6144)},                                                                                       //  40
	{Fscript: uint8(69), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(4096), Fbprops: uint16(50)},                                                                  //  41
	{Fscript: uint8(69), Fchartype: uint8(29), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(52)},                                           //  42
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(54)},                                          //  43
	{Fscript: uint8(69), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(54)},                                          //  44
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(54)},                                          //  45
	{Fscript: uint8(69), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(56)},                                          //  46
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(58)},                                          //  47
	{Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(60)},                                                               //  48
	{Fscript: uint8(69), Fchartype: uint8(20), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(62)},                                          //  49
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(64)},                                          //  50
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(66)},                                             //  51
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(54)},                                          //  52
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(64)},                                          //  53
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(10240), Fbprops: uint16(68)},                                          //  54
	{Fscript: uint8(69), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(26), Fother_case: 775, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},    //  55
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(72)},                                          //  56
	{Fscript: uint8(69), Fchartype: uint8(19), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(62)},                                          //  57
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          //  58
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                              //  59
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(104), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                        //  60
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 7615, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                                            //  61
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             //  62
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(104), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                       //  63
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 121, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             //  64
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                               //  65
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                              //  66
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(78)},                                              //  67
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                                               //  68
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                                               //  69
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(60)},                                                               //  70
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(80)},                                                               //  71
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -121, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                            //  72
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(1), Fother_case: -268, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                        //  73
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 195, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             //  74
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 210, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  75
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 206, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  76
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 205, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  77
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 79, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                              //  78
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 202, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  79
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 203, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  80
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 207, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  81
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 97, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                              //  82
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 211, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  83
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 209, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  84
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 163, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             //  85
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 213, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  86
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 130, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             //  87
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 214, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  88
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 218, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  89
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 217, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  90
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 219, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             //  91
	{Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                                               //  92
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 56, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                              //  93
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(5), Fother_case: 2, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(84)},                           //  94
	{Fchartype: uint8(8), Fgbprop: uint8(12), Fcaseset: uint8(5), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(86)},                           //  95
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(5), Fother_case: -2, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          //  96
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(9), Fother_case: 2, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(84)},                           //  97
	{Fchartype: uint8(8), Fgbprop: uint8(12), Fcaseset: uint8(9), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(86)},                           //  98
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(9), Fother_case: -2, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          //  99
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(13), Fother_case: 2, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(84)},                          // 100
	{Fchartype: uint8(8), Fgbprop: uint8(12), Fcaseset: uint8(13), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(86)},                          // 101
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(13), Fother_case: -2, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                         // 102
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -79, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             // 103
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(17), Fother_case: 2, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(84)},                          // 104
	{Fchartype: uint8(8), Fgbprop: uint8(12), Fcaseset: uint8(17), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(86)},                          // 105
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(17), Fother_case: -2, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                         // 106
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -97, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             // 107
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -56, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             // 108
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -130, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                            // 109
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 10795, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                           // 110
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -163, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                            // 111
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 10792, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                           // 112
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 10815, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 113
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -195, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                            // 114
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 69, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                              // 115
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 71, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                              // 116
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 10783, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 117
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 10780, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 118
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 10782, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 119
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -210, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 120
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -206, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 121
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -205, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 122
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -202, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 123
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -203, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 124
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42319, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 125
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42315, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 126
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -207, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 127
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42280, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 128
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42308, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 129
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -209, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(78)},                                            // 130
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -211, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 131
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 10743, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 132
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42305, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 133
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 10749, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 134
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -213, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 135
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -214, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 136
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 10727, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 137
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -218, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 138
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42307, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 139
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42282, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 140
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -69, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             // 141
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -217, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 142
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -71, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             // 143
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -219, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 144
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42261, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(78)},                                           // 145
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 42258, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 146
	{Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(88)},                                                               // 147
	{Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(90)},                                                               // 148
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(92)},                                           // 149
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(92)},                                           // 150
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(88)},                                           // 151
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(94)},                                           // 152
	{Fscript: uint8(22), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(56)},                                          // 153
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 154
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26636), Fbprops: uint16(96)},                                           // 155
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fcaseset: uint8(21), Fother_case: 116, Fscriptx_bidiclass: uint16(26636), Fbprops: uint16(98)},    // 156
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(100)},                                          // 157
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 158
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26642), Fbprops: uint16(102)},                                          // 159
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                            // 160
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                           // 161
	{Fscript: uint8(1), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(56)},                                           // 162
	{Fscript: uint8(68), Fchartype: uint8(2), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432)},                                                                // 163
	{Fscript: uint8(1), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(104)},                                           // 164
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 130, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 165
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(106)},                                         // 166
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 116, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                          // 167
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 38, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 168
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(108)},                                         // 169
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 37, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 170
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 64, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 171
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 63, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 172
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 173
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 174
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(34), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 175
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(59), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 176
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(38), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 177
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(21), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 178
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(51), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 179
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(26), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 180
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(47), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 181
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(55), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 182
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(30), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 183
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(43), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 184
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(96), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 185
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -38, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 186
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -37, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 187
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 188
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(34), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 189
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(59), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 190
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(38), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 191
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(21), Fother_case: -116, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},    // 192
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(51), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 193
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(26), Fother_case: -775, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},    // 194
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(47), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 195
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(55), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 196
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(30), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},       // 197
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(30), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 198
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(43), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 199
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(96), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 200
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -64, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 201
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -63, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 202
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 8, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                            // 203
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(34), Fother_case: -30, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(110)},    // 204
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(38), Fother_case: -25, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(110)},    // 205
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(112)},                                           // 206
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(114)},                                           // 207
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(43), Fother_case: -15, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(110)},    // 208
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(47), Fother_case: -22, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},     // 209
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -8, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                           // 210
	{Fscript: uint8(34), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 211
	{Fscript: uint8(34), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 212
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(51), Fother_case: -54, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(110)},    // 213
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(55), Fother_case: -48, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(110)},    // 214
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 7, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                            // 215
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -116, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(78)},                         // 216
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(38), Fother_case: -60, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(116)},    // 217
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(59), Fother_case: -64, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(110)},    // 218
	{Fscript: uint8(1), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(118)},                                          // 219
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -7, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 220
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(60)},                                            // 221
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -130, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 222
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 80, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 223
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 224
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(63), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 225
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(67), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 226
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(71), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 227
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(75), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 228
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(79), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 229
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(84), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 230
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 231
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(63), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 232
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(67), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 233
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(71), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 234
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(75), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 235
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(79), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 236
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(84), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},     // 237
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -80, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 238
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -80, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(78)},                          // 239
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                            // 240
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                           // 241
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(88), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},       // 242
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(88), Fother_case: -1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},      // 243
	{Fscript: uint8(2), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                           // 244
	{Fscript: uint8(2), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26684), Fbprops: uint16(96)},                                            // 245
	{Fscript: uint8(2), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26678), Fbprops: uint16(96)},                                            // 246
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26681), Fbprops: uint16(96)},                                           // 247
	{Fscript: uint8(2), Fchartype: uint8(11), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(120)},                                           // 248
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 15, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 249
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -15, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 250
	{Fscript: uint8(70), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 48, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                          // 251
	{Fscript: uint8(70), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(92)},                                           // 252
	{Fscript: uint8(70), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 253
	{Fscript: uint8(70), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(122)},                                         // 254
	{Fscript: uint8(70), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(60)},                                           // 255
	{Fscript: uint8(70), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -48, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                         // 256
	{Fscript: uint8(70), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                                           // 257
	{Fscript: uint8(70), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 258
	{Fscript: uint8(70), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(126)},                                         // 259
	{Fscript: uint8(70), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 260
	{Fscript: uint8(70), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                          // 261
	{Fscript: uint8(68), Fchartype: uint8(2), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816)},                                                                // 262
	{Fscript: uint8(71), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 263
	{Fscript: uint8(71), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 264
	{Fscript: uint8(71), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(128)},                                          // 265
	{Fscript: uint8(71), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(126)},                                         // 266
	{Fscript: uint8(71), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 267
	{Fscript: uint8(71), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(106)},                                         // 268
	{Fscript: uint8(71), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 269
	{Fscript: uint8(71), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 270
	{Fscript: uint8(71), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(122)},                                         // 271
	{Fscript: uint8(3), Fchartype: uint8(1), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(2048), Fbprops: uint16(132)},                                             // 272
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(2048), Fbprops: uint16(132)},                                            // 273
	{Fscript: uint8(3), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(118)},                                          // 274
	{Fscript: uint8(3), Fchartype: uint8(25), Fgbprop: uint8(12), Fbprops: uint16(118)},                                                                             // 275
	{Fscript: uint8(3), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                           // 276
	{Fscript: uint8(3), Fchartype: uint8(23), Fgbprop: uint8(12), Fbprops: uint16(68)},                                                                              // 277
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8342), Fbprops: uint16(106)},                                          // 278
	{Fscript: uint8(3), Fchartype: uint8(21), Fgbprop: uint8(12), Fbprops: uint16(68)},                                                                              // 279
	{Fscript: uint8(3), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                           // 280
	{Fscript: uint8(3), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                           // 281
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(150), Fbprops: uint16(106)},                                           // 282
	{Fscript: uint8(3), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(108), Fbprops: uint16(134)},                                              // 283
	{Fscript: uint8(3), Fchartype: uint8(21), Fgbprop: uint8(12), Fbprops: uint16(124)},                                                                             // 284
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(159), Fbprops: uint16(124)},                                           // 285
	{Fscript: uint8(3), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(82)},                                                                               // 286
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(165), Fbprops: uint16(136)},                                            // 287
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26660), Fbprops: uint16(128)},                                          // 288
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26660), Fbprops: uint16(130)},                                          // 289
	{Fscript: uint8(3), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(128)},                                           // 290
	{Fscript: uint8(3), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                            // 291
	{Fscript: uint8(3), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(2159), Fbprops: uint16(138)},                                           // 292
	{Fscript: uint8(3), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(2048), Fbprops: uint16(68)},                                            // 293
	{Fscript: uint8(3), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(140)},                                                                              // 294
	{Fscript: uint8(3), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(30), Fbprops: uint16(124)},                                             // 295
	{Fscript: uint8(3), Fchartype: uint8(6), Fgbprop: uint8(12), Fbprops: uint16(92)},                                                                               // 296
	{Fscript: uint8(3), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(10240), Fbprops: uint16(138)},                                          // 297
	{Fscript: uint8(3), Fchartype: uint8(26), Fgbprop: uint8(12), Fbprops: uint16(68)},                                                                              // 298
	{Fscript: uint8(4), Fchartype: uint8(21), Fgbprop: uint8(12), Fbprops: uint16(124)},                                                                             // 299
	{Fscript: uint8(4), Fchartype: uint8(21), Fgbprop: uint8(12), Fbprops: uint16(106)},                                                                             // 300
	{Fscript: uint8(4), Fchartype: uint8(21), Fgbprop: uint8(12), Fbprops: uint16(68)},                                                                              // 301
	{Fscript: uint8(68), Fchartype: uint8(2), Fgbprop: uint8(12)},                                                                                                   // 302
	{Fscript: uint8(4), Fchartype: uint8(1), Fgbprop: uint8(4), Fbprops: uint16(132)},                                                                               // 303
	{Fscript: uint8(4), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(82)},                                                                               // 304
	{Fscript: uint8(4), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                           // 305
	{Fscript: uint8(4), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(128)},                                           // 306
	{Fscript: uint8(4), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                            // 307
	{Fscript: uint8(5), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(82)},                                                                               // 308
	{Fscript: uint8(5), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(128)},                                           // 309
	{Fscript: uint8(38), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(138)},                                         // 310
	{Fscript: uint8(38), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 311
	{Fscript: uint8(38), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 312
	{Fscript: uint8(38), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(92)},                                           // 313
	{Fscript: uint8(38), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 314
	{Fscript: uint8(38), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 315
	{Fscript: uint8(38), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(106)},                                         // 316
	{Fscript: uint8(38), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(124)},                                         // 317
	{Fscript: uint8(38), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(136)},                                          // 318
	{Fscript: uint8(38), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 319
	{Fscript: uint8(38), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 320
	{Fscript: uint8(110), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 321
	{Fscript: uint8(110), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 322
	{Fscript: uint8(110), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 323
	{Fscript: uint8(110), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(142)},                                         // 324
	{Fscript: uint8(110), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                         // 325
	{Fscript: uint8(110), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(106)},                                        // 326
	{Fscript: uint8(110), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(124)},                                        // 327
	{Fscript: uint8(42), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 328
	{Fscript: uint8(42), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 329
	{Fscript: uint8(42), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(106)},                                         // 330
	{Fscript: uint8(3), Fchartype: uint8(24), Fgbprop: uint8(12), Fbprops: uint16(122)},                                                                             // 331
	{Fscript: uint8(3), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                           // 332
	{Fscript: uint8(6), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                           // 333
	{Fscript: uint8(6), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                           // 334
	{Fscript: uint8(6), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 335
	{Fscript: uint8(6), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                            // 336
	{Fscript: uint8(6), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                           // 337
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26798), Fbprops: uint16(96)},                                           // 338
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26795), Fbprops: uint16(96)},                                           // 339
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18615), Fbprops: uint16(124)},                                         // 340
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18618), Fbprops: uint16(124)},                                         // 341
	{Fscript: uint8(6), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18576), Fbprops: uint16(138)},                                          // 342
	{Fscript: uint8(6), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                           // 343
	{Fscript: uint8(6), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(92)},                                            // 344
	{Fscript: uint8(7), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 345
	{Fscript: uint8(7), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                           // 346
	{Fscript: uint8(7), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                           // 347
	{Fscript: uint8(7), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                            // 348
	{Fscript: uint8(7), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                           // 349
	{Fscript: uint8(7), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                           // 350
	{Fscript: uint8(7), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18546), Fbprops: uint16(138)},                                          // 351
	{Fscript: uint8(7), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                           // 352
	{Fscript: uint8(7), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                           // 353
	{Fscript: uint8(7), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                           // 354
	{Fscript: uint8(7), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                           // 355
	{Fscript: uint8(7), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                           // 356
	{Fscript: uint8(8), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                           // 357
	{Fscript: uint8(8), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                           // 358
	{Fscript: uint8(8), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 359
	{Fscript: uint8(8), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                            // 360
	{Fscript: uint8(8), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                           // 361
	{Fscript: uint8(8), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18519), Fbprops: uint16(138)},                                          // 362
	{Fscript: uint8(8), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                           // 363
	{Fscript: uint8(9), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                           // 364
	{Fscript: uint8(9), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                           // 365
	{Fscript: uint8(9), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 366
	{Fscript: uint8(9), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                            // 367
	{Fscript: uint8(9), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                           // 368
	{Fscript: uint8(9), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18516), Fbprops: uint16(138)},                                          // 369
	{Fscript: uint8(9), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                           // 370
	{Fscript: uint8(9), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                           // 371
	{Fscript: uint8(10), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 372
	{Fscript: uint8(10), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 373
	{Fscript: uint8(10), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 374
	{Fscript: uint8(10), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 375
	{Fscript: uint8(10), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                          // 376
	{Fscript: uint8(10), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 377
	{Fscript: uint8(10), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(150)},                                          // 378
	{Fscript: uint8(10), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 379
	{Fscript: uint8(10), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 380
	{Fscript: uint8(10), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 381
	{Fscript: uint8(11), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 382
	{Fscript: uint8(11), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 383
	{Fscript: uint8(11), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                          // 384
	{Fscript: uint8(11), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 385
	{Fscript: uint8(11), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 386
	{Fscript: uint8(11), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18513), Fbprops: uint16(138)},                                         // 387
	{Fscript: uint8(11), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18513), Fbprops: uint16(68)},                                          // 388
	{Fscript: uint8(11), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28753), Fbprops: uint16(68)},                                          // 389
	{Fscript: uint8(11), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 390
	{Fscript: uint8(11), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                          // 391
	{Fscript: uint8(12), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 392
	{Fscript: uint8(12), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 393
	{Fscript: uint8(12), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 394
	{Fscript: uint8(12), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 395
	{Fscript: uint8(12), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 396
	{Fscript: uint8(12), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 397
	{Fscript: uint8(12), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 398
	{Fscript: uint8(12), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 399
	{Fscript: uint8(12), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 400
	{Fscript: uint8(12), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 401
	{Fscript: uint8(13), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 402
	{Fscript: uint8(13), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 403
	{Fscript: uint8(13), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 404
	{Fscript: uint8(13), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 405
	{Fscript: uint8(13), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 406
	{Fscript: uint8(13), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(130)},                                          // 407
	{Fscript: uint8(13), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                          // 408
	{Fscript: uint8(13), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 409
	{Fscript: uint8(13), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18528), Fbprops: uint16(138)},                                         // 410
	{Fscript: uint8(14), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 411
	{Fscript: uint8(14), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 412
	{Fscript: uint8(14), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 413
	{Fscript: uint8(14), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 414
	{Fscript: uint8(14), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                          // 415
	{Fscript: uint8(14), Fchartype: uint8(7), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 416
	{Fscript: uint8(14), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 417
	{Fscript: uint8(14), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 418
	{Fscript: uint8(14), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 419
	{Fscript: uint8(15), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 420
	{Fscript: uint8(15), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 421
	{Fscript: uint8(15), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 422
	{Fscript: uint8(15), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 423
	{Fscript: uint8(15), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                          // 424
	{Fscript: uint8(15), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 425
	{Fscript: uint8(15), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 426
	{Fscript: uint8(72), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 427
	{Fscript: uint8(72), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 428
	{Fscript: uint8(72), Fchartype: uint8(7), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(152)},                                           // 429
	{Fscript: uint8(72), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(154)},                                          // 430
	{Fscript: uint8(69), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                          // 431
	{Fscript: uint8(72), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(156)},                                          // 432
	{Fscript: uint8(72), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 433
	{Fscript: uint8(72), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 434
	{Fscript: uint8(72), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 435
	{Fscript: uint8(72), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 436
	{Fscript: uint8(72), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 437
	{Fscript: uint8(73), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 438
	{Fscript: uint8(73), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 439
	{Fscript: uint8(73), Fchartype: uint8(7), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(152)},                                           // 440
	{Fscript: uint8(73), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 441
	{Fscript: uint8(73), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(156)},                                          // 442
	{Fscript: uint8(73), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 443
	{Fscript: uint8(73), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 444
	{Fscript: uint8(73), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 445
	{Fscript: uint8(74), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 446
	{Fscript: uint8(74), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 447
	{Fscript: uint8(74), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 448
	{Fscript: uint8(74), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 449
	{Fscript: uint8(74), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 450
	{Fscript: uint8(74), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 451
	{Fscript: uint8(74), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 452
	{Fscript: uint8(74), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(158)},                                         // 453
	{Fscript: uint8(74), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(158)},                                         // 454
	{Fscript: uint8(74), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(160)},                                          // 455
	{Fscript: uint8(74), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 456
	{Fscript: uint8(74), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(162)},                                          // 457
	{Fscript: uint8(74), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 458
	{Fscript: uint8(74), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 459
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 460
	{Fscript: uint8(16), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 461
	{Fscript: uint8(16), Fchartype: uint8(10), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 462
	{Fscript: uint8(16), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 463
	{Fscript: uint8(16), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 464
	{Fscript: uint8(16), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 465
	{Fscript: uint8(16), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 466
	{Fscript: uint8(16), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18549), Fbprops: uint16(138)},                                         // 467
	{Fscript: uint8(16), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 468
	{Fscript: uint8(16), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 469
	{Fscript: uint8(16), Fchartype: uint8(10), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(164)},                                         // 470
	{Fscript: uint8(16), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(128)},                                          // 471
	{Fscript: uint8(16), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 472
	{Fscript: uint8(16), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 473
	{Fscript: uint8(17), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 7264, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                        // 474
	{Fscript: uint8(17), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 3008, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(166)},                       // 475
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18510), Fbprops: uint16(68)},                                          // 476
	{Fscript: uint8(17), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(142)},                                          // 477
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(6), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 478
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(6), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(168)},                                           // 479
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(7), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(168)},                                           // 480
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(7), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 481
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(8), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 482
	{Fscript: uint8(75), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 483
	{Fscript: uint8(75), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 484
	{Fscript: uint8(75), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 485
	{Fscript: uint8(75), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 486
	{Fscript: uint8(75), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 487
	{Fscript: uint8(75), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 488
	{Fscript: uint8(75), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 489
	{Fscript: uint8(75), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 490
	{Fscript: uint8(76), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 38864, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(170)},                      // 491
	{Fscript: uint8(76), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 8, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(170)},                          // 492
	{Fscript: uint8(76), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -8, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                          // 493
	{Fscript: uint8(77), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(126)},                                         // 494
	{Fscript: uint8(77), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 495
	{Fscript: uint8(77), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 496
	{Fscript: uint8(77), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 497
	{Fscript: uint8(78), Fchartype: uint8(29), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(45056), Fbprops: uint16(52)},                                          // 498
	{Fscript: uint8(78), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 499
	{Fscript: uint8(78), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(158)},                                         // 500
	{Fscript: uint8(78), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(158)},                                         // 501
	{Fscript: uint8(79), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 502
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 503
	{Fscript: uint8(79), Fchartype: uint8(14), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 504
	{Fscript: uint8(25), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 505
	{Fscript: uint8(25), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 506
	{Fscript: uint8(25), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 507
	{Fscript: uint8(25), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                          // 508
	{Fscript: uint8(26), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 509
	{Fscript: uint8(26), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 510
	{Fscript: uint8(26), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(174)},                                          // 511
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18573), Fbprops: uint16(124)},                                         // 512
	{Fscript: uint8(27), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 513
	{Fscript: uint8(27), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 514
	{Fscript: uint8(28), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 515
	{Fscript: uint8(28), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 516
	{Fscript: uint8(80), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 517
	{Fscript: uint8(80), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(140)},                                          // 518
	{Fscript: uint8(80), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(100)},                                          // 519
	{Fscript: uint8(80), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 520
	{Fscript: uint8(80), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 521
	{Fscript: uint8(80), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 522
	{Fscript: uint8(80), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 523
	{Fscript: uint8(80), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 524
	{Fscript: uint8(80), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(142)},                                          // 525
	{Fscript: uint8(80), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 526
	{Fscript: uint8(80), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                          // 527
	{Fscript: uint8(80), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 528
	{Fscript: uint8(80), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 529
	{Fscript: uint8(19), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 530
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28777), Fbprops: uint16(106)},                                         // 531
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28777), Fbprops: uint16(124)},                                         // 532
	{Fscript: uint8(19), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(106)},                                         // 533
	{Fscript: uint8(19), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(126)},                                         // 534
	{Fscript: uint8(19), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(124)},                                         // 535
	{Fscript: uint8(19), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(176)},                                         // 536
	{Fscript: uint8(19), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(178)},                                          // 537
	{Fscript: uint8(19), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(66)},                                             // 538
	{Fscript: uint8(19), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 539
	{Fscript: uint8(19), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 540
	{Fscript: uint8(19), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 541
	{Fscript: uint8(19), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(180)},                                          // 542
	{Fscript: uint8(19), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 543
	{Fscript: uint8(29), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 544
	{Fscript: uint8(29), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 545
	{Fscript: uint8(29), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 546
	{Fscript: uint8(29), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 547
	{Fscript: uint8(29), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 548
	{Fscript: uint8(29), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(124)},                                         // 549
	{Fscript: uint8(29), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 550
	{Fscript: uint8(30), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 551
	{Fscript: uint8(89), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 552
	{Fscript: uint8(89), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(156)},                                          // 553
	{Fscript: uint8(89), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 554
	{Fscript: uint8(89), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 555
	{Fscript: uint8(89), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 556
	{Fscript: uint8(80), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 557
	{Fscript: uint8(33), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 558
	{Fscript: uint8(33), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 559
	{Fscript: uint8(33), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 560
	{Fscript: uint8(33), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 561
	{Fscript: uint8(106), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 562
	{Fscript: uint8(106), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 563
	{Fscript: uint8(106), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 564
	{Fscript: uint8(106), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(182)},                                         // 565
	{Fscript: uint8(106), Fchartype: uint8(10), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                        // 566
	{Fscript: uint8(106), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 567
	{Fscript: uint8(106), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 568
	{Fscript: uint8(106), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 569
	{Fscript: uint8(106), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                         // 570
	{Fscript: uint8(106), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 571
	{Fscript: uint8(84), Fchartype: uint8(11), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(184)},                                          // 572
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 573
	{Fscript: uint8(93), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 574
	{Fscript: uint8(93), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 575
	{Fscript: uint8(93), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 576
	{Fscript: uint8(93), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 577
	{Fscript: uint8(93), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                          // 578
	{Fscript: uint8(93), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                          // 579
	{Fscript: uint8(93), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 580
	{Fscript: uint8(93), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 581
	{Fscript: uint8(93), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 582
	{Fscript: uint8(93), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 583
	{Fscript: uint8(93), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 584
	{Fscript: uint8(96), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 585
	{Fscript: uint8(96), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 586
	{Fscript: uint8(96), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 587
	{Fscript: uint8(96), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                          // 588
	{Fscript: uint8(96), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 589
	{Fscript: uint8(96), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 590
	{Fscript: uint8(119), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 591
	{Fscript: uint8(119), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                         // 592
	{Fscript: uint8(119), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 593
	{Fscript: uint8(119), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 594
	{Fscript: uint8(119), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(174)},                                         // 595
	{Fscript: uint8(119), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 596
	{Fscript: uint8(97), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 597
	{Fscript: uint8(97), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 598
	{Fscript: uint8(97), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 599
	{Fscript: uint8(97), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(186)},                                          // 600
	{Fscript: uint8(97), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 601
	{Fscript: uint8(97), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 602
	{Fscript: uint8(97), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 603
	{Fscript: uint8(97), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 604
	{Fscript: uint8(98), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 605
	{Fscript: uint8(98), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 606
	{Fscript: uint8(98), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(92)},                                           // 607
	{Fscript: uint8(98), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(94)},                                           // 608
	{Fscript: uint8(98), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 609
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(63), Fother_case: -6222, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},   // 610
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(67), Fother_case: -6221, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},   // 611
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(71), Fother_case: -6212, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},   // 612
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(75), Fother_case: -6210, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},   // 613
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(79), Fother_case: -6210, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},   // 614
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(79), Fother_case: -6211, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},   // 615
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(84), Fother_case: -6204, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},   // 616
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(88), Fother_case: -6180, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},   // 617
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(108), Fother_case: 35267, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},  // 618
	{Fscript: uint8(17), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -3008, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                       // 619
	{Fscript: uint8(96), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 620
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26762), Fbprops: uint16(96)},                                           // 621
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26630), Fbprops: uint16(96)},                                           // 622
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18498), Fbprops: uint16(188)},                                         // 623
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26666), Fbprops: uint16(96)},                                           // 624
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26696), Fbprops: uint16(96)},                                           // 625
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26780), Fbprops: uint16(96)},                                           // 626
	{Fscript: uint8(69), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18474), Fbprops: uint16(160)},                                          // 627
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18501), Fbprops: uint16(82)},                                           // 628
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18474), Fbprops: uint16(82)},                                           // 629
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18438), Fbprops: uint16(82)},                                           // 630
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18594), Fbprops: uint16(82)},                                           // 631
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18498), Fbprops: uint16(82)},                                           // 632
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26750), Fbprops: uint16(96)},                                           // 633
	{Fscript: uint8(69), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18435), Fbprops: uint16(160)},                                          // 634
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26690), Fbprops: uint16(96)},                                           // 635
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18453), Fbprops: uint16(82)},                                           // 636
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(60)},                                            // 637
	{Fscript: uint8(1), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(88)},                                            // 638
	{Fscript: uint8(2), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(190)},                                           // 639
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 35332, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 640
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 3814, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 641
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 35384, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                           // 642
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(192)},                                                              // 643
	{Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(190)},                                                              // 644
	{Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(194)},                                                              // 645
	{Fscript: uint8(1), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(190)},                                           // 646
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26636), Fbprops: uint16(102)},                                          // 647
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26687), Fbprops: uint16(96)},                                           // 648
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26648), Fbprops: uint16(96)},                                           // 649
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(92), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                          // 650
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(92), Fother_case: -1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                         // 651
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                                                               // 652
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(92), Fother_case: -58, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                        // 653
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -7615, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                           // 654
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 8, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                            // 655
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -8, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                           // 656
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 74, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                           // 657
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 86, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                           // 658
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 100, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 659
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 128, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 660
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 112, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 661
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 126, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                          // 662
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 8, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                            // 663
	{Fscript: uint8(1), Fchartype: uint8(8), Fgbprop: uint8(12), Fother_case: -8, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(86)},                           // 664
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                                            // 665
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 9, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                            // 666
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -74, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                          // 667
	{Fscript: uint8(1), Fchartype: uint8(8), Fgbprop: uint8(12), Fother_case: -9, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(86)},                           // 668
	{Fscript: uint8(1), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(21), Fother_case: -7173, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},   // 669
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -86, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                          // 670
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -100, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 671
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -112, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 672
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -128, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 673
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -126, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 674
	{Fscript: uint8(69), Fchartype: uint8(29), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(45056), Fbprops: uint16(52)},                                          // 675
	{Fscript: uint8(84), Fchartype: uint8(1), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(196)},                                            // 676
	{Fscript: uint8(84), Fchartype: uint8(1), Fgbprop: uint8(13), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(198)},                                           // 677
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(200)},                                           // 678
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(200)},                                           // 679
	{Fscript: uint8(69), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(202)},                                         // 680
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(64)},                                          // 681
	{Fscript: uint8(69), Fchartype: uint8(20), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(204)},                                         // 682
	{Fscript: uint8(69), Fchartype: uint8(19), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(204)},                                         // 683
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(206)},                                         // 684
	{Fscript: uint8(69), Fchartype: uint8(20), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(206)},                                         // 685
	{Fscript: uint8(69), Fchartype: uint8(19), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(206)},                                         // 686
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(208)},                                         // 687
	{Fscript: uint8(69), Fchartype: uint8(27), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(45056), Fbprops: uint16(50)},                                           // 688
	{Fscript: uint8(69), Fchartype: uint8(28), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(4096), Fbprops: uint16(50)},                                            // 689
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(20480), Fbprops: uint16(134)},                                           // 690
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(36864), Fbprops: uint16(134)},                                           // 691
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(30720), Fbprops: uint16(134)},                                           // 692
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(24576), Fbprops: uint16(134)},                                           // 693
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(40960), Fbprops: uint16(134)},                                           // 694
	{Fscript: uint8(69), Fchartype: uint8(29), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8291), Fbprops: uint16(52)},                                           // 695
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(54)},                                          // 696
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(64)},                                          // 697
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(210)},                                         // 698
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(212)},                                         // 699
	{Fscript: uint8(69), Fchartype: uint8(16), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(138)},                                         // 700
	{Fscript: uint8(69), Fchartype: uint8(16), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(214)},                                         // 701
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(64)},                                           // 702
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(216)},                                         // 703
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(216)},                                         // 704
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(202)},                                         // 705
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(218)},                                            // 706
	{Fscript: uint8(68), Fchartype: uint8(2), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(220)},                                            // 707
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(22528), Fbprops: uint16(134)},                                           // 708
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(38912), Fbprops: uint16(134)},                                           // 709
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(16384), Fbprops: uint16(134)},                                           // 710
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(32768), Fbprops: uint16(134)},                                           // 711
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(222)},                                            // 712
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(12288), Fbprops: uint16(118)},                                         // 713
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(12288), Fbprops: uint16(224)},                                         // 714
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(118)},                                         // 715
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(226)},                                         // 716
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(226)},                                         // 717
	{Fscript: uint8(68), Fchartype: uint8(2), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336)},                                                                // 718
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(228)},                                          // 719
	{Fscript: uint8(84), Fchartype: uint8(11), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(120)},                                          // 720
	{Fscript: uint8(84), Fchartype: uint8(11), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(230)},                                          // 721
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26753), Fbprops: uint16(102)},                                          // 722
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 723
	{Fscript: uint8(69), Fchartype: uint8(9), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(112)},                                          // 724
	{Fscript: uint8(69), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(232)},                                          // 725
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(234)},                                         // 726
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(236)},                                         // 727
	{Fscript: uint8(1), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(96), Fother_case: -7517, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},   // 728
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(118)},                                         // 729
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(100), Fother_case: -8383, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                     // 730
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(104), Fother_case: -8262, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                     // 731
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(238)},                                         // 732
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 28, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                              // 733
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(240)},                                          // 734
	{Fscript: uint8(69), Fchartype: uint8(5), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(242)},                                          // 735
	{Fscript: uint8(69), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(244)},                                          // 736
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -28, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                             // 737
	{Fchartype: uint8(14), Fgbprop: uint8(12), Fother_case: 16, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             // 738
	{Fchartype: uint8(14), Fgbprop: uint8(12), Fother_case: -16, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 739
	{Fchartype: uint8(14), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                                              // 740
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(246)},                                         // 741
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(246)},                                         // 742
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(64)},                                          // 743
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(248)},                                         // 744
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(12288), Fbprops: uint16(250)},                                         // 745
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(248)},                                         // 746
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(248)},                                         // 747
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(252)},                                         // 748
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(254)},                                         // 749
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(254)},                                         // 750
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(54)},                                          // 751
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(256)},                                         // 752
	{Fscript: uint8(68), Fchartype: uint8(2), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(258)},                                          // 753
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fother_case: 26, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(260)},                        // 754
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fother_case: 26, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(262)},                        // 755
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fother_case: -26, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(264)},                       // 756
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(266)},                                         // 757
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(268)},                                         // 758
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(270)},                                         // 759
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(268)},                                         // 760
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(256)},                                         // 761
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(272)},                                         // 762
	{Fscript: uint8(88), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(54)},                                          // 763
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(216)},                                         // 764
	{Fscript: uint8(35), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 48, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                          // 765
	{Fscript: uint8(35), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -48, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                         // 766
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -10743, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 767
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -3814, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                           // 768
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -10727, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 769
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -10795, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                          // 770
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -10792, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                          // 771
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -10780, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 772
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -10749, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 773
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -10783, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 774
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -10782, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 775
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -10815, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 776
	{Fscript: uint8(34), Fchartype: uint8(5), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(60)},                                           // 777
	{Fscript: uint8(34), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 778
	{Fscript: uint8(34), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 779
	{Fscript: uint8(34), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 780
	{Fscript: uint8(34), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 781
	{Fscript: uint8(17), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -7264, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                       // 782
	{Fscript: uint8(90), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 783
	{Fscript: uint8(90), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(142)},                                          // 784
	{Fscript: uint8(90), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 785
	{Fscript: uint8(90), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(182)},                                          // 786
	{Fscript: uint8(2), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                           // 787
	{Fscript: uint8(69), Fchartype: uint8(20), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(216)},                                         // 788
	{Fscript: uint8(69), Fchartype: uint8(19), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(216)},                                         // 789
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(274)},                                          // 790
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(276)},                                         // 791
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28726), Fbprops: uint16(54)},                                          // 792
	{Fscript: uint8(23), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(278)},                                         // 793
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(280)},                                         // 794
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(282)},                                         // 795
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(276)},                                         // 796
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(212)},                                         // 797
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28819), Fbprops: uint16(54)},                                          // 798
	{Fscript: uint8(23), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 799
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18447), Fbprops: uint16(284)},                                          // 800
	{Fscript: uint8(23), Fchartype: uint8(14), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(284)},                                         // 801
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(216)},                                         // 802
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(216)},                                         // 803
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(62)},                                          // 804
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(62)},                                          // 805
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28819), Fbprops: uint16(54)},                                          // 806
	{Fscript: uint8(69), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28819), Fbprops: uint16(202)},                                         // 807
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28819), Fbprops: uint16(206)},                                         // 808
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28819), Fbprops: uint16(206)},                                         // 809
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26669), Fbprops: uint16(96)},                                           // 810
	{Fscript: uint8(18), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(286)},                                          // 811
	{Fscript: uint8(69), Fchartype: uint8(17), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28819), Fbprops: uint16(288)},                                         // 812
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18525), Fbprops: uint16(136)},                                          // 813
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28819), Fbprops: uint16(68)},                                          // 814
	{Fscript: uint8(23), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(142)},                                          // 815
	{Fscript: uint8(69), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18564), Fbprops: uint16(82)},                                           // 816
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28804), Fbprops: uint16(236)},                                         // 817
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28687), Fbprops: uint16(68)},                                          // 818
	{Fscript: uint8(20), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 819
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26717), Fbprops: uint16(96)},                                           // 820
	{Fscript: uint8(69), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28765), Fbprops: uint16(290)},                                         // 821
	{Fscript: uint8(20), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 822
	{Fscript: uint8(69), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28765), Fbprops: uint16(126)},                                         // 823
	{Fscript: uint8(21), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 824
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(68)},                                          // 825
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18525), Fbprops: uint16(94)},                                           // 826
	{Fscript: uint8(21), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 827
	{Fscript: uint8(22), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 828
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 829
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(168)},                                          // 830
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18447), Fbprops: uint16(68)},                                          // 831
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18447), Fbprops: uint16(68)},                                          // 832
	{Fscript: uint8(18), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 833
	{Fscript: uint8(18), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 834
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 835
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(18447), Fbprops: uint16(236)},                                         // 836
	{Fscript: uint8(21), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 837
	{Fscript: uint8(23), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(292)},                                          // 838
	{Fscript: uint8(24), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 839
	{Fscript: uint8(24), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 840
	{Fscript: uint8(24), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 841
	{Fscript: uint8(111), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 842
	{Fscript: uint8(111), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(142)},                                         // 843
	{Fscript: uint8(111), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 844
	{Fscript: uint8(111), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 845
	{Fscript: uint8(99), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 846
	{Fscript: uint8(99), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 847
	{Fscript: uint8(99), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(106)},                                         // 848
	{Fscript: uint8(99), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(124)},                                         // 849
	{Fscript: uint8(99), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 850
	{Fscript: uint8(2), Fchartype: uint8(9), Fgbprop: uint8(12), Fcaseset: uint8(108), Fother_case: 1, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},      // 851
	{Fscript: uint8(2), Fchartype: uint8(5), Fgbprop: uint8(12), Fcaseset: uint8(108), Fother_case: -35267, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)}, // 852
	{Fscript: uint8(2), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 853
	{Fscript: uint8(2), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                           // 854
	{Fscript: uint8(2), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                            // 855
	{Fscript: uint8(2), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(92)},                                            // 856
	{Fscript: uint8(2), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(88)},                                            // 857
	{Fscript: uint8(112), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 858
	{Fscript: uint8(112), Fchartype: uint8(14), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                         // 859
	{Fscript: uint8(112), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 860
	{Fscript: uint8(112), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 861
	{Fscript: uint8(112), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 862
	{Fscript: uint8(112), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 863
	{Fscript: uint8(69), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28762), Fbprops: uint16(56)},                                          // 864
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -35332, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 865
	{Fscript: uint8(69), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(56)},                                          // 866
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42280, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 867
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: 48, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                              // 868
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42308, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 869
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42319, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 870
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42315, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 871
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42305, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 872
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42258, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 873
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42282, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 874
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42261, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 875
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 928, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             // 876
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -48, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                             // 877
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -42307, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 878
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: -35384, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                                          // 879
	{Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(142)},                                                              // 880
	{Fscript: uint8(36), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 881
	{Fscript: uint8(36), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 882
	{Fscript: uint8(36), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(182)},                                          // 883
	{Fscript: uint8(36), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 884
	{Fscript: uint8(36), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 885
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18612), Fbprops: uint16(68)},                                          // 886
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18609), Fbprops: uint16(68)},                                          // 887
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18600), Fbprops: uint16(68)},                                          // 888
	{Fscript: uint8(69), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14504), Fbprops: uint16(68)},                                          // 889
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14504), Fbprops: uint16(68)},                                          // 890
	{Fscript: uint8(37), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 891
	{Fscript: uint8(37), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 892
	{Fscript: uint8(37), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(124)},                                         // 893
	{Fscript: uint8(100), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 894
	{Fscript: uint8(100), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 895
	{Fscript: uint8(100), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 896
	{Fscript: uint8(100), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 897
	{Fscript: uint8(100), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 898
	{Fscript: uint8(100), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 899
	{Fscript: uint8(6), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26666), Fbprops: uint16(96)},                                            // 900
	{Fscript: uint8(6), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18507), Fbprops: uint16(82)},                                            // 901
	{Fscript: uint8(39), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 902
	{Fscript: uint8(39), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 903
	{Fscript: uint8(39), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 904
	{Fscript: uint8(39), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 905
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18567), Fbprops: uint16(188)},                                         // 906
	{Fscript: uint8(39), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 907
	{Fscript: uint8(101), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 908
	{Fscript: uint8(101), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 909
	{Fscript: uint8(101), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 910
	{Fscript: uint8(101), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                         // 911
	{Fscript: uint8(101), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 912
	{Fscript: uint8(40), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 913
	{Fscript: uint8(40), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 914
	{Fscript: uint8(40), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 915
	{Fscript: uint8(40), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 916
	{Fscript: uint8(40), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                          // 917
	{Fscript: uint8(40), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 918
	{Fscript: uint8(40), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 919
	{Fscript: uint8(40), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 920
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18480), Fbprops: uint16(136)},                                          // 921
	{Fscript: uint8(40), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 922
	{Fscript: uint8(16), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                          // 923
	{Fscript: uint8(105), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 924
	{Fscript: uint8(105), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 925
	{Fscript: uint8(105), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 926
	{Fscript: uint8(105), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 927
	{Fscript: uint8(105), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 928
	{Fscript: uint8(105), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 929
	{Fscript: uint8(107), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 930
	{Fscript: uint8(107), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 931
	{Fscript: uint8(107), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(156)},                                         // 932
	{Fscript: uint8(107), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 933
	{Fscript: uint8(107), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(294)},                                         // 934
	{Fscript: uint8(107), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                         // 935
	{Fscript: uint8(107), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 936
	{Fscript: uint8(107), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 937
	{Fscript: uint8(113), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 938
	{Fscript: uint8(113), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 939
	{Fscript: uint8(113), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 940
	{Fscript: uint8(113), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 941
	{Fscript: uint8(113), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                         // 942
	{Fscript: uint8(113), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 943
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -928, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                                            // 944
	{Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(92)},                                                               // 945
	{Fscript: uint8(76), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -38864, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(70)},                      // 946
	{Fscript: uint8(113), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(160)},                                         // 947
	{Fscript: uint8(113), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 948
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(9), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 949
	{Fscript: uint8(18), Fchartype: uint8(7), Fgbprop: uint8(10), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 950
	{Fscript: uint8(68), Fchartype: uint8(4), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432)},                                                                // 951
	{Fscript: uint8(68), Fchartype: uint8(3), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432)},                                                                // 952
	{Fscript: uint8(23), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(284)},                                          // 953
	{Fscript: uint8(71), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(12288), Fbprops: uint16(118)},                                         // 954
	{Fscript: uint8(3), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(296)},                                                                              // 955
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28705), Fbprops: uint16(54)},                                          // 956
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28705), Fbprops: uint16(54)},                                          // 957
	{Fscript: uint8(68), Fchartype: uint8(2), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(298)},                                           // 958
	{Fscript: uint8(3), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(39), Fbprops: uint16(82)},                                               // 959
	{Fscript: uint8(3), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28711), Fbprops: uint16(68)},                                           // 960
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(178)},                                          // 961
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(300)},                                          // 962
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 963
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(122)},                                         // 964
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 965
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 966
	{Fscript: uint8(69), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(126)},                                         // 967
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(302)},                                         // 968
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(302)},                                         // 969
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(106)},                                          // 970
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(304)},                                          // 971
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(306)},                                          // 972
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(124)},                                         // 973
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(158)},                                         // 974
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(158)},                                         // 975
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                          // 976
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(118)},                                         // 977
	{Fscript: uint8(69), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(12288), Fbprops: uint16(224)},                                         // 978
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(226)},                                         // 979
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(302)},                                         // 980
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(308)},                                         // 981
	{Fscript: uint8(69), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(12288), Fbprops: uint16(126)},                                         // 982
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(8192), Fbprops: uint16(68)},                                           // 983
	{Fscript: uint8(69), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(10240), Fbprops: uint16(310)},                                         // 984
	{Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(312)},                                             // 985
	{Fscript: uint8(69), Fchartype: uint8(24), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(314)},                                         // 986
	{Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(316)},                                            // 987
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(124)},                                         // 988
	{Fscript: uint8(69), Fchartype: uint8(22), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(318)},                                         // 989
	{Fscript: uint8(69), Fchartype: uint8(18), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(318)},                                         // 990
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28825), Fbprops: uint16(106)},                                         // 991
	{Fscript: uint8(69), Fchartype: uint8(6), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18525), Fbprops: uint16(320)},                                           // 992
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(322)},                                           // 993
	{Fscript: uint8(31), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 994
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18552), Fbprops: uint16(68)},                                          // 995
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28792), Fbprops: uint16(68)},                                          // 996
	{Fscript: uint8(69), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18483), Fbprops: uint16(68)},                                          // 997
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18555), Fbprops: uint16(68)},                                          // 998
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18483), Fbprops: uint16(68)},                                          // 999
	{Fscript: uint8(1), Fchartype: uint8(14), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(82)},                                           // 1000
	{Fscript: uint8(1), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                           // 1001
	{Fscript: uint8(1), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                           // 1002
	{Fscript: uint8(1), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                           // 1003
	{Fscript: uint8(102), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1004
	{Fscript: uint8(103), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1005
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26651), Fbprops: uint16(96)},                                           // 1006
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(10267), Fbprops: uint16(68)},                                          // 1007
	{Fscript: uint8(81), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1008
	{Fscript: uint8(81), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1009
	{Fscript: uint8(82), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1010
	{Fscript: uint8(82), Fchartype: uint8(14), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1011
	{Fscript: uint8(53), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1012
	{Fscript: uint8(53), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1013
	{Fscript: uint8(85), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1014
	{Fscript: uint8(85), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 1015
	{Fscript: uint8(91), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1016
	{Fscript: uint8(91), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 1017
	{Fscript: uint8(91), Fchartype: uint8(14), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1018
	{Fscript: uint8(83), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 40, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                          // 1019
	{Fscript: uint8(83), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -40, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                         // 1020
	{Fscript: uint8(86), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1021
	{Fscript: uint8(87), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1022
	{Fscript: uint8(87), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1023
	{Fscript: uint8(145), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 40, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 1024
	{Fscript: uint8(145), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -40, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                        // 1025
	{Fscript: uint8(127), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1026
	{Fscript: uint8(125), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1027
	{Fscript: uint8(125), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1028
	{Fscript: uint8(161), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 39, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 1029
	{Fscript: uint8(161), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -39, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                        // 1030
	{Fscript: uint8(49), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1031
	{Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(94)},                                                               // 1032
	{Fscript: uint8(32), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 1033
	{Fscript: uint8(114), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1034
	{Fscript: uint8(114), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(106)},                                        // 1035
	{Fscript: uint8(114), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1036
	{Fscript: uint8(133), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1037
	{Fscript: uint8(133), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1038
	{Fscript: uint8(133), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1039
	{Fscript: uint8(132), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1040
	{Fscript: uint8(132), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1041
	{Fscript: uint8(139), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1042
	{Fscript: uint8(139), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1043
	{Fscript: uint8(95), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 1044
	{Fscript: uint8(95), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 1045
	{Fscript: uint8(95), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(106)},                                         // 1046
	{Fscript: uint8(104), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1047
	{Fscript: uint8(104), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1048
	{Fscript: uint8(122), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1049
	{Fscript: uint8(121), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1050
	{Fscript: uint8(121), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1051
	{Fscript: uint8(92), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 1052
	{Fscript: uint8(92), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1053
	{Fscript: uint8(92), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 1054
	{Fscript: uint8(92), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(182)},                                          // 1055
	{Fscript: uint8(92), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 1056
	{Fscript: uint8(92), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 1057
	{Fscript: uint8(92), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(124)},                                         // 1058
	{Fscript: uint8(115), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1059
	{Fscript: uint8(115), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1060
	{Fscript: uint8(115), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1061
	{Fscript: uint8(131), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1062
	{Fscript: uint8(131), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1063
	{Fscript: uint8(51), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 1064
	{Fscript: uint8(51), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 1065
	{Fscript: uint8(51), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1066
	{Fscript: uint8(51), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 1067
	{Fscript: uint8(51), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(106)},                                         // 1068
	{Fscript: uint8(51), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34918), Fbprops: uint16(106)},                                         // 1069
	{Fscript: uint8(51), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 1070
	{Fscript: uint8(108), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1071
	{Fscript: uint8(108), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                         // 1072
	{Fscript: uint8(108), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(106)},                                        // 1073
	{Fscript: uint8(116), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1074
	{Fscript: uint8(116), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1075
	{Fscript: uint8(117), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1076
	{Fscript: uint8(117), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1077
	{Fscript: uint8(54), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 1078
	{Fscript: uint8(54), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(106)},                                         // 1079
	{Fscript: uint8(54), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 1080
	{Fscript: uint8(118), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1081
	{Fscript: uint8(140), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 64, Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(74)},                         // 1082
	{Fscript: uint8(140), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -64, Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(76)},                        // 1083
	{Fscript: uint8(140), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1084
	{Fscript: uint8(62), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(82)},                                                                              // 1085
	{Fscript: uint8(62), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(294)},                                                                             // 1086
	{Fscript: uint8(62), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(128)},                                          // 1087
	{Fscript: uint8(62), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(2048), Fbprops: uint16(138)},                                          // 1088
	{Fscript: uint8(3), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(2048), Fbprops: uint16(68)},                                            // 1089
	{Fscript: uint8(65), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 1090
	{Fscript: uint8(65), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1091
	{Fscript: uint8(65), Fchartype: uint8(17), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(126)},                                         // 1092
	{Fscript: uint8(152), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1093
	{Fscript: uint8(152), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1094
	{Fscript: uint8(63), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(82)},                                                                              // 1095
	{Fscript: uint8(63), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1096
	{Fscript: uint8(63), Fchartype: uint8(15), Fgbprop: uint8(12), Fbprops: uint16(68)},                                                                             // 1097
	{Fscript: uint8(63), Fchartype: uint8(21), Fgbprop: uint8(12), Fbprops: uint16(124)},                                                                            // 1098
	{Fscript: uint8(67), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                           // 1099
	{Fscript: uint8(67), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1100
	{Fscript: uint8(67), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(124)},                                         // 1101
	{Fscript: uint8(156), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1102
	{Fscript: uint8(156), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1103
	{Fscript: uint8(153), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1104
	{Fscript: uint8(120), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1105
	{Fscript: uint8(120), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1106
	{Fscript: uint8(120), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1107
	{Fscript: uint8(120), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 1108
	{Fscript: uint8(120), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1109
	{Fscript: uint8(120), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1110
	{Fscript: uint8(120), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                         // 1111
	{Fscript: uint8(120), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1112
	{Fscript: uint8(120), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(182)},                                         // 1113
	{Fscript: uint8(41), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 1114
	{Fscript: uint8(41), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1115
	{Fscript: uint8(41), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1116
	{Fscript: uint8(41), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1117
	{Fscript: uint8(41), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1118
	{Fscript: uint8(41), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1119
	{Fscript: uint8(41), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1120
	{Fscript: uint8(41), Fchartype: uint8(1), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(132)},                                           // 1121
	{Fscript: uint8(41), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 1122
	{Fscript: uint8(124), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1123
	{Fscript: uint8(124), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1124
	{Fscript: uint8(43), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1125
	{Fscript: uint8(43), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1126
	{Fscript: uint8(43), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1127
	{Fscript: uint8(43), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1128
	{Fscript: uint8(43), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1129
	{Fscript: uint8(43), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1130
	{Fscript: uint8(43), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 1131
	{Fscript: uint8(50), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1132
	{Fscript: uint8(50), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1133
	{Fscript: uint8(50), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1134
	{Fscript: uint8(44), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1135
	{Fscript: uint8(44), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1136
	{Fscript: uint8(44), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1137
	{Fscript: uint8(44), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                          // 1138
	{Fscript: uint8(44), Fchartype: uint8(7), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 1139
	{Fscript: uint8(44), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 1140
	{Fscript: uint8(44), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1141
	{Fscript: uint8(44), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 1142
	{Fscript: uint8(44), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1143
	{Fscript: uint8(44), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1144
	{Fscript: uint8(15), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1145
	{Fscript: uint8(48), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1146
	{Fscript: uint8(48), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1147
	{Fscript: uint8(48), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1148
	{Fscript: uint8(48), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                          // 1149
	{Fscript: uint8(48), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1150
	{Fscript: uint8(48), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 1151
	{Fscript: uint8(48), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 1152
	{Fscript: uint8(48), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1153
	{Fscript: uint8(57), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1154
	{Fscript: uint8(57), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 1155
	{Fscript: uint8(55), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1156
	{Fscript: uint8(55), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1157
	{Fscript: uint8(55), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1158
	{Fscript: uint8(55), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1159
	{Fscript: uint8(55), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1160
	{Fscript: uint8(55), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1161
	{Fscript: uint8(47), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1162
	{Fscript: uint8(47), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26705), Fbprops: uint16(130)},                                          // 1163
	{Fscript: uint8(47), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1164
	{Fscript: uint8(47), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18513), Fbprops: uint16(144)},                                          // 1165
	{Fscript: uint8(47), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1166
	{Fscript: uint8(84), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26705), Fbprops: uint16(102)},                                          // 1167
	{Fscript: uint8(47), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26705), Fbprops: uint16(96)},                                           // 1168
	{Fscript: uint8(47), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                          // 1169
	{Fscript: uint8(47), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                          // 1170
	{Fscript: uint8(47), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(324)},                                          // 1171
	{Fscript: uint8(47), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1172
	{Fscript: uint8(144), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1173
	{Fscript: uint8(144), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1174
	{Fscript: uint8(144), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1175
	{Fscript: uint8(144), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 1176
	{Fscript: uint8(144), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1177
	{Fscript: uint8(144), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1178
	{Fscript: uint8(144), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1179
	{Fscript: uint8(144), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1180
	{Fscript: uint8(144), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1181
	{Fscript: uint8(144), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                         // 1182
	{Fscript: uint8(56), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1183
	{Fscript: uint8(56), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                          // 1184
	{Fscript: uint8(56), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1185
	{Fscript: uint8(56), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1186
	{Fscript: uint8(56), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1187
	{Fscript: uint8(56), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1188
	{Fscript: uint8(56), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1189
	{Fscript: uint8(56), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1190
	{Fscript: uint8(135), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1191
	{Fscript: uint8(135), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                         // 1192
	{Fscript: uint8(135), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1193
	{Fscript: uint8(135), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1194
	{Fscript: uint8(135), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 1195
	{Fscript: uint8(135), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1196
	{Fscript: uint8(135), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1197
	{Fscript: uint8(135), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1198
	{Fscript: uint8(135), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1199
	{Fscript: uint8(135), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(176)},                                        // 1200
	{Fscript: uint8(52), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1201
	{Fscript: uint8(52), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1202
	{Fscript: uint8(52), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1203
	{Fscript: uint8(52), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1204
	{Fscript: uint8(52), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 1205
	{Fscript: uint8(52), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1206
	{Fscript: uint8(52), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1207
	{Fscript: uint8(45), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1208
	{Fscript: uint8(45), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1209
	{Fscript: uint8(45), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1210
	{Fscript: uint8(45), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                          // 1211
	{Fscript: uint8(45), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1212
	{Fscript: uint8(45), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1213
	{Fscript: uint8(45), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1214
	{Fscript: uint8(137), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1215
	{Fscript: uint8(137), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1216
	{Fscript: uint8(137), Fchartype: uint8(10), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                        // 1217
	{Fscript: uint8(137), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1218
	{Fscript: uint8(137), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 1219
	{Fscript: uint8(137), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1220
	{Fscript: uint8(137), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1221
	{Fscript: uint8(137), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1222
	{Fscript: uint8(137), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1223
	{Fscript: uint8(60), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1224
	{Fscript: uint8(60), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1225
	{Fscript: uint8(60), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1226
	{Fscript: uint8(60), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1227
	{Fscript: uint8(60), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1228
	{Fscript: uint8(60), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1229
	{Fscript: uint8(136), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 1230
	{Fscript: uint8(136), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                        // 1231
	{Fscript: uint8(136), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1232
	{Fscript: uint8(136), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1233
	{Fscript: uint8(136), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1234
	{Fscript: uint8(157), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1235
	{Fscript: uint8(157), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(148)},                                         // 1236
	{Fscript: uint8(157), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1237
	{Fscript: uint8(157), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1238
	{Fscript: uint8(157), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(172)},                                         // 1239
	{Fscript: uint8(157), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 1240
	{Fscript: uint8(157), Fchartype: uint8(7), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1241
	{Fscript: uint8(157), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1242
	{Fscript: uint8(157), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1243
	{Fscript: uint8(157), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1244
	{Fscript: uint8(157), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1245
	{Fscript: uint8(64), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1246
	{Fscript: uint8(64), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1247
	{Fscript: uint8(64), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1248
	{Fscript: uint8(64), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1249
	{Fscript: uint8(64), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1250
	{Fscript: uint8(149), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1251
	{Fscript: uint8(149), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1252
	{Fscript: uint8(149), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(130)},                                         // 1253
	{Fscript: uint8(149), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                         // 1254
	{Fscript: uint8(149), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 1255
	{Fscript: uint8(149), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1256
	{Fscript: uint8(149), Fchartype: uint8(7), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1257
	{Fscript: uint8(149), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1258
	{Fscript: uint8(149), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1259
	{Fscript: uint8(148), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1260
	{Fscript: uint8(148), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1261
	{Fscript: uint8(148), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1262
	{Fscript: uint8(148), Fchartype: uint8(7), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1263
	{Fscript: uint8(148), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(326)},                                         // 1264
	{Fscript: uint8(148), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                         // 1265
	{Fscript: uint8(148), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1266
	{Fscript: uint8(148), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1267
	{Fscript: uint8(148), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1268
	{Fscript: uint8(134), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1269
	{Fscript: uint8(142), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1270
	{Fscript: uint8(142), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1271
	{Fscript: uint8(142), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1272
	{Fscript: uint8(142), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(146)},                                         // 1273
	{Fscript: uint8(142), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1274
	{Fscript: uint8(142), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1275
	{Fscript: uint8(142), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1276
	{Fscript: uint8(142), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1277
	{Fscript: uint8(142), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1278
	{Fscript: uint8(143), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1279
	{Fscript: uint8(143), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1280
	{Fscript: uint8(143), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1281
	{Fscript: uint8(143), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1282
	{Fscript: uint8(143), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1283
	{Fscript: uint8(59), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1284
	{Fscript: uint8(59), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1285
	{Fscript: uint8(59), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1286
	{Fscript: uint8(59), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1287
	{Fscript: uint8(59), Fchartype: uint8(7), Fgbprop: uint8(4), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                            // 1288
	{Fscript: uint8(59), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1289
	{Fscript: uint8(61), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1290
	{Fscript: uint8(61), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                          // 1291
	{Fscript: uint8(61), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1292
	{Fscript: uint8(61), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(146)},                                          // 1293
	{Fscript: uint8(61), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                         // 1294
	{Fscript: uint8(150), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1295
	{Fscript: uint8(150), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1296
	{Fscript: uint8(150), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1297
	{Fscript: uint8(150), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1298
	{Fscript: uint8(11), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1299
	{Fscript: uint8(11), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1300
	{Fscript: uint8(94), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1301
	{Fscript: uint8(94), Fchartype: uint8(14), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1302
	{Fscript: uint8(94), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                         // 1303
	{Fscript: uint8(66), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1304
	{Fscript: uint8(66), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1305
	{Fscript: uint8(109), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1306
	{Fscript: uint8(109), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(322)},                                          // 1307
	{Fscript: uint8(138), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1308
	{Fscript: uint8(130), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1309
	{Fscript: uint8(130), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1310
	{Fscript: uint8(130), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1311
	{Fscript: uint8(159), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1312
	{Fscript: uint8(159), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1313
	{Fscript: uint8(126), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1314
	{Fscript: uint8(126), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1315
	{Fscript: uint8(126), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1316
	{Fscript: uint8(128), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1317
	{Fscript: uint8(128), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1318
	{Fscript: uint8(128), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1319
	{Fscript: uint8(128), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1320
	{Fscript: uint8(128), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1321
	{Fscript: uint8(128), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1322
	{Fscript: uint8(128), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(142)},                                         // 1323
	{Fscript: uint8(128), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                         // 1324
	{Fscript: uint8(128), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1325
	{Fscript: uint8(128), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1326
	{Fscript: uint8(151), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(74)},                         // 1327
	{Fscript: uint8(151), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -32, Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(76)},                        // 1328
	{Fscript: uint8(151), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1329
	{Fscript: uint8(151), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1330
	{Fscript: uint8(151), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1331
	{Fscript: uint8(151), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1332
	{Fscript: uint8(123), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1333
	{Fscript: uint8(123), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                         // 1334
	{Fscript: uint8(123), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(144)},                                         // 1335
	{Fscript: uint8(123), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(128)},                                         // 1336
	{Fscript: uint8(123), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(92)},                                          // 1337
	{Fscript: uint8(146), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                         // 1338
	{Fscript: uint8(147), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                         // 1339
	{Fscript: uint8(23), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(68)},                                          // 1340
	{Fscript: uint8(158), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(328)},                                         // 1341
	{Fscript: uint8(23), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(164)},                                          // 1342
	{Fscript: uint8(146), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(284)},                                         // 1343
	{Fscript: uint8(158), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(284)},                                         // 1344
	{Fscript: uint8(21), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(92)},                                           // 1345
	{Fscript: uint8(147), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(284)},                                         // 1346
	{Fscript: uint8(46), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                           // 1347
	{Fscript: uint8(46), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1348
	{Fscript: uint8(46), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                          // 1349
	{Fscript: uint8(46), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1350
	{Fscript: uint8(46), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                         // 1351
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(2), Fscriptx_bidiclass: uint16(6153), Fbprops: uint16(66)},                                             // 1352
	{Fscript: uint8(69), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(330)},                                          // 1353
	{Fscript: uint8(69), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                          // 1354
	{Fscript: uint8(69), Fchartype: uint8(10), Fgbprop: uint8(5), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(160)},                                          // 1355
	{Fscript: uint8(69), Fchartype: uint8(10), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(286)},                                          // 1356
	{Fscript: uint8(1), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                           // 1357
	{Fscript: uint8(69), Fchartype: uint8(25), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(118)},                                         // 1358
	{Fscript: uint8(69), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(10240), Fbprops: uint16(214)},                                         // 1359
	{Fscript: uint8(141), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1360
	{Fscript: uint8(141), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(102)},                                         // 1361
	{Fscript: uint8(141), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(106)},                                        // 1362
	{Fscript: uint8(141), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(124)},                                        // 1363
	{Fscript: uint8(141), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1364
	{Fscript: uint8(35), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1365
	{Fscript: uint8(154), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1366
	{Fscript: uint8(154), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1367
	{Fscript: uint8(154), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(142)},                                         // 1368
	{Fscript: uint8(154), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(136)},                                         // 1369
	{Fscript: uint8(154), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1370
	{Fscript: uint8(154), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                         // 1371
	{Fscript: uint8(160), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1372
	{Fscript: uint8(160), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1373
	{Fscript: uint8(155), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(82)},                                          // 1374
	{Fscript: uint8(155), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1375
	{Fscript: uint8(155), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(138)},                                        // 1376
	{Fscript: uint8(155), Fchartype: uint8(23), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(14336), Fbprops: uint16(68)},                                         // 1377
	{Fscript: uint8(129), Fchartype: uint8(7), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(82)},                                          // 1378
	{Fscript: uint8(129), Fchartype: uint8(15), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                         // 1379
	{Fscript: uint8(129), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                          // 1380
	{Fscript: uint8(58), Fchartype: uint8(9), Fgbprop: uint8(12), Fother_case: 34, Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(74)},                          // 1381
	{Fscript: uint8(58), Fchartype: uint8(5), Fgbprop: uint8(12), Fother_case: -34, Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(76)},                         // 1382
	{Fscript: uint8(58), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(150)},                                          // 1383
	{Fscript: uint8(58), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(130)},                                          // 1384
	{Fscript: uint8(58), Fchartype: uint8(12), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(26624), Fbprops: uint16(96)},                                           // 1385
	{Fscript: uint8(58), Fchartype: uint8(6), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(142)},                                          // 1386
	{Fscript: uint8(58), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(138)},                                         // 1387
	{Fscript: uint8(58), Fchartype: uint8(21), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(34816), Fbprops: uint16(68)},                                          // 1388
	{Fscript: uint8(69), Fchartype: uint8(15), Fgbprop: uint8(12), Fbprops: uint16(68)},                                                                             // 1389
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fbprops: uint16(68)},                                                                             // 1390
	{Fscript: uint8(69), Fchartype: uint8(23), Fgbprop: uint8(12), Fbprops: uint16(68)},                                                                             // 1391
	{Fscript: uint8(3), Fchartype: uint8(7), Fgbprop: uint8(12), Fbprops: uint16(240)},                                                                              // 1392
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(332)},                                         // 1393
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(334)},                                         // 1394
	{Fscript: uint8(68), Fchartype: uint8(2), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(336)},                                          // 1395
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(338)},                                         // 1396
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(340)},                                         // 1397
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(334)},                                         // 1398
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(11), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(342)},                                         // 1399
	{Fscript: uint8(20), Fchartype: uint8(26), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(68)},                                          // 1400
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(18432), Fbprops: uint16(236)},                                         // 1401
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(18447), Fbprops: uint16(334)},                                         // 1402
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(344)},                                         // 1403
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(346)},                                         // 1404
	{Fscript: uint8(69), Fchartype: uint8(24), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(348)},                                          // 1405
	{Fscript: uint8(69), Fchartype: uint8(26), Fgbprop: uint8(14), Fscriptx_bidiclass: uint16(28672), Fbprops: uint16(350)},                                         // 1406
	{Fscript: uint8(69), Fchartype: uint8(13), Fgbprop: uint8(12), Fscriptx_bidiclass: uint16(10240), Fbprops: uint16(138)},                                         // 1407
	{Fscript: uint8(69), Fchartype: uint8(1), Fgbprop: uint8(3), Fscriptx_bidiclass: uint16(6144), Fbprops: uint16(352)},                                            // 1408
} /* pcre2_ucd.c:427:18 */

var X_pcre2_ucd_stage1_8 = [8704]uint16{ // 17408 bytes
	uint16(0), uint16(1), uint16(2), uint16(3), uint16(4), uint16(5), uint16(6), uint16(7), uint16(8), uint16(9), uint16(10), uint16(11), uint16(12), uint16(13), uint16(14), uint16(15), // U+0000
	uint16(16), uint16(17), uint16(18), uint16(19), uint16(20), uint16(21), uint16(22), uint16(23), uint16(24), uint16(25), uint16(26), uint16(27), uint16(28), uint16(29), uint16(30), uint16(31), // U+0800
	uint16(32), uint16(33), uint16(34), uint16(35), uint16(36), uint16(37), uint16(38), uint16(39), uint16(40), uint16(41), uint16(41), uint16(41), uint16(42), uint16(43), uint16(44), uint16(45), // U+1000
	uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(58), uint16(59), uint16(60), uint16(61), // U+1800
	uint16(62), uint16(63), uint16(64), uint16(65), uint16(66), uint16(67), uint16(68), uint16(69), uint16(70), uint16(71), uint16(72), uint16(73), uint16(74), uint16(75), uint16(76), uint16(77), // U+2000
	uint16(78), uint16(78), uint16(79), uint16(80), uint16(81), uint16(82), uint16(83), uint16(84), uint16(85), uint16(86), uint16(87), uint16(88), uint16(89), uint16(90), uint16(91), uint16(92), // U+2800
	uint16(93), uint16(94), uint16(95), uint16(96), uint16(97), uint16(98), uint16(99), uint16(100), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+3000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+3800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+4000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(102), uint16(101), uint16(101), uint16(101), uint16(101), // U+4800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+5000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+5800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+6000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+6800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+7000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+7800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+8000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+8800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+9000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+9800
	uint16(103), uint16(104), uint16(104), uint16(104), uint16(104), uint16(104), uint16(104), uint16(104), uint16(104), uint16(105), uint16(106), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), // U+A000
	uint16(111), uint16(112), uint16(113), uint16(114), uint16(115), uint16(116), uint16(117), uint16(118), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), // U+A800
	uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), // U+B000
	uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), // U+B800
	uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), // U+C000
	uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), // U+C800
	uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(119), uint16(120), uint16(121), uint16(126), // U+D000
	uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), uint16(127), // U+D800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+E000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+E800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F000
	uint16(128), uint16(128), uint16(129), uint16(129), uint16(130), uint16(131), uint16(132), uint16(133), uint16(134), uint16(135), uint16(136), uint16(137), uint16(138), uint16(139), uint16(140), uint16(141), // U+F800
	uint16(142), uint16(143), uint16(144), uint16(145), uint16(146), uint16(147), uint16(148), uint16(149), uint16(150), uint16(151), uint16(152), uint16(153), uint16(154), uint16(154), uint16(155), uint16(156), // U+10000
	uint16(157), uint16(158), uint16(159), uint16(160), uint16(161), uint16(162), uint16(163), uint16(164), uint16(165), uint16(166), uint16(167), uint16(168), uint16(169), uint16(170), uint16(171), uint16(172), // U+10800
	uint16(173), uint16(174), uint16(175), uint16(176), uint16(177), uint16(178), uint16(179), uint16(146), uint16(180), uint16(181), uint16(146), uint16(182), uint16(183), uint16(184), uint16(185), uint16(146), // U+11000
	uint16(186), uint16(187), uint16(188), uint16(189), uint16(190), uint16(191), uint16(146), uint16(146), uint16(192), uint16(193), uint16(194), uint16(195), uint16(146), uint16(196), uint16(146), uint16(197), // U+11800
	uint16(198), uint16(198), uint16(198), uint16(198), uint16(198), uint16(198), uint16(198), uint16(199), uint16(200), uint16(198), uint16(201), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+12000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(202), // U+12800
	uint16(203), uint16(203), uint16(203), uint16(203), uint16(203), uint16(203), uint16(203), uint16(203), uint16(204), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+13000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+13800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(205), uint16(205), uint16(205), uint16(205), uint16(206), uint16(146), uint16(146), uint16(146), // U+14000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+14800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+15000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+15800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+16000
	uint16(207), uint16(207), uint16(207), uint16(207), uint16(208), uint16(209), uint16(210), uint16(211), uint16(146), uint16(146), uint16(146), uint16(146), uint16(212), uint16(213), uint16(214), uint16(215), // U+16800
	uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), // U+17000
	uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), // U+17800
	uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(217), // U+18000
	uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(216), uint16(218), uint16(218), uint16(218), uint16(219), uint16(220), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+18800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+19000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+19800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+1A000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(221), // U+1A800
	uint16(222), uint16(223), uint16(224), uint16(225), uint16(225), uint16(226), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+1B000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(227), uint16(228), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+1B800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+1C000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(229), uint16(230), // U+1C800
	uint16(231), uint16(232), uint16(233), uint16(234), uint16(235), uint16(236), uint16(237), uint16(146), uint16(238), uint16(239), uint16(240), uint16(241), uint16(242), uint16(243), uint16(244), uint16(245), // U+1D000
	uint16(246), uint16(246), uint16(246), uint16(246), uint16(247), uint16(248), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(249), uint16(146), // U+1D800
	uint16(250), uint16(146), uint16(251), uint16(146), uint16(146), uint16(252), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(253), // U+1E000
	uint16(254), uint16(255), uint16(256), uint16(168), uint16(168), uint16(168), uint16(168), uint16(168), uint16(257), uint16(258), uint16(259), uint16(168), uint16(260), uint16(261), uint16(168), uint16(168), // U+1E800
	uint16(262), uint16(263), uint16(264), uint16(265), uint16(266), uint16(267), uint16(268), uint16(269), uint16(270), uint16(271), uint16(272), uint16(273), uint16(274), uint16(275), uint16(276), uint16(277), // U+1F000
	uint16(278), uint16(279), uint16(280), uint16(281), uint16(282), uint16(283), uint16(284), uint16(285), uint16(267), uint16(267), uint16(267), uint16(267), uint16(267), uint16(267), uint16(267), uint16(286), // U+1F800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+20000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+20800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+21000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+21800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+22000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+22800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+23000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+23800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+24000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+24800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+25000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+25800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+26000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+26800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+27000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+27800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+28000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+28800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+29000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+29800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(287), uint16(101), uint16(101), // U+2A000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+2A800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(288), uint16(101), // U+2B000
	uint16(289), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+2B800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+2C000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(290), uint16(101), uint16(101), // U+2C800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+2D000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+2D800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+2E000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(291), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+2E800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+2F000
	uint16(129), uint16(129), uint16(129), uint16(129), uint16(292), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+2F800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+30000
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), // U+30800
	uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(101), uint16(294), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+31000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+31800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+32000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+32800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+33000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+33800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+34000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+34800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+35000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+35800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+36000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+36800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+37000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+37800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+38000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+38800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+39000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+39800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3A000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3A800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3B000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3B800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3C000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3C800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3D000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3D800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3E000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3E800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+3F000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+3F800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+40000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+40800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+41000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+41800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+42000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+42800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+43000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+43800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+44000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+44800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+45000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+45800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+46000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+46800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+47000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+47800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+48000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+48800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+49000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+49800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4A000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4A800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4B000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4B800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4C000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4C800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4D000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4D800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4E000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4E800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+4F000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+4F800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+50000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+50800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+51000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+51800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+52000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+52800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+53000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+53800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+54000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+54800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+55000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+55800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+56000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+56800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+57000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+57800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+58000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+58800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+59000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+59800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5A000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5A800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5B000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5B800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5C000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5C800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5D000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5D800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5E000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5E800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+5F000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+5F800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+60000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+60800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+61000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+61800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+62000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+62800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+63000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+63800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+64000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+64800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+65000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+65800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+66000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+66800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+67000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+67800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+68000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+68800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+69000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+69800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6A000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6A800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6B000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6B800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6C000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6C800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6D000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6D800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6E000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6E800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+6F000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+6F800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+70000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+70800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+71000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+71800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+72000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+72800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+73000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+73800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+74000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+74800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+75000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+75800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+76000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+76800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+77000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+77800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+78000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+78800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+79000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+79800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7A000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7A800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7B000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7B800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7C000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7C800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7D000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7D800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7E000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7E800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+7F000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+7F800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+80000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+80800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+81000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+81800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+82000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+82800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+83000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+83800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+84000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+84800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+85000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+85800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+86000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+86800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+87000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+87800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+88000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+88800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+89000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+89800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8A000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8A800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8B000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8B800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8C000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8C800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8D000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8D800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8E000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8E800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+8F000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+8F800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+90000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+90800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+91000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+91800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+92000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+92800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+93000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+93800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+94000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+94800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+95000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+95800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+96000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+96800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+97000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+97800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+98000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+98800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+99000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+99800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9A000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9A800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9B000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9B800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9C000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9C800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9D000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9D800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9E000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9E800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+9F000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+9F800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A0000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A0800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A1000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A1800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A2000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A2800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A3000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A3800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A4000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A4800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A5000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A5800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A6000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A6800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A7000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A7800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A8000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A8800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A9000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+A9800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AA000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AA800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AB000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AB800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AC000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AC800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AD000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AD800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AE000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AE800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+AF000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+AF800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B0000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B0800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B1000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B1800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B2000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B2800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B3000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B3800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B4000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B4800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B5000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B5800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B6000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B6800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B7000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B7800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B8000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B8800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B9000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+B9800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BA000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BA800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BB000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BB800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BC000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BC800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BD000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BD800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BE000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BE800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+BF000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+BF800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C0000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C0800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C1000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C1800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C2000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C2800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C3000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C3800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C4000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C4800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C5000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C5800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C6000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C6800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C7000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C7800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C8000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C8800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C9000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+C9800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CA000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CA800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CB000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CB800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CC000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CC800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CD000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CD800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CE000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CE800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+CF000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+CF800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D0000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D0800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D1000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D1800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D2000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D2800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D3000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D3800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D4000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D4800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D5000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D5800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D6000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D6800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D7000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D7800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D8000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D8800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D9000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+D9800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DA000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DA800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DB000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DB800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DC000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DC800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DD000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DD800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DE000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DE800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+DF000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+DF800
	uint16(295), uint16(296), uint16(297), uint16(298), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), // U+E0000
	uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), uint16(296), // U+E0800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E1000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E1800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E2000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E2800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E3000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E3800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E4000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E4800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E5000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E5800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E6000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E6800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E7000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E7800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E8000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E8800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E9000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+E9800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EA000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EA800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EB000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EB800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EC000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EC800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+ED000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+ED800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EE000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EE800
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), // U+EF000
	uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(146), uint16(293), // U+EF800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F0000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F0800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F1000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F1800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F2000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F2800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F3000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F3800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F4000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F4800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F5000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F5800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F6000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F6800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F7000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F7800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F8000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F8800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F9000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+F9800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FA000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FA800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FB000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FB800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FC000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FC800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FD000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FD800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FE000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FE800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+FF000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(299), // U+FF800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+100000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+100800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+101000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+101800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+102000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+102800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+103000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+103800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+104000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+104800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+105000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+105800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+106000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+106800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+107000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+107800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+108000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+108800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+109000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+109800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10A000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10A800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10B000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10B800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10C000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10C800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10D000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10D800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10E000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10E800
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), // U+10F000
	uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(128), uint16(299), // U+10F800
} /* pcre2_ucd.c:1839:16 */

var X_pcre2_ucd_stage2_8 = [38400]uint16{ // 76800 bytes, block = 128

	// block 0
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(1), uint16(2), uint16(1), uint16(3), uint16(4), uint16(0), uint16(0),
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(5), uint16(5), uint16(5), uint16(6),
	uint16(7), uint16(8), uint16(9), uint16(10), uint16(11), uint16(12), uint16(13), uint16(14), uint16(15), uint16(16), uint16(17), uint16(18), uint16(19), uint16(20), uint16(21), uint16(22),
	uint16(23), uint16(23), uint16(23), uint16(23), uint16(23), uint16(23), uint16(23), uint16(23), uint16(23), uint16(23), uint16(24), uint16(25), uint16(26), uint16(27), uint16(26), uint16(8),
	uint16(13), uint16(28), uint16(28), uint16(28), uint16(28), uint16(28), uint16(28), uint16(29), uint16(29), uint16(29), uint16(29), uint16(30), uint16(29), uint16(29), uint16(29), uint16(29),
	uint16(29), uint16(29), uint16(29), uint16(31), uint16(29), uint16(29), uint16(29), uint16(29), uint16(29), uint16(29), uint16(29), uint16(15), uint16(13), uint16(16), uint16(32), uint16(33),
	uint16(34), uint16(35), uint16(35), uint16(35), uint16(35), uint16(35), uint16(35), uint16(36), uint16(36), uint16(37), uint16(37), uint16(38), uint16(36), uint16(36), uint16(36), uint16(36),
	uint16(36), uint16(36), uint16(36), uint16(39), uint16(36), uint16(36), uint16(36), uint16(36), uint16(36), uint16(36), uint16(36), uint16(15), uint16(27), uint16(16), uint16(27), uint16(0),

	// block 1
	uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(41), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40),
	uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40), uint16(40),
	uint16(42), uint16(43), uint16(44), uint16(44), uint16(44), uint16(44), uint16(45), uint16(43), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(47), uint16(46),
	uint16(52), uint16(53), uint16(54), uint16(54), uint16(46), uint16(55), uint16(43), uint16(56), uint16(46), uint16(54), uint16(48), uint16(57), uint16(58), uint16(58), uint16(58), uint16(43),
	uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(60), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59),
	uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(50), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(61),
	uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(63), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62),
	uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(50), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(64),

	// block 2
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(67),
	uint16(68), uint16(69), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(70), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65),
	uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(71), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(72), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(73),

	// block 3
	uint16(74), uint16(75), uint16(65), uint16(66), uint16(65), uint16(66), uint16(76), uint16(65), uint16(66), uint16(77), uint16(77), uint16(65), uint16(66), uint16(70), uint16(78), uint16(79),
	uint16(80), uint16(65), uint16(66), uint16(77), uint16(81), uint16(82), uint16(83), uint16(84), uint16(65), uint16(66), uint16(85), uint16(70), uint16(83), uint16(86), uint16(87), uint16(88),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(89), uint16(65), uint16(66), uint16(89), uint16(70), uint16(70), uint16(65), uint16(66), uint16(89), uint16(65),
	uint16(66), uint16(90), uint16(90), uint16(65), uint16(66), uint16(65), uint16(66), uint16(91), uint16(65), uint16(66), uint16(70), uint16(92), uint16(65), uint16(66), uint16(70), uint16(93),
	uint16(92), uint16(92), uint16(92), uint16(92), uint16(94), uint16(95), uint16(96), uint16(97), uint16(98), uint16(99), uint16(100), uint16(101), uint16(102), uint16(65), uint16(66), uint16(65),
	uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(103), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(69), uint16(104), uint16(105), uint16(106), uint16(65), uint16(66), uint16(107), uint16(108), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),

	// block 4
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(109), uint16(70), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(110), uint16(65), uint16(66), uint16(111), uint16(112), uint16(113),
	uint16(113), uint16(65), uint16(66), uint16(114), uint16(115), uint16(116), uint16(65), uint16(66), uint16(65), uint16(67), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(117), uint16(118), uint16(119), uint16(120), uint16(121), uint16(70), uint16(122), uint16(122), uint16(70), uint16(123), uint16(70), uint16(124), uint16(125), uint16(70), uint16(70), uint16(70),
	uint16(122), uint16(126), uint16(70), uint16(127), uint16(70), uint16(128), uint16(129), uint16(70), uint16(130), uint16(131), uint16(129), uint16(132), uint16(133), uint16(70), uint16(70), uint16(131),
	uint16(70), uint16(134), uint16(135), uint16(70), uint16(70), uint16(136), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(137), uint16(70), uint16(70),

	// block 5
	uint16(138), uint16(70), uint16(139), uint16(138), uint16(70), uint16(70), uint16(70), uint16(140), uint16(138), uint16(141), uint16(142), uint16(142), uint16(143), uint16(70), uint16(70), uint16(70),
	uint16(70), uint16(70), uint16(144), uint16(70), uint16(92), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(145), uint16(146), uint16(70),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70),
	uint16(147), uint16(147), uint16(148), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(149), uint16(149), uint16(150), uint16(150), uint16(150), uint16(150), uint16(150),
	uint16(151), uint16(151), uint16(46), uint16(46), uint16(46), uint16(46), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149),
	uint16(152), uint16(152), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46),
	uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(153), uint16(153), uint16(149), uint16(46), uint16(150), uint16(46),
	uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46),

	// block 6
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),
	uint16(154), uint16(154), uint16(155), uint16(154), uint16(154), uint16(156), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(157),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(154), uint16(154), uint16(154),
	uint16(154), uint16(154), uint16(154), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159), uint16(159),
	uint16(160), uint16(161), uint16(160), uint16(161), uint16(149), uint16(162), uint16(160), uint16(161), uint16(163), uint16(163), uint16(164), uint16(165), uint16(165), uint16(165), uint16(166), uint16(167),

	// block 7
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(162), uint16(46), uint16(168), uint16(169), uint16(170), uint16(170), uint16(170), uint16(163), uint16(171), uint16(163), uint16(172), uint16(172),
	uint16(173), uint16(174), uint16(175), uint16(174), uint16(174), uint16(176), uint16(174), uint16(174), uint16(177), uint16(178), uint16(179), uint16(174), uint16(180), uint16(174), uint16(174), uint16(174),
	uint16(181), uint16(182), uint16(163), uint16(183), uint16(174), uint16(174), uint16(184), uint16(174), uint16(174), uint16(185), uint16(174), uint16(174), uint16(186), uint16(187), uint16(187), uint16(187),
	uint16(173), uint16(188), uint16(189), uint16(188), uint16(188), uint16(190), uint16(188), uint16(188), uint16(191), uint16(192), uint16(193), uint16(188), uint16(194), uint16(188), uint16(188), uint16(188),
	uint16(195), uint16(196), uint16(197), uint16(198), uint16(188), uint16(188), uint16(199), uint16(188), uint16(188), uint16(200), uint16(188), uint16(188), uint16(201), uint16(202), uint16(202), uint16(203),
	uint16(204), uint16(205), uint16(206), uint16(207), uint16(207), uint16(208), uint16(209), uint16(210), uint16(160), uint16(161), uint16(160), uint16(161), uint16(160), uint16(161), uint16(160), uint16(161),
	uint16(160), uint16(161), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212),
	uint16(213), uint16(214), uint16(215), uint16(216), uint16(217), uint16(218), uint16(219), uint16(160), uint16(161), uint16(220), uint16(160), uint16(161), uint16(221), uint16(222), uint16(222), uint16(222),

	// block 8
	uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223), uint16(223),
	uint16(224), uint16(224), uint16(225), uint16(224), uint16(226), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224), uint16(227), uint16(224),
	uint16(224), uint16(228), uint16(229), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224), uint16(230), uint16(224), uint16(224), uint16(224), uint16(224), uint16(224),
	uint16(231), uint16(231), uint16(232), uint16(231), uint16(233), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231), uint16(234), uint16(231),
	uint16(231), uint16(235), uint16(236), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231), uint16(237), uint16(231), uint16(231), uint16(231), uint16(231), uint16(231),
	uint16(238), uint16(238), uint16(238), uint16(238), uint16(238), uint16(238), uint16(239), uint16(238), uint16(239), uint16(238), uint16(238), uint16(238), uint16(238), uint16(238), uint16(238), uint16(238),
	uint16(240), uint16(241), uint16(242), uint16(243), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),

	// block 9
	uint16(240), uint16(241), uint16(244), uint16(245), uint16(246), uint16(247), uint16(247), uint16(246), uint16(248), uint16(248), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(249), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(250),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),

	// block 10
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(163), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251),
	uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251),
	uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(251), uint16(163), uint16(163), uint16(252), uint16(253), uint16(253), uint16(253), uint16(253), uint16(253), uint16(254),
	uint16(255), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256),
	uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256),

	// block 11
	uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(256), uint16(257), uint16(255), uint16(258), uint16(259), uint16(163), uint16(163), uint16(260), uint16(260), uint16(261),
	uint16(262), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263),
	uint16(263), uint16(263), uint16(264), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263), uint16(263),
	uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(265), uint16(266), uint16(265),
	uint16(267), uint16(265), uint16(265), uint16(268), uint16(265), uint16(269), uint16(267), uint16(269), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270),
	uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(262), uint16(262), uint16(262), uint16(262), uint16(270),
	uint16(270), uint16(270), uint16(270), uint16(267), uint16(271), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 12
	uint16(272), uint16(272), uint16(272), uint16(272), uint16(272), uint16(273), uint16(274), uint16(274), uint16(275), uint16(276), uint16(276), uint16(277), uint16(278), uint16(279), uint16(280), uint16(280),
	uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(282), uint16(283), uint16(284), uint16(284), uint16(285),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(287), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(288), uint16(288), uint16(288), uint16(288), uint16(288),
	uint16(288), uint16(288), uint16(288), uint16(289), uint16(289), uint16(289), uint16(281), uint16(290), uint16(291), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281),
	uint16(292), uint16(292), uint16(292), uint16(292), uint16(292), uint16(292), uint16(292), uint16(292), uint16(292), uint16(292), uint16(276), uint16(293), uint16(293), uint16(279), uint16(286), uint16(286),
	uint16(289), uint16(286), uint16(286), uint16(294), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),

	// block 13
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(295), uint16(286), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(273), uint16(280), uint16(291),
	uint16(291), uint16(281), uint16(281), uint16(281), uint16(281), uint16(296), uint16(296), uint16(281), uint16(281), uint16(280), uint16(291), uint16(291), uint16(291), uint16(281), uint16(286), uint16(286),
	uint16(297), uint16(297), uint16(297), uint16(297), uint16(297), uint16(297), uint16(297), uint16(297), uint16(297), uint16(297), uint16(286), uint16(286), uint16(286), uint16(298), uint16(298), uint16(286),

	// block 14
	uint16(299), uint16(299), uint16(299), uint16(300), uint16(300), uint16(300), uint16(300), uint16(300), uint16(300), uint16(300), uint16(300), uint16(301), uint16(300), uint16(301), uint16(302), uint16(303),
	uint16(304), uint16(305), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304),
	uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304),
	uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306), uint16(306),
	uint16(307), uint16(307), uint16(307), uint16(307), uint16(307), uint16(307), uint16(307), uint16(307), uint16(307), uint16(307), uint16(307), uint16(302), uint16(302), uint16(304), uint16(304), uint16(304),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),

	// block 15
	uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308),
	uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308),
	uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(309), uint16(309), uint16(309), uint16(309), uint16(309), uint16(309), uint16(309), uint16(309), uint16(309), uint16(309),
	uint16(309), uint16(308), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(310), uint16(310), uint16(310), uint16(310), uint16(310), uint16(310), uint16(310), uint16(310), uint16(310), uint16(310), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311),
	uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311),
	uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(311), uint16(312), uint16(312), uint16(312), uint16(312), uint16(312),
	uint16(312), uint16(312), uint16(312), uint16(312), uint16(313), uint16(313), uint16(314), uint16(315), uint16(316), uint16(317), uint16(318), uint16(262), uint16(262), uint16(319), uint16(320), uint16(320),

	// block 16
	uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321),
	uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(321), uint16(322), uint16(322), uint16(323), uint16(323), uint16(324), uint16(322), uint16(322), uint16(322), uint16(322), uint16(322),
	uint16(322), uint16(322), uint16(322), uint16(322), uint16(324), uint16(322), uint16(322), uint16(322), uint16(324), uint16(322), uint16(322), uint16(322), uint16(322), uint16(325), uint16(262), uint16(262),
	uint16(326), uint16(326), uint16(326), uint16(326), uint16(326), uint16(326), uint16(326), uint16(327), uint16(326), uint16(327), uint16(326), uint16(326), uint16(326), uint16(327), uint16(327), uint16(262),
	uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328),
	uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(328), uint16(329), uint16(329), uint16(329), uint16(262), uint16(262), uint16(330), uint16(262),
	uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(304), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),

	// block 17
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(331), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(302),
	uint16(272), uint16(272), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(291), uint16(291), uint16(291), uint16(291), uint16(291), uint16(291), uint16(291), uint16(291),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(296), uint16(291), uint16(291), uint16(291), uint16(291), uint16(291), uint16(291),
	uint16(291), uint16(291), uint16(291), uint16(332), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281), uint16(281),
	uint16(332), uint16(332), uint16(273), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(291), uint16(291), uint16(291), uint16(291), uint16(291), uint16(291),
	uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(290), uint16(281),

	// block 18
	uint16(333), uint16(333), uint16(333), uint16(334), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335),
	uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335),
	uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335),
	uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(333), uint16(334), uint16(336), uint16(335), uint16(334), uint16(334),
	uint16(334), uint16(333), uint16(333), uint16(333), uint16(333), uint16(333), uint16(333), uint16(333), uint16(333), uint16(334), uint16(334), uint16(334), uint16(334), uint16(337), uint16(334), uint16(334),
	uint16(335), uint16(338), uint16(339), uint16(154), uint16(154), uint16(333), uint16(333), uint16(333), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335),
	uint16(335), uint16(335), uint16(333), uint16(333), uint16(340), uint16(341), uint16(342), uint16(342), uint16(342), uint16(342), uint16(342), uint16(342), uint16(342), uint16(342), uint16(342), uint16(342),
	uint16(343), uint16(344), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335), uint16(335),

	// block 19
	uint16(345), uint16(346), uint16(347), uint16(347), uint16(163), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(163), uint16(163), uint16(345),
	uint16(345), uint16(163), uint16(163), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345),
	uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(163), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345), uint16(345),
	uint16(345), uint16(163), uint16(345), uint16(163), uint16(163), uint16(163), uint16(345), uint16(345), uint16(345), uint16(345), uint16(163), uint16(163), uint16(348), uint16(345), uint16(349), uint16(347),
	uint16(347), uint16(346), uint16(346), uint16(346), uint16(346), uint16(163), uint16(163), uint16(347), uint16(347), uint16(163), uint16(163), uint16(347), uint16(347), uint16(350), uint16(345), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(349), uint16(163), uint16(163), uint16(163), uint16(163), uint16(345), uint16(345), uint16(163), uint16(345),
	uint16(345), uint16(345), uint16(346), uint16(346), uint16(163), uint16(163), uint16(351), uint16(351), uint16(351), uint16(351), uint16(351), uint16(351), uint16(351), uint16(351), uint16(351), uint16(351),
	uint16(345), uint16(345), uint16(352), uint16(352), uint16(353), uint16(353), uint16(353), uint16(353), uint16(353), uint16(353), uint16(354), uint16(352), uint16(345), uint16(355), uint16(356), uint16(163),

	// block 20
	uint16(163), uint16(357), uint16(357), uint16(358), uint16(163), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(163), uint16(163), uint16(163), uint16(163), uint16(359),
	uint16(359), uint16(163), uint16(163), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359),
	uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(163), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359), uint16(359),
	uint16(359), uint16(163), uint16(359), uint16(359), uint16(163), uint16(359), uint16(359), uint16(163), uint16(359), uint16(359), uint16(163), uint16(163), uint16(360), uint16(163), uint16(358), uint16(358),
	uint16(358), uint16(357), uint16(357), uint16(163), uint16(163), uint16(163), uint16(163), uint16(357), uint16(357), uint16(163), uint16(163), uint16(357), uint16(357), uint16(361), uint16(163), uint16(163),
	uint16(163), uint16(357), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(359), uint16(359), uint16(359), uint16(359), uint16(163), uint16(359), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(362), uint16(362), uint16(362), uint16(362), uint16(362), uint16(362), uint16(362), uint16(362), uint16(362), uint16(362),
	uint16(357), uint16(357), uint16(359), uint16(359), uint16(359), uint16(357), uint16(363), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 21
	uint16(163), uint16(364), uint16(364), uint16(365), uint16(163), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(163), uint16(366),
	uint16(366), uint16(366), uint16(163), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366),
	uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(163), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366),
	uint16(366), uint16(163), uint16(366), uint16(366), uint16(163), uint16(366), uint16(366), uint16(366), uint16(366), uint16(366), uint16(163), uint16(163), uint16(367), uint16(366), uint16(365), uint16(365),
	uint16(365), uint16(364), uint16(364), uint16(364), uint16(364), uint16(364), uint16(163), uint16(364), uint16(364), uint16(365), uint16(163), uint16(365), uint16(365), uint16(368), uint16(163), uint16(163),
	uint16(366), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(366), uint16(366), uint16(364), uint16(364), uint16(163), uint16(163), uint16(369), uint16(369), uint16(369), uint16(369), uint16(369), uint16(369), uint16(369), uint16(369), uint16(369), uint16(369),
	uint16(370), uint16(371), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(366), uint16(364), uint16(364), uint16(364), uint16(367), uint16(367), uint16(367),

	// block 22
	uint16(163), uint16(372), uint16(373), uint16(373), uint16(163), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(163), uint16(163), uint16(374),
	uint16(374), uint16(163), uint16(163), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374),
	uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(163), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374),
	uint16(374), uint16(163), uint16(374), uint16(374), uint16(163), uint16(374), uint16(374), uint16(374), uint16(374), uint16(374), uint16(163), uint16(163), uint16(375), uint16(374), uint16(376), uint16(372),
	uint16(373), uint16(372), uint16(372), uint16(372), uint16(372), uint16(163), uint16(163), uint16(373), uint16(373), uint16(163), uint16(163), uint16(373), uint16(373), uint16(377), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(378), uint16(372), uint16(376), uint16(163), uint16(163), uint16(163), uint16(163), uint16(374), uint16(374), uint16(163), uint16(374),
	uint16(374), uint16(374), uint16(372), uint16(372), uint16(163), uint16(163), uint16(379), uint16(379), uint16(379), uint16(379), uint16(379), uint16(379), uint16(379), uint16(379), uint16(379), uint16(379),
	uint16(380), uint16(374), uint16(381), uint16(381), uint16(381), uint16(381), uint16(381), uint16(381), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 23
	uint16(163), uint16(163), uint16(382), uint16(383), uint16(163), uint16(383), uint16(383), uint16(383), uint16(383), uint16(383), uint16(383), uint16(163), uint16(163), uint16(163), uint16(383), uint16(383),
	uint16(383), uint16(163), uint16(383), uint16(383), uint16(383), uint16(383), uint16(163), uint16(163), uint16(163), uint16(383), uint16(383), uint16(163), uint16(383), uint16(163), uint16(383), uint16(383),
	uint16(163), uint16(163), uint16(163), uint16(383), uint16(383), uint16(163), uint16(163), uint16(163), uint16(383), uint16(383), uint16(383), uint16(163), uint16(163), uint16(163), uint16(383), uint16(383),
	uint16(383), uint16(383), uint16(383), uint16(383), uint16(383), uint16(383), uint16(383), uint16(383), uint16(383), uint16(383), uint16(163), uint16(163), uint16(163), uint16(163), uint16(384), uint16(385),
	uint16(382), uint16(385), uint16(385), uint16(163), uint16(163), uint16(163), uint16(385), uint16(385), uint16(385), uint16(163), uint16(385), uint16(385), uint16(385), uint16(386), uint16(163), uint16(163),
	uint16(383), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(384), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(387), uint16(387), uint16(387), uint16(387), uint16(387), uint16(387), uint16(387), uint16(387), uint16(387), uint16(387),
	uint16(388), uint16(388), uint16(388), uint16(389), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(391), uint16(390), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 24
	uint16(392), uint16(393), uint16(393), uint16(393), uint16(394), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(163), uint16(395), uint16(395),
	uint16(395), uint16(163), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395),
	uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(163), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395),
	uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(395), uint16(163), uint16(163), uint16(396), uint16(395), uint16(392), uint16(392),
	uint16(392), uint16(393), uint16(393), uint16(393), uint16(393), uint16(163), uint16(392), uint16(392), uint16(392), uint16(163), uint16(392), uint16(392), uint16(392), uint16(397), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(392), uint16(392), uint16(163), uint16(395), uint16(395), uint16(395), uint16(163), uint16(163), uint16(395), uint16(163), uint16(163),
	uint16(395), uint16(395), uint16(392), uint16(392), uint16(163), uint16(163), uint16(398), uint16(398), uint16(398), uint16(398), uint16(398), uint16(398), uint16(398), uint16(398), uint16(398), uint16(398),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(399), uint16(400), uint16(400), uint16(400), uint16(400), uint16(400), uint16(400), uint16(400), uint16(401),

	// block 25
	uint16(402), uint16(403), uint16(404), uint16(404), uint16(405), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(163), uint16(402), uint16(402),
	uint16(402), uint16(163), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402),
	uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(163), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402),
	uint16(402), uint16(402), uint16(402), uint16(402), uint16(163), uint16(402), uint16(402), uint16(402), uint16(402), uint16(402), uint16(163), uint16(163), uint16(406), uint16(402), uint16(404), uint16(407),
	uint16(404), uint16(404), uint16(408), uint16(404), uint16(404), uint16(163), uint16(407), uint16(404), uint16(404), uint16(163), uint16(404), uint16(404), uint16(403), uint16(409), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(408), uint16(408), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(402), uint16(402), uint16(163),
	uint16(402), uint16(402), uint16(403), uint16(403), uint16(163), uint16(163), uint16(410), uint16(410), uint16(410), uint16(410), uint16(410), uint16(410), uint16(410), uint16(410), uint16(410), uint16(410),
	uint16(163), uint16(402), uint16(402), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 26
	uint16(411), uint16(411), uint16(412), uint16(412), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(163), uint16(413), uint16(413),
	uint16(413), uint16(163), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413),
	uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413),
	uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(414), uint16(414), uint16(413), uint16(415), uint16(412),
	uint16(412), uint16(411), uint16(411), uint16(411), uint16(411), uint16(163), uint16(412), uint16(412), uint16(412), uint16(163), uint16(412), uint16(412), uint16(412), uint16(414), uint16(416), uint16(417),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(413), uint16(413), uint16(413), uint16(415), uint16(418), uint16(418), uint16(418), uint16(418), uint16(418), uint16(418), uint16(418), uint16(413),
	uint16(413), uint16(413), uint16(411), uint16(411), uint16(163), uint16(163), uint16(419), uint16(419), uint16(419), uint16(419), uint16(419), uint16(419), uint16(419), uint16(419), uint16(419), uint16(419),
	uint16(418), uint16(418), uint16(418), uint16(418), uint16(418), uint16(418), uint16(418), uint16(418), uint16(418), uint16(417), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413), uint16(413),

	// block 27
	uint16(163), uint16(420), uint16(421), uint16(421), uint16(163), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422),
	uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(163), uint16(163), uint16(163), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422),
	uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422),
	uint16(422), uint16(422), uint16(163), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(163), uint16(422), uint16(163), uint16(163),
	uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(422), uint16(163), uint16(163), uint16(163), uint16(423), uint16(163), uint16(163), uint16(163), uint16(163), uint16(424),
	uint16(421), uint16(421), uint16(420), uint16(420), uint16(420), uint16(163), uint16(420), uint16(163), uint16(421), uint16(421), uint16(421), uint16(421), uint16(421), uint16(421), uint16(421), uint16(424),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(425), uint16(425), uint16(425), uint16(425), uint16(425), uint16(425), uint16(425), uint16(425), uint16(425), uint16(425),
	uint16(163), uint16(163), uint16(421), uint16(421), uint16(426), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 28
	uint16(163), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427),
	uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427),
	uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427), uint16(427),
	uint16(427), uint16(428), uint16(427), uint16(429), uint16(428), uint16(428), uint16(428), uint16(428), uint16(428), uint16(428), uint16(430), uint16(163), uint16(163), uint16(163), uint16(163), uint16(431),
	uint16(432), uint16(432), uint16(432), uint16(432), uint16(432), uint16(427), uint16(433), uint16(434), uint16(434), uint16(434), uint16(434), uint16(434), uint16(434), uint16(428), uint16(434), uint16(435),
	uint16(436), uint16(436), uint16(436), uint16(436), uint16(436), uint16(436), uint16(436), uint16(436), uint16(436), uint16(436), uint16(437), uint16(437), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 29
	uint16(163), uint16(438), uint16(438), uint16(163), uint16(438), uint16(163), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(163), uint16(438), uint16(438), uint16(438), uint16(438),
	uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438),
	uint16(438), uint16(438), uint16(438), uint16(438), uint16(163), uint16(438), uint16(163), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438), uint16(438),
	uint16(438), uint16(439), uint16(438), uint16(440), uint16(439), uint16(439), uint16(439), uint16(439), uint16(439), uint16(439), uint16(441), uint16(439), uint16(439), uint16(438), uint16(163), uint16(163),
	uint16(442), uint16(442), uint16(442), uint16(442), uint16(442), uint16(163), uint16(443), uint16(163), uint16(444), uint16(444), uint16(444), uint16(444), uint16(444), uint16(439), uint16(163), uint16(163),
	uint16(445), uint16(445), uint16(445), uint16(445), uint16(445), uint16(445), uint16(445), uint16(445), uint16(445), uint16(445), uint16(163), uint16(163), uint16(438), uint16(438), uint16(438), uint16(438),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 30
	uint16(446), uint16(447), uint16(447), uint16(447), uint16(448), uint16(448), uint16(448), uint16(448), uint16(449), uint16(448), uint16(448), uint16(448), uint16(448), uint16(449), uint16(449), uint16(449),
	uint16(449), uint16(449), uint16(449), uint16(447), uint16(448), uint16(447), uint16(447), uint16(447), uint16(450), uint16(450), uint16(447), uint16(447), uint16(447), uint16(447), uint16(447), uint16(447),
	uint16(451), uint16(451), uint16(451), uint16(451), uint16(451), uint16(451), uint16(451), uint16(451), uint16(451), uint16(451), uint16(452), uint16(452), uint16(452), uint16(452), uint16(452), uint16(452),
	uint16(452), uint16(452), uint16(452), uint16(452), uint16(447), uint16(450), uint16(447), uint16(450), uint16(447), uint16(450), uint16(453), uint16(454), uint16(453), uint16(454), uint16(455), uint16(455),
	uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(163), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446),
	uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446),
	uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(457), uint16(456), uint16(457), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(458),

	// block 31
	uint16(456), uint16(456), uint16(450), uint16(450), uint16(459), uint16(448), uint16(450), uint16(450), uint16(446), uint16(446), uint16(446), uint16(446), uint16(446), uint16(456), uint16(456), uint16(456),
	uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(163), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456),
	uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456),
	uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(456), uint16(163), uint16(447), uint16(447),
	uint16(447), uint16(447), uint16(447), uint16(447), uint16(447), uint16(447), uint16(450), uint16(447), uint16(447), uint16(447), uint16(447), uint16(447), uint16(447), uint16(163), uint16(447), uint16(447),
	uint16(448), uint16(448), uint16(448), uint16(448), uint16(448), uint16(460), uint16(460), uint16(460), uint16(460), uint16(448), uint16(448), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 32
	uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461),
	uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461),
	uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(462), uint16(462), uint16(463), uint16(463), uint16(463),
	uint16(463), uint16(464), uint16(463), uint16(463), uint16(463), uint16(463), uint16(463), uint16(465), uint16(462), uint16(466), uint16(466), uint16(464), uint16(464), uint16(463), uint16(463), uint16(461),
	uint16(467), uint16(467), uint16(467), uint16(467), uint16(467), uint16(467), uint16(467), uint16(467), uint16(467), uint16(467), uint16(468), uint16(468), uint16(469), uint16(469), uint16(469), uint16(469),
	uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(464), uint16(464), uint16(463), uint16(463), uint16(461), uint16(461), uint16(461), uint16(461), uint16(463), uint16(463),
	uint16(463), uint16(461), uint16(462), uint16(470), uint16(470), uint16(461), uint16(461), uint16(462), uint16(462), uint16(470), uint16(470), uint16(470), uint16(470), uint16(470), uint16(461), uint16(461),
	uint16(461), uint16(463), uint16(463), uint16(463), uint16(463), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461),

	// block 33
	uint16(461), uint16(461), uint16(463), uint16(462), uint16(464), uint16(463), uint16(463), uint16(470), uint16(470), uint16(470), uint16(470), uint16(470), uint16(470), uint16(471), uint16(461), uint16(470),
	uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(470), uint16(470), uint16(462), uint16(463), uint16(473), uint16(473),
	uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474),
	uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474),
	uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(474), uint16(163), uint16(474), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(474), uint16(163), uint16(163),
	uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475),
	uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475),
	uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(476), uint16(477), uint16(475), uint16(475), uint16(475),

	// block 34
	uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478),
	uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478),
	uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478),
	uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478),
	uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478),
	uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(479),
	uint16(480), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481),
	uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481),

	// block 35
	uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481),
	uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481),
	uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),
	uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),
	uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),
	uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),
	uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),
	uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),

	// block 36
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),

	// block 37
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163),
	uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),

	// block 38
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163), uint16(484), uint16(484), uint16(484),
	uint16(485), uint16(486), uint16(487), uint16(486), uint16(486), uint16(486), uint16(486), uint16(487), uint16(487), uint16(488), uint16(488), uint16(488), uint16(488), uint16(488), uint16(488), uint16(488),
	uint16(488), uint16(488), uint16(489), uint16(489), uint16(489), uint16(489), uint16(489), uint16(489), uint16(489), uint16(489), uint16(489), uint16(489), uint16(489), uint16(163), uint16(163), uint16(163),

	// block 39
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(490), uint16(490), uint16(490), uint16(490), uint16(490), uint16(490), uint16(490), uint16(490), uint16(490), uint16(490), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491),
	uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491),
	uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491),
	uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491),
	uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491), uint16(491),
	uint16(492), uint16(492), uint16(492), uint16(492), uint16(492), uint16(492), uint16(163), uint16(163), uint16(493), uint16(493), uint16(493), uint16(493), uint16(493), uint16(493), uint16(163), uint16(163),

	// block 40
	uint16(494), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),

	// block 41
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),

	// block 42
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(496), uint16(497), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),

	// block 43
	uint16(498), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499),
	uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(499), uint16(500), uint16(501), uint16(163), uint16(163), uint16(163),
	uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502),
	uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502),
	uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502),
	uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502),
	uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(503), uint16(503), uint16(503), uint16(504), uint16(504),
	uint16(504), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(502), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 44
	uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505), uint16(505),
	uint16(505), uint16(505), uint16(506), uint16(506), uint16(507), uint16(508), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(505),
	uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509), uint16(509),
	uint16(509), uint16(509), uint16(510), uint16(510), uint16(511), uint16(512), uint16(512), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513), uint16(513),
	uint16(513), uint16(513), uint16(514), uint16(514), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(515), uint16(163), uint16(515), uint16(515),
	uint16(515), uint16(163), uint16(516), uint16(516), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 45
	uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517),
	uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517),
	uint16(517), uint16(517), uint16(517), uint16(518), uint16(518), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517), uint16(517),
	uint16(517), uint16(517), uint16(517), uint16(517), uint16(519), uint16(519), uint16(520), uint16(521), uint16(521), uint16(521), uint16(521), uint16(521), uint16(521), uint16(521), uint16(520), uint16(520),
	uint16(520), uint16(520), uint16(520), uint16(520), uint16(520), uint16(520), uint16(521), uint16(520), uint16(520), uint16(522), uint16(522), uint16(522), uint16(522), uint16(522), uint16(522), uint16(522),
	uint16(522), uint16(522), uint16(523), uint16(522), uint16(524), uint16(524), uint16(524), uint16(525), uint16(526), uint16(526), uint16(524), uint16(527), uint16(517), uint16(522), uint16(163), uint16(163),
	uint16(528), uint16(528), uint16(528), uint16(528), uint16(528), uint16(528), uint16(528), uint16(528), uint16(528), uint16(528), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(529), uint16(529), uint16(529), uint16(529), uint16(529), uint16(529), uint16(529), uint16(529), uint16(529), uint16(529), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 46
	uint16(530), uint16(530), uint16(531), uint16(532), uint16(533), uint16(531), uint16(534), uint16(530), uint16(533), uint16(535), uint16(536), uint16(537), uint16(537), uint16(537), uint16(538), uint16(537),
	uint16(539), uint16(539), uint16(539), uint16(539), uint16(539), uint16(539), uint16(539), uint16(539), uint16(539), uint16(539), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540),
	uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540),
	uint16(540), uint16(540), uint16(540), uint16(541), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540),
	uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540),
	uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540),
	uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 47
	uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(542), uint16(542), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540),
	uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540),
	uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(540), uint16(543), uint16(540), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 48
	uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544),
	uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(544), uint16(163),
	uint16(545), uint16(545), uint16(545), uint16(546), uint16(546), uint16(546), uint16(546), uint16(545), uint16(545), uint16(546), uint16(546), uint16(546), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(546), uint16(546), uint16(545), uint16(546), uint16(546), uint16(546), uint16(546), uint16(546), uint16(546), uint16(547), uint16(547), uint16(547), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(548), uint16(163), uint16(163), uint16(163), uint16(549), uint16(549), uint16(550), uint16(550), uint16(550), uint16(550), uint16(550), uint16(550), uint16(550), uint16(550), uint16(550), uint16(550),
	uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551),
	uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(163), uint16(163),
	uint16(551), uint16(551), uint16(551), uint16(551), uint16(551), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 49
	uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552),
	uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552),
	uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(553), uint16(553), uint16(553), uint16(552), uint16(552), uint16(553), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552),
	uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(552), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(554), uint16(554), uint16(554), uint16(554), uint16(554), uint16(554), uint16(554), uint16(554), uint16(554), uint16(554), uint16(555), uint16(163), uint16(163), uint16(163), uint16(556), uint16(556),
	uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557),
	uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557), uint16(557),

	// block 50
	uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558),
	uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(558), uint16(559), uint16(559), uint16(560), uint16(560), uint16(559), uint16(163), uint16(163), uint16(561), uint16(561),
	uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562),
	uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562),
	uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(562),
	uint16(562), uint16(562), uint16(562), uint16(562), uint16(562), uint16(563), uint16(564), uint16(563), uint16(564), uint16(564), uint16(564), uint16(564), uint16(564), uint16(564), uint16(564), uint16(163),
	uint16(565), uint16(566), uint16(564), uint16(566), uint16(566), uint16(564), uint16(564), uint16(564), uint16(564), uint16(564), uint16(564), uint16(564), uint16(564), uint16(563), uint16(563), uint16(563),
	uint16(563), uint16(563), uint16(563), uint16(564), uint16(564), uint16(567), uint16(567), uint16(567), uint16(567), uint16(567), uint16(567), uint16(567), uint16(567), uint16(163), uint16(163), uint16(567),

	// block 51
	uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(568), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(569), uint16(569), uint16(569), uint16(569), uint16(569), uint16(569), uint16(569), uint16(570), uint16(571), uint16(571), uint16(571), uint16(571), uint16(569), uint16(569), uint16(163), uint16(163),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(572), uint16(573),
	uint16(573), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(573), uint16(573), uint16(573), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 52
	uint16(574), uint16(574), uint16(574), uint16(574), uint16(575), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576),
	uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576),
	uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576),
	uint16(576), uint16(576), uint16(576), uint16(576), uint16(577), uint16(578), uint16(574), uint16(574), uint16(574), uint16(574), uint16(574), uint16(575), uint16(574), uint16(575), uint16(575), uint16(575),
	uint16(575), uint16(575), uint16(574), uint16(575), uint16(579), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(576), uint16(163), uint16(163), uint16(163),
	uint16(580), uint16(580), uint16(580), uint16(580), uint16(580), uint16(580), uint16(580), uint16(580), uint16(580), uint16(580), uint16(581), uint16(581), uint16(582), uint16(583), uint16(581), uint16(581),
	uint16(582), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(577), uint16(577), uint16(577), uint16(577), uint16(577),
	uint16(577), uint16(577), uint16(577), uint16(577), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(584), uint16(581), uint16(581), uint16(163),

	// block 53
	uint16(585), uint16(585), uint16(586), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587),
	uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587),
	uint16(587), uint16(586), uint16(585), uint16(585), uint16(585), uint16(585), uint16(586), uint16(586), uint16(585), uint16(585), uint16(588), uint16(589), uint16(585), uint16(585), uint16(587), uint16(587),
	uint16(590), uint16(590), uint16(590), uint16(590), uint16(590), uint16(590), uint16(590), uint16(590), uint16(590), uint16(590), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587), uint16(587),
	uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591),
	uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591),
	uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(591), uint16(592), uint16(593), uint16(594), uint16(594), uint16(593), uint16(593), uint16(593), uint16(594), uint16(593), uint16(594),
	uint16(594), uint16(594), uint16(595), uint16(595), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(596), uint16(596), uint16(596), uint16(596),

	// block 54
	uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597),
	uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597), uint16(597),
	uint16(597), uint16(597), uint16(597), uint16(597), uint16(598), uint16(598), uint16(598), uint16(598), uint16(598), uint16(598), uint16(598), uint16(598), uint16(599), uint16(599), uint16(599), uint16(599),
	uint16(599), uint16(599), uint16(599), uint16(599), uint16(598), uint16(598), uint16(600), uint16(601), uint16(163), uint16(163), uint16(163), uint16(602), uint16(602), uint16(603), uint16(603), uint16(603),
	uint16(604), uint16(604), uint16(604), uint16(604), uint16(604), uint16(604), uint16(604), uint16(604), uint16(604), uint16(604), uint16(163), uint16(163), uint16(163), uint16(597), uint16(597), uint16(597),
	uint16(605), uint16(605), uint16(605), uint16(605), uint16(605), uint16(605), uint16(605), uint16(605), uint16(605), uint16(605), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606),
	uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606),
	uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(606), uint16(607), uint16(607), uint16(607), uint16(608), uint16(607), uint16(607), uint16(609), uint16(609),

	// block 55
	uint16(610), uint16(611), uint16(612), uint16(613), uint16(614), uint16(615), uint16(616), uint16(617), uint16(618), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619),
	uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619),
	uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(619), uint16(163), uint16(163), uint16(619), uint16(619), uint16(619),
	uint16(620), uint16(620), uint16(620), uint16(620), uint16(620), uint16(620), uint16(620), uint16(620), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(621), uint16(622), uint16(621), uint16(623), uint16(622), uint16(624), uint16(624), uint16(625), uint16(624), uint16(625), uint16(626), uint16(622), uint16(625), uint16(625), uint16(622), uint16(622),
	uint16(625), uint16(627), uint16(622), uint16(622), uint16(622), uint16(622), uint16(622), uint16(622), uint16(622), uint16(628), uint16(629), uint16(630), uint16(630), uint16(624), uint16(630), uint16(630),
	uint16(630), uint16(630), uint16(631), uint16(632), uint16(633), uint16(629), uint16(629), uint16(634), uint16(635), uint16(635), uint16(636), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 56
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(221), uint16(221), uint16(221), uint16(221), uint16(221), uint16(637), uint16(147), uint16(147), uint16(147), uint16(147),
	uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147),
	uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147),
	uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(638), uint16(638), uint16(638),
	uint16(638), uint16(638), uint16(148), uint16(147), uint16(147), uint16(147), uint16(638), uint16(638), uint16(638), uint16(638), uint16(638), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(639), uint16(640), uint16(70), uint16(70), uint16(70), uint16(641), uint16(70), uint16(70),

	// block 57
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(642), uint16(70),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(643), uint16(70), uint16(70), uint16(70), uint16(70), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644),
	uint16(644), uint16(644), uint16(644), uint16(644), uint16(645), uint16(644), uint16(644), uint16(644), uint16(645), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644),
	uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(646),
	uint16(647), uint16(647), uint16(158), uint16(158), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),
	uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158),
	uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(158), uint16(573), uint16(573), uint16(573), uint16(573), uint16(573), uint16(573), uint16(573), uint16(573), uint16(573),
	uint16(573), uint16(573), uint16(573), uint16(573), uint16(573), uint16(154), uint16(154), uint16(154), uint16(648), uint16(154), uint16(649), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),

	// block 58
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(67), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(650), uint16(651), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),

	// block 59
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(69), uint16(69), uint16(69), uint16(69), uint16(652), uint16(653), uint16(70), uint16(70), uint16(654), uint16(70),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(67), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),

	// block 60
	uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656),
	uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(163), uint16(163), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(163), uint16(163),
	uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656),
	uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656),
	uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(163), uint16(163), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(163), uint16(163),
	uint16(173), uint16(655), uint16(173), uint16(655), uint16(173), uint16(655), uint16(173), uint16(655), uint16(163), uint16(656), uint16(163), uint16(656), uint16(163), uint16(656), uint16(163), uint16(656),
	uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(655), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656), uint16(656),
	uint16(657), uint16(657), uint16(658), uint16(658), uint16(658), uint16(658), uint16(659), uint16(659), uint16(660), uint16(660), uint16(661), uint16(661), uint16(662), uint16(662), uint16(163), uint16(163),

	// block 61
	uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664),
	uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664),
	uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(663), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664), uint16(664),
	uint16(655), uint16(655), uint16(665), uint16(666), uint16(665), uint16(163), uint16(173), uint16(665), uint16(656), uint16(656), uint16(667), uint16(667), uint16(668), uint16(162), uint16(669), uint16(162),
	uint16(162), uint16(162), uint16(665), uint16(666), uint16(665), uint16(163), uint16(173), uint16(665), uint16(670), uint16(670), uint16(670), uint16(670), uint16(668), uint16(162), uint16(162), uint16(162),
	uint16(655), uint16(655), uint16(173), uint16(173), uint16(163), uint16(163), uint16(173), uint16(173), uint16(656), uint16(656), uint16(671), uint16(671), uint16(163), uint16(162), uint16(162), uint16(162),
	uint16(655), uint16(655), uint16(173), uint16(173), uint16(173), uint16(215), uint16(173), uint16(173), uint16(656), uint16(656), uint16(672), uint16(672), uint16(220), uint16(162), uint16(162), uint16(162),
	uint16(163), uint16(163), uint16(665), uint16(666), uint16(665), uint16(163), uint16(173), uint16(665), uint16(673), uint16(673), uint16(674), uint16(674), uint16(668), uint16(162), uint16(162), uint16(163),

	// block 62
	uint16(675), uint16(675), uint16(675), uint16(675), uint16(675), uint16(675), uint16(675), uint16(675), uint16(675), uint16(675), uint16(675), uint16(51), uint16(676), uint16(677), uint16(678), uint16(679),
	uint16(680), uint16(680), uint16(680), uint16(680), uint16(680), uint16(680), uint16(681), uint16(43), uint16(682), uint16(683), uint16(684), uint16(685), uint16(685), uint16(686), uint16(684), uint16(685),
	uint16(43), uint16(43), uint16(43), uint16(43), uint16(687), uint16(43), uint16(43), uint16(687), uint16(688), uint16(689), uint16(690), uint16(691), uint16(692), uint16(693), uint16(694), uint16(695),
	uint16(696), uint16(696), uint16(697), uint16(697), uint16(697), uint16(43), uint16(43), uint16(43), uint16(43), uint16(49), uint16(57), uint16(43), uint16(698), uint16(699), uint16(43), uint16(700),
	uint16(701), uint16(43), uint16(43), uint16(43), uint16(702), uint16(703), uint16(704), uint16(699), uint16(699), uint16(698), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43),
	uint16(43), uint16(43), uint16(50), uint16(705), uint16(700), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(675),
	uint16(51), uint16(706), uint16(706), uint16(706), uint16(706), uint16(707), uint16(708), uint16(709), uint16(710), uint16(711), uint16(712), uint16(712), uint16(712), uint16(712), uint16(712), uint16(712),
	uint16(54), uint16(645), uint16(163), uint16(163), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(713), uint16(714), uint16(715), uint16(716), uint16(717), uint16(644),

	// block 63
	uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(713), uint16(714), uint16(715), uint16(716), uint16(717), uint16(163),
	uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(644), uint16(163), uint16(163), uint16(163),
	uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431),
	uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431), uint16(431),
	uint16(431), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718), uint16(718),
	uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719), uint16(720), uint16(720), uint16(720),
	uint16(720), uint16(719), uint16(720), uint16(721), uint16(720), uint16(719), uint16(719), uint16(158), uint16(158), uint16(158), uint16(158), uint16(719), uint16(719), uint16(719), uint16(719), uint16(719),
	uint16(722), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 64
	uint16(723), uint16(723), uint16(724), uint16(723), uint16(723), uint16(723), uint16(723), uint16(724), uint16(723), uint16(723), uint16(725), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725),
	uint16(724), uint16(724), uint16(724), uint16(725), uint16(723), uint16(724), uint16(723), uint16(723), uint16(726), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(727), uint16(723), uint16(724), uint16(723), uint16(728), uint16(723), uint16(724), uint16(729), uint16(730), uint16(731), uint16(724), uint16(724), uint16(732), uint16(725),
	uint16(724), uint16(724), uint16(733), uint16(724), uint16(725), uint16(734), uint16(734), uint16(734), uint16(734), uint16(735), uint16(723), uint16(723), uint16(725), uint16(725), uint16(724), uint16(724),
	uint16(715), uint16(715), uint16(715), uint16(715), uint16(715), uint16(724), uint16(725), uint16(725), uint16(736), uint16(736), uint16(723), uint16(715), uint16(723), uint16(723), uint16(737), uint16(460),
	uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),
	uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738), uint16(738),
	uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739), uint16(739),

	// block 65
	uint16(740), uint16(740), uint16(740), uint16(65), uint16(66), uint16(740), uint16(740), uint16(740), uint16(740), uint16(58), uint16(723), uint16(723), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(741), uint16(742), uint16(742), uint16(742), uint16(742), uint16(742), uint16(50), uint16(50), uint16(743), uint16(743), uint16(743), uint16(743),
	uint16(50), uint16(743), uint16(743), uint16(50), uint16(743), uint16(743), uint16(50), uint16(743), uint16(45), uint16(742), uint16(742), uint16(743), uint16(743), uint16(743), uint16(50), uint16(45),
	uint16(743), uint16(743), uint16(45), uint16(45), uint16(45), uint16(45), uint16(743), uint16(743), uint16(45), uint16(45), uint16(45), uint16(45), uint16(743), uint16(743), uint16(743), uint16(743),
	uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(50), uint16(50),
	uint16(743), uint16(743), uint16(50), uint16(743), uint16(50), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(45), uint16(743), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(743), uint16(743), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),

	// block 66
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(745), uint16(53), uint16(50), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(50), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(744), uint16(50), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(744), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744),

	// block 67
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(744), uint16(50), uint16(744), uint16(744), uint16(50), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50),
	uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50),
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50),

	// block 68
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(746), uint16(747), uint16(746), uint16(747), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(748), uint16(748), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(50), uint16(50), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(47), uint16(749), uint16(750), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751),
	uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751),
	uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751),
	uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751),
	uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(751), uint16(45), uint16(50), uint16(45), uint16(45), uint16(45),

	// block 69
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(752), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(751), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(743), uint16(743), uint16(45), uint16(743), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(47),
	uint16(743), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(743), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(748), uint16(748), uint16(748), uint16(748), uint16(47), uint16(47), uint16(47),
	uint16(748), uint16(47), uint16(47), uint16(748), uint16(45), uint16(45), uint16(45), uint16(45), uint16(47), uint16(47), uint16(47), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),

	// block 70
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753),
	uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753),
	uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753),
	uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),
	uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),

	// block 71
	uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54),
	uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754),
	uint16(754), uint16(754), uint16(755), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754), uint16(754),
	uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756),
	uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(756), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),
	uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),

	// block 72
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),

	// block 73
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(743), uint16(743), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(47), uint16(47), uint16(45), uint16(45), uint16(743), uint16(743),
	uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(742), uint16(50), uint16(45), uint16(45), uint16(45), uint16(45), uint16(743), uint16(743), uint16(743), uint16(743),
	uint16(742), uint16(50), uint16(45), uint16(45), uint16(45), uint16(45), uint16(743), uint16(743), uint16(45), uint16(45), uint16(743), uint16(743), uint16(45), uint16(45), uint16(45), uint16(743),
	uint16(743), uint16(743), uint16(743), uint16(743), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(743), uint16(45), uint16(743), uint16(45), uint16(45), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(743), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(50), uint16(50), uint16(50), uint16(741), uint16(741), uint16(757), uint16(757), uint16(50),

	// block 74
	uint16(47), uint16(47), uint16(47), uint16(47), uint16(47), uint16(758), uint16(743), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(47), uint16(752),
	uint16(752), uint16(47), uint16(752), uint16(45), uint16(748), uint16(748), uint16(752), uint16(752), uint16(47), uint16(752), uint16(752), uint16(752), uint16(752), uint16(759), uint16(752), uint16(752),
	uint16(47), uint16(752), uint16(47), uint16(47), uint16(752), uint16(752), uint16(47), uint16(752), uint16(752), uint16(752), uint16(47), uint16(752), uint16(752), uint16(752), uint16(47), uint16(47),
	uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(47), uint16(47), uint16(47), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752),
	uint16(742), uint16(752), uint16(742), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(748), uint16(748), uint16(748), uint16(748), uint16(748), uint16(748), uint16(748), uint16(748),
	uint16(748), uint16(748), uint16(748), uint16(748), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(47),
	uint16(742), uint16(758), uint16(758), uint16(742), uint16(752), uint16(47), uint16(47), uint16(752), uint16(47), uint16(752), uint16(752), uint16(752), uint16(752), uint16(758), uint16(758), uint16(760),
	uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(47), uint16(752), uint16(752), uint16(47), uint16(748),

	// block 75
	uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(752), uint16(752), uint16(47), uint16(748), uint16(47), uint16(47), uint16(47), uint16(47), uint16(752), uint16(47), uint16(752), uint16(47), uint16(47), uint16(752), uint16(752), uint16(752),
	uint16(47), uint16(748), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(47), uint16(752), uint16(752), uint16(748), uint16(748), uint16(761), uint16(752), uint16(752), uint16(752),
	uint16(47), uint16(47), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(748), uint16(748), uint16(752),
	uint16(752), uint16(752), uint16(752), uint16(752), uint16(748), uint16(748), uint16(752), uint16(752), uint16(47), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(748), uint16(47),
	uint16(752), uint16(47), uint16(752), uint16(47), uint16(748), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752),
	uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752), uint16(47), uint16(748), uint16(752), uint16(752), uint16(752), uint16(752), uint16(752),
	uint16(47), uint16(47), uint16(748), uint16(748), uint16(47), uint16(748), uint16(752), uint16(47), uint16(47), uint16(759), uint16(748), uint16(752), uint16(752), uint16(748), uint16(752), uint16(752),

	// block 76
	uint16(752), uint16(752), uint16(47), uint16(752), uint16(752), uint16(748), uint16(45), uint16(45), uint16(47), uint16(47), uint16(762), uint16(762), uint16(759), uint16(759), uint16(752), uint16(47),
	uint16(752), uint16(752), uint16(47), uint16(45), uint16(47), uint16(45), uint16(47), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(47), uint16(45), uint16(45),
	uint16(45), uint16(47), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(748), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(47), uint16(47), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(47), uint16(45), uint16(45), uint16(47), uint16(45), uint16(45), uint16(45), uint16(45), uint16(748), uint16(45), uint16(748), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(748), uint16(748), uint16(748), uint16(45), uint16(748), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(47), uint16(47), uint16(752), uint16(752), uint16(752), uint16(703), uint16(704), uint16(703), uint16(704), uint16(703), uint16(704), uint16(703), uint16(704),
	uint16(703), uint16(704), uint16(703), uint16(704), uint16(703), uint16(704), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),

	// block 77
	uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),
	uint16(58), uint16(58), uint16(58), uint16(58), uint16(45), uint16(748), uint16(748), uint16(748), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(47), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(748), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(748),
	uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(746), uint16(747), uint16(50), uint16(744), uint16(744), uint16(50), uint16(744), uint16(50), uint16(744), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(50),
	uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),

	// block 78
	uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763),
	uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763),
	uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763),
	uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763),
	uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763),
	uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763),
	uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763),
	uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763), uint16(763),

	// block 79
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(741), uint16(741), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),

	// block 80
	uint16(50), uint16(50), uint16(50), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746),
	uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(746), uint16(747), uint16(50), uint16(50), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(744), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(744), uint16(744), uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(746), uint16(747), uint16(746), uint16(747), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(746), uint16(747), uint16(50), uint16(50),

	// block 81
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744),

	// block 82
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744),
	uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(744), uint16(744), uint16(744), uint16(744), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),

	// block 83
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(47), uint16(47), uint16(47), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(748), uint16(748), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50),
	uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(45), uint16(45), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(50), uint16(45), uint16(45), uint16(45),
	uint16(748), uint16(45), uint16(45), uint16(45), uint16(45), uint16(748), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(753), uint16(753), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),

	// block 84
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(753), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45),
	uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(45), uint16(764), uint16(45),

	// block 85
	uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765),
	uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765),
	uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765), uint16(765),
	uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766),
	uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766),
	uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766), uint16(766),
	uint16(65), uint16(66), uint16(767), uint16(768), uint16(769), uint16(770), uint16(771), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(772), uint16(773), uint16(774),
	uint16(775), uint16(70), uint16(65), uint16(66), uint16(70), uint16(65), uint16(66), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(645), uint16(644), uint16(776), uint16(776),

	// block 86
	uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212),
	uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212),
	uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212),
	uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212),
	uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212),
	uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212), uint16(211), uint16(212),
	uint16(211), uint16(212), uint16(211), uint16(212), uint16(777), uint16(778), uint16(778), uint16(778), uint16(778), uint16(778), uint16(778), uint16(211), uint16(212), uint16(211), uint16(212), uint16(779),
	uint16(779), uint16(779), uint16(211), uint16(212), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(780), uint16(780), uint16(780), uint16(780), uint16(781), uint16(780), uint16(780),

	// block 87
	uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782),
	uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782),
	uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(782), uint16(163), uint16(782), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(782), uint16(163), uint16(163),
	uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783),
	uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783),
	uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783),
	uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(783), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(784),
	uint16(785), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(786),

	// block 88
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163),
	uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787),
	uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787),

	// block 89
	uint16(43), uint16(43), uint16(788), uint16(789), uint16(788), uint16(789), uint16(43), uint16(43), uint16(43), uint16(788), uint16(789), uint16(43), uint16(788), uint16(789), uint16(43), uint16(43),
	uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(680), uint16(43), uint16(43), uint16(680), uint16(43), uint16(788), uint16(789), uint16(43), uint16(43),
	uint16(788), uint16(789), uint16(703), uint16(704), uint16(703), uint16(704), uint16(703), uint16(704), uint16(703), uint16(704), uint16(43), uint16(43), uint16(43), uint16(43), uint16(699), uint16(790),
	uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(680), uint16(680), uint16(699), uint16(43), uint16(43), uint16(43),
	uint16(680), uint16(791), uint16(684), uint16(792), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(43), uint16(791), uint16(43), uint16(791), uint16(791),
	uint16(45), uint16(45), uint16(43), uint16(699), uint16(699), uint16(703), uint16(704), uint16(703), uint16(704), uint16(703), uint16(704), uint16(703), uint16(704), uint16(680), uint16(753), uint16(753),
	uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753),
	uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753), uint16(753),

	// block 90
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(163), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 91
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),

	// block 92
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793),
	uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(793), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(794), uint16(794), uint16(795), uint16(795), uint16(794), uint16(794), uint16(794), uint16(794), uint16(794), uint16(794), uint16(794), uint16(794), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 93
	uint16(675), uint16(796), uint16(797), uint16(798), uint16(723), uint16(799), uint16(800), uint16(801), uint16(802), uint16(803), uint16(802), uint16(803), uint16(804), uint16(805), uint16(804), uint16(805),
	uint16(802), uint16(803), uint16(45), uint16(806), uint16(802), uint16(803), uint16(802), uint16(803), uint16(802), uint16(803), uint16(802), uint16(803), uint16(807), uint16(808), uint16(809), uint16(809),
	uint16(45), uint16(801), uint16(801), uint16(801), uint16(801), uint16(801), uint16(801), uint16(801), uint16(801), uint16(801), uint16(810), uint16(810), uint16(810), uint16(810), uint16(811), uint16(811),
	uint16(812), uint16(813), uint16(813), uint16(813), uint16(813), uint16(813), uint16(723), uint16(814), uint16(801), uint16(801), uint16(801), uint16(815), uint16(816), uint16(817), uint16(818), uint16(818),
	uint16(163), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),

	// block 94
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(163), uint16(163), uint16(820), uint16(820), uint16(821), uint16(821), uint16(822), uint16(822), uint16(819),
	uint16(823), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),
	uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),
	uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),
	uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),
	uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),
	uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(825), uint16(826), uint16(827), uint16(827), uint16(824),

	// block 95
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828),
	uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828),
	uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828),
	uint16(163), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829),
	uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829),
	uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829),
	uint16(829), uint16(829), uint16(829), uint16(829), uint16(830), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829),
	uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829),

	// block 96
	uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(163),
	uint16(831), uint16(831), uint16(832), uint16(832), uint16(832), uint16(832), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828),
	uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828), uint16(828),
	uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818),
	uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818), uint16(818),
	uint16(818), uint16(818), uint16(818), uint16(818), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),

	// block 97
	uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833),
	uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(834), uint16(834), uint16(163),
	uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835),
	uint16(723), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),
	uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833),
	uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(833), uint16(834), uint16(834), uint16(834), uint16(460),

	// block 98
	uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(836), uint16(831), uint16(836), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(831), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58), uint16(58),
	uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837),
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837),
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(831),

	// block 99
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837),
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837),
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837),
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837),
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837),
	uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(837), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(831), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(723), uint16(723), uint16(723), uint16(723), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),

	// block 100
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(723), uint16(723),
	uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831),
	uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(831), uint16(723),

	// block 101
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),

	// block 102
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),

	// block 103
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(840), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),

	// block 104
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839),

	// block 105
	uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(839), uint16(163), uint16(163), uint16(163),
	uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841),
	uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841),
	uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841),
	uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(841), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842),
	uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842),
	uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(842), uint16(843), uint16(843), uint16(843), uint16(843), uint16(843), uint16(843), uint16(844), uint16(845),

	// block 106
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),

	// block 107
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(847), uint16(848), uint16(849), uint16(849),
	uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846), uint16(846),
	uint16(850), uint16(850), uint16(850), uint16(850), uint16(850), uint16(850), uint16(850), uint16(850), uint16(850), uint16(850), uint16(846), uint16(846), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(851), uint16(852), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(853), uint16(246),
	uint16(248), uint16(248), uint16(248), uint16(854), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(787), uint16(855), uint16(855), uint16(854), uint16(856),

	// block 108
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241),
	uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(240), uint16(241), uint16(857), uint16(857), uint16(787), uint16(787),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(859), uint16(859), uint16(859), uint16(859), uint16(859), uint16(859), uint16(859), uint16(859), uint16(859), uint16(859),
	uint16(860), uint16(860), uint16(861), uint16(862), uint16(863), uint16(863), uint16(863), uint16(862), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 109
	uint16(864), uint16(864), uint16(864), uint16(864), uint16(864), uint16(864), uint16(864), uint16(864), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46),
	uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(46), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149), uint16(149),
	uint16(46), uint16(46), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(70), uint16(70), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(644), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(65), uint16(66), uint16(65), uint16(66), uint16(865), uint16(65), uint16(66),

	// block 110
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(149), uint16(866), uint16(866), uint16(65), uint16(66), uint16(867), uint16(70), uint16(92),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(868), uint16(70), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(869), uint16(870), uint16(871), uint16(872), uint16(869), uint16(70),
	uint16(873), uint16(874), uint16(875), uint16(876), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66), uint16(65), uint16(66),
	uint16(65), uint16(66), uint16(65), uint16(66), uint16(877), uint16(878), uint16(879), uint16(65), uint16(66), uint16(65), uint16(66), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(65), uint16(66), uint16(163), uint16(70), uint16(163), uint16(70), uint16(65), uint16(66), uint16(65), uint16(66), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(880), uint16(880), uint16(880), uint16(65), uint16(66), uint16(92), uint16(147), uint16(147), uint16(70), uint16(92), uint16(92), uint16(92), uint16(92), uint16(92),

	// block 111
	uint16(881), uint16(881), uint16(882), uint16(881), uint16(881), uint16(881), uint16(883), uint16(881), uint16(881), uint16(881), uint16(881), uint16(882), uint16(881), uint16(881), uint16(881), uint16(881),
	uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881), uint16(881),
	uint16(881), uint16(881), uint16(881), uint16(884), uint16(884), uint16(882), uint16(882), uint16(884), uint16(885), uint16(885), uint16(885), uint16(885), uint16(883), uint16(163), uint16(163), uint16(163),
	uint16(886), uint16(886), uint16(886), uint16(887), uint16(887), uint16(887), uint16(888), uint16(888), uint16(889), uint16(890), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891),
	uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891),
	uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891), uint16(891),
	uint16(891), uint16(891), uint16(891), uint16(891), uint16(892), uint16(892), uint16(893), uint16(893), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 112
	uint16(894), uint16(894), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895),
	uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895),
	uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895), uint16(895),
	uint16(895), uint16(895), uint16(895), uint16(895), uint16(894), uint16(894), uint16(894), uint16(894), uint16(894), uint16(894), uint16(894), uint16(894), uint16(894), uint16(894), uint16(894), uint16(894),
	uint16(894), uint16(894), uint16(894), uint16(894), uint16(896), uint16(897), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(898), uint16(898),
	uint16(899), uint16(899), uint16(899), uint16(899), uint16(899), uint16(899), uint16(899), uint16(899), uint16(899), uint16(899), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336), uint16(336),
	uint16(336), uint16(900), uint16(335), uint16(901), uint16(335), uint16(335), uint16(335), uint16(335), uint16(343), uint16(343), uint16(343), uint16(335), uint16(343), uint16(335), uint16(335), uint16(333),

	// block 113
	uint16(902), uint16(902), uint16(902), uint16(902), uint16(902), uint16(902), uint16(902), uint16(902), uint16(902), uint16(902), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903),
	uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903),
	uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(903), uint16(904), uint16(904), uint16(904), uint16(904), uint16(904), uint16(905), uint16(905), uint16(905), uint16(906), uint16(907),
	uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908),
	uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(908), uint16(909), uint16(909), uint16(909), uint16(909), uint16(909), uint16(909), uint16(909), uint16(909), uint16(909),
	uint16(909), uint16(909), uint16(910), uint16(911), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(912),
	uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478),
	uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(478), uint16(163), uint16(163), uint16(163),

	// block 114
	uint16(913), uint16(913), uint16(913), uint16(914), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915),
	uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915),
	uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915), uint16(915),
	uint16(915), uint16(915), uint16(915), uint16(916), uint16(914), uint16(914), uint16(913), uint16(913), uint16(913), uint16(913), uint16(914), uint16(914), uint16(913), uint16(913), uint16(914), uint16(914),
	uint16(917), uint16(918), uint16(918), uint16(918), uint16(918), uint16(918), uint16(918), uint16(919), uint16(920), uint16(920), uint16(918), uint16(918), uint16(918), uint16(918), uint16(163), uint16(921),
	uint16(922), uint16(922), uint16(922), uint16(922), uint16(922), uint16(922), uint16(922), uint16(922), uint16(922), uint16(922), uint16(163), uint16(163), uint16(163), uint16(163), uint16(918), uint16(918),
	uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(471), uint16(923), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461),
	uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(472), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(163),

	// block 115
	uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924),
	uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924),
	uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(925), uint16(925), uint16(925), uint16(925), uint16(925), uint16(925), uint16(926),
	uint16(926), uint16(925), uint16(925), uint16(926), uint16(926), uint16(925), uint16(925), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(924), uint16(924), uint16(924), uint16(925), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(924), uint16(925), uint16(926), uint16(163), uint16(163),
	uint16(927), uint16(927), uint16(927), uint16(927), uint16(927), uint16(927), uint16(927), uint16(927), uint16(927), uint16(927), uint16(163), uint16(163), uint16(928), uint16(929), uint16(929), uint16(929),
	uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461),
	uint16(923), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(461), uint16(473), uint16(473), uint16(473), uint16(461), uint16(470), uint16(471), uint16(470), uint16(461), uint16(461),

	// block 116
	uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930),
	uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930),
	uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930), uint16(930),
	uint16(931), uint16(930), uint16(931), uint16(931), uint16(931), uint16(932), uint16(932), uint16(931), uint16(931), uint16(932), uint16(930), uint16(932), uint16(932), uint16(930), uint16(931), uint16(933),
	uint16(934), uint16(933), uint16(934), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(930), uint16(930), uint16(935), uint16(936), uint16(937),
	uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(939), uint16(940), uint16(940), uint16(939), uint16(939),
	uint16(941), uint16(941), uint16(938), uint16(942), uint16(942), uint16(939), uint16(943), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 117
	uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163),
	uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70),
	uint16(70), uint16(70), uint16(70), uint16(944), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(866), uint16(147), uint16(147), uint16(147), uint16(147),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(221), uint16(70), uint16(70), uint16(70), uint16(945), uint16(46), uint16(46), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946),

	// block 118
	uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946),
	uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946),
	uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946),
	uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946), uint16(946),
	uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938),
	uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938), uint16(938),
	uint16(938), uint16(938), uint16(938), uint16(939), uint16(939), uint16(940), uint16(939), uint16(939), uint16(940), uint16(939), uint16(939), uint16(941), uint16(947), uint16(943), uint16(163), uint16(163),
	uint16(948), uint16(948), uint16(948), uint16(948), uint16(948), uint16(948), uint16(948), uint16(948), uint16(948), uint16(948), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 119
	uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),

	// block 120
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950),

	// block 121
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),

	// block 122
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),

	// block 123
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),

	// block 124
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),

	// block 125
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),

	// block 126
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(949), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950), uint16(950),
	uint16(950), uint16(950), uint16(950), uint16(950), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481),
	uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(481), uint16(163), uint16(163), uint16(163), uint16(163), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),
	uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),
	uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482),
	uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(482), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 127
	uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951),
	uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951),
	uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951),
	uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951),
	uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951),
	uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951),
	uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951),
	uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951), uint16(951),

	// block 128
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),

	// block 129
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),

	// block 130
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(838), uint16(838),
	uint16(953), uint16(838), uint16(953), uint16(838), uint16(838), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(838),
	uint16(953), uint16(838), uint16(953), uint16(838), uint16(838), uint16(953), uint16(953), uint16(838), uint16(838), uint16(838), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(163), uint16(163),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),

	// block 131
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 132
	uint16(652), uint16(652), uint16(652), uint16(652), uint16(652), uint16(652), uint16(652), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(257), uint16(257), uint16(257), uint16(257), uint16(257), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(270), uint16(265), uint16(270),
	uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(954), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270),
	uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(262), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(262), uint16(270), uint16(262),
	uint16(270), uint16(270), uint16(262), uint16(270), uint16(270), uint16(262), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270), uint16(270),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),

	// block 133
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331), uint16(331),
	uint16(331), uint16(331), uint16(331), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(302), uint16(302), uint16(302), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),

	// block 134
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(955), uint16(955),
	uint16(955), uint16(955), uint16(955), uint16(955), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),

	// block 135
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),

	// block 136
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(956), uint16(957),
	uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280), uint16(280),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),

	// block 137
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(302), uint16(302), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(280),
	uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958),
	uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958), uint16(958),
	uint16(286), uint16(286), uint16(959), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(955), uint16(955), uint16(277), uint16(960), uint16(280), uint16(280),

	// block 138
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(962),
	uint16(963), uint16(963), uint16(963), uint16(964), uint16(963), uint16(963), uint16(963), uint16(965), uint16(966), uint16(963), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(855), uint16(855),
	uint16(963), uint16(967), uint16(967), uint16(700), uint16(700), uint16(965), uint16(966), uint16(965), uint16(966), uint16(965), uint16(966), uint16(965), uint16(966), uint16(965), uint16(966), uint16(965),
	uint16(966), uint16(968), uint16(969), uint16(968), uint16(969), uint16(798), uint16(798), uint16(965), uint16(966), uint16(963), uint16(963), uint16(963), uint16(963), uint16(700), uint16(700), uint16(700),
	uint16(970), uint16(166), uint16(971), uint16(163), uint16(166), uint16(972), uint16(973), uint16(973), uint16(967), uint16(974), uint16(975), uint16(974), uint16(975), uint16(974), uint16(975), uint16(976),
	uint16(963), uint16(977), uint16(713), uint16(978), uint16(979), uint16(979), uint16(715), uint16(163), uint16(977), uint16(431), uint16(976), uint16(963), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(955), uint16(286), uint16(955), uint16(286), uint16(955), uint16(302), uint16(955), uint16(286), uint16(955), uint16(286), uint16(955), uint16(286), uint16(955), uint16(286), uint16(955), uint16(286),

	// block 139
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286),
	uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(286), uint16(302), uint16(302), uint16(51),

	// block 140
	uint16(163), uint16(973), uint16(980), uint16(976), uint16(431), uint16(976), uint16(963), uint16(981), uint16(974), uint16(975), uint16(963), uint16(713), uint16(970), uint16(982), uint16(971), uint16(983),
	uint16(984), uint16(984), uint16(984), uint16(984), uint16(984), uint16(984), uint16(984), uint16(984), uint16(984), uint16(984), uint16(972), uint16(166), uint16(979), uint16(715), uint16(979), uint16(973),
	uint16(963), uint16(985), uint16(985), uint16(985), uint16(985), uint16(985), uint16(985), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59),
	uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(974), uint16(977), uint16(975), uint16(986), uint16(700),
	uint16(46), uint16(987), uint16(987), uint16(987), uint16(987), uint16(987), uint16(987), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62),
	uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(62), uint16(974), uint16(715), uint16(975), uint16(715), uint16(974),
	uint16(975), uint16(988), uint16(989), uint16(990), uint16(991), uint16(825), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),
	uint16(826), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),

	// block 141
	uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824),
	uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(824), uint16(992), uint16(992),
	uint16(830), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829),
	uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(163),
	uint16(163), uint16(163), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(163), uint16(163), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829),
	uint16(163), uint16(163), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(829), uint16(163), uint16(163), uint16(829), uint16(829), uint16(829), uint16(163), uint16(163), uint16(163),
	uint16(431), uint16(431), uint16(715), uint16(46), uint16(723), uint16(431), uint16(431), uint16(163), uint16(723), uint16(715), uint16(715), uint16(715), uint16(715), uint16(723), uint16(723), uint16(163),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(993), uint16(993), uint16(993), uint16(723), uint16(723), uint16(958), uint16(958),

	// block 142
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(163), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(163), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(163), uint16(994), uint16(994), uint16(163), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(163), uint16(163),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 143
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994),
	uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(994), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 144
	uint16(995), uint16(996), uint16(997), uint16(163), uint16(163), uint16(163), uint16(163), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998),
	uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998),
	uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998), uint16(998),
	uint16(998), uint16(998), uint16(998), uint16(998), uint16(163), uint16(163), uint16(163), uint16(999), uint16(999), uint16(999), uint16(999), uint16(999), uint16(999), uint16(999), uint16(999), uint16(999),
	uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000),
	uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000),
	uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000),
	uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1000), uint16(1001), uint16(1001), uint16(1001), uint16(1001), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002),

	// block 145
	uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1001), uint16(1001), uint16(1002), uint16(1003), uint16(1003), uint16(163),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(163), uint16(163), uint16(163),
	uint16(1002), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(158), uint16(163), uint16(163),

	// block 146
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 147
	uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004),
	uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(1004), uint16(163), uint16(163), uint16(163),
	uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005),
	uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005),
	uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005), uint16(1005),
	uint16(1005), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1006), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007),
	uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(1007), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 148
	uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008),
	uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008), uint16(1008),
	uint16(1009), uint16(1009), uint16(1009), uint16(1009), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1008), uint16(1008), uint16(1008),
	uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010),
	uint16(1010), uint16(1011), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1010), uint16(1011), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012),
	uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012),
	uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1012), uint16(1013), uint16(1013), uint16(1013), uint16(1013), uint16(1013), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 149
	uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014),
	uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(1014), uint16(163), uint16(1015),
	uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016),
	uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016),
	uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016), uint16(1016),
	uint16(1017), uint16(1018), uint16(1018), uint16(1018), uint16(1018), uint16(1018), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 150
	uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019),
	uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019),
	uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1019), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020),
	uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020),
	uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020), uint16(1020),
	uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021),
	uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021),
	uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021), uint16(1021),

	// block 151
	uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022),
	uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(1022), uint16(163), uint16(163),
	uint16(1023), uint16(1023), uint16(1023), uint16(1023), uint16(1023), uint16(1023), uint16(1023), uint16(1023), uint16(1023), uint16(1023), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024),
	uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(1024),
	uint16(1024), uint16(1024), uint16(1024), uint16(1024), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025),
	uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025),
	uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(1025), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 152
	uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026),
	uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026),
	uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(1026), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027),
	uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027),
	uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(1027),
	uint16(1027), uint16(1027), uint16(1027), uint16(1027), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1028),
	uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(163), uint16(1029), uint16(1029), uint16(1029), uint16(1029),

	// block 153
	uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(1029), uint16(163), uint16(1029), uint16(1029), uint16(1029), uint16(1029),
	uint16(1029), uint16(1029), uint16(1029), uint16(163), uint16(1029), uint16(1029), uint16(163), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030),
	uint16(1030), uint16(1030), uint16(163), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030),
	uint16(1030), uint16(1030), uint16(163), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(1030), uint16(163), uint16(1030), uint16(1030), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 154
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),

	// block 155
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(1031), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 156
	uint16(147), uint16(1032), uint16(1032), uint16(147), uint16(147), uint16(147), uint16(163), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147),
	uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147),
	uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147),
	uint16(147), uint16(163), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(147), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 157
	uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(262), uint16(262), uint16(1033), uint16(262), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033),
	uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033),
	uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033),
	uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(1033), uint16(262), uint16(1033), uint16(1033), uint16(262), uint16(262), uint16(262), uint16(1033), uint16(262), uint16(262), uint16(1033),
	uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034),
	uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(1034), uint16(262), uint16(1035), uint16(1036), uint16(1036), uint16(1036), uint16(1036), uint16(1036), uint16(1036), uint16(1036), uint16(1036),
	uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037),
	uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1037), uint16(1038), uint16(1038), uint16(1039), uint16(1039), uint16(1039), uint16(1039), uint16(1039), uint16(1039), uint16(1039),

	// block 158
	uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040),
	uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(1040), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1041), uint16(1041), uint16(1041), uint16(1041), uint16(1041), uint16(1041), uint16(1041), uint16(1041), uint16(1041),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042), uint16(1042),
	uint16(1042), uint16(1042), uint16(1042), uint16(262), uint16(1042), uint16(1042), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1043), uint16(1043), uint16(1043), uint16(1043), uint16(1043),

	// block 159
	uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044),
	uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1044), uint16(1045), uint16(1045), uint16(1045), uint16(1045), uint16(1045), uint16(1045), uint16(262), uint16(262), uint16(262), uint16(1046),
	uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047),
	uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(1047), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1048),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 160
	uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049),
	uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049), uint16(1049),
	uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050),
	uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(1050), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1051), uint16(1051), uint16(1050), uint16(1050),
	uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051),
	uint16(262), uint16(262), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051),
	uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051),
	uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051), uint16(1051),

	// block 161
	uint16(1052), uint16(1053), uint16(1053), uint16(1053), uint16(262), uint16(1053), uint16(1053), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1053), uint16(1053), uint16(1053), uint16(1053),
	uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(262), uint16(1052), uint16(1052), uint16(1052), uint16(262), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052),
	uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052),
	uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(1052), uint16(262), uint16(262), uint16(1054), uint16(1054), uint16(1054), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1055),
	uint16(1056), uint16(1056), uint16(1056), uint16(1056), uint16(1056), uint16(1056), uint16(1056), uint16(1056), uint16(1056), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1057), uint16(1057), uint16(1057), uint16(1057), uint16(1057), uint16(1057), uint16(1058), uint16(1058), uint16(1057), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059),
	uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1059), uint16(1060), uint16(1060), uint16(1061),

	// block 162
	uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062),
	uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1062), uint16(1063), uint16(1063), uint16(1063),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1065), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064),
	uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064),
	uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1064), uint16(1066), uint16(1066), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1067), uint16(1067), uint16(1067), uint16(1067), uint16(1067),
	uint16(1068), uint16(1068), uint16(1069), uint16(1068), uint16(1068), uint16(1068), uint16(1070), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 163
	uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071),
	uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071),
	uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071),
	uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(1071), uint16(262), uint16(262), uint16(262), uint16(1072), uint16(1073), uint16(1073), uint16(1073), uint16(1073), uint16(1073), uint16(1073),
	uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074),
	uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(1074), uint16(262), uint16(262), uint16(1075), uint16(1075), uint16(1075), uint16(1075), uint16(1075), uint16(1075), uint16(1075), uint16(1075),
	uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076), uint16(1076),
	uint16(1076), uint16(1076), uint16(1076), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1077), uint16(1077), uint16(1077), uint16(1077), uint16(1077), uint16(1077), uint16(1077), uint16(1077),

	// block 164
	uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078), uint16(1078),
	uint16(1078), uint16(1078), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1079), uint16(1079), uint16(1079), uint16(1079), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1080), uint16(1080), uint16(1080), uint16(1080), uint16(1080), uint16(1080), uint16(1080),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 165
	uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081),
	uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081),
	uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081),
	uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081),
	uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(1081), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 166
	uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082),
	uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082),
	uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082), uint16(1082),
	uint16(1082), uint16(1082), uint16(1082), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083),
	uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083),
	uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083), uint16(1083),
	uint16(1083), uint16(1083), uint16(1083), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1084), uint16(1084), uint16(1084), uint16(1084), uint16(1084), uint16(1084),

	// block 167
	uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085),
	uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085), uint16(1085),
	uint16(1085), uint16(1085), uint16(1086), uint16(1086), uint16(1087), uint16(1087), uint16(1087), uint16(1087), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(1088), uint16(1088), uint16(1088), uint16(1088), uint16(1088), uint16(1088), uint16(1088), uint16(1088), uint16(1088), uint16(1088), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 168
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 169
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089),
	uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(1089), uint16(262),

	// block 170
	uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090),
	uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090),
	uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(1090), uint16(262), uint16(1091), uint16(1091), uint16(1092), uint16(262), uint16(262),
	uint16(1090), uint16(1090), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 171
	uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093),
	uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1094), uint16(1094), uint16(1094),
	uint16(1094), uint16(1094), uint16(1094), uint16(1094), uint16(1094), uint16(1094), uint16(1094), uint16(1093), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095),
	uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1095), uint16(1096), uint16(1096), uint16(1096), uint16(1096), uint16(1096), uint16(1096), uint16(1096), uint16(1096), uint16(1096), uint16(1096),
	uint16(1096), uint16(1097), uint16(1097), uint16(1097), uint16(1097), uint16(1098), uint16(1098), uint16(1098), uint16(1098), uint16(1098), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099), uint16(1099),

	// block 172
	uint16(1099), uint16(1099), uint16(1100), uint16(1100), uint16(1100), uint16(1100), uint16(1101), uint16(1101), uint16(1101), uint16(1101), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102),
	uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1102), uint16(1103), uint16(1103), uint16(1103), uint16(1103), uint16(1103), uint16(1103), uint16(1103), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104),
	uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(1104), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 173
	uint16(1105), uint16(1106), uint16(1105), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107),
	uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107),
	uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107),
	uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1107), uint16(1106), uint16(1106), uint16(1106), uint16(1106), uint16(1106), uint16(1106), uint16(1106), uint16(1106),
	uint16(1106), uint16(1106), uint16(1106), uint16(1106), uint16(1106), uint16(1106), uint16(1108), uint16(1109), uint16(1109), uint16(1110), uint16(1110), uint16(1110), uint16(1110), uint16(1110), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111),
	uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1111), uint16(1112), uint16(1112), uint16(1112), uint16(1112), uint16(1112), uint16(1112), uint16(1112), uint16(1112), uint16(1112), uint16(1112),
	uint16(1108), uint16(1107), uint16(1107), uint16(1106), uint16(1106), uint16(1107), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1113),

	// block 174
	uint16(1114), uint16(1114), uint16(1115), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116),
	uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116),
	uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116), uint16(1116),
	uint16(1115), uint16(1115), uint16(1115), uint16(1117), uint16(1117), uint16(1117), uint16(1117), uint16(1115), uint16(1115), uint16(1118), uint16(1119), uint16(1120), uint16(1120), uint16(1121), uint16(1122), uint16(1122),
	uint16(1122), uint16(1122), uint16(1117), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1121), uint16(163), uint16(163),
	uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123),
	uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(1123), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1124), uint16(1124), uint16(1124), uint16(1124), uint16(1124), uint16(1124), uint16(1124), uint16(1124), uint16(1124), uint16(1124), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 175
	uint16(1125), uint16(1125), uint16(1125), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126),
	uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126),
	uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1126), uint16(1125), uint16(1125), uint16(1125), uint16(1125), uint16(1125), uint16(1127), uint16(1125), uint16(1125), uint16(1125),
	uint16(1125), uint16(1125), uint16(1125), uint16(1128), uint16(1128), uint16(163), uint16(1129), uint16(1129), uint16(1129), uint16(1129), uint16(1129), uint16(1129), uint16(1129), uint16(1129), uint16(1129), uint16(1129),
	uint16(1130), uint16(1131), uint16(1131), uint16(1131), uint16(1126), uint16(1127), uint16(1127), uint16(1126), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132),
	uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132), uint16(1132),
	uint16(1132), uint16(1132), uint16(1132), uint16(1133), uint16(1134), uint16(1134), uint16(1132), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 176
	uint16(1135), uint16(1135), uint16(1136), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137),
	uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137),
	uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137), uint16(1137),
	uint16(1137), uint16(1137), uint16(1137), uint16(1136), uint16(1136), uint16(1136), uint16(1135), uint16(1135), uint16(1135), uint16(1135), uint16(1135), uint16(1135), uint16(1135), uint16(1135), uint16(1135), uint16(1136),
	uint16(1138), uint16(1137), uint16(1139), uint16(1139), uint16(1137), uint16(1140), uint16(1140), uint16(1141), uint16(1141), uint16(1142), uint16(1143), uint16(1143), uint16(1143), uint16(1140), uint16(1136), uint16(1135),
	uint16(1144), uint16(1144), uint16(1144), uint16(1144), uint16(1144), uint16(1144), uint16(1144), uint16(1144), uint16(1144), uint16(1144), uint16(1137), uint16(1141), uint16(1137), uint16(1141), uint16(1140), uint16(1140),
	uint16(163), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145),
	uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(1145), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 177
	uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146),
	uint16(1146), uint16(1146), uint16(163), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146),
	uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1146), uint16(1147), uint16(1147), uint16(1147), uint16(1148),
	uint16(1148), uint16(1148), uint16(1147), uint16(1147), uint16(1148), uint16(1149), uint16(1150), uint16(1148), uint16(1151), uint16(1151), uint16(1152), uint16(1151), uint16(1151), uint16(1153), uint16(1148), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 178
	uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(163), uint16(1154), uint16(163), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(163), uint16(1154),
	uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(163), uint16(1154),
	uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1154), uint16(1155), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156),
	uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156),
	uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1156), uint16(1157),
	uint16(1158), uint16(1158), uint16(1158), uint16(1157), uint16(1157), uint16(1157), uint16(1157), uint16(1157), uint16(1157), uint16(1159), uint16(1160), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1161), uint16(1161), uint16(1161), uint16(1161), uint16(1161), uint16(1161), uint16(1161), uint16(1161), uint16(1161), uint16(1161), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 179
	uint16(1162), uint16(1163), uint16(1164), uint16(1165), uint16(163), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(163), uint16(163), uint16(1166),
	uint16(1166), uint16(163), uint16(163), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166),
	uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(163), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166),
	uint16(1166), uint16(163), uint16(1166), uint16(1166), uint16(163), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(1166), uint16(163), uint16(1167), uint16(1168), uint16(1166), uint16(1169), uint16(1164),
	uint16(1162), uint16(1164), uint16(1164), uint16(1164), uint16(1164), uint16(163), uint16(163), uint16(1164), uint16(1164), uint16(163), uint16(163), uint16(1164), uint16(1164), uint16(1170), uint16(163), uint16(163),
	uint16(1166), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1169), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1171), uint16(1166), uint16(1166),
	uint16(1166), uint16(1166), uint16(1164), uint16(1164), uint16(163), uint16(163), uint16(1172), uint16(1172), uint16(1172), uint16(1172), uint16(1172), uint16(1172), uint16(1172), uint16(163), uint16(163), uint16(163),
	uint16(1172), uint16(1172), uint16(1172), uint16(1172), uint16(1172), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 180
	uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173),
	uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173),
	uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173),
	uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1174), uint16(1174), uint16(1174), uint16(1175), uint16(1175), uint16(1175), uint16(1175), uint16(1175), uint16(1175), uint16(1175), uint16(1175),
	uint16(1174), uint16(1174), uint16(1176), uint16(1175), uint16(1175), uint16(1174), uint16(1177), uint16(1173), uint16(1173), uint16(1173), uint16(1173), uint16(1178), uint16(1178), uint16(1179), uint16(1180), uint16(1180),
	uint16(1181), uint16(1181), uint16(1181), uint16(1181), uint16(1181), uint16(1181), uint16(1181), uint16(1181), uint16(1181), uint16(1181), uint16(1179), uint16(1179), uint16(163), uint16(1180), uint16(1182), uint16(1173),
	uint16(1173), uint16(1173), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 181
	uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183),
	uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183),
	uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183), uint16(1183),
	uint16(1184), uint16(1185), uint16(1185), uint16(1186), uint16(1186), uint16(1186), uint16(1186), uint16(1186), uint16(1186), uint16(1185), uint16(1186), uint16(1185), uint16(1185), uint16(1184), uint16(1185), uint16(1186),
	uint16(1186), uint16(1185), uint16(1187), uint16(1188), uint16(1183), uint16(1183), uint16(1189), uint16(1183), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1190), uint16(1190), uint16(1190), uint16(1190), uint16(1190), uint16(1190), uint16(1190), uint16(1190), uint16(1190), uint16(1190), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 182
	uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191),
	uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191),
	uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1192),
	uint16(1193), uint16(1193), uint16(1194), uint16(1194), uint16(1194), uint16(1194), uint16(163), uint16(163), uint16(1193), uint16(1193), uint16(1193), uint16(1193), uint16(1194), uint16(1194), uint16(1193), uint16(1195),
	uint16(1196), uint16(1197), uint16(1198), uint16(1198), uint16(1199), uint16(1199), uint16(1200), uint16(1200), uint16(1200), uint16(1198), uint16(1198), uint16(1198), uint16(1198), uint16(1198), uint16(1198), uint16(1198),
	uint16(1198), uint16(1198), uint16(1198), uint16(1198), uint16(1198), uint16(1198), uint16(1198), uint16(1198), uint16(1191), uint16(1191), uint16(1191), uint16(1191), uint16(1194), uint16(1194), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 183
	uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201),
	uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201),
	uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201), uint16(1201),
	uint16(1202), uint16(1202), uint16(1202), uint16(1203), uint16(1203), uint16(1203), uint16(1203), uint16(1203), uint16(1203), uint16(1203), uint16(1203), uint16(1202), uint16(1202), uint16(1203), uint16(1202), uint16(1204),
	uint16(1203), uint16(1205), uint16(1205), uint16(1206), uint16(1201), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1207), uint16(1207), uint16(1207), uint16(1207), uint16(1207), uint16(1207), uint16(1207), uint16(1207), uint16(1207), uint16(1207), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(530), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 184
	uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208),
	uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208),
	uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1208), uint16(1209), uint16(1210), uint16(1209), uint16(1210), uint16(1210),
	uint16(1209), uint16(1209), uint16(1209), uint16(1209), uint16(1209), uint16(1209), uint16(1211), uint16(1212), uint16(1208), uint16(1213), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1214), uint16(1214), uint16(1214), uint16(1214), uint16(1214), uint16(1214), uint16(1214), uint16(1214), uint16(1214), uint16(1214), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 185
	uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215),
	uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(163), uint16(163), uint16(1216), uint16(1216), uint16(1216),
	uint16(1217), uint16(1217), uint16(1216), uint16(1216), uint16(1216), uint16(1216), uint16(1218), uint16(1216), uint16(1216), uint16(1216), uint16(1216), uint16(1219), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1220), uint16(1220), uint16(1220), uint16(1220), uint16(1220), uint16(1220), uint16(1220), uint16(1220), uint16(1220), uint16(1220), uint16(1221), uint16(1221), uint16(1222), uint16(1222), uint16(1222), uint16(1223),
	uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(1215), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 186
	uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224),
	uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224),
	uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1224), uint16(1225), uint16(1225), uint16(1225), uint16(1226),
	uint16(1226), uint16(1226), uint16(1226), uint16(1226), uint16(1226), uint16(1226), uint16(1226), uint16(1226), uint16(1225), uint16(1227), uint16(1228), uint16(1229), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 187
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230),
	uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230), uint16(1230),
	uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231),
	uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231), uint16(1231),
	uint16(1232), uint16(1232), uint16(1232), uint16(1232), uint16(1232), uint16(1232), uint16(1232), uint16(1232), uint16(1232), uint16(1232), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233),
	uint16(1233), uint16(1233), uint16(1233), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1234),

	// block 188
	uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(163), uint16(163), uint16(1235), uint16(163), uint16(163), uint16(1235), uint16(1235), uint16(1235), uint16(1235),
	uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(163), uint16(1235), uint16(1235), uint16(163), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235),
	uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235),
	uint16(1236), uint16(1237), uint16(1237), uint16(1237), uint16(1237), uint16(1237), uint16(163), uint16(1237), uint16(1237), uint16(163), uint16(163), uint16(1238), uint16(1238), uint16(1239), uint16(1240), uint16(1241),
	uint16(1237), uint16(1241), uint16(1237), uint16(1242), uint16(1243), uint16(1244), uint16(1243), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1245), uint16(1245), uint16(1245), uint16(1245), uint16(1245), uint16(1245), uint16(1245), uint16(1245), uint16(1245), uint16(1245), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 189
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(163), uint16(163), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246),
	uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246),
	uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246), uint16(1246),
	uint16(1246), uint16(1247), uint16(1247), uint16(1247), uint16(1248), uint16(1248), uint16(1248), uint16(1248), uint16(163), uint16(163), uint16(1248), uint16(1248), uint16(1247), uint16(1247), uint16(1247), uint16(1247),
	uint16(1249), uint16(1246), uint16(1250), uint16(1246), uint16(1247), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 190
	uint16(1251), uint16(1252), uint16(1252), uint16(1252), uint16(1252), uint16(1252), uint16(1252), uint16(1253), uint16(1253), uint16(1252), uint16(1252), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251),
	uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251),
	uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251), uint16(1251),
	uint16(1251), uint16(1251), uint16(1251), uint16(1254), uint16(1255), uint16(1252), uint16(1252), uint16(1252), uint16(1252), uint16(1256), uint16(1257), uint16(1252), uint16(1252), uint16(1252), uint16(1252), uint16(1258),
	uint16(1258), uint16(1258), uint16(1259), uint16(1259), uint16(1258), uint16(1258), uint16(1258), uint16(1255), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1260), uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1262), uint16(1262), uint16(1261), uint16(1261), uint16(1261), uint16(1260), uint16(1260), uint16(1260), uint16(1260),
	uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260),
	uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1260),

	// block 191
	uint16(1260), uint16(1260), uint16(1260), uint16(1260), uint16(1263), uint16(1263), uint16(1263), uint16(1263), uint16(1263), uint16(1263), uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1261),
	uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1261), uint16(1262), uint16(1264), uint16(1265), uint16(1266), uint16(1267), uint16(1267), uint16(1260), uint16(1266), uint16(1266),
	uint16(1266), uint16(1268), uint16(1268), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495), uint16(495),
	uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269),
	uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269),
	uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269),
	uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(1269), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 192
	uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(163), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270),
	uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270),
	uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1270), uint16(1271),
	uint16(1272), uint16(1272), uint16(1272), uint16(1272), uint16(1272), uint16(1272), uint16(1272), uint16(163), uint16(1272), uint16(1272), uint16(1272), uint16(1272), uint16(1272), uint16(1272), uint16(1271), uint16(1273),
	uint16(1270), uint16(1274), uint16(1274), uint16(1275), uint16(1276), uint16(1276), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1277), uint16(1277), uint16(1277), uint16(1277), uint16(1277), uint16(1277), uint16(1277), uint16(1277), uint16(1277), uint16(1277), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278),
	uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(1278), uint16(163), uint16(163), uint16(163),
	uint16(1279), uint16(1280), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281),

	// block 193
	uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281), uint16(1281),
	uint16(163), uint16(163), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282),
	uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(163), uint16(1283), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282), uint16(1282),
	uint16(1282), uint16(1283), uint16(1282), uint16(1282), uint16(1283), uint16(1282), uint16(1282), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 194
	uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(163), uint16(1284), uint16(1284), uint16(163), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284),
	uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284),
	uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284), uint16(1284),
	uint16(1284), uint16(1285), uint16(1285), uint16(1285), uint16(1285), uint16(1285), uint16(1285), uint16(163), uint16(163), uint16(163), uint16(1285), uint16(163), uint16(1285), uint16(1285), uint16(163), uint16(1285),
	uint16(1285), uint16(1285), uint16(1286), uint16(1285), uint16(1287), uint16(1287), uint16(1288), uint16(1285), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1289), uint16(1289), uint16(1289), uint16(1289), uint16(1289), uint16(1289), uint16(1289), uint16(1289), uint16(1289), uint16(1289), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(163), uint16(1290), uint16(1290), uint16(163), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290),
	uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290),

	// block 195
	uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1290), uint16(1291), uint16(1291), uint16(1291), uint16(1291), uint16(1291), uint16(163),
	uint16(1292), uint16(1292), uint16(163), uint16(1291), uint16(1291), uint16(1292), uint16(1291), uint16(1293), uint16(1290), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1294), uint16(1294), uint16(1294), uint16(1294), uint16(1294), uint16(1294), uint16(1294), uint16(1294), uint16(1294), uint16(1294), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 196
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295), uint16(1295),
	uint16(1295), uint16(1295), uint16(1295), uint16(1296), uint16(1296), uint16(1297), uint16(1297), uint16(1298), uint16(1298), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 197
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(842), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299), uint16(1299),
	uint16(388), uint16(388), uint16(1299), uint16(388), uint16(1299), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(391), uint16(391), uint16(391),
	uint16(391), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390), uint16(390),
	uint16(390), uint16(390), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1300),

	// block 198
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),

	// block 199
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 200
	uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302),
	uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302),
	uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302),
	uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302),
	uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302),
	uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302),
	uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(1302), uint16(163),
	uint16(1303), uint16(1303), uint16(1303), uint16(1303), uint16(1303), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 201
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(1301),
	uint16(1301), uint16(1301), uint16(1301), uint16(1301), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 202
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304),
	uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304),
	uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304),
	uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304),
	uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304),
	uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304), uint16(1304),
	uint16(1304), uint16(1305), uint16(1305), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 203
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),

	// block 204
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306),
	uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(1306), uint16(163),
	uint16(1307), uint16(1307), uint16(1307), uint16(1307), uint16(1307), uint16(1307), uint16(1307), uint16(1307), uint16(1307), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 205
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),

	// block 206
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308),
	uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(1308), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 207
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),

	// block 208
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858),
	uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(858), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309),
	uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(1309), uint16(163),
	uint16(1310), uint16(1310), uint16(1310), uint16(1310), uint16(1310), uint16(1310), uint16(1310), uint16(1310), uint16(1310), uint16(1310), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1311), uint16(1311),
	uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312),

	// block 209
	uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312),
	uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312),
	uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312),
	uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(1312), uint16(163),
	uint16(1313), uint16(1313), uint16(1313), uint16(1313), uint16(1313), uint16(1313), uint16(1313), uint16(1313), uint16(1313), uint16(1313), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314),
	uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(1314), uint16(163), uint16(163),
	uint16(1315), uint16(1315), uint16(1315), uint16(1315), uint16(1315), uint16(1316), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 210
	uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317),
	uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317),
	uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317),
	uint16(1318), uint16(1318), uint16(1318), uint16(1318), uint16(1318), uint16(1318), uint16(1318), uint16(1319), uint16(1319), uint16(1320), uint16(1321), uint16(1321), uint16(1322), uint16(1322), uint16(1322), uint16(1322),
	uint16(1323), uint16(1323), uint16(1324), uint16(1324), uint16(1319), uint16(1322), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1325), uint16(1325), uint16(1325), uint16(1325), uint16(1325), uint16(1325), uint16(1325), uint16(1325), uint16(1325), uint16(1325), uint16(163), uint16(1326), uint16(1326), uint16(1326), uint16(1326), uint16(1326),
	uint16(1326), uint16(1326), uint16(163), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317),
	uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1317), uint16(1317), uint16(1317),

	// block 211
	uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1317),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 212
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327),
	uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327), uint16(1327),
	uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328),
	uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328), uint16(1328),

	// block 213
	uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329),
	uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1329), uint16(1330), uint16(1331), uint16(1332), uint16(1332), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 214
	uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333),
	uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333),
	uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333),
	uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333),
	uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(1333), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1334),
	uint16(1333), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335),
	uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335),
	uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335),

	// block 215
	uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1336),
	uint16(1336), uint16(1336), uint16(1336), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337), uint16(1337),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1338), uint16(1339), uint16(1340), uint16(799), uint16(1341), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1342), uint16(1342), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 216
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),

	// block 217
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343),
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 218
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),

	// block 219
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344),
	uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(1344), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 220
	uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(1343), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 221
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1345), uint16(1345), uint16(1345), uint16(1345), uint16(163), uint16(1345), uint16(1345), uint16(1345), uint16(1345), uint16(1345), uint16(1345), uint16(1345), uint16(163), uint16(1345), uint16(1345), uint16(163),

	// block 222
	uint16(824), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),

	// block 223
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),

	// block 224
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819), uint16(819),
	uint16(824), uint16(824), uint16(824), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(819), uint16(819), uint16(819), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(824), uint16(824), uint16(824), uint16(824), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),

	// block 225
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),

	// block 226
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346),
	uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(1346), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 227
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347),
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347),
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347),
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347),
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347),
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347),
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(163), uint16(163), uint16(163),

	// block 228
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(1347), uint16(163), uint16(163), uint16(1348), uint16(1349), uint16(1350), uint16(1351),
	uint16(1352), uint16(1352), uint16(1352), uint16(1352), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 229
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(163), uint16(163),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),
	uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),

	// block 230
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 231
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),

	// block 232
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 233
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(163), uint16(163), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(1353), uint16(1354), uint16(154), uint16(154), uint16(154), uint16(460), uint16(460), uint16(460), uint16(1355), uint16(1356), uint16(1356),
	uint16(1356), uint16(1356), uint16(1356), uint16(51), uint16(51), uint16(51), uint16(51), uint16(51), uint16(51), uint16(51), uint16(51), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154),

	// block 234
	uint16(154), uint16(154), uint16(154), uint16(460), uint16(460), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(154), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(154), uint16(154), uint16(154), uint16(154), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(723), uint16(723), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 235
	uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002),
	uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002),
	uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002),
	uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002), uint16(1002),
	uint16(1002), uint16(1002), uint16(1357), uint16(1357), uint16(1357), uint16(1002), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 236
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835),
	uint16(835), uint16(835), uint16(835), uint16(835), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 237
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832), uint16(832),
	uint16(832), uint16(832), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(835), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 238
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(163), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),

	// block 239
	uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(163), uint16(724), uint16(724),
	uint16(163), uint16(163), uint16(724), uint16(163), uint16(163), uint16(724), uint16(724), uint16(163), uint16(163), uint16(724), uint16(724), uint16(724), uint16(724), uint16(163), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(163), uint16(725), uint16(163), uint16(725), uint16(736), uint16(736),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(163), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),

	// block 240
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(163), uint16(724), uint16(724), uint16(724), uint16(724), uint16(163), uint16(163), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(163), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(163), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(163), uint16(724), uint16(724), uint16(724), uint16(724), uint16(163),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(163), uint16(724), uint16(163), uint16(163), uint16(163), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(163), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),

	// block 241
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(736), uint16(736),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),

	// block 242
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(736), uint16(736),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),

	// block 243
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(736), uint16(736), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(163), uint16(163), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(1358), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(715), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(1358), uint16(725), uint16(725), uint16(725), uint16(725),

	// block 244
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(715), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(1358), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(715),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(1358),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),

	// block 245
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(715), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724),
	uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(724), uint16(1358), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725),
	uint16(725), uint16(725), uint16(725), uint16(715), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(725), uint16(724), uint16(725), uint16(163), uint16(163), uint16(1359), uint16(1359),
	uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359),
	uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359),
	uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359), uint16(1359),

	// block 246
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),

	// block 247
	uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361),
	uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361),
	uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361),
	uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361),
	uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361),
	uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361),
	uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1360), uint16(1360), uint16(1360),
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1361), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1360),

	// block 248
	uint16(1360), uint16(1360), uint16(1360), uint16(1360), uint16(1361), uint16(1360), uint16(1360), uint16(1362), uint16(1363), uint16(1362), uint16(1362), uint16(1364), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361),
	uint16(163), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361), uint16(1361),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 249
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(92), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70),
	uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(70), uint16(643), uint16(70), uint16(70), uint16(70), uint16(70), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 250
	uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(163), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365),
	uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(163), uint16(163), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365),
	uint16(1365), uint16(1365), uint16(163), uint16(1365), uint16(1365), uint16(163), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(1365), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 251
	uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366),
	uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366),
	uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(1366), uint16(163), uint16(163), uint16(163),
	uint16(1367), uint16(1367), uint16(1367), uint16(1367), uint16(1367), uint16(1367), uint16(1367), uint16(1368), uint16(1368), uint16(1368), uint16(1368), uint16(1368), uint16(1369), uint16(1369), uint16(163), uint16(163),
	uint16(1370), uint16(1370), uint16(1370), uint16(1370), uint16(1370), uint16(1370), uint16(1370), uint16(1370), uint16(1370), uint16(1370), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1366), uint16(1371),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 252
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372),
	uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1372), uint16(1373), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374),
	uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374),
	uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1374), uint16(1375), uint16(1375), uint16(1375), uint16(1375),
	uint16(1376), uint16(1376), uint16(1376), uint16(1376), uint16(1376), uint16(1376), uint16(1376), uint16(1376), uint16(1376), uint16(1376), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(1377),

	// block 253
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163), uint16(483), uint16(483), uint16(163),
	uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(483), uint16(163),

	// block 254
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),

	// block 255
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378),
	uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(1378), uint16(262), uint16(262), uint16(1379), uint16(1379), uint16(1379), uint16(1379), uint16(1379), uint16(1379), uint16(1379), uint16(1379), uint16(1379),
	uint16(1380), uint16(1380), uint16(1380), uint16(1380), uint16(1380), uint16(1380), uint16(1380), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 256
	uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381),
	uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381), uint16(1381),
	uint16(1381), uint16(1381), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382),
	uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1382),
	uint16(1382), uint16(1382), uint16(1382), uint16(1382), uint16(1383), uint16(1383), uint16(1383), uint16(1384), uint16(1385), uint16(1385), uint16(1385), uint16(1386), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(1387), uint16(1387), uint16(1387), uint16(1387), uint16(1387), uint16(1387), uint16(1387), uint16(1387), uint16(1387), uint16(1387), uint16(262), uint16(262), uint16(262), uint16(262), uint16(1388), uint16(1388),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 257
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(302), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389),

	// block 258
	uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389),
	uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389),
	uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1390), uint16(1389), uint16(1389), uint16(1389),
	uint16(1391), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 259
	uint16(302), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389),
	uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389),
	uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1390), uint16(1389),
	uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(1389), uint16(302), uint16(302),
	uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),
	uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262),

	// block 260
	uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392),
	uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392),
	uint16(302), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(302), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392),
	uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(302), uint16(302), uint16(1392), uint16(302), uint16(302), uint16(302), uint16(302), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392),
	uint16(302), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(302), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(1392),
	uint16(302), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(302), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392),
	uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(302),

	// block 261
	uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392),
	uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392),
	uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(1392), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),
	uint16(274), uint16(274), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302), uint16(302),

	// block 262
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1394), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),

	// block 263
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1395),
	uint16(1395), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1395), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1394),
	uint16(1395), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),

	// block 264
	uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(54), uint16(58), uint16(58), uint16(1393), uint16(1393), uint16(1393),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(1393),
	uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396),
	uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396),
	uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(723), uint16(723), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1397), uint16(1397), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1397), uint16(1397),

	// block 265
	uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(1396), uint16(460), uint16(460), uint16(460), uint16(460), uint16(1398), uint16(460),
	uint16(460), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(1393), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399),
	uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399), uint16(1399),

	// block 266
	uint16(1400), uint16(1398), uint16(1401), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(1398), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(1398),
	uint16(460), uint16(460), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(1398), uint16(1401), uint16(1398), uint16(1398), uint16(1398), uint16(460), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(460), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1402), uint16(1402), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),

	// block 267
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),

	// block 268
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(727), uint16(1393), uint16(1393), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(727), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(727), uint16(1394), uint16(1394),

	// block 269
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1393), uint16(1393), uint16(727), uint16(727), uint16(1393), uint16(727), uint16(727), uint16(727), uint16(1393), uint16(1393), uint16(727), uint16(727),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1394), uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1403), uint16(1404), uint16(1404), uint16(727), uint16(727), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1393), uint16(1393), uint16(727), uint16(1394), uint16(727), uint16(1393), uint16(727), uint16(1394), uint16(1394), uint16(1394), uint16(1405), uint16(1405), uint16(1405), uint16(1405), uint16(1405),

	// block 270
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(727),
	uint16(1394), uint16(727), uint16(1403), uint16(1403), uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403),
	uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403),
	uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1394),

	// block 271
	uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403),
	uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(727), uint16(1393), uint16(1394),

	// block 272
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(727), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1393),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(727),
	uint16(727), uint16(1393), uint16(1393), uint16(727), uint16(1404), uint16(1404), uint16(727), uint16(727), uint16(727), uint16(727), uint16(1403), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),

	// block 273
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(1393), uint16(1393), uint16(727), uint16(727), uint16(727), uint16(727), uint16(1393), uint16(1393),
	uint16(1404), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1403), uint16(1403), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1394), uint16(727), uint16(1393), uint16(1393), uint16(727), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(727), uint16(727), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(727), uint16(727), uint16(727), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(727), uint16(727), uint16(727), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(727), uint16(727), uint16(1393),
	uint16(1393), uint16(727), uint16(1393), uint16(727), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(727),
	uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),

	// block 274
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),

	// block 275
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(1403), uint16(727), uint16(727), uint16(727),
	uint16(1394), uint16(1394), uint16(1394), uint16(1393), uint16(1393), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1394), uint16(1394), uint16(1394),
	uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(727), uint16(1393), uint16(1393), uint16(1393), uint16(727), uint16(1393), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395),
	uint16(727), uint16(1393), uint16(1393), uint16(727), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395),

	// block 276
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),

	// block 277
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1394), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),

	// block 278
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),

	// block 279
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(1395), uint16(1395),
	uint16(1393), uint16(1393), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),

	// block 280
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(1403), uint16(1394), uint16(1394), uint16(1403),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1394), uint16(723), uint16(1403), uint16(1403), uint16(1403), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(723), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),

	// block 281
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1406), uint16(1406), uint16(1406), uint16(1406), uint16(1394), uint16(1403), uint16(1403), uint16(1394), uint16(1403), uint16(1403), uint16(1394), uint16(1403), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403),
	uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),

	// block 282
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1393), uint16(1395), uint16(1395),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395),

	// block 283
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1394), uint16(1394), uint16(1394), uint16(1403), uint16(1403), uint16(1403), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1394), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1403), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),

	// block 284
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),

	// block 285
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(163), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723),
	uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(723), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(1407), uint16(1407), uint16(1407), uint16(1407), uint16(1407), uint16(1407), uint16(1407), uint16(1407), uint16(1407), uint16(1407), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 286
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395),
	uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(1395), uint16(958), uint16(958),

	// block 287
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 288
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),

	// block 289
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(163), uint16(163),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),

	// block 290
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),

	// block 291
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 292
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953),
	uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(953), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 293
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(958), uint16(958),

	// block 294
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838),
	uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(838), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),
	uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163), uint16(163),

	// block 295
	uint16(707), uint16(712), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408),
	uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408),
	uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408),
	uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408),
	uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408),
	uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408), uint16(1408),

	// block 296
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),

	// block 297
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),

	// block 298
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961), uint16(961),
	uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707), uint16(707),

	// block 299
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952),
	uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(952), uint16(958), uint16(958),
} /* pcre2_ucd.c:2386:16 */

// End of pcre2_ucd.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//           Validate a UTF string                *
//

// This function is called (optionally) at the start of compile or match, to
// check that a supposed UTF string is actually valid. The early check means
// that subsequent code can assume it is dealing with a valid string. The check
// can be turned off for maximum performance, but the consequences of supplying an
// invalid string are then undefined.
//
// Arguments:
//   string       points to the string
//   length       length of string
//   errp         pointer to an error position offset variable
//
// Returns:       == 0    if the string is a valid UTF string
//                != 0    otherwise, setting the offset of the bad character

func X_pcre2_valid_utf_8(tls *libc.TLS, string uintptr, length uint64, erroroffset uintptr) int32 { /* pcre2_valid_utf.c:94:1: */
	var p uintptr
	var c uint32

	// ----------------- Check a UTF-8 string -----------------

	// Originally, this function checked according to RFC 2279, allowing for values
	// in the range 0 to 0x7fffffff, up to 6 bytes long, but ensuring that they were
	// in the canonical format. Once somebody had pointed out RFC 3629 to me (it
	// obsoletes 2279), additional restrictions were applied. The values are now
	// limited to be between 0 and 0x0010ffff, no more than 4 bytes long, and the
	// subrange 0xd000 to 0xdfff is excluded. However, the format of 5-byte and 6-byte
	// characters is still checked. Error returns are as follows:
	//
	// PCRE2_ERROR_UTF8_ERR1   Missing 1 byte at the end of the string
	// PCRE2_ERROR_UTF8_ERR2   Missing 2 bytes at the end of the string
	// PCRE2_ERROR_UTF8_ERR3   Missing 3 bytes at the end of the string
	// PCRE2_ERROR_UTF8_ERR4   Missing 4 bytes at the end of the string
	// PCRE2_ERROR_UTF8_ERR5   Missing 5 bytes at the end of the string
	// PCRE2_ERROR_UTF8_ERR6   2nd-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR7   3rd-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR8   4th-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR9   5th-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR10  6th-byte's two top bits are not 0x80
	// PCRE2_ERROR_UTF8_ERR11  5-byte character is not permitted by RFC 3629
	// PCRE2_ERROR_UTF8_ERR12  6-byte character is not permitted by RFC 3629
	// PCRE2_ERROR_UTF8_ERR13  4-byte character with value > 0x10ffff is not permitted
	// PCRE2_ERROR_UTF8_ERR14  3-byte character with value 0xd800-0xdfff is not permitted
	// PCRE2_ERROR_UTF8_ERR15  Overlong 2-byte sequence
	// PCRE2_ERROR_UTF8_ERR16  Overlong 3-byte sequence
	// PCRE2_ERROR_UTF8_ERR17  Overlong 4-byte sequence
	// PCRE2_ERROR_UTF8_ERR18  Overlong 5-byte sequence (won't ever occur)
	// PCRE2_ERROR_UTF8_ERR19  Overlong 6-byte sequence (won't ever occur)
	// PCRE2_ERROR_UTF8_ERR20  Isolated 0x80 byte (not within UTF-8 character)
	// PCRE2_ERROR_UTF8_ERR21  Byte with the illegal value 0xfe or 0xff

	for p = string; length > uint64(0); p++ {
		var ab uint32
		var d uint32

		c = uint32(*(*uint8)(unsafe.Pointer(p)))
		length--

		if c < uint32(128) {
			continue
		} // ASCII character

		if c < uint32(0xc0) {
			*(*uint64)(unsafe.Pointer(erroroffset)) = uint64((int64(p) - int64(string)) / 1)
			return -22
		}

		if c >= uint32(0xfe) {
			*(*uint64)(unsafe.Pointer(erroroffset)) = uint64((int64(p) - int64(string)) / 1)
			return -23
		}

		ab = uint32(X_pcre2_utf8_table4[c&uint32(0x3f)]) // Number of additional bytes (1-5)
		if length < uint64(ab) {
			*(*uint64)(unsafe.Pointer(erroroffset)) = uint64((int64(p) - int64(string)) / 1)
			switch uint64(ab) - length {
			case uint64(1):
				return -3
				fallthrough
			case uint64(2):
				return -4
				fallthrough
			case uint64(3):
				return -5
				fallthrough
			case uint64(4):
				return -6
				fallthrough
			case uint64(5):
				return -7
			}
		}
		length = length - uint64(ab) // Length remaining

		// Check top bits in the second byte

		if libc.AssignUint32(&d, uint32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1)))))&uint32(0xc0) != uint32(0x80) {
			*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 1)
			return -8
		}

		// For each length, check that the remaining bytes start with the 0x80 bit
		//   set and not the 0x40 bit. Then check for an overlong sequence, and for the
		//   excluded range 0xd800 to 0xdfff.

		switch ab {
		// 2-byte character. No further bytes to check for 0x80. Check first byte
		//     for for xx00 000x (overlong sequence).

		case uint32(1):
			if c&uint32(0x3e) == uint32(0) {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 1)
				return -17
			}
			break

		// 3-byte character. Check third byte for 0x80. Then check first 2 bytes
		//       for 1110 0000, xx0x xxxx (overlong sequence) or
		//           1110 1101, 1010 xxxx (0xd800 - 0xdfff)

		case uint32(2):
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 2)
				return -9
			}
			if c == uint32(0xe0) && d&uint32(0x20) == uint32(0) {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 2)
				return -18
			}
			if c == uint32(0xed) && d >= uint32(0xa0) {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 2)
				return -16
			}
			break

		// 4-byte character. Check 3rd and 4th bytes for 0x80. Then check first 2
		//        bytes for for 1111 0000, xx00 xxxx (overlong sequence), then check for a
		//        character greater than 0x0010ffff (f4 8f bf bf)

		case uint32(3):
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 2)
				return -9
			}
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 3)
				return -10
			}
			if c == uint32(0xf0) && d&uint32(0x30) == uint32(0) {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 3)
				return -19
			}
			if c > uint32(0xf4) || c == uint32(0xf4) && d > uint32(0x8f) {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 3)
				return -15
			}
			break

		// 5-byte and 6-byte characters are not allowed by RFC 3629, and will be
		//     rejected by the length test below. However, we do the appropriate tests
		//     here so that overlong sequences get diagnosed, and also in case there is
		//     ever an option for handling these larger code points.

		// 5-byte character. Check 3rd, 4th, and 5th bytes for 0x80. Then check for
		//     1111 1000, xx00 0xxx

		case uint32(4):
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 2)
				return -9
			}
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 3)
				return -10
			}
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 4)
				return -11
			}
			if c == uint32(0xf8) && d&uint32(0x38) == uint32(0) {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 4)
				return -20
			}
			break

		// 6-byte character. Check 3rd-6th bytes for 0x80. Then check for
		//     1111 1100, xx00 00xx.

		case uint32(5):
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 2)
				return -9
			}
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 3)
				return -10
			}
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 4)
				return -11
			}
			if int32(*(*uint8)(unsafe.Pointer(libc.PreIncUintptr(&p, 1))))&0xc0 != 0x80 {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 5)
				return -12
			}
			if c == uint32(0xfc) && d&uint32(0x3c) == uint32(0) {
				*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(int32((int64(p)-int64(string))/1) - 5)
				return -21
			}
			break
		}

		// Character is valid under RFC 2279, but 4-byte and 5-byte characters are
		//   excluded by RFC 3629. The pointer p is currently at the last byte of the
		//   character.

		if ab > uint32(3) {
			*(*uint64)(unsafe.Pointer(erroroffset)) = uint64(uint32(int32((int64(p)-int64(string))/1)) - ab)
			if ab == uint32(4) {
				return -13
			}
			return -14
		}
	}
	return 0

	// ----------------- Check a UTF-16 string -----------------

}

// End of pcre2_valid_utf.c

// This function is needed only when memmove() is not available.

// End of pcre2_internal.h

// ************************************************
//
//       Match character against an XCLASS        *
//

// This function is called to match a character against an extended class that
// might contain codepoints above 255 and/or Unicode properties.
//
// Arguments:
//   c           the character
//   data        points to the flag code unit of the XCLASS data
//   utf         TRUE if in UTF mode
//
// Returns:      TRUE if character matches, else FALSE

func X_pcre2_xclass_8(tls *libc.TLS, c uint32, data uintptr, utf int32) int32 { /* pcre2_xclass.c:69:1: */
	var t uint8
	var negated int32 = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(data)))&DXCL_NOT != 0)

	// In 8 bit mode, this must always be TRUE. Help the compiler to know that.
	utf = DTRUE

	// Code points < 256 are matched against a bitmap, if one is present. If not,
	// we still carry on, because there may be ranges that start below 256 in the
	// additional data.

	if c < uint32(256) {
		if int32(*(*uint8)(unsafe.Pointer(data)))&DXCL_HASPROP == 0 {
			if int32(*(*uint8)(unsafe.Pointer(data)))&DXCL_MAP == 0 {
				return negated
			}
			return libc.Bool32(uint32(*(*uint8)(unsafe.Pointer(data + uintptr(1) + uintptr(c/uint32(8)))))&(uint32(1)<<(c&uint32(7))) != uint32(0))
		}
		if int32(*(*uint8)(unsafe.Pointer(data)))&DXCL_MAP != 0 && uint32(*(*uint8)(unsafe.Pointer(data + uintptr(1) + uintptr(c/uint32(8)))))&(uint32(1)<<(c&uint32(7))) != uint32(0) {
			return libc.BoolInt32(!(negated != 0))
		} // char found
	}

	// First skip the bit map if present. Then match against the list of Unicode
	// properties or large chars or ranges that end with a large char. We won't ever
	// encounter XCL_PROP or XCL_NOTPROP when UTF support is not compiled.

	if int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))&DXCL_MAP != 0 {
		data += uintptr(uint64(32) / uint64(unsafe.Sizeof(uint8(0))))
	}

	for int32(libc.AssignUint8(&t, *(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))) != DXCL_END {
		var x uint32
		var y uint32
		if int32(t) == DXCL_SINGLE {
			if utf != 0 {
				x = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
				if x >= 0xc0 {
					if x&0x20 == uint32(0) {
						x = x&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))&0x3f
					} else if x&0x10 == uint32(0) {
						x = x&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f
						data += uintptr(2)
					} else if x&0x08 == uint32(0) {
						x = x&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f
						data += uintptr(3)
					} else if x&0x04 == uint32(0) {
						x = x&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 3)))&0x3f
						data += uintptr(4)
					} else {
						x = x&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 4)))&0x3f
						data += uintptr(5)
					}
				}

				// macro generates multiple statements
			} else {
				x = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
			}
			if c == x {
				return libc.BoolInt32(!(negated != 0))
			}
		} else if int32(t) == DXCL_RANGE {
			if utf != 0 {
				x = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
				if x >= 0xc0 {
					if x&0x20 == uint32(0) {
						x = x&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))&0x3f
					} else if x&0x10 == uint32(0) {
						x = x&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f
						data += uintptr(2)
					} else if x&0x08 == uint32(0) {
						x = x&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f
						data += uintptr(3)
					} else if x&0x04 == uint32(0) {
						x = x&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 3)))&0x3f
						data += uintptr(4)
					} else {
						x = x&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 4)))&0x3f
						data += uintptr(5)
					}
				}

				// macro generates multiple statements
				y = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
				if y >= 0xc0 {
					if y&0x20 == uint32(0) {
						y = y&0x1f<<6 | uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))&0x3f
					} else if y&0x10 == uint32(0) {
						y = y&0x0f<<12 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f
						data += uintptr(2)
					} else if y&0x08 == uint32(0) {
						y = y&0x07<<18 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f
						data += uintptr(3)
					} else if y&0x04 == uint32(0) {
						y = y&0x03<<24 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 3)))&0x3f
						data += uintptr(4)
					} else {
						y = y&0x01<<30 | uint32(*(*uint8)(unsafe.Pointer(data)))&0x3f<<24 | uint32(*(*uint8)(unsafe.Pointer(data + 1)))&0x3f<<18 | uint32(*(*uint8)(unsafe.Pointer(data + 2)))&0x3f<<12 | uint32(*(*uint8)(unsafe.Pointer(data + 3)))&0x3f<<6 | uint32(*(*uint8)(unsafe.Pointer(data + 4)))&0x3f
						data += uintptr(5)
					}
				}

				// macro generates multiple statements
			} else {
				x = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
				y = uint32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&data, 1))))
			}
			if c >= x && c <= y {
				return libc.BoolInt32(!(negated != 0))
			}
		} else {
			var prop uintptr = uintptr(unsafe.Pointer(&X_pcre2_ucd_records_8)) + uintptr(X_pcre2_ucd_stage2_8[int32(X_pcre2_ucd_stage1_8[int32(c)/DUCD_BLOCK_SIZE])*DUCD_BLOCK_SIZE+int32(c)%DUCD_BLOCK_SIZE])*12
			var isprop int32 = libc.Bool32(int32(t) == DXCL_PROP)
			var ok int32

			switch int32(*(*uint8)(unsafe.Pointer(data))) {
			case DPT_ANY:
				if isprop != 0 {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_LAMP:
				if libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lu || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Ll || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Lt) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_GC:
				if libc.Bool32(uint32(*(*uint8)(unsafe.Pointer(data + 1))) == X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype]) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_PC:
				if libc.Bool32(int32(*(*uint8)(unsafe.Pointer(data + 1))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype)) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_SC:
				if libc.Bool32(int32(*(*uint8)(unsafe.Pointer(data + 1))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript)) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_SCX:
				ok = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(data + 1))) == int32((*Tucd_record)(unsafe.Pointer(prop)).Fscript) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_script_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)&DUCD_SCRIPTX_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(data + 1)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(data + 1)))%32)) != uint32(0))
				if ok == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_ALNUM:
				if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// Perl space used to exclude VT, but from Perl 5.18 it is included,
			//       which means that Perl space and POSIX space are now identical. PCRE
			//       was changed at release 8.34.

			case DPT_SPACE:
				fallthrough // Perl space
			case DPT_PXSPACE: // POSIX space
				switch c {
				case uint32('\011'):
					fallthrough
				case uint32('\040'):
					fallthrough
				case libc.Uint32FromUint8(libc.Uint8FromInt32(160)):
					fallthrough
				case uint32(0x1680):
					fallthrough /* OGHAM SPACE MARK */
				case uint32(0x180e):
					fallthrough /* MONGOLIAN VOWEL SEPARATOR */
				case uint32(0x2000):
					fallthrough /* EN QUAD */
				case uint32(0x2001):
					fallthrough /* EM QUAD */
				case uint32(0x2002):
					fallthrough /* EN SPACE */
				case uint32(0x2003):
					fallthrough /* EM SPACE */
				case uint32(0x2004):
					fallthrough /* THREE-PER-EM SPACE */
				case uint32(0x2005):
					fallthrough /* FOUR-PER-EM SPACE */
				case uint32(0x2006):
					fallthrough /* SIX-PER-EM SPACE */
				case uint32(0x2007):
					fallthrough /* FIGURE SPACE */
				case uint32(0x2008):
					fallthrough /* PUNCTUATION SPACE */
				case uint32(0x2009):
					fallthrough /* THIN SPACE */
				case uint32(0x200A):
					fallthrough /* HAIR SPACE */
				case uint32(0x202f):
					fallthrough /* NARROW NO-BREAK SPACE */
				case uint32(0x205f):
					fallthrough /* MEDIUM MATHEMATICAL SPACE */
				case uint32(0x3000):
					fallthrough
				case uint32('\012'):
					fallthrough
				case uint32('\013'):
					fallthrough
				case uint32('\014'):
					fallthrough
				case uint32('\015'):
					fallthrough
				case libc.Uint32FromUint8(libc.Uint8FromInt32(133)):
					fallthrough
				case uint32(0x2028):
					fallthrough /* LINE SEPARATOR */
				case uint32(0x2029):
					if isprop != 0 {
						return libc.BoolInt32(!(negated != 0))
					}
					break
					fallthrough

				default:
					if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_Z) == isprop {
						return libc.BoolInt32(!(negated != 0))
					}
					break
				}
				break
				fallthrough

			case DPT_WORD:
				if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_L || X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_N || c == uint32('\137')) ==
					isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_UCNC:
				if c < uint32(0xa0) {
					if libc.Bool32(c == uint32('\044') || c == uint32('\100') || c == uint32('\140')) == isprop {
						return libc.BoolInt32(!(negated != 0))
					}
				} else {
					if libc.Bool32(c < uint32(0xd800) || c > uint32(0xdfff)) == isprop {
						return libc.BoolInt32(!(negated != 0))
					}
				}
				break
				fallthrough

			case DPT_BIDICL:
				if libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fscriptx_bidiclass)>>DUCD_BIDICLASS_SHIFT == int32(*(*uint8)(unsafe.Pointer(data + 1)))) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			case DPT_BOOL:
				ok = libc.Bool32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_ucd_boolprop_sets_8)) + uintptr(int32((*Tucd_record)(unsafe.Pointer(prop)).Fbprops)&DUCD_BPROPS_MASK)*4 + uintptr(int32(*(*uint8)(unsafe.Pointer(data + 1)))/32)*4))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(data + 1)))%32)) != uint32(0))
				if ok == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// The following three properties can occur only in an XCLASS, as there
			//       is no \p or \P coding for them.

			// Graphic character. Implement this as not Z (space or separator) and
			//       not C (other), except for Cf (format) with a few exceptions. This seems
			//       to be what Perl does. The exceptional characters are:
			//
			//       U+061C           Arabic Letter Mark
			//       U+180E           Mongolian Vowel Separator
			//       U+2066 - U+2069  Various "isolate"s
			//

			case DPT_PXGRAPH:
				if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] != ucp_Z && (X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] != ucp_C || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Cf && c != uint32(0x061c) && c != uint32(0x180e) && (c < uint32(0x2066) || c > uint32(0x2069)))) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// Printable character: same as graphic, with the addition of Zs, i.e.
			//       not Zl and not Zp, and U+180E.

			case DPT_PXPRINT:
				if libc.Bool32(int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) != ucp_Zl && int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) != ucp_Zp && (X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] != ucp_C || int32((*Tucd_record)(unsafe.Pointer(prop)).Fchartype) == ucp_Cf && c != uint32(0x061c) && (c < uint32(0x2066) || c > uint32(0x2069)))) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// Punctuation: all Unicode punctuation, plus ASCII characters that
			//       Unicode treats as symbols rather than punctuation, for Perl
			//       compatibility (these are $+<=>^`|~).

			case DPT_PXPUNCT:
				if libc.Bool32(X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_P || c < uint32(128) && X_pcre2_ucp_gentype_8[(*Tucd_record)(unsafe.Pointer(prop)).Fchartype] == ucp_S) == isprop {
					return libc.BoolInt32(!(negated != 0))
				}
				break
				fallthrough

			// This should never occur, but compilers may mutter if there is no
			//       default.

			default:
				return DFALSE
			}

			data += uintptr(2)
		}
	}

	return negated // char did not match
}

// End of pcre2_xclass.c

func init() {
	*(*func(*libc.TLS, uint64, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 0)) = default_malloc                   // pcre2_context.c:134:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 8)) = default_free                            // pcre2_context.c:134:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 40 /* .tables */)) = uintptr(unsafe.Pointer(&X_pcre2_default_tables_8)) // pcre2_context.c:137:3:
	*(*func(*libc.TLS, uint64, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 0)) = default_malloc                   // pcre2_context.c:134:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 8)) = default_free                            // pcre2_context.c:134:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_compile_context_8)) + 40 /* .tables */)) = uintptr(unsafe.Pointer(&X_pcre2_default_tables_8)) // pcre2_context.c:137:3:
	*(*func(*libc.TLS, uint64, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8)) + 0)) = default_malloc                   // pcre2_context.c:198:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8)) + 8)) = default_free                            // pcre2_context.c:198:21:
	*(*func(*libc.TLS, uint64, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8)) + 0)) = default_malloc                   // pcre2_context.c:198:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_convert_context_8)) + 8)) = default_free                            // pcre2_context.c:198:21:
	*(*func(*libc.TLS, uint64, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8)) + 0)) = default_malloc                     // pcre2_context.c:164:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8)) + 8)) = default_free                              // pcre2_context.c:164:21:
	*(*func(*libc.TLS, uint64, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8)) + 0)) = default_malloc                     // pcre2_context.c:164:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&X_pcre2_default_match_context_8)) + 8)) = default_free                              // pcre2_context.c:164:21:
}

var ts1 = "\x00MARK\x00ACCEPT\x00F\x00FAIL\x00COMMIT\x00PRUNE\x00SKIP\x00THEN\x00pla\x00plb\x00napla\x00naplb\x00nla\x00nlb\x00positive_lookahead\x00positive_lookbehind\x00non_atomic_positive_lookahead\x00non_atomic_positive_lookbehind\x00negative_lookahead\x00negative_lookbehind\x00atomic\x00sr\x00asr\x00script_run\x00atomic_script_run\x00alpha\x00lower\x00upper\x00alnum\x00ascii\x00blank\x00cntrl\x00digit\x00graph\x00print\x00punct\x00space\x00word\x00xdigit\x00UTF8)\x00UTF)\x00UCP)\x00NOTEMPTY)\x00NOTEMPTY_ATSTART)\x00NO_AUTO_POSSESS)\x00NO_DOTSTAR_ANCHOR)\x00NO_JIT)\x00NO_START_OPT)\x00LIMIT_HEAP=\x00LIMIT_MATCH=\x00LIMIT_DEPTH=\x00LIMIT_RECURSION=\x00CR)\x00LF)\x00CRLF)\x00ANY)\x00NUL)\x00ANYCRLF)\x00BSR_ANYCRLF)\x00BSR_UNICODE)\x00bidiclass\x00bc\x00script\x00sc\x00scriptextensions\x00scx\x00[:<:]]\x00[:>:]]\x00Q\\E\x00VERSION\x00DEFINE\x00Z\x0010.42 2022-12-11\x0010.422022-12-11\x00\\?*+|.^${}[]()\x00(){}123456789\x00(*NUL)\x00]\x00:]\x00\\\x00[\x00^\x00alnum:alpha:ascii:blank:cntrl:digit:graph:lower:print:punct:space:upper:word:xdigit:\x00\x00no error\x00\\ at end of pattern\x00\\c at end of pattern\x00unrecognized character follows \\\x00numbers out of order in {} quantifier\x00number too big in {} quantifier\x00missing terminating ] for character class\x00escape sequence is invalid in character class\x00range out of order in character class\x00quantifier does not follow a repeatable item\x00internal error: unexpected repeat\x00unrecognized character after (? or (?-\x00POSIX named classes are supported only within a class\x00POSIX collating elements are not supported\x00missing closing parenthesis\x00reference to non-existent subpattern\x00pattern passed as NULL\x00unrecognised compile-time option bit(s)\x00missing ) after (?# comment\x00parentheses are too deeply nested\x00regular expression is too large\x00failed to allocate heap memory\x00unmatched closing parenthesis\x00internal error: code overflow\x00missing closing parenthesis for condition\x00lookbehind assertion is not fixed length\x00a relative value of zero is not allowed\x00conditional subpattern contains more than two branches\x00assertion expected after (?( or (?(?C)\x00digit expected after (?+ or (?-\x00unknown POSIX class name\x00internal error in pcre2_study(): should not occur\x00this version of PCRE2 does not have Unicode support\x00parentheses are too deeply nested (stack check)\x00character code point value in \\x{} or \\o{} is too large\x00lookbehind is too complicated\x00\\C is not allowed in a lookbehind assertion in UTF-8 mode\x00PCRE2 does not support \\F, \\L, \\l, \\N{name}, \\U, or \\u\x00number after (?C is greater than 255\x00closing parenthesis for (?C expected\x00invalid escape sequence in (*VERB) name\x00unrecognized character after (?P\x00syntax error in subpattern name (missing terminator?)\x00two named subpatterns have the same name (PCRE2_DUPNAMES not set)\x00subpattern name must start with a non-digit\x00this version of PCRE2 does not have support for \\P, \\p, or \\X\x00malformed \\P or \\p sequence\x00unknown property after \\P or \\p\x00subpattern name is too long (maximum 32 code units)\x00too many named subpatterns (maximum 10000)\x00invalid range in character class\x00octal value is greater than \\377 in 8-bit non-UTF-8 mode\x00internal error: overran compiling workspace\x00internal error: previously-checked referenced subpattern not found\x00DEFINE subpattern contains more than one branch\x00missing opening brace after \\o\x00internal error: unknown newline setting\x00\\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\x00(?R (recursive pattern call) must be followed by a closing parenthesis\x00obsolete error (should not occur)\x00(*VERB) not recognized or malformed\x00subpattern number is too big\x00subpattern name expected\x00internal error: parsed pattern overflow\x00non-octal character in \\o{} (closing brace missing?)\x00different names for subpatterns of the same number are not allowed\x00(*MARK) must have an argument\x00non-hex character in \\x{} (closing brace missing?)\x00\\c must be followed by a printable ASCII character\x00\\k is not followed by a braced, angle-bracketed, or quoted name\x00internal error: unknown meta code in check_lookbehinds()\x00\\N is not supported in a class\x00callout string is too long\x00disallowed Unicode code point (>= 0xd800 && <= 0xdfff)\x00using UTF is disabled by the application\x00using UCP is disabled by the application\x00name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN)\x00character code point value in \\u.... sequence is too large\x00digits missing in \\x{} or \\o{} or \\N{U+}\x00syntax error or number too big in (?(VERSION condition\x00internal error: unknown opcode in auto_possessify()\x00missing terminating delimiter for callout with string argument\x00unrecognized string delimiter follows (?C\x00using \\C is disabled by the application\x00(?| and/or (?J: or (?x: parentheses are too deeply nested\x00using \\C is disabled in this PCRE2 library\x00regular expression is too complicated\x00lookbehind assertion is too long\x00pattern string is longer than the limit set by the application\x00internal error: unknown code in parsed pattern\x00internal error: bad code value in parsed_skip()\x00PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not allowed in UTF-16 mode\x00invalid option bits with PCRE2_LITERAL\x00\\N{U+dddd} is supported only in Unicode (UTF) mode\x00invalid hyphen in option setting\x00(*alpha_assertion) not recognized\x00script runs require Unicode support, which this version of PCRE2 does not have\x00too many capturing groups (maximum 65535)\x00atomic assertion expected after (?( or (?(?C)\x00\\K is not allowed in lookarounds (but see PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK)\x00\x00no error\x00no match\x00partial match\x00UTF-8 error: 1 byte missing at end\x00UTF-8 error: 2 bytes missing at end\x00UTF-8 error: 3 bytes missing at end\x00UTF-8 error: 4 bytes missing at end\x00UTF-8 error: 5 bytes missing at end\x00UTF-8 error: byte 2 top bits not 0x80\x00UTF-8 error: byte 3 top bits not 0x80\x00UTF-8 error: byte 4 top bits not 0x80\x00UTF-8 error: byte 5 top bits not 0x80\x00UTF-8 error: byte 6 top bits not 0x80\x00UTF-8 error: 5-byte character is not allowed (RFC 3629)\x00UTF-8 error: 6-byte character is not allowed (RFC 3629)\x00UTF-8 error: code points greater than 0x10ffff are not defined\x00UTF-8 error: code points 0xd800-0xdfff are not defined\x00UTF-8 error: overlong 2-byte sequence\x00UTF-8 error: overlong 3-byte sequence\x00UTF-8 error: overlong 4-byte sequence\x00UTF-8 error: overlong 5-byte sequence\x00UTF-8 error: overlong 6-byte sequence\x00UTF-8 error: isolated byte with 0x80 bit set\x00UTF-8 error: illegal byte (0xfe or 0xff)\x00UTF-16 error: missing low surrogate at end\x00UTF-16 error: invalid low surrogate\x00UTF-16 error: isolated low surrogate\x00UTF-32 error: code points 0xd800-0xdfff are not defined\x00UTF-32 error: code points greater than 0x10ffff are not defined\x00bad data value\x00patterns do not all use the same character tables\x00magic number missing\x00pattern compiled in wrong mode: 8/16/32-bit error\x00bad offset value\x00bad option value\x00invalid replacement string\x00bad offset into UTF string\x00callout error code\x00invalid data in workspace for DFA restart\x00too much recursion for DFA matching\x00backreference condition or recursion test is not supported for DFA matching\x00function is not supported for DFA matching\x00pattern contains an item that is not supported for DFA matching\x00workspace size exceeded in DFA matching\x00internal error - pattern overwritten?\x00bad JIT option\x00JIT stack limit reached\x00match limit exceeded\x00no more memory\x00unknown substring\x00non-unique substring name\x00NULL argument passed with non-zero length\x00nested recursion at the same subject position\x00matching depth limit exceeded\x00requested value is not available\x00requested value is not set\x00offset limit set without PCRE2_USE_OFFSET_LIMIT\x00bad escape sequence in replacement string\x00expected closing curly bracket in replacement string\x00bad substitution in replacement string\x00match with end before start or start moved backwards is not supported\x00too many replacements (more than INT_MAX)\x00bad serialized data\x00heap limit exceeded\x00invalid syntax\x00internal error - duplicate substitution match\x00PCRE2_MATCH_INVALID_UTF is not supported for DFA matching\x00\x00\x00\x00JIT is not supported\x00MARK\x00adlam\x00adlm\x00aghb\x00ahex\x00ahom\x00alpha\x00alphabetic\x00anatolianhieroglyphs\x00any\x00arab\x00arabic\x00armenian\x00armi\x00armn\x00ascii\x00asciihexdigit\x00avestan\x00avst\x00bali\x00balinese\x00bamu\x00bamum\x00bass\x00bassavah\x00batak\x00batk\x00beng\x00bengali\x00bhaiksuki\x00bhks\x00bidial\x00bidian\x00bidib\x00bidibn\x00bidic\x00bidicontrol\x00bidics\x00bidien\x00bidies\x00bidiet\x00bidifsi\x00bidil\x00bidilre\x00bidilri\x00bidilro\x00bidim\x00bidimirrored\x00bidinsm\x00bidion\x00bidipdf\x00bidipdi\x00bidir\x00bidirle\x00bidirli\x00bidirlo\x00bidis\x00bidiws\x00bopo\x00bopomofo\x00brah\x00brahmi\x00brai\x00braille\x00bugi\x00buginese\x00buhd\x00buhid\x00c\x00cakm\x00canadianaboriginal\x00cans\x00cari\x00carian\x00cased\x00caseignorable\x00caucasianalbanian\x00cc\x00cf\x00chakma\x00cham\x00changeswhencasefolded\x00changeswhencasemapped\x00changeswhenlowercased\x00changeswhentitlecased\x00changeswhenuppercased\x00cher\x00cherokee\x00chorasmian\x00chrs\x00ci\x00cn\x00co\x00common\x00copt\x00coptic\x00cpmn\x00cprt\x00cs\x00cuneiform\x00cwcf\x00cwcm\x00cwl\x00cwt\x00cwu\x00cypriot\x00cyprominoan\x00cyrillic\x00cyrl\x00dash\x00defaultignorablecodepoint\x00dep\x00deprecated\x00deseret\x00deva\x00devanagari\x00di\x00dia\x00diacritic\x00diak\x00divesakuru\x00dogr\x00dogra\x00dsrt\x00dupl\x00duployan\x00ebase\x00ecomp\x00egyp\x00egyptianhieroglyphs\x00elba\x00elbasan\x00elym\x00elymaic\x00emod\x00emoji\x00emojicomponent\x00emojimodifier\x00emojimodifierbase\x00emojipresentation\x00epres\x00ethi\x00ethiopic\x00ext\x00extendedpictographic\x00extender\x00extpict\x00geor\x00georgian\x00glag\x00glagolitic\x00gong\x00gonm\x00goth\x00gothic\x00gran\x00grantha\x00graphemebase\x00graphemeextend\x00graphemelink\x00grbase\x00greek\x00grek\x00grext\x00grlink\x00gujarati\x00gujr\x00gunjalagondi\x00gurmukhi\x00guru\x00han\x00hang\x00hangul\x00hani\x00hanifirohingya\x00hano\x00hanunoo\x00hatr\x00hatran\x00hebr\x00hebrew\x00hex\x00hexdigit\x00hira\x00hiragana\x00hluw\x00hmng\x00hmnp\x00hung\x00idc\x00idcontinue\x00ideo\x00ideographic\x00ids\x00idsb\x00idsbinaryoperator\x00idst\x00idstart\x00idstrinaryoperator\x00imperialaramaic\x00inherited\x00inscriptionalpahlavi\x00inscriptionalparthian\x00ital\x00java\x00javanese\x00joinc\x00joincontrol\x00kaithi\x00kali\x00kana\x00kannada\x00katakana\x00kayahli\x00khar\x00kharoshthi\x00khitansmallscript\x00khmer\x00khmr\x00khoj\x00khojki\x00khudawadi\x00kits\x00knda\x00kthi\x00l\x00l&\x00lana\x00lao\x00laoo\x00latin\x00latn\x00lc\x00lepc\x00lepcha\x00limb\x00limbu\x00lina\x00linb\x00lineara\x00linearb\x00lisu\x00ll\x00lm\x00lo\x00loe\x00logicalorderexception\x00lower\x00lowercase\x00lt\x00lu\x00lyci\x00lycian\x00lydi\x00lydian\x00m\x00mahajani\x00mahj\x00maka\x00makasar\x00malayalam\x00mand\x00mandaic\x00mani\x00manichaean\x00marc\x00marchen\x00masaramgondi\x00math\x00mc\x00me\x00medefaidrin\x00medf\x00meeteimayek\x00mend\x00mendekikakui\x00merc\x00mero\x00meroiticcursive\x00meroitichieroglyphs\x00miao\x00mlym\x00mn\x00modi\x00mong\x00mongolian\x00mro\x00mroo\x00mtei\x00mult\x00multani\x00myanmar\x00mymr\x00n\x00nabataean\x00nand\x00nandinagari\x00narb\x00nbat\x00nchar\x00nd\x00newa\x00newtailue\x00nko\x00nkoo\x00nl\x00no\x00noncharactercodepoint\x00nshu\x00nushu\x00nyiakengpuachuehmong\x00ogam\x00ogham\x00olchiki\x00olck\x00oldhungarian\x00olditalic\x00oldnortharabian\x00oldpermic\x00oldpersian\x00oldsogdian\x00oldsoutharabian\x00oldturkic\x00olduyghur\x00oriya\x00orkh\x00orya\x00osage\x00osge\x00osma\x00osmanya\x00ougr\x00p\x00pahawhhmong\x00palm\x00palmyrene\x00patsyn\x00patternsyntax\x00patternwhitespace\x00patws\x00pauc\x00paucinhau\x00pc\x00pcm\x00pd\x00pe\x00perm\x00pf\x00phag\x00phagspa\x00phli\x00phlp\x00phnx\x00phoenician\x00pi\x00plrd\x00po\x00prependedconcatenationmark\x00prti\x00ps\x00psalterpahlavi\x00qaac\x00qaai\x00qmark\x00quotationmark\x00radical\x00regionalindicator\x00rejang\x00ri\x00rjng\x00rohg\x00runic\x00runr\x00s\x00samaritan\x00samr\x00sarb\x00saur\x00saurashtra\x00sc\x00sd\x00sentenceterminal\x00sgnw\x00sharada\x00shavian\x00shaw\x00shrd\x00sidd\x00siddham\x00signwriting\x00sind\x00sinh\x00sinhala\x00sk\x00sm\x00so\x00softdotted\x00sogd\x00sogdian\x00sogo\x00sora\x00sorasompeng\x00soyo\x00soyombo\x00space\x00sterm\x00sund\x00sundanese\x00sylo\x00sylotinagri\x00syrc\x00syriac\x00tagalog\x00tagb\x00tagbanwa\x00taile\x00taitham\x00taiviet\x00takr\x00takri\x00tale\x00talu\x00tamil\x00taml\x00tang\x00tangsa\x00tangut\x00tavt\x00telu\x00telugu\x00term\x00terminalpunctuation\x00tfng\x00tglg\x00thaa\x00thaana\x00thai\x00tibetan\x00tibt\x00tifinagh\x00tirh\x00tirhuta\x00tnsa\x00toto\x00ugar\x00ugaritic\x00uideo\x00unifiedideograph\x00unknown\x00upper\x00uppercase\x00vai\x00vaii\x00variationselector\x00vith\x00vithkuqi\x00vs\x00wancho\x00wara\x00warangciti\x00wcho\x00whitespace\x00wspace\x00xan\x00xidc\x00xidcontinue\x00xids\x00xidstart\x00xpeo\x00xps\x00xsp\x00xsux\x00xuc\x00xwd\x00yezi\x00yezidi\x00yi\x00yiii\x00z\x00zanabazarsquare\x00zanb\x00zinh\x00zl\x00zp\x00zs\x00zyyy\x00zzzz\x00\x0014.0.0\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
